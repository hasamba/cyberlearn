{
  "lesson_id": "e3c4d5f6-7a8b-9c0d-1e2f-3a4b5c6d7e8f",
  "domain": "cloud",
  "title": "Kubernetes Security: Cluster Hardening and Container Security",
  "difficulty": 2,
  "order_index": 3,
  "prerequisites": [
    "c1a2b3d4-5e6f-7a8b-9c0d-1e2f3a4b5c6d"
  ],
  "concepts": [
    "Kubernetes RBAC and Service Accounts",
    "Pod Security Standards (Restricted, Baseline, Privileged)",
    "Network Policies for Pod Isolation",
    "Secrets Management in Kubernetes",
    "Container Image Security and Vulnerability Scanning",
    "Admission Controllers and Policy Enforcement",
    "Runtime Security with Falco",
    "Kubernetes API Server Security",
    "etcd Encryption at Rest",
    "Supply Chain Security for Containers"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Implement Kubernetes RBAC with least privilege for users and service accounts",
    "Configure Pod Security Standards to prevent privileged container breakouts",
    "Deploy Network Policies for micro-segmentation between pods and namespaces",
    "Secure Kubernetes secrets with encryption at rest and external secret managers",
    "Scan container images for vulnerabilities and enforce security policies",
    "Use admission controllers (OPA Gatekeeper, Kyverno) for policy enforcement",
    "Detect runtime threats with Falco behavioral monitoring",
    "Harden Kubernetes control plane and API server configurations"
  ],
  "content_blocks": [
    {
      "type": "explanation",
      "title": "Kubernetes Security Fundamentals",
      "content": {
        "text": "Kubernetes (k8s) is the dominant container orchestration platform, powering 88% of containerized workloads. It's also complex and has a large attack surface if misconfigured.\n\n**Why Kubernetes Security Matters**\n\nIn 2018, Tesla's Kubernetes dashboard was exposed to the internet with no authentication. Attackers:\n1. Accessed the dashboard\n2. Deployed cryptocurrency mining containers\n3. Accessed AWS credentials stored in Kubernetes secrets\n4. Exfiltrated proprietary data from S3 buckets\n\nThis was 100% preventable with basic Kubernetes security controls.\n\n**The Kubernetes Attack Surface**\n\n```\n┌─────────────────────────────────────────────────────┐\n│  KUBERNETES CLUSTER ATTACK SURFACE                  │\n├─────────────────────────────────────────────────────┤\n│  1. API Server (exposed endpoint)                   │\n│  2. etcd (cluster state database - very sensitive)  │\n│  3. kubelet (node agent - often exposed)            │\n│  4. Container Runtime (Docker/containerd escapes)   │\n│  5. Container Images (vulnerable dependencies)      │\n│  6. Application Code (inside containers)            │\n│  7. Network (pod-to-pod, pod-to-external)           │\n│  8. Secrets (credentials stored in cluster)         │\n│  9. RBAC Misconfigurations (excessive permissions)  │\n│  10. Supply Chain (compromised base images)         │\n└─────────────────────────────────────────────────────┘\n```\n\n**Kubernetes RBAC (Role-Based Access Control)**\n\nKubernetes RBAC controls who can do what in the cluster.\n\n**Key Components:**\n- **ServiceAccount**: Identity for pods\n- **User**: Identity for humans (managed externally, e.g., via OIDC)\n- **Role**: Permissions within a namespace\n- **ClusterRole**: Permissions across all namespaces\n- **RoleBinding**: Assigns Role to User/ServiceAccount in a namespace\n- **ClusterRoleBinding**: Assigns ClusterRole globally\n\n**Default Dangerous Behavior:**\n\nEvery pod gets a ServiceAccount. By default, this ServiceAccount can query the Kubernetes API. This is a security risk.\n\n**Pod Security Standards (PSS)**\n\nReplaced Pod Security Policies in Kubernetes 1.25+. Three levels:\n\n**1. Privileged**: Unrestricted (dangerous, use only for trusted workloads)\n**2. Baseline**: Minimally restrictive (prevents known privilege escalations)\n**3. Restricted**: Heavily restricted (defense in depth)\n\n**Restricted Standard Enforces:**\n- No privileged containers\n- No host namespaces (hostPID, hostIPC, hostNetwork)\n- No host paths mounted\n- Containers run as non-root user\n- Capabilities dropped (all except NET_BIND_SERVICE)\n- No privilege escalation allowed\n- Read-only root filesystem\n\n**Network Policies**\n\nBy default, all pods can communicate with all pods (flat network). Network Policies create firewall rules between pods.\n\n**Default Deny All Traffic:**\n```yaml\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\nname: default-deny-all\nnamespace: production\nspec:\npodSelector: {}\npolicyTypes:\n- Ingress\n- Egress\n```\n\nThen explicitly allow only necessary traffic.\n\n**Secrets Management**\n\nKubernetes Secrets are base64-encoded (NOT encrypted) by default. Anyone with etcd access or API access can read them.\n\n**Better Approaches:**\n1. **Encrypt etcd at rest** (encrypt secrets in etcd database)\n2. **External Secrets Manager** (AWS Secrets Manager, Azure Key Vault, HashiCorp Vault)\n3. **Sealed Secrets** (bitnami-labs/sealed-secrets - encrypt secrets with controller's public key)\n\n**Container Image Security**\n\n**Vulnerabilities to Scan For:**\n- OS package vulnerabilities (outdated apt/yum packages)\n- Language dependencies (npm, pip, gem with known CVEs)\n- Malware in base images\n- Hardcoded secrets\n\n**Tools:**\n- Trivy (Aqua Security)\n- Grype (Anchore)\n- Snyk\n- Docker Scout\n\n**Admission Controllers**\n\nAdmission controllers intercept Kubernetes API requests BEFORE objects are created. They can:\n- **Validate**: Reject requests that violate policies\n- **Mutate**: Modify requests (e.g., inject sidecar containers)\n\n**Popular Policy Engines:**\n- **OPA Gatekeeper** (Open Policy Agent)\n- **Kyverno** (Kubernetes-native policy engine)\n\n**Example Policy:** \"Reject any pod that runs as root\"\n\n**Runtime Security**\n\n**Falco** (CNCF project) monitors container behavior and alerts on:\n- Shell spawned in container\n- Sensitive file access (/etc/shadow)\n- Unexpected network connections\n- Privilege escalation attempts\n- Binary execution from /tmp\n\n**Supply Chain Security**\n\n**Attacks:**\n- Compromised base images (malicious Dockerfiles on Docker Hub)\n- Dependency confusion (malicious npm/pip packages)\n- Build system compromise (inject malware during CI/CD)\n\n**Defenses:**\n- Sign images (Docker Content Trust, Sigstore Cosign)\n- Verify signatures before deployment\n- Use minimal base images (distroless, Alpine)\n- Scan images in CI/CD pipeline\n- Use private registries for approved images only"
      }
    },
    {
      "type": "code_exercise",
      "title": "Kubernetes Security Hardening",
      "content": {
        "text": "**Exercise 1: Create Least-Privilege ServiceAccount**\n\n```yaml\n# 1. Create namespace\napiVersion: v1\nkind: Namespace\nmetadata:\nname: webapp\n---\n# 2. Create ServiceAccount\napiVersion: v1\nkind: ServiceAccount\nmetadata:\nname: webapp-sa\nnamespace: webapp\nautomountServiceAccountToken: false  # Don't auto-mount API token\n---\n# 3. Create Role (namespace-scoped permissions)\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\nname: webapp-role\nnamespace: webapp\nrules:\n- apiGroups: [\"\"]\nresources: [\"configmaps\"]\nverbs: [\"get\", \"list\"]\n# Only read ConfigMaps, nothing else\n---\n# 4. Bind Role to ServiceAccount\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\nname: webapp-rolebinding\nnamespace: webapp\nsubjects:\n- kind: ServiceAccount\nname: webapp-sa\nnamespace: webapp\nroleRef:\nkind: Role\nname: webapp-role\napiGroup: rbac.authorization.k8s.io\n---\n# 5. Deploy pod with this ServiceAccount\napiVersion: v1\nkind: Pod\nmetadata:\nname: webapp-pod\nnamespace: webapp\nspec:\nserviceAccountName: webapp-sa\ncontainers:\n- name: app\nimage: nginx:1.25-alpine\nsecurityContext:\nrunAsNonRoot: true\nrunAsUser: 1000\nallowPrivilegeEscalation: false\ncapabilities:\ndrop:\n- ALL\nreadOnlyRootFilesystem: true\n```\n\n**Exercise 2: Enforce Pod Security Standards**\n\n```yaml\n# Apply Restricted standard to namespace\napiVersion: v1\nkind: Namespace\nmetadata:\nname: production\nlabels:\npod-security.kubernetes.io/enforce: restricted\npod-security.kubernetes.io/audit: restricted\npod-security.kubernetes.io/warn: restricted\n---\n# This pod will be REJECTED (privileged)\napiVersion: v1\nkind: Pod\nmetadata:\nname: bad-pod\nnamespace: production\nspec:\ncontainers:\n- name: nginx\nimage: nginx\nsecurityContext:\nprivileged: true  # VIOLATION\n# Error: pods \"bad-pod\" is forbidden: violates PodSecurity \"restricted:latest\"\n---\n# This pod will be ACCEPTED (compliant)\napiVersion: v1\nkind: Pod\nmetadata:\nname: good-pod\nnamespace: production\nspec:\nsecurityContext:\nrunAsNonRoot: true\nrunAsUser: 1000\nfsGroup: 1000\nseccompProfile:\ntype: RuntimeDefault\ncontainers:\n- name: nginx\nimage: nginx:1.25-alpine\nsecurityContext:\nallowPrivilegeEscalation: false\nrunAsNonRoot: true\nrunAsUser: 1000\ncapabilities:\ndrop:\n- ALL\nreadOnlyRootFilesystem: true\nvolumeMounts:\n- name: cache\nmountPath: /var/cache/nginx\n- name: run\nmountPath: /var/run\nvolumes:\n- name: cache\nemptyDir: {}\n- name: run\nemptyDir: {}\n```\n\n**Exercise 3: Implement Network Policies**\n\n```yaml\n# Scenario: 3-tier app (frontend, backend, database)\n# Frontend can access backend, backend can access database, nothing else\n\n# 1. Default deny all\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\nname: default-deny-all\nnamespace: production\nspec:\npodSelector: {}\npolicyTypes:\n- Ingress\n- Egress\n---\n# 2. Allow frontend to receive traffic from ingress\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\nname: allow-frontend-ingress\nnamespace: production\nspec:\npodSelector:\nmatchLabels:\napp: frontend\npolicyTypes:\n- Ingress\ningress:\n- from:\n- namespaceSelector:\nmatchLabels:\nname: ingress-nginx\nports:\n- protocol: TCP\nport: 80\n---\n# 3. Allow frontend to call backend\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\nname: allow-backend-from-frontend\nnamespace: production\nspec:\npodSelector:\nmatchLabels:\napp: backend\npolicyTypes:\n- Ingress\ningress:\n- from:\n- podSelector:\nmatchLabels:\napp: frontend\nports:\n- protocol: TCP\nport: 8080\n---\n# 4. Allow backend to call database\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\nname: allow-db-from-backend\nnamespace: production\nspec:\npodSelector:\nmatchLabels:\napp: database\npolicyTypes:\n- Ingress\ningress:\n- from:\n- podSelector:\nmatchLabels:\napp: backend\nports:\n- protocol: TCP\nport: 5432\n---\n# 5. Allow all pods to do DNS lookups\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\nname: allow-dns\nnamespace: production\nspec:\npodSelector: {}\npolicyTypes:\n- Egress\negress:\n- to:\n- namespaceSelector:\nmatchLabels:\nname: kube-system\nports:\n- protocol: UDP\nport: 53\n```\n\n**Exercise 4: Scan Container Image for Vulnerabilities**\n\n```bash\n# Install Trivy\ncurl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin\n\n# Scan an image\ntrivy image nginx:1.21\n\n# Output shows vulnerabilities:\n# nginx:1.21 (debian 11.6)\n# Total: 145 (CRITICAL: 12, HIGH: 45, MEDIUM: 67, LOW: 21)\n# \n# Package: openssl\n# Installed Version: 1.1.1n-0+deb11u3\n# Fixed Version: 1.1.1n-0+deb11u4\n\n# Scan with severity threshold (fail if CRITICAL found)\ntrivy image --severity CRITICAL --exit-code 1 nginx:1.21\n\n# Scan local Dockerfile before building\ntrivy config Dockerfile\n\n# Scan Kubernetes manifests\ntrivy config k8s-deployment.yaml\n\n# Integrate into CI/CD (GitHub Actions example)\n# .github/workflows/scan.yml\nname: Container Scan\non: [push]\njobs:\nscan:\nruns-on: ubuntu-latest\nsteps:\n- uses: actions/checkout@v3\n- name: Build image\nrun: docker build -t myapp:${{ github.sha }} .\n- name: Scan image\nuses: aquasecurity/trivy-action@master\nwith:\nimage-ref: myapp:${{ github.sha }}\nseverity: CRITICAL,HIGH\nexit-code: 1  # Fail build if vulnerabilities found\n```\n\n**Exercise 5: Deploy Falco for Runtime Security**\n\n```bash\n# Install Falco using Helm\nhelm repo add falcosecurity https://falcosecurity.github.io/charts\nhelm repo update\n\nhelm install falco falcosecurity/falco \\\n--namespace falco \\\n--create-namespace \\\n--set falcosidekick.enabled=true \\\n--set falcosidekick.webui.enabled=true\n\n# Falco rules detect suspicious behavior\n# Example: Shell spawned in container\n- rule: Shell Spawned in Container\ndesc: Detect shell execution in containers\ncondition: >\nspawned_process and\ncontainer and\nproc.name in (bash, sh, dash, zsh)\noutput: >\nShell spawned in container (user=%user.name container=%container.name\nshell=%proc.name parent=%proc.pname cmdline=%proc.cmdline)\npriority: WARNING\n\n# Test Falco detection\nkubectl run test --image=nginx --rm -it -- /bin/bash\n# Falco will alert: \"Shell spawned in container\"\n\n# View Falco alerts\nkubectl logs -n falco -l app.kubernetes.io/name=falco -f\n\n# Custom rule: Detect cryptocurrency mining\n- rule: Crypto Mining Activity\ndesc: Detect cryptocurrency mining in containers\ncondition: >\nspawned_process and\ncontainer and\nproc.name in (xmrig, ethminer, cgminer)\noutput: Crypto mining detected (container=%container.name process=%proc.name)\npriority: CRITICAL\n```\n\n**Exercise 6: Implement OPA Gatekeeper Policy**\n\n```yaml\n# Install Gatekeeper\nkubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/master/deploy/gatekeeper.yaml\n\n# Create ConstraintTemplate (policy definition)\napiVersion: templates.gatekeeper.sh/v1\nkind: ConstraintTemplate\nmetadata:\nname: k8sblockprivileged\nspec:\ncrd:\nspec:\nnames:\nkind: K8sBlockPrivileged\ntargets:\n- target: admission.k8s.gatekeeper.sh\nrego: |\npackage k8sblockprivileged\nviolation[{\"msg\": msg}] {\nc := input.review.object.spec.containers[_]\nc.securityContext.privileged\nmsg := sprintf(\"Privileged container is not allowed: %v\", [c.name])\n}\n---\n# Create Constraint (policy enforcement)\napiVersion: constraints.gatekeeper.sh/v1beta1\nkind: K8sBlockPrivileged\nmetadata:\nname: block-privileged-containers\nspec:\nmatch:\nkinds:\n- apiGroups: [\"\"]\nkinds: [\"Pod\"]\nnamespaces:\n- production\nenforcementAction: deny  # or \"dryrun\" for testing\n---\n# Test: Try to create privileged pod\napiVersion: v1\nkind: Pod\nmetadata:\nname: privileged-pod\nnamespace: production\nspec:\ncontainers:\n- name: nginx\nimage: nginx\nsecurityContext:\nprivileged: true\n\n# Result: REJECTED by Gatekeeper\n# Error: admission webhook \"validation.gatekeeper.sh\" denied the request:\n# Privileged container is not allowed: nginx\n```"
      }
    },
    {
      "type": "real_world",
      "title": "Real-World Kubernetes Security Incidents",
      "content": {
        "text": "**Tesla Kubernetes Cryptojacking (2018)**\n\n**Attack Vector:**\n- Kubernetes dashboard exposed to internet without authentication\n- Default credentials or no authentication required\n\n**Attack Chain:**\n1. Attacker discovered exposed dashboard via Shodan search\n2. Accessed dashboard with no credentials\n3. Deployed cryptocurrency mining pods\n4. Found AWS credentials in Kubernetes secrets\n5. Accessed Tesla's S3 buckets containing proprietary data\n\n**Cost:**\n- Unknown AWS bill for mining operations\n- Data exfiltration (unknown scope)\n- Reputational damage\n\n**Prevention:**\n- Never expose Kubernetes dashboard to internet\n- Use RBAC authentication for dashboard\n- Don't store cloud credentials in Kubernetes secrets (use IAM roles/Managed Identities)\n- Enable Network Policies to restrict pod egress\n- Monitor for unexpected CPU usage (cryptomining signature)\n\n**Kubeflow Security Flaw (2023)**\n\n**Vulnerability:**\n- Kubeflow Pipelines had path traversal vulnerability\n- Allowed reading arbitrary files from containers\n- Could access service account tokens from /var/run/secrets/kubernetes.io/serviceaccount/token\n\n**Impact:**\n- Attackers could steal Kubernetes API credentials\n- Escalate privileges within cluster\n- Access other namespaces and resources\n\n**Prevention:**\n- Set `automountServiceAccountToken: false` unless needed\n- Use least-privilege service accounts\n- Keep Kubernetes and ecosystem tools updated\n- Implement admission controllers to audit/block risky configurations\n\n**TeamTNT Cryptojacking Campaign (2020-2023)**\n\n**Attack Vector:**\n- Scans internet for exposed Docker daemons and Kubernetes APIs\n- Exploits misconfigured kubelet APIs\n\n**Attack Chain:**\n1. Find exposed kubelet on port 10250 (read/write API)\n2. Use kubelet API to execute commands in containers\n3. Deploy cryptocurrency miners\n4. Steal cloud credentials from instance metadata\n5. Lateral movement to other clusters\n\n**Prevention:**\n- Disable kubelet anonymous authentication: `--anonymous-auth=false`\n- Enable kubelet authentication: `--authentication-token-webhook=true`\n- Use Network Policies and firewalls to restrict kubelet access\n- Monitor for unexpected outbound connections"
      }
    },
    {
      "type": "mindset_coach",
      "content": {
        "text": "**Mindset: Kubernetes Security is Your Cloud Career Accelerator**\n\nKubernetes runs production workloads at virtually every tech company—Google, Netflix, Spotify, Airbnb. Understanding K8s security isn't just valuable; it's becoming mandatory for cloud security roles.\n\n**Why This Investment Pays Off:**\n- 94% of organizations use containers in production (CNCF survey)\n- Kubernetes security roles command $140k-200k+ salaries\n- Most security professionals avoid K8s due to complexity—your opportunity\n\n**Embracing the Learning Curve:**\nKubernetes feels overwhelming because it's a distributed system with many moving parts: pods, services, ingress, RBAC, network policies, admission controllers. But here's the secret: you don't need to master everything at once.\n\n**Your Learning Path:**\n1. Understand basic K8s architecture (control plane, worker nodes)\n2. Learn how pods are created and managed\n3. Focus on security primitives (RBAC, network policies, pod security policies)\n4. Practice attacks and defenses in a local cluster (kind, minikube)\n\n**Real-World Demand:**\nOrganizations are desperately seeking security professionals who understand:\n- Kubernetes RBAC misconfigurations (excessive permissions)\n- Container escape techniques (protecting the host)\n- Supply chain attacks (malicious container images)\n\n**Career Insight:**\nAdding \"Kubernetes security\" to your resume unlocks:\n- Cloud security engineer positions at Fortune 500 companies\n- DevSecOps roles where you embed security into CI/CD pipelines\n- Consulting opportunities at premium rates\n\n**Mindset Shift:**\nDon't think \"Kubernetes is too complex for me.\" The engineers who built K8s aren't smarter than you—they just invested the time. You're making that same investment now.\n\nEvery container orchestration platform has complexity. Kubernetes won the market. By mastering K8s security, you're positioning yourself for the next decade of cloud security careers.\n\nStart small, practice consistently, and watch this skill transform your opportunities."
      }
    },
    {
      "type": "reflection",
      "title": "Kubernetes Security Reflection",
      "content": {
        "text": "**Key Questions:**\n\n1. Why is Kubernetes security more complex than traditional VM security?\n2. What is the default security posture of Kubernetes? (Hint: permissive)\n3. How do Network Policies implement zero-trust networking?\n4. Why are secrets not actually \"secret\" in Kubernetes by default?\n5. What is the difference between admission control (preventive) and runtime security (detective)?\n\n**Career Application:**\n- Kubernetes skills are in extreme demand (200k+ job openings globally)\n- CKS (Certified Kubernetes Security Specialist) certification demonstrates expertise\n- Understanding k8s security applies to AWS EKS, Azure AKS, Google GKE\n\n**Hands-On Challenge:**\nDeploy a local Kubernetes cluster (Minikube/Kind) and implement:\n1. Network Policies for 3-tier app\n2. Pod Security Standards (Restricted)\n3. Falco runtime monitoring\n4. OPA Gatekeeper policy\n\nThis practical experience is what employers value most."
      }
    },
    {
      "type": "memory_aid",
      "title": "Kubernetes Security Quick Reference",
      "content": {
        "text": "**Pod Security Standards: \"PRB\"**\n- **P**rivileged (unrestricted, dangerous)\n- **R**estricted (most secure, production default)\n- **B**aseline (middle ground)\n\n**Secure Pod Checklist: \"RUN-CAP-RO\"**\n- **R**unAsNonRoot: true\n- **U**ser: runAsUser: 1000 (non-root)\n- **N**o privilege escalation: allowPrivilegeEscalation: false\n- **CAP**abilities: drop ALL\n- **R**eadOnlyRootFilesystem: true\n- **O**mit automountServiceAccountToken (unless needed)\n\n**Network Policy Default Deny:**\n```yaml\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\nname: default-deny\nspec:\npodSelector: {}\npolicyTypes: [Ingress, Egress]\n```\n\n**Trivy Quick Scan:**\n```bash\ntrivy image --severity CRITICAL,HIGH nginx:latest\n```\n\n**Falco Shell Detection Rule (Memorize This Pattern):**\n```yaml\nspawned_process + container + proc.name in (bash, sh)\n```\n\n**RBAC Assignment Formula:**\n```\nSubject (User/SA) + Verb (get/list/create) + Resource (pods/secrets) + Namespace = Permission\n```\n\n**Security Layers (Defense in Depth):**\n1. Image scanning (build time)\n2. Admission control (deploy time)\n3. RBAC + Network Policies (runtime boundaries)\n4. Runtime security (Falco, behavioral monitoring)\n5. Audit logging (forensics)"
      }
    },
    {
      "type": "video",
      "title": "Kubernetes Security Learning Resources",
      "content": {
        "resources": "**Featured Video**: [Certified Kubernetes Security Specialists (CKS) Full Course -  Cluster Hardening 2.1](https://www.youtube.com/watch?v=8Dj3YjxVG5Y)\n\n**Official Kubernetes Security:**\n- \"Kubernetes Security Best Practices\" (CNCF webinar)\n- \"Securing Kubernetes\" (official k8s docs)\n\n**Certifications:**\n- CKA (Certified Kubernetes Administrator)\n- CKS (Certified Kubernetes Security Specialist)\n\n**YouTube Channels:**\n- \"TechWorld with Nana\" (Kubernetes security tutorials)\n- \"That DevOps Guy\" (practical k8s security)\n- \"CNCF\" (Cloud Native Computing Foundation official)\n\n**Hands-On Labs:**\n- \"Killer.sh\" (CKS exam practice)\n- \"Kubernetes Goat\" (deliberately vulnerable k8s cluster for learning)\n- \"KubeCon talks\" (search \"security\" on YouTube)\n\n**Tools to Learn:**\n- Trivy (vulnerability scanning)\n- Falco (runtime security)\n- OPA Gatekeeper or Kyverno (policy enforcement)\n- kubescape (security posture assessment)\n\n**Practice Environment:**\n```bash\n# Install Minikube (local k8s)\ncurl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64\nsudo install minikube-linux-amd64 /usr/local/bin/minikube\nminikube start\n```"
      }
    }
  ],
  "post_assessment": [
    {
      "question": "A pod with `automountServiceAccountToken: true` (default) is compromised. What can the attacker immediately access?",
      "options": [
        "Only resources within the pod's namespace",
        "The Kubernetes API using the service account token at /var/run/secrets/kubernetes.io/serviceaccount/token",
        "All secrets in the cluster",
        "The underlying node's filesystem"
      ],
      "correct_answer": 1,
      "explanation": "**Correct: The Kubernetes API using the service account token.**\n\nBy default, Kubernetes mounts the service account token inside every pod at `/var/run/secrets/kubernetes.io/serviceaccount/token`. An attacker with shell access can:\n\n```bash\nTOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\ncurl -k -H \"Authorization: Bearer $TOKEN\" https://kubernetes.default.svc/api/v1/namespaces/default/pods\n```\n\nThe permissions depend on the service account's RBAC bindings. With the default service account, they can usually query basic API endpoints.\n\n**Prevention:**\n```yaml\nspec:\n  automountServiceAccountToken: false\n```\n\nOnly enable when the pod actually needs to call the Kubernetes API.",
      "question_id": "3a88950e-80ef-4366-bdec-87da3e79df90",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "You deploy a Network Policy that denies all ingress traffic to a namespace. Developers report they can't access pod logs or exec into containers. Why?",
      "options": [
        "Network Policies block kubectl commands",
        "The API server can't reach the kubelet on worker nodes due to the policy",
        "This is expected behavior; developers need a separate RBAC role",
        "Network Policies don't affect exec/logs operations"
      ],
      "correct_answer": 3,
      "explanation": "**Correct: Network Policies don't affect exec/logs operations.**\n\nNetwork Policies control pod-to-pod network traffic, NOT API operations like `kubectl logs` or `kubectl exec`. Those operations:\n1. User → API server (no Network Policy)\n2. API server → kubelet → container (kubelet is on the node, outside pod network namespace)\n\nIf this is broken, the issue is likely:\n- RBAC (user lacks permissions)\n- Firewall rules blocking API server → kubelet communication\n- kubelet authentication/authorization issues\n\nNetwork Policies operate at Layer 3/4 (IP/port) for pod networking only.",
      "question_id": "e97bb259-422d-4a8a-af97-2d14890c2d80",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "A container runs as UID 0 (root) inside the container. The pod has `runAsNonRoot: true` in securityContext. What happens?",
      "options": [
        "Pod starts successfully; container images define the user",
        "Pod is rejected at admission time",
        "Pod starts but container is killed immediately at runtime",
        "Pod starts with UID remapped to a non-root user"
      ],
      "correct_answer": 2,
      "explanation": "**Correct: Pod starts but container is killed immediately at runtime.**\n\nThe admission phase doesn't inspect container image metadata (what USER the Dockerfile specifies). The pod is created successfully.\n\nHowever, when the container runtime (containerd/CRI-O) starts the container:\n1. It checks the image's default UID (0 in this case)\n2. It sees `runAsNonRoot: true` in securityContext\n3. Runtime detects conflict: container wants to run as UID 0, policy says non-root\n4. Container is killed with error: \"container has runAsNonRoot and image will run as root\"\n\n**Check with:**\n```bash\nkubectl describe pod <pod-name>\n# Events:\n# Error: container has runAsNonRoot and image will run as root (pod: \"...\", container: \"...\")\n```\n\n**Prevention:** Explicitly set `runAsUser` in securityContext:\n```yaml\nsecurityContext:\n  runAsNonRoot: true\n  runAsUser: 1000\n```",
      "question_id": "7f9653ec-373b-4fd3-9461-95532d135354",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "Your Kubernetes cluster stores secrets encrypted at rest in etcd. An attacker gains read access to etcd database files. Can they read the secrets?",
      "options": [
        "No, secrets are encrypted and unreadable",
        "Yes, if they also obtain the encryption key from the API server configuration",
        "Yes, secrets are only base64-encoded by default even with encryption at rest enabled",
        "No, etcd access requires Kubernetes API authentication"
      ],
      "correct_answer": 1,
      "explanation": "**Correct: Yes, if they also obtain the encryption key.**\n\nKubernetes etcd encryption at rest works like this:\n\n1. API server encrypts secrets before writing to etcd using an encryption key\n2. Encryption key is stored in `EncryptionConfiguration` file on API server\n3. If attacker has etcd database files AND the encryption key, they can decrypt secrets\n\n**Encryption config location:**\n```yaml\n# /etc/kubernetes/encryption-config.yaml (on control plane nodes)\napiVersion: apiserver.config.k8s.io/v1\nkind: EncryptionConfiguration\nresources:\n- resources:\n  - secrets\n  providers:\n  - aescbc:\n      keys:\n      - name: key1\n        secret: <base64-encoded-32-byte-key>  # THIS is what attacker needs\n```\n\n**Defense in depth:**\n1. Encrypt etcd at rest (API server does this)\n2. Encrypt etcd database disk (LUKS, cloud KMS)\n3. Protect encryption key file (restrict file permissions, use KMS provider)\n4. Use external secrets (HashiCorp Vault, AWS Secrets Manager)\n5. Restrict etcd access (TLS client certs, network policies)\n\n**Better approach: KMS Provider**\n```yaml\nproviders:\n- kms:\n    name: aws-kms\n    endpoint: unix:///var/run/kmsplugin/socket.sock\n```\n\nNow the encryption key is stored in AWS KMS, not on the API server filesystem.",
      "question_id": "6da334b6-ba2c-4639-ba56-4d72042eab00",
      "type": "multiple_choice",
      "difficulty": 2
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "teach_like_im_10",
    "memory_hooks",
    "minimum_effective_dose",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ]
}