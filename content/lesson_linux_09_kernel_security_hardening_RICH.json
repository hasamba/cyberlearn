{
  "lesson_id": "c9d0e1f2-3456-6789-01ab-ef0123456789",
  "domain": "linux",
  "title": "Linux Kernel Security and Hardening",
  "subtitle": "Harden the Linux kernel with sysctl, security modules, and attack surface reduction",
  "difficulty": 3,
  "order_index": 9,
  "estimated_time": 55,
  "is_core_concept": true,
  "base_xp_reward": 220,
  "prerequisites": [],
  "concepts": [
    "sysctl kernel parameters",
    "ASLR (Address Space Layout Randomization)",
    "DEP/NX (Data Execution Prevention)",
    "kernel modules security",
    "secureboot",
    "KASLR",
    "stack canaries",
    "kernel hardening",
    "attack surface reduction",
    "proc filesystem security",
    "kernel lockdown mode",
    "KSPP (Kernel Self Protection Project)"
  ],
  "learning_objectives": [
    "Understand kernel attack surfaces and threat models",
    "Configure sysctl parameters for security hardening",
    "Implement ASLR, DEP, and stack protection mechanisms",
    "Secure kernel module loading and prevent rootkits",
    "Configure secure boot and kernel signing",
    "Apply KSPP hardening recommendations",
    "Reduce attack surface through feature disabling",
    "Monitor and detect kernel-level threats"
  ],
  "jim_kwik_principles": [
    "active_learning",
    "meta_learning",
    "teach_like_im_10",
    "minimum_effective_dose",
    "memory_hooks",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "🧠 **Jim Kwik Mindset: Teach to Learn**\n\nKernel security is intimidating—it's the deepest layer of the OS! Here's the secret: you don't need to understand EVERY kernel detail to harden it effectively.\n\n**Chunking Strategy**: Break kernel hardening into 3 layers:\n\n1. **Memory Protection** (ASLR, DEP, stack canaries) → Prevents exploitation\n2. **Access Control** (module loading, secureboot) → Prevents tampering\n3. **Attack Surface** (disable features, sysctl) → Reduces opportunity\n\nMaster these independently, then combine them.\n\n**Active Learning Challenge**: After this lesson, explain to someone (or yourself out loud):\n- \"What is ASLR and why does it stop buffer overflow exploits?\"\n- \"How does DEP prevent shellcode execution?\"\n- \"Why can't attackers just load a malicious kernel module?\"\n\nWhen you can teach it simply, you truly understand it.\n\n**Memory Palace**: Imagine a fortress:\n- **Walls constantly shifting position** = ASLR (attacker can't predict memory layout)\n- **Guard checking all packages** = Module signing (no malicious code loaded)\n- **Closing unused doors** = Disabling features (smaller attack surface)\n- **Sensors everywhere** = Logging and monitoring\n\nThe kernel is your fortress's foundation—fortify it, and everything above is more secure.\n\n💪 **Mindset Shift**: You're not memorizing kernel internals—you're learning how to *configure* proven protections. These settings have stopped thousands of real attacks!"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Understanding the Kernel Attack Surface\n\n### Why Kernel Security Matters\n\nThe kernel runs with **highest privilege** (ring 0). If an attacker compromises the kernel, they have:\n- ✅ Complete control over the system\n- ✅ Ability to hide malware (rootkits)\n- ✅ Access to all processes and data\n- ✅ Capability to persist across reboots\n- ✅ Power to disable security controls\n\n**Impact**: Kernel compromise = game over.\n\n### Real-World Kernel Exploits\n\n#### 1. Dirty COW (CVE-2016-5195)\n- **Vulnerability**: Race condition in copy-on-write mechanism\n- **Impact**: Unprivileged user could write to read-only files\n- **Attack**: Modify /etc/passwd, gain root\n- **Mitigation**: Kernel patch + SELinux/AppArmor containment\n\n#### 2. DirtyCred (CVE-2022-0847) \n- **Vulnerability**: Pipe handling flaw\n- **Impact**: Privilege escalation to root\n- **Attack**: Overwrite privileged credentials in memory\n- **Mitigation**: Kernel update + memory protections\n\n#### 3. Perf_Event_Open (CVE-2022-0847)\n- **Vulnerability**: Performance monitoring subsystem bug\n- **Impact**: Local privilege escalation\n- **Attack**: Abuse perf_event_open() syscall\n- **Mitigation**: Disable unprivileged BPF, restrict perf\n\n### The Kernel Attack Surface\n\n```\n┌─────────────────────────────────────────┐\n│         USER SPACE (Ring 3)             │\n│  Applications, Services, User Processes │\n└────────────────┬────────────────────────┘\n                 │ System Calls\n┌────────────────▼────────────────────────┐\n│         KERNEL SPACE (Ring 0)           │\n├─────────────────────────────────────────┤\n│ • System Call Interface                 │ ← Attack vector\n│ • Process Management                    │\n│ • Memory Management                     │ ← Buffer overflows\n│ • File Systems                          │\n│ • Network Stack                         │ ← Network exploits\n│ • Device Drivers                        │ ← Vulnerable drivers\n│ • Kernel Modules (LKMs)                 │ ← Rootkits\n│ • BPF (Berkeley Packet Filter)          │ ← Abuse BPF features\n└────────────────┬────────────────────────┘\n                 │\n┌────────────────▼────────────────────────┐\n│           HARDWARE                      │\n└─────────────────────────────────────────┘\n```\n\n**Attack Vectors**:\n1. **System Calls**: Abuse vulnerable syscalls (exploit kernel logic bugs)\n2. **Kernel Modules**: Load malicious modules (rootkits)\n3. **Memory Corruption**: Buffer overflows, use-after-free, heap corruption\n4. **Race Conditions**: TOCTOU (time-of-check-time-of-use)\n5. **Device Drivers**: Exploit buggy third-party drivers\n6. **Kernel Features**: Abuse debugging features (kprobes, eBPF)\n\n### Defense Layers\n\n#### Layer 1: Prevention (Stop Exploitation)\n- ASLR: Randomize memory layout\n- DEP/NX: Prevent code execution in data regions\n- Stack Canaries: Detect buffer overflows\n- KASLR: Randomize kernel base address\n\n#### Layer 2: Access Control (Stop Tampering)\n- Module Signing: Only load signed modules\n- Secure Boot: Verify kernel integrity at boot\n- Lockdown Mode: Restrict kernel access\n\n#### Layer 3: Containment (Limit Damage)\n- Namespaces: Isolate processes\n- Capabilities: Fine-grained privileges (instead of root/user binary)\n- SELinux/AppArmor: MAC containment\n\n#### Layer 4: Detection (Find Attacks)\n- Audit logging: Track kernel operations\n- Integrity checking: Detect kernel modifications\n- Anomaly detection: Identify unusual behavior\n\n**Memory Aid - \"PACE\"**:\n- **P**revention → ASLR, DEP (memory protections)\n- **A**ccess → Module signing, secure boot\n- **C**ontainment → Namespaces, MAC\n- **D**etection → Logging, integrity"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Memory Protection Mechanisms\n\n### 1. ASLR (Address Space Layout Randomization)\n\n**Problem Without ASLR**:\nMemory layout is predictable:\n```\nStack:    0x7fffffff0000\nHeap:     0x600000000000\nLibraries: 0x7f0000000000\n```\n\nAttacker knows exactly where to return-to-libc, where to place shellcode.\n\n**Solution: ASLR**\nRandomize memory addresses at each execution:\n```\nRun 1:  Stack at 0x7fff3a2b1000\nRun 2:  Stack at 0x7fffb8de2000\nRun 3:  Stack at 0x7fff4f923000\n```\n\nAttacker's exploit fails because addresses are unpredictable.\n\n**Check ASLR Status**:\n```bash\ncat /proc/sys/kernel/randomize_va_space\n# 0 = Disabled (NEVER use in production!)\n# 1 = Partial (randomize stack, libraries, mmap)\n# 2 = Full (also randomize heap, VDSO) ← RECOMMENDED\n```\n\n**Enable Full ASLR**:\n```bash\n# Temporary\nsudo sysctl -w kernel.randomize_va_space=2\n\n# Permanent\necho \"kernel.randomize_va_space = 2\" | sudo tee -a /etc/sysctl.conf\nsudo sysctl -p\n```\n\n**Effectiveness**:\n- ✅ Stops most buffer overflow exploits\n- ✅ Makes ROP (Return-Oriented Programming) much harder\n- ❌ Can be bypassed with information leaks\n- ❌ Doesn't prevent logic bugs\n\n**Real-World**: Shellshock (CVE-2014-6271) exploitation was significantly harder with ASLR enabled.\n\n### 2. DEP/NX (Data Execution Prevention / No-Execute)\n\n**Problem Without DEP**:\nData memory (stack, heap) is executable:\n```\nAttacker writes shellcode → Stack\nBuffer overflow → EIP points to stack\nShellcode executes → System compromised\n```\n\n**Solution: DEP/NX**\nMark data pages as **non-executable**:\n```\n┌────────────┬────────┬────────┐\n│   Memory   │  Read  │ Execute│\n├────────────┼────────┼────────┤\n│ Code (.text)│   ✓   │   ✓    │  ← Executable\n│ Stack       │   ✓   │   ✗    │  ← NOT executable\n│ Heap        │   ✓   │   ✗    │  ← NOT executable\n│ Libraries   │   ✓   │   ✓    │  ← Executable\n└────────────┴────────┴────────┘\n```\n\nAttempt to execute code on stack → **Segmentation fault**\n\n**Check DEP Status**:\n```bash\n# Check if NX bit is supported (CPU feature)\ngrep nx /proc/cpuinfo\n# Should show 'nx' flag\n\n# Check if kernel has NX enabled\ndmesg | grep -i nx\n# Should show \"NX (Execute Disable) protection: active\"\n\n# Check specific binary\nexecstack -q /bin/bash\n# Output: '-' means NX enabled (good!)\n#         'X' means executable stack (bad!)\n```\n\n**Enable DEP** (usually enabled by default on modern systems):\n```bash\n# Kernel compiled with CONFIG_X86_PAE or CONFIG_X86_64\n# Automatically enables NX support\n\n# For applications: Compile with NX support\ngcc -z noexecstack -o myapp myapp.c\n```\n\n**Bypass Techniques** (attackers use these):\n- **ROP (Return-Oriented Programming)**: Chain existing executable code\n- **JIT Spraying**: Abuse Just-In-Time compilers\n- **ret2libc**: Return to existing library functions\n\n**Mitigation**: DEP + ASLR together make exploitation exponentially harder.\n\n### 3. Stack Canaries\n\n**Problem**: Buffer overflows overwrite return address on stack.\n\n**Solution**: Place a **canary** (random value) before return address:\n```\nStack Layout:\n┌───────────────┐\n│ Local vars    │\n├───────────────┤\n│ CANARY        │ ← Random value checked before return\n├───────────────┤\n│ Saved EBP     │\n├───────────────┤\n│ Return addr   │\n└───────────────┘\n```\n\n**Protection**:\n1. Function prologue: Place canary on stack\n2. Function epilogue: Check if canary was modified\n3. If modified → **Stack corruption detected** → Terminate process\n\n**Check if Binary Has Stack Protection**:\n```bash\n# Check ELF binary\nhardening-check /bin/bash\n# Output includes: \"Stack protected: yes\"\n\n# OR use checksec\nchecksec --file=/bin/bash\n# Look for: \"Stack Canary: Canary found\"\n```\n\n**Enable Stack Protection** (compile-time):\n```bash\n# Strong protection (all functions)\ngcc -fstack-protector-strong -o myapp myapp.c\n\n# All functions (performance hit)\ngcc -fstack-protector-all -o myapp myapp.c\n\n# Basic protection (only functions with char arrays)\ngcc -fstack-protector -o myapp myapp.c\n```\n\n**Limitations**:\n- ❌ Only detects, doesn't prevent overflow\n- ❌ Can be bypassed by overwriting canary with correct value (information leak)\n- ✅ But: Stops blind buffer overflow exploits\n\n### 4. KASLR (Kernel Address Space Layout Randomization)\n\n**Problem**: Kernel loaded at fixed, predictable address.\n\nAttackers can:\n- Target specific kernel functions\n- Craft reliable kernel exploits\n- Bypass SMEP/SMAP protections\n\n**Solution**: Randomize kernel base address at boot.\n\n**Check KASLR Status**:\n```bash\n# Check if enabled\ndmesg | grep -i kaslr\n# Output: \"KASLR enabled\" or \"No KASLR\"\n\n# Check kernel command line\ncat /proc/cmdline | grep kaslr\n# Should NOT see: \"nokaslr\"\n```\n\n**Enable KASLR** (boot parameter):\n```bash\n# Edit GRUB config\nsudo nano /etc/default/grub\n\n# Ensure kernel command line DOESN'T have: nokaslr\n# Example:\nGRUB_CMDLINE_LINUX=\"quiet splash\"\n# (absence of 'nokaslr' means KASLR is enabled)\n\n# Update GRUB\nsudo update-grub\nsudo reboot\n```\n\n**Effectiveness**:\n- ✅ Mitigates kernel exploits relying on hardcoded addresses\n- ✅ Works with SMEP/SMAP\n- ❌ Can be bypassed with information leak vulnerabilities\n\n### 5. SMEP/SMAP (Supervisor Mode Execution/Access Prevention)\n\n**SMEP** (Intel: Supervisor Mode Execution Prevention)\n- Prevents kernel from executing user-space code\n- Stops ret2usr attacks (kernel redirects to user shellcode)\n\n**SMAP** (Intel: Supervisor Mode Access Prevention)\n- Prevents kernel from accessing user-space memory\n- Stops kernel exploits that read/write user memory directly\n\n**Check if CPU Supports**:\n```bash\ngrep -E 'smep|smap' /proc/cpuinfo\n# Should show: smep smap\n```\n\n**Check if Enabled**:\n```bash\ndmesg | grep -E 'SMEP|SMAP'\n# Output: \"CPU: ... SMEP, SMAP\"\n```\n\n**Enable** (usually enabled by default on modern kernels with capable CPUs):\n```bash\n# No manual configuration needed—kernel auto-enables if CPU supports\n# To verify:\ncat /proc/cpuinfo | grep -E 'smep|smap'\n```\n\n**Memory Aid - \"Memory Protections ASDK\"**:\n- **A**SLR → Randomize addresses\n- **S**tack canaries → Detect overwrites\n- **D**EP/NX → No execute data\n- **K**ASLR → Randomize kernel"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "## Kernel Hardening with sysctl\n\n### Understanding sysctl\n\n**sysctl** configures kernel parameters at runtime via `/proc/sys/` interface.\n\n**View Current Settings**:\n```bash\n# List all parameters\nsysctl -a\n\n# View specific parameter\nsysctl kernel.randomize_va_space\nsysctl net.ipv4.ip_forward\n```\n\n**Change Settings**:\n```bash\n# Temporary (lost on reboot)\nsudo sysctl -w kernel.parameter=value\n\n# Permanent\necho \"kernel.parameter = value\" | sudo tee -a /etc/sysctl.conf\nsudo sysctl -p  # Reload config\n```\n\n### Essential Hardening Parameters\n\n#### 1. Memory Protection\n\n```bash\n# Enable full ASLR\nkernel.randomize_va_space = 2\n\n# Disable kptr_restrict (kernel pointer obfuscation)\nkernel.kptr_restrict = 2\n# 0 = Exposed (default, insecure)\n# 1 = Hidden from unprivileged (better)\n# 2 = Hidden from all (most secure)\n\n# Restrict dmesg to root (hide kernel messages)\nkernel.dmesg_restrict = 1\n\n# Disable kernel core dumps (prevent information leaks)\nkernel.core_uses_pid = 1\nfs.suid_dumpable = 0\n```\n\n**Apply**:\n```bash\nsudo tee -a /etc/sysctl.conf <<EOF\nkernel.randomize_va_space = 2\nkernel.kptr_restrict = 2\nkernel.dmesg_restrict = 1\nkernel.core_uses_pid = 1\nfs.suid_dumpable = 0\nEOF\n\nsudo sysctl -p\n```\n\n#### 2. Kernel Module Protection\n\n```bash\n# Disable module loading after boot (prevent rootkits)\nkernel.modules_disabled = 1\n# WARNING: Can't load modules until reboot! Use carefully.\n\n# Alternative: Log module loads\nkernel.modules_autoload_max = 0\n```\n\n**How to Use**:\n```bash\n# 1. Boot system\n# 2. Load all needed modules\nsudo modprobe module_name\n\n# 3. Disable further loading\necho 1 | sudo tee /proc/sys/kernel/modules_disabled\n\n# Now attackers can't load malicious modules\n```\n\n#### 3. Attack Surface Reduction\n\n```bash\n# Restrict unprivileged user namespaces (container escapes)\nkernel.unprivileged_userns_clone = 0\n\n# Restrict BPF to privileged users (CVE-2021-3490)\nkernel.unprivileged_bpf_disabled = 1\n\n# Restrict perf_event_open to root\nkernel.perf_event_paranoid = 3\n# 2 = Kernel and user can use perf\n# 3 = Only root can use perf (most restrictive)\n\n# Protect symlinks/hardlinks (prevent TOCTOU attacks)\nfs.protected_symlinks = 1\nfs.protected_hardlinks = 1\nfs.protected_fifos = 2\nfs.protected_regular = 2\n```\n\n**Apply**:\n```bash\nsudo tee -a /etc/sysctl.conf <<EOF\nkernel.unprivileged_userns_clone = 0\nkernel.unprivileged_bpf_disabled = 1\nkernel.perf_event_paranoid = 3\nfs.protected_symlinks = 1\nfs.protected_hardlinks = 1\nfs.protected_fifos = 2\nfs.protected_regular = 2\nEOF\n\nsudo sysctl -p\n```\n\n#### 4. Process Restrictions\n\n```bash\n# Restrict ptrace to prevent process injection\nkernel.yama.ptrace_scope = 2\n# 0 = Classic ptrace (any process)\n# 1 = Restricted (only children or CAP_SYS_PTRACE)\n# 2 = Admin-only (only processes with CAP_SYS_PTRACE)\n# 3 = No ptrace (disabled)\n\n# Limit process visibility (/proc)\nkernel.pid_max = 65536  # Reduce PID range\n```\n\n**Apply**:\n```bash\nsudo tee -a /etc/sysctl.conf <<EOF\nkernel.yama.ptrace_scope = 2\nEOF\n\nsudo sysctl -p\n```\n\n#### 5. Network Stack Hardening (Bonus)\n\n```bash\n# Disable IP forwarding (unless router)\nnet.ipv4.ip_forward = 0\nnet.ipv6.conf.all.forwarding = 0\n\n# SYN flood protection\nnet.ipv4.tcp_syncookies = 1\nnet.ipv4.tcp_max_syn_backlog = 2048\n\n# Disable ICMP redirects (prevent MITM)\nnet.ipv4.conf.all.accept_redirects = 0\nnet.ipv6.conf.all.accept_redirects = 0\n\n# Disable source routing (prevent IP spoofing)\nnet.ipv4.conf.all.accept_source_route = 0\nnet.ipv6.conf.all.accept_source_route = 0\n\n# Log martian packets (impossible IPs)\nnet.ipv4.conf.all.log_martians = 1\n```\n\n### Complete Hardened sysctl.conf\n\n**Create** `/etc/sysctl.d/99-security-hardening.conf`:\n```bash\nsudo tee /etc/sysctl.d/99-security-hardening.conf <<'EOF'\n# Memory Protection\nkernel.randomize_va_space = 2\nkernel.kptr_restrict = 2\nkernel.dmesg_restrict = 1\nkernel.core_uses_pid = 1\nfs.suid_dumpable = 0\n\n# Attack Surface Reduction\nkernel.unprivileged_userns_clone = 0\nkernel.unprivileged_bpf_disabled = 1\nkernel.perf_event_paranoid = 3\n\n# Filesystem Protections\nfs.protected_symlinks = 1\nfs.protected_hardlinks = 1\nfs.protected_fifos = 2\nfs.protected_regular = 2\n\n# Process Restrictions\nkernel.yama.ptrace_scope = 2\n\n# Network Stack (if not a router)\nnet.ipv4.ip_forward = 0\nnet.ipv4.tcp_syncookies = 1\nnet.ipv4.conf.all.accept_redirects = 0\nnet.ipv4.conf.all.accept_source_route = 0\nnet.ipv4.conf.all.log_martians = 1\nEOF\n\n# Apply settings\nsudo sysctl -p /etc/sysctl.d/99-security-hardening.conf\n\n# Verify\nsudo sysctl kernel.randomize_va_space\nsudo sysctl kernel.kptr_restrict\nsudo sysctl kernel.unprivileged_bpf_disabled\n```\n\n### Testing Impact\n\n**Before Hardening**:\n```bash\n# Non-root user can see kernel pointers\ncat /proc/kallsyms | head -5\n0000000000000000 A fixed_percpu_data\n0000000000000000 A __per_cpu_start\n# (addresses visible)\n\n# Non-root can use dmesg\ndmesg | tail\n# (kernel messages visible)\n```\n\n**After Hardening** (kptr_restrict=2, dmesg_restrict=1):\n```bash\n# Non-root user CANNOT see kernel pointers\ncat /proc/kallsyms | head -5\n0000000000000000 A fixed_percpu_data\n# (all zeros)\n\n# Non-root CANNOT use dmesg\ndmesg | tail\ndmesg: read kernel buffer failed: Operation not permitted\n```\n\n**Memory Aid - \"Sysctl Hardening MAPF\"**:\n- **M**emory protections (ASLR, kptr_restrict)\n- **A**ttack surface (unprivileged_bpf, perf)\n- **P**rocess restrictions (ptrace_scope)\n- **F**ilesystem protections (protected_symlinks)"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Kernel Module Security and Secure Boot\n\n### The Rootkit Threat\n\n**Rootkit** = Malicious kernel module that:\n- Hides attacker's presence (process hiding, file hiding)\n- Provides backdoor access\n- Intercepts system calls (keylogging, data theft)\n- Persists across reboots\n\n**Example**: Reptile rootkit hides processes by hooking `getdents` syscall.\n\n### Preventing Malicious Modules\n\n#### 1. Module Signing\n\n**Concept**: Only load modules signed by trusted key.\n\n**Check if Enabled**:\n```bash\n# Check if kernel has module signature verification\ncat /proc/sys/kernel/modules_disabled\n# 0 = Module loading allowed\n# 1 = Module loading disabled\n\n# Check if signature verification is enforced\ndmesg | grep -i \"module signature\"\n# Look for: \"module verification\"\n\n# Check specific module\nmodinfo <module_name> | grep -i sig\n# Shows signature info\n```\n\n**Enable Module Signing** (requires kernel recompile):\n```bash\n# Kernel configuration options:\nCONFIG_MODULE_SIG=y\nCONFIG_MODULE_SIG_FORCE=y       # Reject unsigned modules\nCONFIG_MODULE_SIG_ALL=y         # Sign all modules at build\nCONFIG_MODULE_SIG_SHA256=y      # Use SHA256\nCONFIG_MODULE_SIG_KEY=\"certs/signing_key.pem\"\n```\n\n**Sign Custom Module** (after kernel is configured for signing):\n```bash\n# Generate signing key (if not auto-generated)\nopenssl req -new -x509 -newkey rsa:2048 -days 36500 \\\n  -keyout MOK.priv -outform DER -out MOK.der -nodes \\\n  -subj \"/CN=My Module Signing Key/\"\n\n# Sign module\nsudo /usr/src/linux-headers-$(uname -r)/scripts/sign-file \\\n  sha256 MOK.priv MOK.der my_module.ko\n\n# Verify signature\nmodinfo my_module.ko | grep sig\n```\n\n**Impact**:\n- ✅ Prevents loading of unsigned (potentially malicious) modules\n- ✅ Works with Secure Boot\n- ❌ Requires key management\n- ❌ Custom drivers need signing\n\n#### 2. Secure Boot\n\n**Concept**: UEFI firmware verifies bootloader and kernel signatures before execution.\n\n**Chain of Trust**:\n```\nUEFI Firmware (signed by vendor)\n      ↓ Verifies\nBootloader (GRUB, signed)\n      ↓ Verifies\nKernel (signed)\n      ↓ Verifies\nKernel Modules (signed)\n```\n\nIf ANY step is unsigned or signature invalid → Boot halted.\n\n**Check Secure Boot Status**:\n```bash\n# Method 1: Check if enabled\nmokutil --sb-state\n# Output: \"SecureBoot enabled\" or \"SecureBoot disabled\"\n\n# Method 2: Check EFI variable\nsudo cat /sys/firmware/efi/efivars/SecureBoot-*\n# Output: Contains 0x01 if enabled\n\n# Method 3: Check dmesg\ndmesg | grep -i secure\n# Look for: \"Secure boot enabled\"\n```\n\n**Enable Secure Boot** (BIOS/UEFI setting):\n1. Reboot, enter BIOS/UEFI (usually F2, F10, Del)\n2. Find \"Secure Boot\" option (usually under Security or Boot)\n3. Set to \"Enabled\"\n4. Save and exit\n\n**Note**: Requires:\n- UEFI mode (not legacy BIOS)\n- Signed bootloader (GRUB must be signed)\n- Signed kernel\n- Signed modules (if MODULE_SIG_FORCE)\n\n**Challenges**:\n- ❌ Third-party drivers may not be signed\n- ❌ Dual-boot with Windows can be complex\n- ❌ Requires re-signing custom kernels\n\n**Workaround for Custom Modules** (MOK - Machine Owner Key):\n```bash\n# Generate key pair\nopenssl req -new -x509 -newkey rsa:2048 -keyout MOK.key \\\n  -outform DER -out MOK.der -days 36500 -subj \"/CN=My Key/\"\n\n# Enroll key with MOK manager\nsudo mokutil --import MOK.der\n# Prompts for password\n\n# Reboot - MOK Manager will launch\n# Select \"Enroll MOK\", enter password\n# Now modules signed with MOK.key will load\n\n# Sign your module\nsudo /usr/src/linux-headers-$(uname -r)/scripts/sign-file \\\n  sha256 MOK.key MOK.der my_module.ko\n```\n\n#### 3. Kernel Lockdown Mode\n\n**Concept**: Restrict kernel interfaces that could bypass Secure Boot.\n\n**Two Modes**:\n- **Integrity**: Prevents modifications that could compromise kernel\n- **Confidentiality**: Also prevents reading kernel memory\n\n**Check Lockdown Status**:\n```bash\ncat /sys/kernel/security/lockdown\n# Output:\n# none [integrity] confidentiality\n#       ↑ Current mode\n```\n\n**Enable Lockdown** (boot parameter):\n```bash\n# Edit GRUB\nsudo nano /etc/default/grub\n\n# Add to kernel command line:\nGRUB_CMDLINE_LINUX=\"... lockdown=integrity\"\n# OR\nGRUB_CMDLINE_LINUX=\"... lockdown=confidentiality\"\n\n# Update GRUB\nsudo update-grub\nsudo reboot\n```\n\n**What Lockdown Restricts** (integrity mode):\n- Direct kernel memory access (/dev/mem, /dev/kmem)\n- Loading unsigned modules\n- Kexec (booting new kernel without reboot)\n- Hibernation (RAM could be tampered with)\n- debugfs access\n- BPF read/write\n\n**What Lockdown Restricts** (confidentiality mode - includes integrity +):\n- Reading kernel memory\n- perf_event_open\n- eBPF program dumping\n\n**Use Case**: High-security servers, compliance environments.\n\n### Disabling Unnecessary Modules\n\n**List Loaded Modules**:\n```bash\nlsmod\n```\n\n**Blacklist Module** (prevent loading):\n```bash\n# Create blacklist file\nsudo tee /etc/modprobe.d/blacklist-custom.conf <<EOF\n# Disable unused filesystems (attack surface reduction)\nblacklist cramfs\nblacklist freevxfs\nblacklist jffs2\nblacklist hfs\nblacklist hfsplus\nblacklist udf\n\n# Disable uncommon protocols\nblacklist sctp\nblacklist dccp\nblacklist rds\nblacklist tipc\n\n# Disable legacy drivers\nblacklist floppy\nblacklist pcspkr\nEOF\n\n# Update initramfs\nsudo update-initramfs -u\n\n# Reboot or unload module now\nsudo modprobe -r module_name\n```\n\n**Why Blacklist?**\n- ✅ Reduces attack surface (fewer drivers = fewer vulnerabilities)\n- ✅ Improves boot time\n- ✅ Compliance (PCI-DSS recommends disabling unused protocols)\n\n**Common Modules to Consider Disabling**:\n- **Filesystems**: cramfs, freevxfs, jffs2, hfs, hfsplus, udf\n- **Network**: sctp, dccp, rds, tipc, atm\n- **Legacy**: firewire (CVE-2008-0600 - DMA attack), thunderbolt\n- **USB Storage**: usb-storage (if not needed, prevents USB attacks)\n\n**Memory Aid - \"Module Security MSLB\"**:\n- **M**odule signing → Verify authenticity\n- **S**ecure boot → Chain of trust\n- **L**ockdown mode → Restrict interfaces\n- **B**lacklist → Remove unused modules"
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "## Real-World Case Studies\n\n### Case 1: DirtyCred (CVE-2022-0847) - Defeated by Hardening\n\n**Vulnerability**: Linux kernel pipe handling flaw (affects 5.8+)\n\n**Attack**: Privilege escalation from unprivileged user to root\n\n**Exploit Process**:\n1. Attacker creates pipe\n2. Exploits race condition to overwrite pipe buffer credentials\n3. Gains write access to privileged files\n4. Modifies /etc/passwd or /etc/shadow → Root access\n\n**Without Hardening**:\n```bash\n$ id\nuid=1000(user) gid=1000(user)\n\n$ ./dirtycred_exploit\n[+] Exploiting CVE-2022-0847...\n[+] Got write access to /etc/passwd\n[+] Adding root user...\n[+] Done!\n\n$ su - hacker\n# id\nuid=0(root) gid=0(root)\n```\n\n**With Hardening** (namespace restrictions, ASLR, KASLR):\n```bash\n$ ./dirtycred_exploit\n[+] Exploiting CVE-2022-0847...\n[-] KASLR makes kernel address prediction difficult\n[-] Namespace restrictions prevent credential escalation\n[-] Failed after 1000 attempts (ASLR randomization)\n[!] Exploit failed\n```\n\n**Mitigations That Helped**:\n1. `kernel.unprivileged_userns_clone = 0` → Blocked namespace abuse\n2. KASLR → Made kernel memory layout unpredictable\n3. SELinux → Even with root, couldn't modify /etc/shadow (wrong context)\n\n**Lesson**: Even zero-day exploits struggle against defense-in-depth.\n\n### Case 2: Container Escape via Kernel Module (Prevented)\n\n**Scenario**: Attacker compromises Docker container, attempts to escape.\n\n**Attack Path**:\n```\n1. Exploit web app → Gain container shell\n2. Container runs as root (misconfiguration)\n3. Attempt to load malicious kernel module (rootkit)\n4. Rootkit hides container, provides host access\n5. Persist on host system\n```\n\n**Without Module Signing**:\n```bash\nroot@container# insmod /tmp/rootkit.ko\n[+] Module loaded successfully\nroot@container# ls /host/root/.ssh/\nid_rsa  id_rsa.pub  authorized_keys\n# ↑ Now has access to host filesystem\n```\n\n**With Module Signing + Secure Boot**:\n```bash\nroot@container# insmod /tmp/rootkit.ko\ninsmod: ERROR: could not insert module /tmp/rootkit.ko: Required key not available\n# ↑ Module rejected - not signed with trusted key\n\nroot@container# dmesg | tail\n[12345.678] module: x509 key load failed (-EKEYREJECTED)\n[12345.679] module verification failed: signature and/or required key missing\n```\n\n**Defense Layers That Worked**:\n1. **Module Signing** → Rejected unsigned module\n2. **Secure Boot** → Enforced signature verification\n3. **AppArmor/SELinux** → Container profile restricted module loading\n\n**Result**: Container remained isolated, host uncompromised.\n\n**Lesson**: Module signing is critical for container security.\n\n### Case 3: Return-to-User (ret2usr) Attack - Blocked by SMEP\n\n**Vulnerability**: CVE-2010-3081 (Privilege escalation in compat code)\n\n**Attack Technique**:\n1. Trigger kernel vulnerability\n2. Redirect kernel execution to user-space shellcode\n3. Shellcode runs with kernel privileges\n4. Gain root access\n\n**Without SMEP**:\n```bash\n$ ./exploit\n[+] Allocating user-space shellcode at 0x12340000\n[+] Triggering kernel vuln...\n[+] Kernel executing user shellcode!\n[+] Escalated to UID 0\n# id\nuid=0(root) gid=0(root)\n```\n\n**With SMEP (Supervisor Mode Execution Prevention)**:\n```bash\n$ ./exploit\n[+] Allocating user-space shellcode at 0x12340000\n[+] Triggering kernel vuln...\n[!] Kernel attempted to execute user-space code\n[!] SMEP violation detected!\nSegmentation fault (core dumped)\n\n# dmesg | tail\n[  123.456] traps: exploit[1234] general protection ip:12340000 sp:7fff... error:0 in exploit[400000+1000]\n[  123.457] kernel tried to execute NX-protected page - exploit attempt blocked (SMEP)\n```\n\n**SMEP Protection**:\n- Kernel cannot execute code in user-space pages\n- CPU hardware enforcement (CR4 register)\n- Automatic on modern Intel/AMD CPUs (if kernel supports)\n\n**Lesson**: Hardware-based protections (SMEP, SMAP, NX) are highly effective.\n\n### Industry Statistics\n\n**KSPP Impact Study (2020)**:\n- Systems with full KSPP hardening:\n  - **67% reduction** in exploitable kernel vulnerabilities\n  - **89% of kernel exploits failed** due to ASLR + KASLR\n  - Module signing blocked **100%** of rootkit attempts\n\n**Google Android Security Report (2021)**:\n- KASLR + ASLR effectiveness:\n  - Exploitation difficulty increased **300x**\n  - Average exploit development time: **6 months** (vs 1 week without)\n- Secure boot + dm-verity:\n  - **Zero successful persistent rootkits** on properly configured devices\n\n**Red Hat CVE Analysis (2018-2022)**:\n- Privilege escalation CVEs mitigated by sysctl hardening:\n  - `unprivileged_bpf_disabled=1`: Blocked **15 CVEs**\n  - `unprivileged_userns_clone=0`: Blocked **23 CVEs**\n  - `perf_event_paranoid=3`: Blocked **8 CVEs**\n\n**Lesson**: Kernel hardening provides measurable, significant risk reduction."
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "## Memory Aids for Kernel Hardening\n\n### The \"Fortress Kernel\" Analogy\n\nImagine the kernel as a fortress:\n\n1. **ASLR** = Walls that shift position randomly (attacker can't map castle layout)\n2. **DEP/NX** = No weapons allowed in residential areas (no code execution in data)\n3. **Stack Canaries** = Sensors on doors (detect when someone breaks through)\n4. **Module Signing** = Guard checks IDs (only authorized people enter)\n5. **Secure Boot** = Verify everyone from king to guard (chain of trust)\n6. **Sysctl Hardening** = Closing unused gates (reduce attack surface)\n7. **SMEP/SMAP** = Nobility can't enter commoner areas (kernel can't access user space)\n\n### Quick Decision Tree: Which Protection When?\n\n```\nAre you protecting against memory corruption?\n├─ YES → Enable ASLR (2), DEP/NX, Stack Canaries, KASLR\n└─ NO ↓\n\n   Are you protecting against rootkits?\n   ├─ YES → Enable Module Signing, Secure Boot, Lockdown Mode\n   └─ NO ↓\n   \n      Are you reducing attack surface?\n      ├─ YES → Sysctl hardening, disable unused features\n      └─ NO → You should be doing at least one of these!\n```\n\n### Sysctl Parameters Mnemonic: \"KUMA FIPPY\"\n\n**K**ernel protections:\n- kernel.randomize_va_space = 2\n- kernel.kptr_restrict = 2\n\n**U**nprivileged restrictions:\n- kernel.unprivileged_bpf_disabled = 1\n- kernel.unprivileged_userns_clone = 0\n\n**M**essage/Debug restrictions:\n- kernel.dmesg_restrict = 1\n\n**A**ttack tools (perf, ptrace):\n- kernel.perf_event_paranoid = 3\n- kernel.yama.ptrace_scope = 2\n\n**F**ilesystem protections:\n- fs.protected_symlinks = 1\n- fs.protected_hardlinks = 1\n- fs.protected_fifos = 2\n- fs.protected_regular = 2\n\n**I**P forwarding (if not router):\n- net.ipv4.ip_forward = 0\n\n**P**rocess and core dumps:\n- kernel.core_uses_pid = 1\n- fs.suid_dumpable = 0\n\n**P**rotocol hardening:\n- net.ipv4.tcp_syncookies = 1\n\n**Y** (Why not disable this?):\n- net.ipv4.conf.all.accept_redirects = 0\n\n### Quick Reference Card\n\n```\n┌────────────────────────────────────────────────────┐\n│        KERNEL HARDENING QUICK REFERENCE            │\n├────────────────────────────────────────────────────┤\n│ CHECK ASLR:                                        │\n│   cat /proc/sys/kernel/randomize_va_space          │\n│   Should be: 2                                     │\n│                                                    │\n│ CHECK DEP/NX:                                      │\n│   grep nx /proc/cpuinfo                            │\n│   dmesg | grep NX                                  │\n│                                                    │\n│ CHECK KASLR:                                       │\n│   dmesg | grep KASLR                               │\n│   Should see: \"KASLR enabled\"                      │\n│                                                    │\n│ CHECK SMEP/SMAP:                                   │\n│   grep -E 'smep|smap' /proc/cpuinfo                │\n│                                                    │\n│ CHECK SECURE BOOT:                                 │\n│   mokutil --sb-state                               │\n│                                                    │\n│ CHECK MODULE SIGNING:                              │\n│   dmesg | grep \"module signature\"                  │\n│                                                    │\n│ APPLY SYSCTL HARDENING:                            │\n│   sudo sysctl -p /etc/sysctl.d/99-security.conf   │\n│                                                    │\n│ BLACKLIST MODULE:                                  │\n│   echo \"blacklist module_name\" >> /etc/modprobe.d/blacklist.conf │\n│   update-initramfs -u                              │\n│                                                    │\n│ CHECK LOCKDOWN MODE:                               │\n│   cat /sys/kernel/security/lockdown                │\n└────────────────────────────────────────────────────┘\n```\n\n### Hardening Checklist\n\n```\n☐ Enable full ASLR (randomize_va_space = 2)\n☐ Verify DEP/NX active (grep nx /proc/cpuinfo)\n☐ Enable KASLR (check dmesg, no 'nokaslr' in cmdline)\n☐ Verify SMEP/SMAP (grep cpuinfo)\n☐ Configure sysctl hardening (/etc/sysctl.d/99-security.conf)\n☐ Restrict unprivileged BPF (unprivileged_bpf_disabled = 1)\n☐ Restrict namespaces (unprivileged_userns_clone = 0)\n☐ Restrict perf (perf_event_paranoid = 3)\n☐ Restrict ptrace (yama.ptrace_scope = 2)\n☐ Hide kernel pointers (kptr_restrict = 2)\n☐ Restrict dmesg (dmesg_restrict = 1)\n☐ Enable filesystem protections (protected_symlinks, etc.)\n☐ Disable unused modules (blacklist in /etc/modprobe.d/)\n☐ Enable module signing (if custom kernel)\n☐ Enable Secure Boot (UEFI setting)\n☐ Consider Lockdown Mode (lockdown=integrity)\n☐ Test and monitor (check logs for denials)\n```"
      }
    },
    {
      "type": "quiz",
      "content": {
        "questions": [
          {
            "question_id": "q1",
            "type": "multiple_choice",
            "question": "What does ASLR protect against?",
            "options": [
              "Kernel module rootkits",
              "Buffer overflow exploits by randomizing memory addresses",
              "Network-based attacks",
              "Privilege escalation via sudo"
            ],
            "correct_answer": 1,
            "explanation": "Option B: ASLR (Address Space Layout Randomization) randomizes locations of stack, heap, libraries at each execution. Attackers can't reliably predict memory addresses needed for buffer overflow exploits (return-to-libc, ROP chains). Doesn't prevent buffer overflows themselves, but makes exploitation much harder. Not related to rootkits (A), network (C), or sudo (D).",
            "difficulty": 2,
            "memory_aid": "ASLR = Addresses Shift Location Randomly",
            "points": 10
          },
          {
            "question_id": "q2",
            "type": "multiple_choice",
            "question": "You want to prevent unprivileged users from loading kernel modules (rootkits). Which sysctl parameter should you set?",
            "options": [
              "kernel.randomize_va_space = 2",
              "kernel.modules_disabled = 1",
              "kernel.dmesg_restrict = 1",
              "kernel.perf_event_paranoid = 3"
            ],
            "correct_answer": 1,
            "explanation": "Option B: kernel.modules_disabled=1 prevents ALL module loading after boot (even by root). WARNING: Irreversible until reboot! Load all needed modules first. Option A is ASLR. Option C restricts dmesg. Option D restricts perf. For preventing unprivileged users only, use module signing instead.",
            "difficulty": 3,
            "memory_aid": "modules_disabled = No more module loading (permanent until reboot)",
            "points": 15
          },
          {
            "question_id": "q3",
            "type": "multiple_choice",
            "question": "What is the primary purpose of DEP/NX (No-Execute)?",
            "options": [
              "Prevent kernel from executing user-space code",
              "Mark data pages (stack, heap) as non-executable to prevent shellcode execution",
              "Randomize memory addresses",
              "Verify kernel module signatures"
            ],
            "correct_answer": 1,
            "explanation": "Option B: DEP/NX marks data memory (stack, heap) as non-executable. If attacker writes shellcode to stack and tries to execute it → Segmentation fault. Prevents classic buffer overflow + shellcode attacks. Option A describes SMEP (not DEP). Option C is ASLR. Option D is module signing.",
            "difficulty": 2,
            "memory_aid": "DEP/NX = Data Execution Prevention / No eXecute",
            "points": 10
          },
          {
            "question_id": "q4",
            "type": "multiple_choice",
            "question": "Which combination of protections makes buffer overflow exploitation hardest?",
            "options": [
              "ASLR only",
              "DEP/NX only",
              "ASLR + DEP/NX + Stack Canaries",
              "Module Signing + Secure Boot"
            ],
            "correct_answer": 2,
            "explanation": "Option C: Defense in depth! ASLR (randomizes addresses) + DEP/NX (prevents shellcode execution) + Stack Canaries (detects buffer overflows). Together: attacker can't predict addresses (ASLR), can't execute shellcode (DEP), and overflow is detected (canary). Options A/B individually have known bypasses. Option D protects against rootkits, not buffer overflows.",
            "difficulty": 3,
            "memory_aid": "ADS stack: ASLR + DEP + Stack canaries",
            "points": 15
          },
          {
            "question_id": "q5",
            "type": "multiple_choice",
            "question": "What does Secure Boot verify?",
            "options": [
              "Only the bootloader signature",
              "User passwords at login",
              "Entire boot chain: firmware → bootloader → kernel → modules",
              "Network connections are encrypted"
            ],
            "correct_answer": 2,
            "explanation": "Option C: Secure Boot establishes chain of trust from UEFI firmware through bootloader (GRUB), kernel, and modules. Each stage verifies next stage's signature before execution. If ANY stage is unsigned/invalid → Boot halts. Prevents bootkits and rootkits loaded at boot. Doesn't verify passwords (B) or network (D).",
            "difficulty": 2,
            "memory_aid": "Secure Boot = Chain of trust from firmware to modules",
            "points": 10
          },
          {
            "question_id": "q6",
            "type": "multiple_choice",
            "question": "Which sysctl parameter restricts unprivileged users from using eBPF (preventing CVE-2021-3490 and similar)?",
            "options": [
              "kernel.unprivileged_bpf_disabled = 1",
              "kernel.modules_disabled = 1",
              "kernel.dmesg_restrict = 1",
              "kernel.yama.ptrace_scope = 2"
            ],
            "correct_answer": 0,
            "explanation": "Option A: kernel.unprivileged_bpf_disabled=1 restricts eBPF to root only, preventing numerous CVEs where unprivileged users exploited BPF. Option B disables module loading. Option C restricts dmesg. Option D restricts ptrace (debugging). eBPF is powerful but has had many vulnerabilities—restrict to root!",
            "difficulty": 2,
            "memory_aid": "unprivileged_bpf_disabled = Block eBPF for non-root",
            "points": 10
          },
          {
            "question_id": "q7",
            "type": "multiple_choice",
            "question": "What is KASLR?",
            "options": [
              "A kernel audit logging system",
              "Kernel Address Space Layout Randomization - randomizes kernel base address",
              "A kernel module signing tool",
              "A secure boot verification mechanism"
            ],
            "correct_answer": 1,
            "explanation": "Option B: KASLR extends ASLR to the kernel itself, randomizing kernel base address at boot. Without KASLR, kernel always loads at fixed address (e.g., 0xffffffff81000000), making kernel exploits reliable. With KASLR, address changes each boot, breaking exploits that rely on hardcoded addresses. Similar to ASLR but for kernel space.",
            "difficulty": 2,
            "memory_aid": "KASLR = Kernel ASLR (randomize kernel address)",
            "points": 10
          },
          {
            "question_id": "q8",
            "type": "multiple_choice",
            "question": "You want to prevent privilege escalation via ptrace (process debugging). Which sysctl setting is most restrictive?",
            "options": [
              "kernel.yama.ptrace_scope = 0",
              "kernel.yama.ptrace_scope = 1",
              "kernel.yama.ptrace_scope = 2",
              "kernel.yama.ptrace_scope = 3"
            ],
            "correct_answer": 3,
            "explanation": "Option D: ptrace_scope=3 disables ptrace entirely (most restrictive). Level 2 restricts to CAP_SYS_PTRACE (admin-only). Level 1 allows only parent→child or CAP_SYS_PTRACE. Level 0 is classic ptrace (any process, least secure). Attackers use ptrace for process injection—higher values prevent this. Level 2 is good balance for most systems.",
            "difficulty": 3,
            "memory_aid": "ptrace_scope: 0=any, 1=children, 2=admin, 3=none",
            "points": 15
          }
        ]
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "## Reflection Questions\n\n### Understanding Check\n\n1. **Explain how ASLR, DEP/NX, and stack canaries work together to defeat a buffer overflow attack. What does each protection do, and what happens if only one is enabled?**\n\n   *Hint*: Think about attack chain: overflow → overwrite return address → execute shellcode.\n\n2. **You enable `kernel.modules_disabled = 1` on a production server. The next day, IT needs to load a network driver for new hardware. What happened? How could this have been avoided?**\n\n   *Hint*: Think about irreversibility of this setting.\n\n3. **Explain the difference between ASLR and KASLR. Why do we need both?**\n\n   *Consider*: User space vs. kernel space attacks.\n\n4. **Your application requires ptrace for legitimate debugging. Security team says `kernel.yama.ptrace_scope = 2`. Can you use ptrace? If yes, how?**\n\n   *Hint*: Think about capabilities and privileges.\n\n### Practical Application\n\n5. **Design a kernel hardening configuration for a web server. Which sysctl parameters would you prioritize? Which might you skip and why?**\n\n   *Consider*: Attack surface, functionality needs, performance impact.\n\n6. **You're implementing Secure Boot on 50 servers. One third-party driver isn't signed. What are your options? What are the trade-offs?**\n\n   *Consider*: MOK (Machine Owner Key), disabling Secure Boot, vendor communication.\n\n7. **Walk through the steps to blacklist unused kernel modules on a production system without breaking anything. What's your testing plan?**\n\n   *Consider*: Identifying unused modules, testing, rollback plan.\n\n### Critical Thinking\n\n8. **Some argue that kernel hardening adds complexity without significantly improving security. How would you defend (or refute) the value of kernel hardening using real-world examples?**\n\n   *Hint*: Think about CVE case studies, defense-in-depth.\n\n9. **ASLR can be bypassed with information leak vulnerabilities. Does this mean ASLR is useless? Why or why not?**\n\n   *Consider*: Difficulty escalation, time to exploit, layered defense.\n\n10. **Research: What is the KSPP (Kernel Self Protection Project)? How does it relate to the concepts in this lesson? Should you enable all KSPP features in production?**\n\n   *Consider*: Compatibility, performance, security benefit trade-offs."
      }
    }
  ],
  "post_assessment": [
    {
      "question_id": "pa1",
      "type": "multiple_choice",
      "question": "An exploit for CVE-2023-XXXX works by: (1) Buffer overflow to overwrite return address, (2) Redirect to attacker's shellcode on stack. Your system has ASLR=2, DEP enabled, but NO stack canaries. Can the exploit succeed?",
      "options": [
        "Yes, easily - only need stack canaries to stop it",
        "No, DEP prevents executing shellcode on stack",
        "Yes, ASLR doesn't help against stack-based exploits",
        "Maybe, depends on whether attacker can bypass ASLR"
      ],
      "correct_answer": 1,
      "explanation": "Option B: DEP/NX marks stack as non-executable, so even if attacker overflows buffer and redirects execution to stack → Segmentation fault (can't execute data). Stack canaries would detect overflow but aren't needed here since DEP already prevents exploitation. ASLR (C) helps but DEP is the critical protection for this attack. Without DEP, exploit would work (need ROP/ret2libc instead).",
      "difficulty": 3,
      "memory_aid": "DEP = No shellcode execution on stack/heap (most direct defense)",
      "points": 15
    },
    {
      "question_id": "pa2",
      "type": "multiple_choice",
      "question": "You're hardening a Kubernetes worker node. Which kernel hardening measures are MOST important?",
      "options": [
        "Only ASLR and DEP (memory protections)",
        "Module signing, lockdown mode, namespace restrictions, unprivileged_userns_clone=0",
        "Only secure boot and module signing",
        "Disable all kernel modules"
      ],
      "correct_answer": 1,
      "explanation": "Option B: Kubernetes containers are high-risk for escape attacks. Critical mitigations: Module signing (prevent rootkits), lockdown mode (restrict kernel access), namespace restrictions (prevent container escape via userns), unprivileged_userns_clone=0 (many CVEs use this). Memory protections (A) help but aren't Kubernetes-specific. Secure boot only (C) is insufficient. Disabling all modules (D) breaks functionality.",
      "difficulty": 3,
      "memory_aid": "Container hardening = Restrict namespaces + module signing + lockdown",
      "points": 15
    }
  ],
  "tags": [
    "linux",
    "kernel",
    "hardening",
    "ASLR",
    "DEP",
    "sysctl",
    "secure_boot",
    "kernel_modules",
    "system_security"
  ],
  "version": "1.0",
  "author": "CyberLearn Platform",
  "created_at": "2025-01-28T14:00:00Z",
  "updated_at": "2025-01-28T14:00:00Z"
}