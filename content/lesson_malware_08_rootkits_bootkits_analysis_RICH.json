{
  "lesson_id": "a8f3c2d1-9e7b-4f5a-8d3c-1a2b3c4d5e6f",
  "domain": "malware",
  "title": "Rootkits and Bootkits: Kernel-Level Malware Analysis",
  "difficulty": 3,
  "order_index": 8,
  "prerequisites": [
    "945e789c-12af-4d3e-a567-89bcdef01234"
  ],
  "concepts": [
    "Kernel-mode rootkits",
    "Bootkit infection vectors",
    "SSDT hooking",
    "IRP hooking",
    "DKOM (Direct Kernel Object Manipulation)",
    "MBR and UEFI bootkits",
    "Kernel debugging with WinDbg",
    "Driver signature enforcement bypass",
    "Rootkit detection techniques",
    "Memory forensics for rootkit analysis"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand the architecture and capabilities of kernel-mode rootkits",
    "Analyze bootkit infection mechanisms and persistence techniques",
    "Master kernel debugging techniques for rootkit analysis",
    "Identify SSDT, IDT, and IRP hooking techniques",
    "Detect and analyze Direct Kernel Object Manipulation (DKOM)",
    "Understand MBR and UEFI bootkit infection vectors",
    "Apply memory forensics techniques to detect rootkits",
    "Analyze real-world rootkit families (TDL4, Stuxnet, etc.)"
  ],
  "post_assessment": [
    {
      "question": "What is the primary advantage of kernel-mode rootkits over user-mode rootkits?",
      "options": [
        "They are easier to develop",
        "They have unrestricted access to system resources and can hide from security tools",
        "They don't require administrator privileges",
        "They are immune to antivirus detection"
      ],
      "correct_answer": 1,
      "question_id": "4e21e461-f635-4c16-9209-a13827988099",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "What does SSDT stand for in the context of rootkit hooking?",
      "options": [
        "System Service Dispatch Table",
        "Secure System Data Transfer",
        "Service Stack Descriptor Table",
        "System Security Detection Tool"
      ],
      "correct_answer": 0,
      "question_id": "be1305df-23dd-4ece-a55e-b65f94e970e9",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "Which technique allows rootkits to modify kernel structures directly without hooking?",
      "options": [
        "API hooking",
        "Direct Kernel Object Manipulation (DKOM)",
        "Process injection",
        "DLL hijacking"
      ],
      "correct_answer": 1,
      "question_id": "4597b832-c216-402a-bc3f-a71a516ab775",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "What is the primary infection target for MBR bootkits?",
      "options": [
        "Windows Registry",
        "Boot Configuration Data (BCD)",
        "Master Boot Record (first sector of disk)",
        "Windows kernel drivers"
      ],
      "correct_answer": 2,
      "question_id": "81a86e94-26ce-43b1-b9c8-f2c4d19af780",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "Which Windows feature makes it difficult for attackers to load unsigned kernel drivers?",
      "options": [
        "User Account Control (UAC)",
        "Windows Defender",
        "Driver Signature Enforcement (DSE)",
        "Secure Boot"
      ],
      "correct_answer": 2,
      "question_id": "483b0956-1e55-4035-992c-1477ca68916d",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "What does IRP hooking allow rootkits to intercept?",
      "options": [
        "Network traffic only",
        "I/O Request Packets between drivers and devices",
        "Registry modifications only",
        "User login attempts"
      ],
      "correct_answer": 1,
      "question_id": "5118daac-2c51-4386-9ae2-4ad5806bdd6c",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "Which tool is the industry standard for kernel debugging on Windows?",
      "options": [
        "OllyDbg",
        "IDA Pro",
        "WinDbg",
        "x64dbg"
      ],
      "correct_answer": 2,
      "question_id": "3c6898fa-3c97-45df-b7d1-11e6b4c8ea6c",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "What is a key characteristic of UEFI bootkits compared to MBR bootkits?",
      "options": [
        "They are easier to detect",
        "They infect the UEFI firmware and can survive disk formatting",
        "They only work on 32-bit systems",
        "They require user interaction to activate"
      ],
      "correct_answer": 1,
      "question_id": "676fbe86-4b07-4a9b-9e8d-7e5c83301c26",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "Which Volatility plugin is specifically designed to detect SSDT hooks?",
      "options": [
        "pslist",
        "malfind",
        "ssdt",
        "dlllist"
      ],
      "correct_answer": 2,
      "question_id": "fa9b48af-e415-4622-a793-cbb29a9d7c16",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    },
    {
      "question": "What was significant about the TDL4/TDSS bootkit?",
      "options": [
        "It was the first rootkit ever created",
        "It infected the MBR and could load before the operating system",
        "It only targeted Linux systems",
        "It was developed by a nation-state actor"
      ],
      "correct_answer": 1,
      "question_id": "df3bd832-195a-43f6-bdf4-7abbd8373152",
      "type": "multiple_choice",
      "difficulty": 3,
      "explanation": "Explanation not provided."
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "meta_learning",
    "teach_like_im_10",
    "minimum_effective_dose",
    "memory_hooks",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "explanation",
      "content": {
        "text": "# Introduction to Rootkits and Bootkits\n\nWelcome to the deepest, darkest corner of malware analysis! Rootkits and bootkits represent the most sophisticated and stealthy forms of malware. Operating at the kernel level or even below the operating system, these threats can completely compromise a system while remaining invisible to traditional security tools.\n\n## What Makes Rootkits Special?\n\nWhile most malware operates at the user level (Ring 3), rootkits operate at the kernel level (Ring 0) or even lower (Ring -1 for hypervisor rootkits, Ring -2 for SMM rootkits). This privileged position gives them:\n\n- **Complete system control**: Full access to memory, processes, files, and network traffic\n- **Stealth capabilities**: Ability to hide processes, files, registry keys, and network connections\n- **Persistence**: Difficult to remove without specialized tools or complete system reinstallation\n- **Security tool evasion**: Can disable or manipulate antivirus, EDR, and monitoring tools\n\n## Rootkit vs. Bootkit\n\n**Rootkit**: Malware that operates at the kernel level (Ring 0) and uses hooking or Direct Kernel Object Manipulation to hide its presence and maintain control.\n\n**Bootkit**: A type of rootkit that infects the boot process (MBR, VBR, or UEFI firmware) and loads before the operating system, giving it even deeper control.\n\n## Historical Context\n\nRootkits have evolved significantly:\n- **1990s**: Early user-mode rootkits (simple API hooking)\n- **Early 2000s**: Kernel-mode rootkits (FU, Hacker Defender)\n- **2007**: First MBR bootkit (Stoned bootkit at Black Hat)\n- **2011**: TDL4/TDSS bootkit (infected millions of systems)\n- **2015**: Hacking Team's UEFI rootkit leaked\n- **2018**: LoJax - first UEFI bootkit found in the wild\n- **Present**: Nation-state actors use firmware rootkits (NSA's ANT catalog)\n\nUnderstanding rootkits is essential for advanced malware analysts, incident responders, and anyone working in enterprise security."
      }
    },
    {
      "type": "video",
      "content": {
        "title": "Video: Rootkits and Bootkits: Kernel-Level Malware Analysis Overview",
        "url": "https://www.youtube.com/embed/Vh_h6NfLkAg",
        "description": "Watch this video for a visual introduction to the concepts covered in this lesson."
      }
    },
    {
      "type": "mindset_coach",
      "content": {
        "text": "**Mindset Moment: Embracing Complexity**\n\nRootkit analysis is challenging. You're dealing with the most complex layer of the operating system, cryptic assembly code, and malware designed by highly skilled attackers. Here's your mindset for success:\n\n**1. Start Simple, Go Deep**: Don't try to understand everything at once. Master user-mode concepts first, then move to kernel basics, then advanced rootkit techniques.\n\n**2. Build Your Foundation**: Understanding Windows internals (processes, drivers, memory management) is non-negotiable. Every hour spent learning the legitimate system pays dividends when analyzing malicious modifications.\n\n**3. Practice Pattern Recognition**: Rootkits use similar techniques (hooking, DKOM, etc.). Once you recognize these patterns, new rootkits become variations on familiar themes.\n\n**4. Learn from the Masters**: Study famous rootkits (FU, TDL4, Stuxnet kernel module). Read papers and presentations from researchers like Alex Ionescu, Joanna Rutkowska, and Peter Kleissner.\n\n**5. Embrace Failure**: Your first few rootkit analyses will be frustrating. You'll get lost in kernel structures, misinterpret memory dumps, and spend hours on false leads. That's normal. Each failure teaches you something new.\n\n**Remember**: Every expert rootkit analyst started exactly where you are. The difference isn't talent—it's persistence and systematic learning. You've got this!"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# Windows Kernel Architecture (Quick Review)\n\nBefore analyzing rootkits, you need to understand what they're attacking. Here's the essential Windows kernel architecture:\n\n## Privilege Rings\n\nWindows uses x86/x64 privilege levels:\n\n```\nRing 0: Kernel Mode (ntoskrnl.exe, drivers)\n  ├─ Full hardware access\n  ├─ No memory restrictions\n  └─ Complete system control\n\nRing 3: User Mode (applications, services)\n  ├─ Limited memory access\n  ├─ Must call kernel for privileged operations\n  └─ Crashes don't affect other processes\n```\n\n## Key Kernel Components\n\n**1. ntoskrnl.exe (NT Kernel)**\n- Core Windows kernel\n- Process/thread management\n- Memory management\n- I/O management\n\n**2. hal.dll (Hardware Abstraction Layer)**\n- Abstracts hardware differences\n- Low-level hardware access\n\n**3. Drivers (.sys files)**\n- Extend kernel functionality\n- Direct hardware communication\n- THIS IS WHERE ROOTKITS LIVE\n\n## Critical Kernel Structures\n\n**SSDT (System Service Dispatch Table)**\n- Table of pointers to kernel functions\n- User-mode programs call kernel via SSDT\n- Classic rootkit hooking target\n\n**IDT (Interrupt Descriptor Table)**\n- Handles hardware/software interrupts\n- Another hooking target\n\n**EPROCESS (Executive Process)**\n- Kernel structure representing a process\n- Contains PID, parent PID, thread list, etc.\n- DKOM rootkits modify this directly\n\n**Driver Objects & IRP**\n- Drivers registered as driver objects\n- I/O Request Packets (IRPs) route I/O operations\n- IRP hooking intercepts file/registry/network operations"
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "**Memory Aid: Rootkit Technique Mnemonic - \"SID HOOKS\"**\n\n**S** - SSDT (System Service Dispatch Table) hooking\n**I** - IDT (Interrupt Descriptor Table) hooking  \n**D** - DKOM (Direct Kernel Object Manipulation)\n\n**H** - Hardware manipulation (PCI, DMA)\n**O** - Object callback (process/thread/image load notifications)\n**O** - Output filtering (file system filter drivers)\n**K** - Kernel patching (inline hooks in ntoskrnl)\n**S** - Syscall manipulation (MSR modification on x64)\n\nWhen analyzing a rootkit, check each of these techniques systematically. Most rootkits use 2-4 of these methods."
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# Rootkit Technique #1: SSDT Hooking\n\nSSDT hooking was the most popular rootkit technique in the Windows XP era. While less effective on modern 64-bit Windows (due to PatchGuard), understanding it is essential for analyzing legacy malware and virtualized environments.\n\n## How SSDT Hooking Works\n\n1. **User-mode call**: Application calls `CreateFile()` (Win32 API)\n2. **Transition to kernel**: Call goes through ntdll.dll → `NtCreateFile()` (Native API)\n3. **SSDT lookup**: Kernel looks up `NtCreateFile` in the SSDT\n4. **Normal behavior**: SSDT points to legitimate kernel function\n5. **Rootkit behavior**: SSDT modified to point to rootkit's function\n6. **Filtering**: Rootkit examines the call, hides malicious files, then calls original function\n\n## SSDT Structure\n\n```c\ntypedef struct _SERVICE_DESCRIPTOR_TABLE {\n    PULONG_PTR ServiceTableBase;      // Array of function pointers\n    PULONG ServiceCounterTableBase;   // Not used on modern Windows\n    ULONG NumberOfServices;            // Number of functions in table\n    PUCHAR ParamTableBase;             // Parameter count for each function\n} SERVICE_DESCRIPTOR_TABLE, *PSERVICE_DESCRIPTOR_TABLE;\n```\n\n## Example: Hiding a File via SSDT Hook\n\n```c\n// Rootkit's hooked NtQueryDirectoryFile function\nNTSTATUS HookedNtQueryDirectoryFile(\n    HANDLE FileHandle,\n    HANDLE Event,\n    PIO_APC_ROUTINE ApcRoutine,\n    PVOID ApcContext,\n    PIO_STATUS_BLOCK IoStatusBlock,\n    PVOID FileInformation,\n    ULONG Length,\n    FILE_INFORMATION_CLASS FileInformationClass,\n    BOOLEAN ReturnSingleEntry,\n    PUNICODE_STRING FileName,\n    BOOLEAN RestartScan\n) {\n    NTSTATUS status;\n    \n    // Call the original function\n    status = OriginalNtQueryDirectoryFile(\n        FileHandle, Event, ApcRoutine, ApcContext,\n        IoStatusBlock, FileInformation, Length,\n        FileInformationClass, ReturnSingleEntry,\n        FileName, RestartScan\n    );\n    \n    if (NT_SUCCESS(status)) {\n        // Remove malicious files from the listing\n        PFILE_DIRECTORY_INFORMATION pEntry = (PFILE_DIRECTORY_INFORMATION)FileInformation;\n        PFILE_DIRECTORY_INFORMATION pPrevEntry = NULL;\n        \n        while (pEntry != NULL) {\n            if (wcsstr(pEntry->FileName, L\"rootkit\") != NULL) {\n                // This is our malicious file - hide it!\n                if (pPrevEntry != NULL) {\n                    if (pEntry->NextEntryOffset != 0) {\n                        pPrevEntry->NextEntryOffset += pEntry->NextEntryOffset;\n                    } else {\n                        pPrevEntry->NextEntryOffset = 0;\n                    }\n                }\n            } else {\n                pPrevEntry = pEntry;\n            }\n            \n            if (pEntry->NextEntryOffset == 0) break;\n            pEntry = (PFILE_DIRECTORY_INFORMATION)((PUCHAR)pEntry + pEntry->NextEntryOffset);\n        }\n    }\n    \n    return status;\n}\n```\n\nThis technique allows the rootkit to hide any file containing \"rootkit\" in its name from directory listings.\n\n## PatchGuard (Kernel Patch Protection)\n\nMicrosoft introduced PatchGuard on x64 Windows to prevent SSDT hooking:\n- Periodically checks kernel structures for modifications\n- Triggers BSOD (Blue Screen of Death) if modifications detected\n- Forced rootkit developers to use more sophisticated techniques\n\nModern rootkits on 64-bit systems use:\n- IRP hooking (harder to detect)\n- File system filter drivers (legitimate API)\n- DKOM (no hooking, direct manipulation)"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Hands-On: Detecting SSDT Hooks with Volatility\n\nLet's analyze a memory dump to detect SSDT hooks.\n\n## Step 1: Dump the SSDT\n\n```bash\n# Using Volatility 3\npython3 vol.py -f memory.dmp windows.ssdt\n\n# Output:\nIndex    Address              Module\n-----    -------              ------\n0x0000   0xfffff80002a3c1e0   ntoskrnl.exe\n0x0001   0xfffff80002a3c2f0   ntoskrnl.exe\n0x0002   0xfffff80002a3c400   ntoskrnl.exe\n...\n0x0042   0xfffff88001234567   rootkit.sys  # SUSPICIOUS!\n0x0043   0xfffff80002a3c510   ntoskrnl.exe\n```\n\n## Step 2: Identify Suspicious Entries\n\nLook for:\n- Entries pointing to unknown modules (not ntoskrnl.exe or win32k.sys)\n- Entries pointing to unmapped memory regions\n- Entries with suspicious names (random strings, misspelled system names)\n\n## Step 3: Examine the Hooked Function\n\n```bash\n# Disassemble the suspicious address\npython3 vol.py -f memory.dmp windows.dumpaddr --address 0xfffff88001234567 --size 256 -o rootkit_hook.bin\n\n# Analyze with IDA Pro or Ghidra\n# Look for:\n# 1. JMP instruction to rootkit code\n# 2. Call to original function\n# 3. Filtering logic (hiding files, processes, etc.)\n```\n\n## Step 4: Compare with Clean System\n\n```bash\n# Export SSDT from known-good system\npython3 vol.py -f clean_memory.dmp windows.ssdt > clean_ssdt.txt\n\n# Compare\ndiff clean_ssdt.txt infected_ssdt.txt\n\n# Any differences indicate potential hooks\n```\n\n## Detection Tools\n\n**GMER** (Windows tool):\n- Real-time SSDT monitoring\n- Detects hooks and hidden processes\n- Free: http://www.gmer.net\n\n**IceSword** (Legacy tool):\n- Shows hidden processes, drivers, files\n- SSDT restoration capability\n\n**Rootkit Revealer** (Sysinternals - outdated):\n- Compares registry and file system APIs\n- Detects discrepancies indicating rootkits"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# Rootkit Technique #2: Direct Kernel Object Manipulation (DKOM)\n\nDKOM is the modern rootkit technique of choice. Instead of hooking APIs (which PatchGuard detects), DKOM directly modifies kernel data structures. It's stealthier but more fragile (system crashes if done incorrectly).\n\n## How DKOM Works\n\nRather than intercepting function calls, DKOM:\n1. Locates kernel structures in memory (EPROCESS, driver objects, etc.)\n2. Directly modifies pointers and fields\n3. Unlinks structures from linked lists\n4. No hooks = PatchGuard doesn't detect it\n\n## Example: Hiding a Process\n\nWindows maintains a doubly-linked list of all EPROCESS structures:\n\n```\nEPROCESS (csrss.exe)\n  |\n  v\nEPROCESS (lsass.exe) <--> EPROCESS (svchost.exe) <--> EPROCESS (rootkit.exe) <--> EPROCESS (explorer.exe)\n                          ^                                                     |\n                          |_____________________________________________________|\n```\n\nTo hide a process, the rootkit unlinks it:\n\n```c\n// EPROCESS structure (simplified)\ntypedef struct _EPROCESS {\n    // ... many fields ...\n    LIST_ENTRY ActiveProcessLinks;  // Doubly-linked list\n    ULONG_PTR UniqueProcessId;      // PID\n    CHAR ImageFileName[15];         // Process name\n    // ... more fields ...\n} EPROCESS, *PEPROCESS;\n\n// Function to hide a process by PID\nVOID HideProcess(ULONG ProcessId) {\n    PEPROCESS pEprocess = NULL;\n    \n    // Find the EPROCESS structure for our PID\n    if (NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)ProcessId, &pEprocess))) {\n        \n        // Unlink from ActiveProcessLinks list\n        PLIST_ENTRY pList = &pEprocess->ActiveProcessLinks;\n        \n        // Classic doubly-linked list unlink:\n        // previous->next = current->next\n        // next->previous = current->previous\n        \n        pList->Blink->Flink = pList->Flink;\n        pList->Flink->Blink = pList->Blink;\n        \n        // Point to itself to avoid null pointers\n        pList->Flink = pList;\n        pList->Blink = pList;\n        \n        ObDereferenceObject(pEprocess);\n    }\n}\n```\n\nAfter this:\n- Process Manager (`taskmgr.exe`) won't see the process\n- Process Explorer won't see it\n- `tasklist` won't see it\n- Process is still running and functional!\n\n## Other DKOM Techniques\n\n**1. Token Manipulation**\n- Every process has a TOKEN structure (privileges, user SID, etc.)\n- DKOM can replace a process's token with SYSTEM token\n- Result: Privilege escalation without exploits\n\n**2. Driver Object Hiding**\n- Drivers registered in `\\Driver` object manager directory\n- DKOM can unlink driver from this directory\n- Driver remains loaded and functional but invisible\n\n**3. ETHREAD Hiding**\n- Similar to EPROCESS hiding but for threads\n- Hides malicious threads within legitimate processes\n\n**4. Network Connection Hiding**\n- Windows maintains connection tables (TCB table)\n- DKOM can remove entries to hide network connections\n\n## Detection Challenges\n\nDKOM is hard to detect because:\n- No API hooks (PatchGuard can't help)\n- Legitimate kernel code never checks list integrity\n- Requires memory forensics to find hidden structures\n\n## Detection Methods\n\n**1. Cross-view Analysis**\n- Compare multiple views of the same data\n- Example: Compare process list from ActiveProcessLinks vs. PspCidTable vs. handles\n\n**2. List Walking**\n- Walk kernel lists manually and check for inconsistencies\n- Look for processes/drivers in memory not in official lists\n\n**3. Signature Scanning**\n- Scan memory for EPROCESS/ETHREAD/DRIVER_OBJECT signatures\n- Find structures not reachable through normal traversal"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Hands-On: Detecting DKOM Process Hiding\n\n## Method 1: Volatility Cross-View Analysis\n\n```bash\n# List processes via ActiveProcessLinks (normal method)\npython3 vol.py -f memory.dmp windows.pslist > pslist.txt\n\n# List processes via PspCidTable (alternate method)\npython3 vol.py -f memory.dmp windows.psscan > psscan.txt\n\n# Compare the two\ncomm -13 <(sort pslist.txt) <(sort psscan.txt)\n\n# Any processes in psscan but not pslist are potentially DKOM-hidden\n```\n\n## Method 2: Manual EPROCESS Scanning\n\n```python\n# Volatility plugin to find hidden processes\nimport volatility3.framework\nfrom volatility3.framework import interfaces, renderers\nfrom volatility3.plugins.windows import pslist, psscan\n\nclass HiddenProcessFinder(interfaces.plugins.PluginInterface):\n    \n    def run(self):\n        # Get processes via pslist (ActiveProcessLinks)\n        pslist_procs = set()\n        for proc in pslist.PsList.list_processes(self.context, self.config['primary']):\n            pslist_procs.add(proc.UniqueProcessId)\n        \n        # Get processes via psscan (pool scanning)\n        psscan_procs = set()\n        for proc in psscan.PsScan.scan_processes(self.context, self.config['primary']):\n            psscan_procs.add(proc.UniqueProcessId)\n        \n        # Find hidden processes\n        hidden = psscan_procs - pslist_procs\n        \n        return renderers.TreeGrid(\n            [(\"PID\", int), (\"Name\", str), (\"Status\", str)],\n            self._generator(hidden)\n        )\n    \n    def _generator(self, hidden_pids):\n        for pid in hidden_pids:\n            yield (0, (pid, \"Hidden by DKOM\", \"SUSPICIOUS\"))\n```\n\n## Method 3: Check for List Inconsistencies\n\n```bash\n# Using WinDbg (kernel debugger)\nkd> !process 0 0  # List all processes\n\n# Manually walk ActiveProcessLinks\nkd> dt nt!_EPROCESS <address> ActiveProcessLinks\n   +0x188 ActiveProcessLinks : _LIST_ENTRY [ 0xfffffa80`12345678 - 0xfffffa80`87654321 ]\n\n# Check if Flink->Blink points back to current entry\nkd> dt nt!_LIST_ENTRY 0xfffffa80`12345678\n   +0x000 Flink : 0xfffffa80`11111111\n   +0x008 Blink : 0xfffffa80`22222222  # Should point back to original\n\n# If Blink doesn't point back, list has been manipulated!\n```\n\n## Real-World Example: FU Rootkit\n\nThe famous FU rootkit (2005) used DKOM extensively:\n\n```c\n// FU's process hiding function\nvoid HideProcessById(DWORD pid) {\n    PEPROCESS pEprocess = FindProcessByPid(pid);\n    \n    if (pEprocess) {\n        // Unlink from ActiveProcessLinks\n        RemoveListEntry(&pEprocess->ActiveProcessLinks);\n        \n        // Also unlink from SessionProcessLinks\n        RemoveListEntry(&pEprocess->SessionProcessLinks);\n        \n        // Modify token to show PID as 0 (System Idle Process)\n        pEprocess->UniqueProcessId = 0;\n    }\n}\n```\n\nFU was detectable by scanning for pool tags and comparing multiple process lists."
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# Bootkits: Infecting Before the OS\n\nBootkits are the ultimate persistence mechanism. By infecting the boot process, they:\n- Load before the operating system\n- Load before security software (AV, EDR)\n- Survive operating system reinstallation\n- Are extremely difficult to detect and remove\n\n## Boot Process Overview\n\n### Legacy BIOS Boot Process:\n\n1. **Power On** → BIOS initializes hardware\n2. **BIOS** → Loads first sector of disk (MBR) into memory at 0x7C00\n3. **MBR** → Contains bootloader code (446 bytes) + partition table (64 bytes) + signature (2 bytes)\n4. **Bootloader** → Loads Volume Boot Record (VBR) from active partition\n5. **VBR** → Loads Windows Boot Manager (bootmgr)\n6. **Boot Manager** → Loads Windows Loader (winload.exe)\n7. **Windows Loader** → Loads kernel (ntoskrnl.exe) and drivers\n8. **Operating System** → Fully loaded\n\n### UEFI Boot Process:\n\n1. **Power On** → UEFI firmware initializes hardware\n2. **UEFI** → Reads EFI System Partition (ESP)\n3. **Boot Manager** → Loads bootloader from ESP (bootmgfw.efi)\n4. **Secure Boot** → Verifies digital signature (if enabled)\n5. **Bootloader** → Loads Windows\n\n## MBR Bootkits\n\n### Infection Process:\n\n```\nBefore Infection:\n[MBR: Legitimate Bootloader | Partition Table | 0x55AA]\n    ↓ loads\n[VBR: Windows Bootloader]\n    ↓ loads\n[Windows]\n\nAfter Infection:\n[MBR: Malicious Bootloader | Hook Code | 0x55AA]\n    ↓ loads\n[Hidden Sectors: Full Bootkit Code]\n    ↓ loads and hooks\n[VBR: Windows Bootloader] (now compromised)\n    ↓ loads\n[Windows] (bootkit has kernel control)\n```\n\n### TDL4/TDSS Bootkit (2011)\n\nTDL4 was one of the most sophisticated MBR bootkits:\n\n**Infection Steps:**\n1. Dropper runs with admin privileges\n2. Saves original MBR to hidden sectors\n3. Writes malicious bootloader to MBR\n4. Installs bootkit driver in hidden file system\n5. Modifies boot process to load bootkit\n\n**Bootkit Capabilities:**\n- Loads before Windows kernel\n- Hooks ATAPI/SCSI disk drivers (hides MBR modifications)\n- Injects payload into services.exe\n- Downloads additional malware\n- Proxies network traffic through infected machines\n- Survived Windows reinstallation (MBR untouched)\n\n**Removal Difficulty:**\n- Standard AV couldn't detect (loads before AV)\n- Manual removal required bootable USB\n- Many users had to use Kaspersky's TDSSKiller tool\n\n## UEFI Bootkits\n\nUEFI bootkits are more advanced and dangerous:\n\n### LoJax (2018) - First UEFI Bootkit in the Wild\n\nDiscovered by ESET, attributed to APT28 (Russian state-sponsored):\n\n**Infection Process:**\n1. Compromise system with standard malware\n2. Flash modified UEFI firmware using tools like RWEverything\n3. Implant malicious UEFI module\n4. Module loads on every boot, before OS\n5. Module reinstalls malware even after OS reinstallation or disk replacement\n\n**Why So Dangerous:**\n- Survives disk formatting (lives in firmware)\n- Survives disk replacement (lives in motherboard)\n- Difficult to detect (firmware scanning rarely done)\n- Difficult to remove (requires firmware reflashing)\n\n### ESPecter (2021)\n\nMore recent UEFI bootkit discovered by ESET:\n\n**Technique:**\n- Infects Windows Boot Manager (bootmgfw.efi) on ESP\n- Patches bootloader to load bootkit module\n- Bootkit runs with kernel privileges before Windows\n- Deploys userland malware after Windows loads\n\n**Detection Challenges:**\n- Secure Boot disabled or not configured properly\n- ESP rarely monitored by security tools\n- Requires UEFI-aware forensics tools"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Hands-On: Bootkit Detection and Analysis\n\n## Step 1: Check MBR Integrity\n\n### Windows:\n\n```powershell\n# Dump MBR (requires admin)\n# Using built-in tool\ndd if=\\\\.\\PhysicalDrive0 of=mbr.bin bs=512 count=1\n\n# Or using PowerShell\n$drive = [System.IO.File]::OpenRead(\"\\\\.\\PhysicalDrive0\")\n$mbr = New-Object byte[] 512\n$drive.Read($mbr, 0, 512) | Out-Null\n$drive.Close()\n[System.IO.File]::WriteAllBytes(\"mbr.bin\", $mbr)\n```\n\n### Linux:\n\n```bash\n# Dump MBR\nsudo dd if=/dev/sda of=mbr.bin bs=512 count=1\n\n# Calculate hash\nmd5sum mbr.bin\nsha256sum mbr.bin\n\n# Compare with known-good MBR\n# Windows 10 MBR typically starts with: EB 63 90 ...\nhexdump -C mbr.bin | head -n 10\n```\n\n## Step 2: Analyze MBR Content\n\n```python\n# Python script to analyze MBR\nimport struct\n\nwith open('mbr.bin', 'rb') as f:\n    mbr = f.read(512)\n\n# Check signature (last 2 bytes should be 0x55AA)\nsignature = struct.unpack('<H', mbr[510:512])[0]\nif signature != 0xAA55:\n    print(\"[!] INVALID MBR SIGNATURE - POSSIBLE BOOTKIT!\")\nelse:\n    print(\"[+] Valid MBR signature\")\n\n# Check for suspicious strings\nsuspicious_strings = [b'TDL', b'TDSS', b'bootkit', b'evil']\nfor s in suspicious_strings:\n    if s in mbr:\n        print(f\"[!] SUSPICIOUS STRING FOUND: {s}\")\n\n# Analyze bootloader code (first 446 bytes)\nbootloader = mbr[:446]\n\n# Look for suspicious instructions\n# JMP far (EA), unusual INT calls, disk access functions\nif b'\\xea' in bootloader[:10]:  # JMP FAR in first 10 bytes\n    print(\"[!] Unusual JMP FAR in bootloader - investigate\")\n\n# Check partition table (bytes 446-510)\nfor i in range(4):\n    offset = 446 + (i * 16)\n    entry = mbr[offset:offset+16]\n    \n    bootable = entry[0]\n    partition_type = entry[4]\n    \n    print(f\"Partition {i+1}: Bootable={hex(bootable)}, Type={hex(partition_type)}\")\n    \n    # Check for hidden partitions (sometimes used by bootkits)\n    if partition_type in [0x11, 0x14, 0x16, 0x1B, 0x1C, 0x1E]:  # Hidden partition types\n        print(f\"[!] HIDDEN PARTITION DETECTED - POSSIBLE BOOTKIT STORAGE\")\n```\n\n## Step 3: Check UEFI/ESP Integrity\n\n```powershell\n# Mount ESP (EFI System Partition)\nmountvol S: /s\n\n# Check Boot Manager integrity\ncd S:\\EFI\\Microsoft\\Boot\nGet-FileHash bootmgfw.efi -Algorithm SHA256\n\n# Compare with known-good hash\n# Windows 10 21H2 bootmgfw.efi: \n# SHA256: 3B8A3C3B5F... (check Microsoft's MSRC)\n\n# Look for suspicious files\nGet-ChildItem -Recurse -Force\n\n# Check digital signatures\nGet-AuthenticodeSignature bootmgfw.efi\n# Should be signed by \"Microsoft Windows\" or \"Microsoft Corporation\"\n\n# Look for unsigned or suspiciously signed files\nGet-ChildItem -Recurse *.efi | ForEach-Object {\n    $sig = Get-AuthenticodeSignature $_.FullName\n    if ($sig.Status -ne \"Valid\") {\n        Write-Host \"[!] SUSPICIOUS: $($_.FullName) - $($sig.Status)\"\n    }\n}\n```\n\n## Step 4: Memory Forensics for Bootkit Detection\n\n```bash\n# Using Volatility 3\n# Check for hooks in boot drivers\npython3 vol.py -f memory.dmp windows.modscan\n\n# Look for:\n# - Unusual drivers loaded early\n# - Drivers with suspicious names\n# - Unsigned drivers\n\n# Check for MBR hooks in memory\npython3 vol.py -f memory.dmp windows.mbrscan\n\n# Check for IRP hooks (common bootkit technique)\npython3 vol.py -f memory.dmp windows.driverirp\n\n# Look for modified INT handlers\npython3 vol.py -f memory.dmp windows.idt\n```\n\n## Removal\n\n### MBR Bootkit Removal:\n\n```powershell\n# Windows built-in MBR restoration\nbootrec /fixmbr\nbootrec /fixboot\n\n# Or use clean MBR\n# Backup first!\ndd if=\\\\.\\PhysicalDrive0 of=infected_mbr.bin bs=512 count=1\n\n# Write clean MBR (this example is Windows 10 MBR)\n# WARNING: Double-check this for your OS!\nbootsect /nt60 SYS /mbr\n```\n\n### UEFI Bootkit Removal:\n\n```powershell\n# Restore from backup (if you have one)\ncopy backup_bootmgfw.efi S:\\EFI\\Microsoft\\Boot\\bootmgfw.efi\n\n# Or extract from Windows installation media\n# Mount Windows ISO\n# Copy \\sources\\boot.wim → extract → Windows\\Boot\\EFI\\bootmgfw.efi\n\n# In severe cases: Reflash firmware from manufacturer\n# THIS IS DANGEROUS - wrong firmware = bricked motherboard!\n```"
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "# Real-World Case Study: Stuxnet's Rootkit Component\n\n## Background\n\n**Stuxnet** (2010) was a sophisticated nation-state cyberweapon discovered targeting Iranian nuclear facilities. While famous for its PLC (Programmable Logic Controller) payload, it also contained a sophisticated rootkit to hide its presence on Windows systems.\n\n## The Mission\n\nYou're a malware analyst at a cybersecurity firm. A client in the industrial sector has found suspicious drivers on their SCADA (Supervisory Control and Data Acquisition) systems. Initial analysis suggests Stuxnet-related malware. Your job: Analyze the rootkit component.\n\n## Stuxnet Rootkit Analysis\n\n### Initial Discovery\n\n```bash\n# Suspicious files found:\nC:\\Windows\\System32\\Drivers\\mrxnet.sys\nC:\\Windows\\System32\\Drivers\\mrxcls.sys\n\n# Check digital signatures\nsigcheck -v mrxnet.sys\n\nOutput:\nVerified:       Signed\nSigning date:   2:21 AM 1/19/2009\nPublisher:      Realtek Semiconductor Corp.\nIssuer:         VeriSign Class 3 Code Signing 2004 CA\n```\n\n**Red Flag #1**: Realtek driver in a system with no Realtek hardware!\n\n**Red Flag #2**: Digital certificate was STOLEN from Realtek (later revoked)\n\n### Technical Analysis\n\n**1. Driver Load Points**\n\nStuxnet rootkit used multiple persistence mechanisms:\n\n```\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\MRxNet\n  Type: 0x1 (Kernel Driver)\n  Start: 0x1 (System Start - loads before Windows)\n  ImagePath: system32\\drivers\\mrxnet.sys\n```\n\n**2. Hooking Techniques**\n\nStuxnet used IRP hooking (not SSDT - PatchGuard friendly):\n\n```c\n// Stuxnet hooked IRP_MJ_CREATE and IRP_MJ_DIRECTORY_CONTROL\n// to hide its files\n\nDriverObject->MajorFunction[IRP_MJ_CREATE] = StuxnetCreateHook;\nDriverObject->MajorFunction[IRP_MJ_DIRECTORY_CONTROL] = StuxnetDirectoryControlHook;\n\n// Example: Hiding files\nNTSTATUS StuxnetDirectoryControlHook(\n    PDEVICE_OBJECT DeviceObject,\n    PIRP Irp\n) {\n    // Call original driver's IRP handler\n    NTSTATUS status = OriginalIrpHandler(DeviceObject, Irp);\n    \n    // Filter results to hide malicious files\n    if (NT_SUCCESS(status)) {\n        RemoveStuxnetFilesFromListing(Irp);\n    }\n    \n    return status;\n}\n```\n\n**3. Hidden Files**\n\nStuxnet hid multiple files by filename pattern:\n- `~WTR*.tmp` (working files)\n- `*.lnk` (shortcut files used for spreading)\n- `oem*.pnf` (infected driver files)\n\n**4. Process Injection**\n\nRootkit injected code into `services.exe` and `lsass.exe`:\n\n```c\n// Simplified injection technique\nPEPROCESS targetProcess = FindProcessByName(\"services.exe\");\nPVOID remoteMemory = AllocateMemoryInProcess(targetProcess, payloadSize);\nWriteProcessMemory(targetProcess, remoteMemory, payload, payloadSize);\nCreateRemoteThread(targetProcess, remoteMemory);\n```\n\n### Detection Strategy\n\n**Step 1: Signature-based**\n```bash\n# Yara rule for Stuxnet rootkit\nrule Stuxnet_Rootkit {\n    strings:\n        $s1 = \"MRxNet.sys\" nocase\n        $s2 = \"MRxCls.sys\" nocase\n        $s3 = { 55 8B EC 83 EC 10 53 56 57 }  # Function prologue\n        $s4 = \"\\\\SystemRoot\\\\system32\\\\drivers\\\\mrxnet.sys\"\n    condition:\n        2 of them\n}\n```\n\n**Step 2: Behavioral analysis**\n- Monitor IRP hook installations\n- Check for file hiding behavior\n- Look for process injection into critical Windows processes\n\n**Step 3: Memory forensics**\n```bash\n# Volatility analysis\nvol.py -f stuxnet_memory.dmp windows.driverscan | grep -i mrx\nvol.py -f stuxnet_memory.dmp windows.driverirp --driver mrxnet.sys\nvol.py -f stuxnet_memory.dmp windows.malfind\n```\n\n### Key Findings\n\n1. **Stolen Certificate**: Used legitimate Realtek certificate (later revoked)\n2. **Zero-day exploit**: Used MS10-046 (Windows Shell .LNK vulnerability) for spreading\n3. **Advanced persistence**: Multiple infection vectors and fallback mechanisms\n4. **Modular design**: Rootkit was just one component of larger framework\n5. **Nation-state quality**: Code quality and sophistication indicated advanced development team\n\n### Impact\n\n- Infected **~200,000 computers worldwide**\n- Successfully damaged **~1,000 centrifuges** at Natanz facility in Iran\n- First publicly known malware designed to cause **physical destruction**\n- Changed the cybersecurity landscape forever (proof of cyberweapon viability)\n\n### Lessons Learned\n\n1. **Certificate validation isn't enough**: Attackers can steal legitimate certificates\n2. **Defense in depth**: Single security layer (AV) can't stop sophisticated threats\n3. **Kernel-level monitoring**: Need rootkit detection capabilities\n4. **Air-gap isn't secure**: Stuxnet crossed air-gapped networks via USB\n5. **Industrial systems are targets**: SCADA/ICS systems need cybersecurity focus"
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "# Reflection Questions\n\nTake a moment to solidify your learning:\n\n1. **Privilege Levels**: Explain why kernel-mode (Ring 0) rootkits are more powerful than user-mode rootkits. What restrictions do user-mode rootkits face?\n\n2. **Detection Trade-offs**: SSDT hooking is easier to detect than DKOM. Why do some rootkits still use hooking techniques despite the detection risk?\n\n3. **PatchGuard Impact**: How did Microsoft's PatchGuard change the rootkit landscape? What new techniques did rootkit developers adopt?\n\n4. **Bootkit Persistence**: Explain how UEFI bootkits can survive disk replacement. What does this mean for incident response?\n\n5. **Real-World Application**: You're analyzing a memory dump and find a process visible in `psscan` but not `pslist`. What technique is likely being used? What would you do next?\n\n6. **Defense Strategy**: As a security architect, how would you design a system to detect rootkits? What layers of defense would you implement?\n\n7. **Ethical Considerations**: Rootkit techniques can be used for both malicious purposes and legitimate security research. Where do you draw the line?\n\n## Challenge Exercise\n\nDownload a memory dump containing a rootkit (from malware analysis sites like malware-traffic-analysis.net or cyberdefenders.org):\n\n1. Identify the rootkit technique (SSDT hooking, DKOM, IRP hooking)\n2. Determine what the rootkit is hiding (processes, files, network connections)\n3. Extract and analyze the rootkit driver\n4. Write a detection rule (Yara or Sigma)\n5. Document your analysis process\n\nThis hands-on practice will cement your understanding of rootkit analysis techniques."
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "**Quick Reference: Rootkit Analysis Checklist**\n\n## When Analyzing Suspected Rootkit:\n\n**1. Process Analysis**\n- [ ] Run `pslist` and `psscan` - compare results\n- [ ] Check for orphan processes (no parent)\n- [ ] Look for processes with odd names or paths\n- [ ] Check process token privileges (unexpected SYSTEM tokens?)\n\n**2. Driver Analysis**\n- [ ] List all loaded drivers (`ldrmodules`, `driverscan`)\n- [ ] Check driver signatures (unsigned = suspicious)\n- [ ] Look for drivers in unusual paths\n- [ ] Check driver object callbacks\n\n**3. Hooking Detection**\n- [ ] Check SSDT (`ssdt` plugin)\n- [ ] Check IDT (`idt` plugin)\n- [ ] Check IRP hooks (`driverirp` plugin)\n- [ ] Look for inline hooks (`disassemble` suspicious functions)\n\n**4. File System**\n- [ ] Scan for hidden files (cross-view: API vs. raw disk)\n- [ ] Check for alternate data streams (ADS)\n- [ ] Look for files with suspicious attributes\n\n**5. Boot Process**\n- [ ] Dump and analyze MBR\n- [ ] Check ESP/UEFI boot files\n- [ ] Verify boot file signatures\n- [ ] Compare hashes with known-good\n\n**6. Network**\n- [ ] List network connections (`netscan`)\n- [ ] Check for hidden connections (raw socket inspection)\n- [ ] Monitor DNS queries and C2 communications\n\n**Tools Needed:**\n- Volatility 3 (memory forensics)\n- WinDbg (kernel debugging)\n- IDA Pro/Ghidra (disassembly)\n- Yara (signature matching)\n- FTK Imager (disk imaging)\n- Arsenal Image Mounter (disk analysis)\n\n**Remember**: Always work on isolated systems. Rootkits can detect analysis environments and modify behavior!"
      }
    }
  ]
}