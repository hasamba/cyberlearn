{
  "lesson_id": "a5b6c7d8-9e0f-1a2b-3c4d-5e6f7a8b9c0d",
  "domain": "cloud",
  "title": "Serverless Security: Lambda, Functions, and API Gateway",
  "difficulty": 2,
  "order_index": 5,
  "prerequisites": [
    "c1a2b3d4-5e6f-7a8b-9c0d-1e2f3a4b5c6d"
  ],
  "concepts": [
    "AWS Lambda Security and Execution Roles",
    "Azure Functions Security Model",
    "API Gateway Authentication and Authorization",
    "Function-as-a-Service (FaaS) Attack Surface",
    "Serverless Application Model (SAM) Security",
    "Event-Driven Security Monitoring",
    "Secrets Management in Serverless",
    "Cold Start Security Implications",
    "Serverless Supply Chain Attacks",
    "Lambda Layer Security Risks"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Secure AWS Lambda functions with least-privilege execution roles",
    "Implement API Gateway authentication using IAM, Cognito, and Lambda authorizers",
    "Prevent serverless injection attacks (command injection, SQL injection, SSRF)",
    "Manage secrets securely in serverless environments using Parameter Store and Secrets Manager",
    "Detect and prevent serverless-specific attacks (event injection, resource exhaustion)",
    "Implement defense in depth for serverless applications",
    "Monitor serverless security with CloudWatch Logs and distributed tracing",
    "Secure serverless CI/CD pipelines and deployment processes"
  ],
  "content_blocks": [
    {
      "type": "explanation",
      "title": "Serverless Security Fundamentals",
      "content": {
        "text": "Serverless computing (AWS Lambda, Azure Functions, Google Cloud Functions) is rapidly growing, but introduces unique security challenges.\n\n**What is Serverless?**\n\nServerless doesn't mean \"no servers\" - it means YOU don't manage servers. The cloud provider:\n- Provisions compute resources\n- Scales automatically\n- Patches the OS and runtime\n- Manages availability\n\n**You only provide code.**\n\n**Serverless Security Model (Shared Responsibility)**\n\n```\n┌─────────────────────────────────────────────────────┐\n│  SERVERLESS SHARED RESPONSIBILITY                   │\n├─────────────────────────────────────────────────────┤\n│  YOUR RESPONSIBILITY:                               │\n│  ✓ Application code security                        │\n│  ✓ Dependency vulnerabilities                       │\n│  ✓ IAM roles and permissions                        │\n│  ✓ Secrets management                               │\n│  ✓ Input validation                                 │\n│  ✓ Output encoding                                  │\n│  ✓ Third-party API security                         │\n│  ✓ Event source configuration                       │\n├─────────────────────────────────────────────────────┤\n│  CLOUD PROVIDER RESPONSIBILITY:                     │\n│  ✓ OS patching                                      │\n│  ✓ Runtime security                                 │\n│  ✓ Infrastructure security                          │\n│  ✓ Physical security                                │\n│  ✓ Network isolation (VPC)                          │\n└─────────────────────────────────────────────────────┘\n```\n\n**AWS Lambda Execution Model**\n\nLambda functions execute in isolated containers:\n\n1. **Cold Start**: First invocation or after inactivity\n   - Container created\n   - Runtime initialized\n   - Code downloaded\n   - Function handler invoked\n   - **Duration: 100ms - 5s**\n\n2. **Warm Start**: Subsequent invocations\n   - Existing container reused\n   - Function handler invoked\n   - **Duration: 1-10ms**\n\n**Security Implication:**\n- Containers can be reused across invocations (shared state risk)\n- /tmp directory persists between warm invocations\n- Global variables persist\n- Secrets in memory persist\n\n**Lambda Execution Roles**\n\nEvery Lambda function has an **execution role** (IAM role) that defines:\n- What AWS services the function can access\n- What actions it can perform\n\n**Common Mistake: Overly Permissive Roles**\n\n❌ **Bad Example:**\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [{\n    \"Effect\": \"Allow\",\n    \"Action\": \"*\",\n    \"Resource\": \"*\"\n  }]\n}\n```\nThis grants FULL AWS ACCESS - catastrophic if function is compromised.\n\n✅ **Good Example:**\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"dynamodb:GetItem\",\n        \"dynamodb:PutItem\"\n      ],\n      \"Resource\": \"arn:aws:dynamodb:us-east-1:123456789012:table/Users\"\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": \"logs:CreateLogGroup\",\n      \"Resource\": \"arn:aws:logs:us-east-1:123456789012:*\"\n    }\n  ]\n}\n```\nOnly grants necessary DynamoDB access + CloudWatch Logs.\n\n**API Gateway Security**\n\nAPI Gateway sits in front of Lambda functions and provides:\n- Authentication\n- Authorization\n- Rate limiting\n- Request validation\n- Response transformation\n\n**Authentication Methods:**\n\n**1. IAM Authentication**\n- Requests signed with AWS SigV4\n- Caller must have AWS credentials\n- Good for service-to-service communication\n- **Not suitable for public APIs**\n\n**2. Amazon Cognito**\n- Managed user authentication service\n- JWT tokens\n- Social login (Google, Facebook, Apple)\n- Good for mobile/web apps with user accounts\n\n**3. Lambda Authorizer (Custom)**\n- Your code decides if request is authorized\n- Validates custom tokens (JWT, OAuth)\n- Most flexible\n- Can integrate with third-party IdPs\n\n**4. API Keys**\n- Simple shared secrets\n- Good for rate limiting\n- **NOT for authentication** (easily leaked)\n\n**Serverless Attack Vectors**\n\n**1. Event Injection**\n\nLambda functions are triggered by events (S3, DynamoDB, API Gateway, SNS, etc.).\n\n**Attack Scenario:**\nAttacker uploads file to S3 with malicious filename:\n```\n../../etc/passwd\n```\n\nLambda function processes filename without validation:\n```python\nimport os\n\ndef lambda_handler(event, context):\n    bucket = event['Records'][0]['s3']['bucket']['name']\n    key = event['Records'][0]['s3']['object']['key']  # ../../etc/passwd\n    \n    # VULNERABLE: Path traversal\n    with open(f'/tmp/{key}', 'w') as f:\n        # Download and process file\n        pass\n```\n\n**Fix:** Validate and sanitize all event data.\n\n**2. Dependency Vulnerabilities**\n\nServerless functions bundle dependencies (npm, pip, gems).\n\n**Attack Scenario:**\nUsing outdated library with known CVE:\n```javascript\n// package.json\n{\n  \"dependencies\": {\n    \"lodash\": \"4.17.4\"  // Has prototype pollution vulnerability\n  }\n}\n```\n\n**Fix:** Regularly scan dependencies (Snyk, npm audit, Dependabot).\n\n**3. Secrets in Code**\n\n❌ **Bad:**\n```python\nDATABASE_PASSWORD = \"MyP@ssw0rd123\"\n```\n\n✅ **Good:**\n```python\nimport boto3\n\nsm = boto3.client('secretsmanager')\nresponse = sm.get_secret_value(SecretId='prod/db/password')\nDATABASE_PASSWORD = response['SecretString']\n```\n\n**4. Over-Privileged Execution Roles**\n\nSee above - always use least privilege.\n\n**5. Resource Exhaustion (DoS)**\n\nServerless scales automatically, which means:\n- Attacker can trigger millions of invocations\n- Massive AWS bill\n- Potential account throttling\n\n**Mitigation:**\n- Set reserved concurrency limits\n- Implement API Gateway throttling\n- Use WAF to block malicious traffic\n- Set CloudWatch billing alarms\n\n**6. Lambda Layer Poisoning**\n\nLambda Layers are reusable code packages. If attacker compromises a layer:\n- All functions using that layer are compromised\n- Supply chain attack\n\n**Mitigation:**\n- Use only trusted layers\n- Pin layer versions (don't use \"latest\")\n- Scan layer contents\n- Use private layers (not public)\n\n**Serverless Monitoring and Logging**\n\n**CloudWatch Logs:**\nAll Lambda stdout/stderr goes to CloudWatch Logs.\n\n**Log sensitive events:**\n- Authentication failures\n- Authorization denials\n- Unusual invocation patterns\n- Errors and exceptions\n\n**CloudWatch Metrics:**\n- Invocations\n- Errors\n- Duration\n- Throttles\n- Concurrent executions\n\n**AWS X-Ray:**\nDistributed tracing for serverless applications.\n\n**Tracks:**\n- Request flow across services\n- Performance bottlenecks\n- Errors and exceptions\n- Downstream service calls\n\n**Security Use Case:**\nDetect unusual call patterns (e.g., function suddenly calling S3 buckets it never accessed before).\n\n**Serverless CI/CD Security**\n\n**Risks:**\n- Compromised deployment pipeline injects malicious code\n- Secrets leaked in build logs\n- Unvetted dependencies deployed to production\n\n**Best Practices:**\n1. **Code scanning** (SAST: Semgrep, Bandit)\n2. **Dependency scanning** (SCA: Snyk, OWASP Dependency-Check)\n3. **Secrets scanning** (detect hardcoded credentials)\n4. **Least-privilege deployment roles**\n5. **Immutable deployments** (blue/green, canary)\n6. **Automated testing** (unit, integration, security)\n\n**Environment Isolation**\n\nNever share Lambda execution roles across environments:\n\n```\nDevelopment Lambda → dev-execution-role → dev-DynamoDB-table\nProduction Lambda → prod-execution-role → prod-DynamoDB-table\n```\n\nIf dev role had access to prod resources, a compromised dev environment could impact production.\n\n**VPC Integration**\n\nLambda functions can run in VPCs to:\n- Access private resources (RDS, ElastiCache)\n- Restrict internet access\n\n**Security Trade-offs:**\n- ✅ Network isolation\n- ✅ Private resource access\n- ❌ Increased cold start time (ENI creation)\n- ❌ Complexity (VPC configuration, NAT gateways)\n\n**When to use VPC:**\n- Need to access RDS/ElastiCache in private subnets\n- Compliance requires network isolation\n- Want to restrict outbound internet access\n\n**When NOT to use VPC:**\n- Only accessing public AWS services (S3, DynamoDB)\n- Performance is critical (avoid cold start overhead)\n- Simpler architecture preferred"
      }
    },
    {
      "type": "code_exercise",
      "title": "Serverless Security Implementation",
      "content": {
        "text": "**Exercise 1: Secure Lambda Function with Least-Privilege Role**\n\n```yaml\n# AWS SAM template (serverless.yaml)\nAWSTemplateFormatVersion: '2010-09-09'\nTransform: AWS::Serverless-2016-10-31\n\nResources:\n  # Lambda function\n  SecureFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      FunctionName: secure-data-processor\n      Runtime: python3.11\n      Handler: app.lambda_handler\n      CodeUri: ./src\n      Timeout: 30\n      MemorySize: 512\n      \n      # Environment variables (NOT secrets!)\n      Environment:\n        Variables:\n          TABLE_NAME: !Ref DataTable\n          REGION: !Ref AWS::Region\n      \n      # Execution role (least privilege)\n      Policies:\n        - DynamoDBCrudPolicy:\n            TableName: !Ref DataTable\n        - Statement:\n          - Effect: Allow\n            Action:\n              - secretsmanager:GetSecretValue\n            Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:prod/api-key-*'\n        - CloudWatchLambdaInsightsExecutionRolePolicy\n      \n      # Security: Run in VPC for database access\n      VpcConfig:\n        SecurityGroupIds:\n          - !Ref LambdaSecurityGroup\n        SubnetIds:\n          - !Ref PrivateSubnet1\n          - !Ref PrivateSubnet2\n      \n      # Tracing\n      Tracing: Active\n      \n      # Events\n      Events:\n        ApiEvent:\n          Type: Api\n          Properties:\n            Path: /process\n            Method: post\n            Auth:\n              Authorizer: CognitoAuthorizer\n  \n  # DynamoDB table\n  DataTable:\n    Type: AWS::DynamoDB::Table\n    Properties:\n      TableName: secure-data-table\n      BillingMode: PAY_PER_REQUEST\n      AttributeDefinitions:\n        - AttributeName: id\n          AttributeType: S\n      KeySchema:\n        - AttributeName: id\n          KeyType: HASH\n      PointInTimeRecoverySpecification:\n        PointInTimeRecoveryEnabled: true\n      SSESpecification:\n        SSEEnabled: true\n  \n  # Security group for Lambda\n  LambdaSecurityGroup:\n    Type: AWS::EC2::SecurityGroup\n    Properties:\n      GroupDescription: Lambda function security group\n      VpcId: !Ref VPC\n      SecurityGroupEgress:\n        # Allow HTTPS to Secrets Manager\n        - IpProtocol: tcp\n          FromPort: 443\n          ToPort: 443\n          CidrIp: 0.0.0.0/0\n        # Allow database access\n        - IpProtocol: tcp\n          FromPort: 5432\n          ToPort: 5432\n          DestinationSecurityGroupId: !Ref DatabaseSecurityGroup\n```\n\n**Lambda Function Code (src/app.py):**\n\n```python\nimport json\nimport boto3\nimport os\nfrom aws_xray_sdk.core import xray_recorder\nfrom aws_xray_sdk.core import patch_all\n\n# Patch boto3 for X-Ray tracing\npatch_all()\n\n# Initialize clients outside handler (reuse across warm starts)\ndynamodb = boto3.resource('dynamodb')\nsm = boto3.client('secretsmanager')\ntable = dynamodb.Table(os.environ['TABLE_NAME'])\n\n# Cache secrets (avoid repeated Secrets Manager calls)\n_api_key_cache = None\n\ndef get_api_key():\n    \"\"\"Retrieve API key from Secrets Manager with caching.\"\"\"\n    global _api_key_cache\n    if _api_key_cache is None:\n        response = sm.get_secret_value(SecretId='prod/api-key')\n        _api_key_cache = response['SecretString']\n    return _api_key_cache\n\n@xray_recorder.capture('validate_input')\ndef validate_input(data):\n    \"\"\"Validate and sanitize input data.\"\"\"\n    if not isinstance(data, dict):\n        raise ValueError(\"Input must be a dictionary\")\n    \n    # Required fields\n    required = ['user_id', 'action', 'payload']\n    for field in required:\n        if field not in data:\n            raise ValueError(f\"Missing required field: {field}\")\n    \n    # Sanitize user_id (prevent injection)\n    user_id = str(data['user_id'])\n    if not user_id.isalnum():\n        raise ValueError(\"user_id must be alphanumeric\")\n    \n    # Limit action to allowed values\n    allowed_actions = ['create', 'update', 'delete']\n    if data['action'] not in allowed_actions:\n        raise ValueError(f\"Invalid action. Allowed: {allowed_actions}\")\n    \n    return data\n\n@xray_recorder.capture('process_request')\ndef process_request(data):\n    \"\"\"Process validated data.\"\"\"\n    # Retrieve secret (cached after first call)\n    api_key = get_api_key()\n    \n    # Call external API (example)\n    # response = requests.post(EXTERNAL_API, headers={'X-API-Key': api_key}, ...)\n    \n    # Store in DynamoDB\n    table.put_item(Item={\n        'id': data['user_id'],\n        'action': data['action'],\n        'payload': data['payload']\n    })\n    \n    return {'status': 'success', 'user_id': data['user_id']}\n\ndef lambda_handler(event, context):\n    \"\"\"Lambda handler with comprehensive error handling and logging.\"\"\"\n    \n    # Log event (for debugging)\n    print(f\"Event: {json.dumps(event)}\")\n    \n    try:\n        # Parse request body\n        body = json.loads(event.get('body', '{}'))\n        \n        # Validate input\n        validated_data = validate_input(body)\n        \n        # Process request\n        result = process_request(validated_data)\n        \n        return {\n            'statusCode': 200,\n            'headers': {\n                'Content-Type': 'application/json',\n                'Access-Control-Allow-Origin': '*'  # Configure properly for production\n            },\n            'body': json.dumps(result)\n        }\n    \n    except ValueError as e:\n        # Validation errors (client error)\n        print(f\"Validation error: {str(e)}\")\n        return {\n            'statusCode': 400,\n            'body': json.dumps({'error': str(e)})\n        }\n    \n    except Exception as e:\n        # Unexpected errors (server error)\n        print(f\"Unexpected error: {str(e)}\")\n        xray_recorder.current_subsegment().put_annotation('error', str(e))\n        return {\n            'statusCode': 500,\n            'body': json.dumps({'error': 'Internal server error'})\n        }\n```\n\n**Exercise 2: Implement Lambda Authorizer (Custom Auth)**\n\n```python\n# authorizer.py - JWT validation\nimport json\nimport jwt\nimport os\n\nJWT_SECRET = os.environ['JWT_SECRET']  # Retrieved from Secrets Manager in real implementation\n\ndef lambda_handler(event, context):\n    \"\"\"Lambda authorizer for API Gateway.\"\"\"\n    \n    token = event['authorizationToken']  # \"Bearer <token>\"\n    method_arn = event['methodArn']\n    \n    try:\n        # Extract token\n        if not token.startswith('Bearer '):\n            raise ValueError('Invalid token format')\n        \n        token = token.replace('Bearer ', '')\n        \n        # Verify JWT\n        payload = jwt.decode(token, JWT_SECRET, algorithms=['HS256'])\n        \n        # Extract user info\n        user_id = payload['sub']\n        roles = payload.get('roles', [])\n        \n        # Generate IAM policy\n        if 'admin' in roles:\n            effect = 'Allow'\n        else:\n            # Non-admins can only access their own resources\n            effect = 'Allow'  # Fine-grained authorization in Lambda function\n        \n        policy = generate_policy(user_id, effect, method_arn, payload)\n        \n        print(f\"Authorized user: {user_id}\")\n        return policy\n    \n    except jwt.ExpiredSignatureError:\n        print(\"Token expired\")\n        raise Exception('Unauthorized')  # API Gateway returns 401\n    \n    except jwt.InvalidTokenError as e:\n        print(f\"Invalid token: {str(e)}\")\n        raise Exception('Unauthorized')\n    \n    except Exception as e:\n        print(f\"Authorization error: {str(e)}\")\n        raise Exception('Unauthorized')\n\ndef generate_policy(principal_id, effect, resource, context):\n    \"\"\"Generate IAM policy for API Gateway.\"\"\"\n    return {\n        'principalId': principal_id,\n        'policyDocument': {\n            'Version': '2012-10-17',\n            'Statement': [{\n                'Action': 'execute-api:Invoke',\n                'Effect': effect,\n                'Resource': resource\n            }]\n        },\n        'context': {\n            'user_id': principal_id,\n            'roles': ','.join(context.get('roles', []))\n        }\n    }\n```\n\n**Exercise 3: Monitor Lambda Security with CloudWatch**\n\n```python\n# security_monitor.py - Detects suspicious Lambda activity\nimport boto3\nimport json\nfrom datetime import datetime, timedelta\n\ncloudwatch = boto3.client('cloudwatch')\nlogs = boto3.client('logs')\nsns = boto3.client('sns')\n\ndef check_error_rate(function_name, threshold=0.05):\n    \"\"\"Alert if error rate exceeds threshold.\"\"\"\n    end_time = datetime.utcnow()\n    start_time = end_time - timedelta(minutes=15)\n    \n    # Get metrics\n    invocations = cloudwatch.get_metric_statistics(\n        Namespace='AWS/Lambda',\n        MetricName='Invocations',\n        Dimensions=[{'Name': 'FunctionName', 'Value': function_name}],\n        StartTime=start_time,\n        EndTime=end_time,\n        Period=900,\n        Statistics=['Sum']\n    )\n    \n    errors = cloudwatch.get_metric_statistics(\n        Namespace='AWS/Lambda',\n        MetricName='Errors',\n        Dimensions=[{'Name': 'FunctionName', 'Value': function_name}],\n        StartTime=start_time,\n        EndTime=end_time,\n        Period=900,\n        Statistics=['Sum']\n    )\n    \n    if invocations['Datapoints'] and errors['Datapoints']:\n        inv_count = invocations['Datapoints'][0]['Sum']\n        err_count = errors['Datapoints'][0]['Sum']\n        error_rate = err_count / inv_count if inv_count > 0 else 0\n        \n        if error_rate > threshold:\n            alert(f\"High error rate for {function_name}: {error_rate:.2%}\")\n\ndef check_unusual_invocations(function_name, baseline_multiplier=10):\n    \"\"\"Detect unusual spike in invocations (potential DoS).\"\"\"\n    # Compare current hour to 7-day baseline\n    # (Implementation similar to error rate check)\n    pass\n\ndef scan_logs_for_threats(function_name):\n    \"\"\"Scan CloudWatch Logs for security indicators.\"\"\"\n    log_group = f\"/aws/lambda/{function_name}\"\n    \n    # Patterns to detect\n    threat_patterns = [\n        'SQL injection',\n        'command injection',\n        '../',  # Path traversal\n        'eval(',  # Code injection\n        '<script>',  # XSS attempt\n    ]\n    \n    for pattern in threat_patterns:\n        response = logs.filter_log_events(\n            logGroupName=log_group,\n            startTime=int((datetime.utcnow() - timedelta(hours=1)).timestamp() * 1000),\n            filterPattern=f'\"{pattern}\"'\n        )\n        \n        if response['events']:\n            alert(f\"Potential attack detected in {function_name}: {pattern}\")\n\ndef alert(message):\n    \"\"\"Send security alert.\"\"\"\n    sns.publish(\n        TopicArn='arn:aws:sns:us-east-1:123456789012:security-alerts',\n        Subject='Lambda Security Alert',\n        Message=message\n    )\n    print(f\"ALERT: {message}\")\n```"
      }
    },
    {
      "type": "real_world",
      "title": "Serverless Security Incidents",
      "content": {
        "text": "**Capital One Breach (2019) - SSRF in Lambda**\n\nWhile primarily an EC2 SSRF vulnerability, the attack chain involved serverless components:\n\n**Attack Flow:**\n1. SSRF vulnerability in WAF (EC2-based)\n2. Accessed EC2 metadata service (169.254.169.254)\n3. Obtained IAM role credentials\n4. Role had overly permissive S3 access\n5. Exfiltrated data from S3 buckets\n\n**Serverless Lesson:**\nIf this had been a Lambda function instead of EC2:\n- Lambda can access IMDS indirectly via compromised libraries\n- Over-privileged execution roles amplify damage\n- Defense: Least-privilege roles, input validation, runtime monitoring\n\n**Cryptocurrency Mining in Lambda (2018-2023)**\n\nMultiple incidents of attackers deploying crypto miners in Lambda:\n\n**Attack Vectors:**\n1. **Compromised CI/CD credentials** → Deployed malicious Lambda function\n2. **Overly permissive IAM roles** → Created Lambda function via API\n3. **Public S3 deployment packages** → Poisoned deployment packages\n\n**Impact:**\n- Massive AWS bills ($50,000+ in some cases)\n- Account throttling/suspension\n- Resource exhaustion\n\n**Detection:**\n- Unusual Lambda invocation patterns (constant execution)\n- High duration (functions running full 15-minute timeout)\n- Unexpected network activity (mining pool connections)\n- CloudWatch billing alarms\n\n**Prevention:**\n- Reserved concurrency limits\n- VPC configuration (restrict outbound to mining pools)\n- Runtime monitoring (detect mining binaries)\n- Least-privilege deployment roles\n\n**Dependency Confusion in Serverless (2021)**\n\nAttacker published malicious npm packages with names similar to private packages:\n\n**Attack:**\n1. Company uses private package \"@company/auth-utils\"\n2. Attacker publishes public package \"auth-utils\" to npm\n3. Build system mistakenly downloads public package\n4. Malicious code exfiltrates environment variables (containing secrets)\n5. Deployed to Lambda in production\n\n**Mitigation:**\n- Use private package registries\n- Pin exact dependency versions\n- Scan dependencies (npm audit, Snyk)\n- Use .npmrc to specify registry for scoped packages"
      }
    },
    {
      "type": "reflection",
      "title": "Serverless Security Reflection",
      "content": {
        "text": "**Key Questions:**\n\n1. How does the serverless shared responsibility model differ from traditional VMs?\n2. Why are warm starts a security concern in Lambda?\n3. What are the security trade-offs of running Lambda in a VPC?\n4. How would you detect a compromised Lambda function in production?\n5. Why is least-privilege especially critical for serverless?\n6. What are the unique supply chain risks in serverless applications?\n\n**Career Application:**\n- Serverless adoption is growing 50% year-over-year\n- Serverless security specialists are rare and highly valued\n- Understanding serverless is critical for cloud-native application security\n- AWS Certified Security Specialty exam has significant serverless coverage\n\n**Hands-On Challenge:**\nDeploy a serverless API with:\n1. Lambda function with least-privilege role\n2. API Gateway with Lambda authorizer\n3. Secrets Manager for API keys\n4. CloudWatch monitoring and alerts\n\nThis practical experience is highly valued by employers."
      }
    },
    {
      "type": "memory_aid",
      "title": "Serverless Security Quick Reference",
      "content": {
        "text": "**Lambda Security Checklist: \"RAVE-SLM\"**\n- **R**ole (least-privilege execution role)\n- **A**uthentication (API Gateway authorizer)\n- **V**alidation (input validation, output encoding)\n- **E**nvironment (VPC if needed, environment variables for config only)\n- **S**ecrets (use Secrets Manager, never hardcode)\n- **L**ogging (CloudWatch Logs, X-Ray tracing)\n- **M**onitoring (error rates, invocation patterns, billing)\n\n**API Gateway Auth Methods: \"CIAL\"**\n- **C**ognito (user pools, JWT)\n- **I**AM (SigV4, service-to-service)\n- **A**uthorizer (Lambda custom auth)\n- **L**imit (API keys for rate limiting only)\n\n**Least-Privilege Lambda Role Template:**\n```json\n{\n  \"Statement\": [{\n    \"Effect\": \"Allow\",\n    \"Action\": [\n      \"dynamodb:GetItem\",\n      \"secretsmanager:GetSecretValue\",\n      \"logs:CreateLogStream\",\n      \"logs:PutLogEvents\"\n    ],\n    \"Resource\": [\n      \"arn:aws:dynamodb:REGION:ACCOUNT:table/TABLE\",\n      \"arn:aws:secretsmanager:REGION:ACCOUNT:secret:SECRET-*\",\n      \"arn:aws:logs:REGION:ACCOUNT:log-group:/aws/lambda/FUNCTION:*\"\n    ]\n  }]\n}\n```\n\n**Retrieve Secret in Lambda:**\n```python\nimport boto3\nimport json\n\nsm = boto3.client('secretsmanager')\n_cache = None\n\ndef get_secret():\n    global _cache\n    if _cache is None:\n        response = sm.get_secret_value(SecretId='prod/api-key')\n        _cache = json.loads(response['SecretString'])\n    return _cache\n```\n\n**CloudWatch Logs Insights Query (Error Detection):**\n```\nfields @timestamp, @message\n| filter @message like /ERROR|Exception/\n| stats count() by bin(5m)\n```\n\n**Serverless Security Tools:**\n- **SAST**: Semgrep, Bandit (Python), ESLint (JavaScript)\n- **Dependency Scanning**: Snyk, npm audit, safety (Python)\n- **Runtime Security**: PureSec, Aqua, Twistlock\n- **IaC Scanning**: Checkov, tfsec, cfn_nag"
      }
    },
    {
      "type": "video",
      "title": "Serverless Security Resources",
      "content": {
        "resources": "**AWS Official Resources:**\n- \"Serverless Security Best Practices\" (AWS Whitepaper)\n- \"AWS Lambda Security\" (AWS re:Invent sessions)\n- \"Securing Serverless Applications\" (AWS Security Blog)\n\n**YouTube Channels:**\n- \"AWS Online Tech Talks\" (serverless security deep dives)\n- \"Serverless Land\" (AWS official serverless content)\n- \"Complete Coding\" (serverless security tutorials)\n\n**Certifications:**\n- AWS Certified Security - Specialty (serverless security section)\n- AWS Certified Solutions Architect - Professional (serverless architecture)\n\n**Hands-On Labs:**\n- \"AWS SAM Workshop\" (hands-on serverless deployment)\n- \"Serverless Application Lens\" (Well-Architected Framework)\n- \"AWS Lambda the Complete Guide\" (Udemy course)\n\n**Open Source Tools:**\n- **ServerlessGoat** (OWASP - intentionally vulnerable serverless app)\n- **SAM CLI** (local Lambda testing)\n- **LocalStack** (local AWS emulation)\n\n**Books:**\n- \"Serverless Security\" (Prabath Siriwardena, O'Reilly)\n- \"AWS Lambda in Action\" (Danilo Poccia, Manning)\n\n**Security Research:**\n- \"OWASP Serverless Top 10\" (common serverless vulnerabilities)\n- \"Breaking Serverless\" (Protego Labs research)\n- \"Lambda Layer Attacks\" (security researcher blogs)"
      }
    }
  ],
  "post_assessment": [
    {
      "question": "A Lambda function stores API keys in environment variables. An attacker gains read access to the Lambda function configuration via a compromised IAM role. Can they retrieve the API keys?",
      "options": [
        "No, environment variables are encrypted at rest",
        "Yes, environment variables are visible to anyone who can read the function configuration",
        "No, environment variables require KMS decryption permissions",
        "Yes, but only if the attacker also has CloudWatch Logs access"
      ],
      "correct_answer": 1,
      "explanation": "**Correct: Yes, environment variables are visible to anyone who can read the function configuration.**\n\nLambda environment variables are encrypted at rest using AWS KMS, but they are **automatically decrypted** when you view the function configuration:\n\n```bash\naws lambda get-function-configuration --function-name my-function\n\n# Returns:\n{\n  \"Environment\": {\n    \"Variables\": {\n      \"API_KEY\": \"super-secret-key-123\",  # PLAINTEXT!\n      \"DB_PASSWORD\": \"MyP@ssw0rd\"\n    }\n  }\n}\n```\n\nAnyone with `lambda:GetFunctionConfiguration` permission can see the plaintext values.\n\n**Why Option C is wrong:**\nWhile you CAN use a custom KMS key for environment variable encryption, by default:\n- Lambda uses AWS-managed KMS key\n- Decryption happens automatically when viewing config\n- No explicit KMS decrypt permission needed\n\n**Best Practice:**\nDon't store secrets in environment variables. Use AWS Secrets Manager:\n\n```python\nimport boto3\n\nsm = boto3.client('secretsmanager')\nresponse = sm.get_secret_value(SecretId='prod/api-key')\napi_key = response['SecretString']\n```\n\nNow the attacker needs BOTH:\n1. `lambda:GetFunctionConfiguration` (to see the secret ID)\n2. `secretsmanager:GetSecretValue` (to retrieve the actual secret)\n\nAnd you can:\n- Rotate secrets independently of Lambda deployment\n- Audit secret access in CloudTrail\n- Apply granular permissions per secret",
      "question_id": "8fe50879-33a2-4d3f-b383-d92ddf803ad2",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "Your Lambda function has execution role with DynamoDB access. An attacker exploits a command injection vulnerability in your function code. What can the attacker do?",
      "options": [
        "Execute arbitrary commands on the underlying EC2 host",
        "Access only the Lambda function's /tmp directory (isolated container)",
        "Access any AWS service the execution role has permissions for (DynamoDB, etc.)",
        "Nothing, Lambda runtime prevents command execution"
      ],
      "correct_answer": 2,
      "explanation": "**Correct: Access any AWS service the execution role has permissions for.**\n\nLambda functions run in isolated containers, but command injection can still:\n\n**Attacker capabilities:**\n1. **Execute arbitrary code inside the Lambda container**\n2. **Use the execution role credentials** (automatically available via environment variables)\n3. **Access any AWS service the role allows**\n\n**Example Attack:**\n\n```python\n# Vulnerable Lambda function\nimport os\n\ndef lambda_handler(event, context):\n    filename = event['filename']  # User-controlled input\n    \n    # VULNERABLE: Command injection\n    os.system(f'cat /tmp/{filename}')\n```\n\n**Attack payload:**\n```json\n{\n  \"filename\": \"test.txt; aws s3 sync s3://victim-bucket /tmp/stolen --region us-east-1\"\n}\n```\n\nThe injected command runs with the Lambda's execution role credentials:\n```bash\ncat /tmp/test.txt; aws s3 sync s3://victim-bucket /tmp/stolen --region us-east-1\n```\n\nIf the execution role has S3 access, the attacker downloads the entire bucket.\n\n**Why other options are wrong:**\n\n**Option A (EC2 host access):** \nLambda uses container isolation (AWS Firecracker microVMs). You cannot escape to the underlying host.\n\n**Option B (/tmp only):**\nWhile Lambda containers are isolated, the attacker can use AWS CLI/SDK inside the container:\n```bash\n# Inside Lambda container, these work:\nexport AWS_ACCESS_KEY_ID=<auto-provided>\nexport AWS_SECRET_ACCESS_KEY=<auto-provided>\nexport AWS_SESSION_TOKEN=<auto-provided>\n\naws s3 ls  # Lists S3 buckets (if execution role allows)\naws dynamodb scan --table-name Users  # Reads DynamoDB\n```\n\n**Option D (Runtime prevents execution):**\nLambda does NOT prevent command execution. Functions regularly run system commands:\n```python\nimport subprocess\nsubprocess.run(['imagemagick', 'convert', 'input.jpg', 'output.png'])\n```\n\n**Defense in Depth:**\n\n1. **Input validation** (prevent injection in first place)\n```python\nimport re\n\ndef sanitize_filename(filename):\n    if not re.match(r'^[a-zA-Z0-9_\\-\\.]+$', filename):\n        raise ValueError('Invalid filename')\n    return filename\n```\n\n2. **Least-privilege execution role** (limit damage if compromised)\n```json\n{\n  \"Statement\": [{\n    \"Effect\": \"Allow\",\n    \"Action\": \"dynamodb:GetItem\",\n    \"Resource\": \"arn:aws:dynamodb:*:*:table/Users\"\n  }]\n}\n```\n\nNow attacker can only read DynamoDB Users table, not access S3/EC2/etc.\n\n3. **Avoid system commands** when possible\n```python\n# Instead of:\nos.system(f'cat {filename}')\n\n# Use:\nwith open(filename, 'r') as f:\n    content = f.read()\n```\n\n4. **Runtime monitoring** (detect unusual behavior)\n- X-Ray tracing (unusual API calls)\n- CloudWatch Logs (scan for command patterns)\n- AWS GuardDuty (detects credential exfiltration)",
      "question_id": "f91215b3-77d9-4ec0-8a8c-041a6c077946",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "You implement API Gateway with Lambda authorizer (custom auth). The authorizer function caches authorization decisions for 5 minutes (TTL=300). A user's permissions are revoked in your database. How quickly does API Gateway block their requests?",
      "options": [
        "Immediately (authorizer queries database on each request)",
        "Within 5 minutes (cache TTL)",
        "Within 1 minute (default cache TTL)",
        "Never (must restart API Gateway to clear cache)"
      ],
      "correct_answer": 1,
      "explanation": "**Correct: Within 5 minutes (cache TTL).**\n\nAPI Gateway Lambda authorizers cache authorization decisions to improve performance:\n\n```python\ndef lambda_handler(event, context):\n    token = event['authorizationToken']\n    \n    # This result is CACHED for TTL duration\n    return {\n        'principalId': 'user123',\n        'policyDocument': {\n            'Statement': [{\n                'Action': 'execute-api:Invoke',\n                'Effect': 'Allow',\n                'Resource': event['methodArn']\n            }]\n        },\n        # Cache this decision for 5 minutes\n        'ttlOverride': 300\n    }\n```\n\n**Cache Behavior:**\n\n1. **Request 1 (09:00:00):**\n   - API Gateway calls authorizer\n   - Authorizer returns Allow policy with TTL=300\n   - Result cached for 5 minutes\n\n2. **Requests 2-N (09:00:01 - 09:04:59):**\n   - API Gateway uses cached result\n   - Authorizer NOT invoked\n   - Requests allowed\n\n3. **User permissions revoked in database (09:02:00)**\n   - API Gateway still uses cached Allow policy\n   - User can still access API until 09:05:00\n\n4. **Request after cache expiration (09:05:01):**\n   - Cache expired\n   - API Gateway calls authorizer again\n   - Authorizer checks database, sees revoked permissions\n   - Returns Deny policy\n   - User blocked\n\n**Security Implications:**\n\n**Problem:** 5-minute delay in enforcing permission changes\n\n**Trade-off:**\n- ✅ **Performance:** Reduced latency, fewer authorizer invocations (lower cost)\n- ❌ **Security:** Delayed permission enforcement\n\n**Mitigations:**\n\n**1. Shorter TTL for sensitive APIs:**\n```python\nreturn {\n    'principalId': 'user123',\n    'policyDocument': {...},\n    'ttlOverride': 60  # 1 minute instead of 5\n}\n```\n\n**2. Disable caching entirely (ttlOverride=0):**\n```python\nreturn {\n    'principalId': 'user123',\n    'policyDocument': {...},\n    'ttlOverride': 0  # No caching, authorizer called every time\n}\n```\n\n**Cost:** Higher latency, more Lambda invocations\n\n**3. Cache invalidation (not natively supported):**\nYou cannot manually clear API Gateway's authorizer cache. Workarounds:\n- Include version/timestamp in authorization token (changes token → cache miss)\n- Use different authorization header value\n\n**4. Two-tier authorization:**\n```python\ndef lambda_handler(event, context):\n    # Tier 1: Cache-friendly check (user exists, basic permissions)\n    # TTL = 5 minutes\n    \n    # Tier 2: In the main Lambda function, do fine-grained check\n    # (check specific resource access, recent permission changes)\n    # No caching\n```\n\n**Best Practice:**\n- Use caching for performance\n- Short TTL (60-300 seconds) for sensitive APIs\n- Implement fine-grained authorization in main Lambda (not just authorizer)\n- Monitor for unusual access patterns (user accessing resources they shouldn't)",
      "question_id": "1fd45bb0-aacf-41e8-9f97-6eafba415068",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "Your Lambda function processes S3 events. An attacker uploads a file named '../../../../../../etc/passwd' to trigger the function. The function code is: `with open(f'/tmp/{key}', 'w') as f:`. What happens?",
      "options": [
        "Lambda writes to /etc/passwd on the underlying host (container escape)",
        "Lambda writes to /tmp/../../../../../../etc/passwd which normalizes to /tmp/passwd (no directory traversal)",
        "Lambda writes to /etc/passwd inside the Lambda container (container compromise)",
        "Lambda throws an exception (path traversal blocked by runtime)"
      ],
      "correct_answer": 1,
      "explanation": "**Correct: Lambda writes to /tmp/../../../../../../etc/passwd which normalizes to /tmp/passwd (no directory traversal in this case).**\n\n**Why path traversal FAILS here:**\n\nPython's `open()` normalizes paths:\n\n```python\nimport os\n\nkey = '../../../../../../etc/passwd'\npath = f'/tmp/{key}'\n\nprint(path)\n# Output: /tmp/../../../../../../etc/passwd\n\nprint(os.path.normpath(path))\n# Output: /etc/passwd  (OUTSIDE /tmp)\n\n# But when you try to open:\nwith open(path, 'w') as f:\n    pass\n\n# Python normalizes the path internally during file operation\n# /tmp/../../../../../../etc/passwd → /etc/passwd\n\n# However, in Lambda:\n# - Lambda container filesystem is read-only except /tmp\n# - Writing to /etc/passwd FAILS (permission denied)\n# - Lambda function crashes with exception\n```\n\n**Actual Behavior:**\n\n```bash\nTraceback (most recent call last):\n  File \"app.py\", line 5, in lambda_handler\n    with open(f'/tmp/{key}', 'w') as f:\nPermissionError: [Errno 13] Permission denied: '/etc/passwd'\n```\n\n**Why other options are wrong:**\n\n**Option A (host compromise):**\nLambda uses Firecracker microVMs for isolation. You cannot escape the container to access the host.\n\n**Option C (container compromise):**\nPartially correct - the path DOES resolve to /etc/passwd inside the container, but:\n- Lambda container filesystem is read-only (except /tmp)\n- Write to /etc/passwd fails with PermissionError\n\n**Option D (runtime blocks):**\nLambda runtime does NOT automatically block path traversal. It's the filesystem permissions that prevent the write.\n\n**Secure Code Pattern:**\n\n```python\nimport os\nimport re\n\ndef lambda_handler(event, context):\n    key = event['Records'][0]['s3']['object']['key']\n    \n    # SECURE: Validate filename\n    filename = os.path.basename(key)  # Extracts only the filename, strips directory\n    \n    if not re.match(r'^[a-zA-Z0-9_\\-\\.]+$', filename):\n        raise ValueError(f'Invalid filename: {filename}')\n    \n    # Safe to use\n    safe_path = os.path.join('/tmp', filename)\n    \n    # Double-check (defense in depth)\n    if not safe_path.startswith('/tmp/'):\n        raise ValueError('Path traversal detected')\n    \n    with open(safe_path, 'w') as f:\n        f.write('safe content')\n```\n\n**Real-World Attack Scenario:**\n\nEven though writing to /etc/passwd fails, an attacker could:\n\n1. **Read sensitive files** (if code does `open(path, 'r')`):\n```python\n# Vulnerable:\nwith open(f'/tmp/{key}', 'r') as f:\n    content = f.read()\n\n# Attack:\nkey = '../../proc/self/environ'\n# Reads environment variables (may contain secrets)\n```\n\n2. **Overwrite /tmp files** (shared across warm invocations):\n```python\nkey = '../shared_config.json'\n# Overwrites config file in /tmp\n# Next invocation reads poisoned config\n```\n\n**Defense in Depth:**\n1. **Input validation** (allowlist only safe characters)\n2. **Path normalization and validation**\n3. **Principle of least privilege** (execution role)\n4. **Runtime monitoring** (detect unusual file access)",
      "question_id": "21b8aeff-e358-4ddd-a45c-5da802264828",
      "type": "multiple_choice",
      "difficulty": 2
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "connect_to_what_i_know",
    "memory_hooks",
    "teach_like_im_10",
    "minimum_effective_dose",
    "meta_learning",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ]
}