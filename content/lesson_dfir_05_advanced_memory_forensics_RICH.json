{
  "lesson_id": "b6c7d8e9-0f1a-2b3c-4d5e-6f7a8b9c0d1e",
  "domain": "dfir",
  "title": "Advanced Memory Forensics and Malware Analysis",
  "difficulty": 3,
  "order_index": 5,
  "prerequisites": [
    "e8f1a2b3-4c5d-6e7f-8a9b-0c1d2e3f4a5b"
  ],
  "concepts": [
    "Volatility 3 Framework Advanced Techniques",
    "Process Injection Detection (DLL Injection, Process Hollowing, Reflective DLL)",
    "Rootkit Detection and Analysis",
    "Memory-Resident Malware (Fileless Attacks)",
    "Credential Dumping from Memory (Mimikatz Detection)",
    "Network Connection Analysis from Memory",
    "Malware Unpacking in Memory",
    "Windows Internals for Forensics",
    "YARA Rules for Memory Scanning",
    "Timeline Analysis from Memory Artifacts"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Use Volatility 3 to detect advanced process injection techniques",
    "Identify rootkits through SSDT hooking and driver analysis",
    "Extract and analyze credentials from memory dumps",
    "Detect fileless malware using behavioral indicators",
    "Create custom YARA rules for memory-based malware detection",
    "Reconstruct attack timelines from memory artifacts",
    "Analyze malware behavior through memory forensics",
    "Perform live memory acquisition and analysis"
  ],
  "content_blocks": [
    {
      "type": "explanation",
      "title": "Advanced Memory Forensics Concepts",
      "content": {
        "text": "Memory forensics is critical for detecting advanced threats that leave minimal disk traces. Modern attackers use in-memory techniques to evade traditional forensics.\n\n**Why Memory Forensics Matters**\n\nDisk forensics misses:\n- **Fileless malware** (PowerShell scripts, reflective DLL injection)\n- **Encrypted network connections** (only visible in memory)\n- **Credentials** (stored in LSASS process memory)\n- **Active rootkits** (hooks visible in memory, not disk)\n- **Running processes** (malware that deletes itself after execution)\n\n**Memory Acquisition Methods**\n\n**1. Cold Acquisition (System Off)**\n- Boot from USB with FTK Imager\n- Physical memory dump\n- \u2705 Forensically sound (no system modification)\n- \u274c Loses volatile data (running processes, network connections)\n\n**2. Live Acquisition (System Running)**\n- DumpIt, WinPmem, LiME (Linux)\n- Captures current system state\n- \u2705 Preserves volatile data\n- \u274c Modifies system state (technically alters evidence)\n\n**3. Crash Dump Analysis**\n- Windows Blue Screen dumps (MEMORY.DMP)\n- Kernel crash dumps\n- \u2705 Already present (no acquisition needed)\n- \u274c May be incomplete\n\n**Volatility 3 Framework**\n\nVolatility is the industry-standard memory forensics framework.\n\n**Key Plugins:**\n\n```bash\n# Process listing\nvol -f memory.dmp windows.pslist\nvol -f memory.dmp windows.pstree  # Tree view\nvol -f memory.dmp windows.psscan  # Find hidden processes\n\n# Network connections\nvol -f memory.dmp windows.netscan\n\n# DLL analysis\nvol -f memory.dmp windows.dlllist --pid 1234\n\n# Handle analysis\nvol -f memory.dmp windows.handles --pid 1234\n\n# Code injection detection\nvol -f memory.dmp windows.malfind\nvol -f memory.dmp windows.hollowprocesses\n\n# Rootkit detection\nvol -f memory.dmp windows.ssdt\nvol -f memory.dmp windows.modules\n```\n\n**Process Injection Techniques**\n\n**1. DLL Injection**\n\nAttacker injects malicious DLL into legitimate process.\n\n**Detection:**\n```bash\nvol -f memory.dmp windows.dlllist --pid 1234 | grep -v \"C:\\\\Windows\"\n# Look for DLLs loaded from unusual paths (/tmp, user directories)\n```\n\n**Indicators:**\n- DLL loaded from non-standard path\n- DLL not signed or signature mismatch\n- Base address in unusual memory region\n\n**2. Process Hollowing**\n\nAttacker creates legitimate process in suspended state, replaces its memory with malicious code, resumes.\n\n**Detection:**\n```bash\nvol -f memory.dmp windows.malfind --pid 1234\n# Look for:\n# - Executable memory regions not backed by files on disk\n# - Mismatched PE headers (process claims to be svchost.exe but code is different)\n```\n\n**Indicators:**\n- Process path doesn't match memory content\n- Entry point outside main executable module\n- Missing/suspicious base relocations\n\n**3. Reflective DLL Injection**\n\nDLL loaded entirely in memory (never touches disk).\n\n**Detection:**\n```bash\nvol -f memory.dmp windows.malfind\n# Reflective DLLs appear as:\n# - Executable memory with PE structure\n# - No corresponding file on disk\n# - Manual memory allocation (VirtualAlloc)\n```\n\n**Rootkit Detection**\n\nRootkits hide processes, files, network connections.\n\n**Kernel Rootkit Techniques:**\n\n**1. SSDT Hooking (System Service Descriptor Table)**\n\nSSDT contains pointers to kernel functions. Rootkits modify these pointers to intercept system calls.\n\n**Detection:**\n```bash\nvol -f memory.dmp windows.ssdt\n# Look for:\n# - Functions pointing outside ntoskrnl.exe (kernel)\n# - Suspicious module names\n# - Inline hooks (first bytes of function modified)\n```\n\n**2. Direct Kernel Object Manipulation (DKOM)**\n\nRootkits modify kernel structures to hide processes.\n\n**Detection:**\n```bash\n# Compare process lists from different sources:\nvol -f memory.dmp windows.pslist  # Walks linked list (can be manipulated)\nvol -f memory.dmp windows.psscan  # Scans memory for EPROCESS structures (harder to hide)\n\n# Processes in psscan but not pslist = hidden by rootkit\n```\n\n**3. Driver-Based Rootkits**\n\n**Detection:**\n```bash\nvol -f memory.dmp windows.modules\n# Look for:\n# - Unsigned drivers\n# - Drivers loaded from unusual paths\n# - Drivers with no file on disk\n# - Drivers with suspicious names (random characters, system32 typos)\n```\n\n**Credential Dumping Detection**\n\nMimikatz and similar tools extract credentials from LSASS process memory.\n\n**LSASS Memory Analysis:**\n```bash\n# Find LSASS process\nvol -f memory.dmp windows.pslist | grep lsass\n# LSASS PID: 612\n\n# Dump LSASS memory\nvol -f memory.dmp windows.memmap --pid 612 --dump\n\n# Scan for credential patterns\nstrings lsass.612.dmp | grep -i password\nstrings lsass.612.dmp | grep -E '[A-Za-z0-9]{32}'  # NTLM hashes\n```\n\n**Mimikatz Detection Indicators:**\n- LSASS process handle opened by non-system process\n- SeDebugPrivilege enabled for user-mode process\n- Suspicious DLLs loaded into LSASS (SSP/AP DLLs)\n- Registry keys: `HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders`\n\n**Fileless Malware Analysis**\n\nFileless malware runs entirely in memory (PowerShell, WMI, MSHTA).\n\n**Detection Strategies:**\n\n**1. PowerShell Script Blocks in Memory**\n```bash\nvol -f memory.dmp windows.cmdline | grep powershell\n# Look for:\n# - Encoded commands (-EncodedCommand)\n# - Download cradles (IEX, Invoke-WebRequest)\n# - Obfuscation (multiple layers of encoding)\n```\n\n**2. Suspicious Process Parent-Child Relationships**\n```bash\nvol -f memory.dmp windows.pstree\n# Suspicious:\n# - winword.exe \u2192 powershell.exe (malicious macro)\n# - excel.exe \u2192 cmd.exe \u2192 powershell.exe\n# - wscript.exe \u2192 powershell.exe\n```\n\n**3. WMI Event Consumers (Persistence)**\n```bash\nvol -f memory.dmp windows.registry.printkey --key \"SOFTWARE\\Microsoft\\Wbem\\ESS\\\\\\\\NAMESPACE\"\n# Malicious WMI consumers for persistence\n```\n\n**YARA Rules for Memory Scanning**\n\nYARA detects malware patterns in memory.\n\n**Example Rule - Mimikatz Detection:**\n```yara\nrule Mimikatz_Memory {\nmeta:\ndescription = \"Detects Mimikatz in memory\"\nauthor = \"DFIR Team\"\nstrings:\n$s1 = \"sekurlsa::logonpasswords\" wide ascii\n$s2 = \"crypto::capi\" wide ascii\n$s3 = \"kerberos::golden\" wide ascii\n$s4 = \"misc::skeleton\" wide ascii\n$hex1 = {68 61 6E 64 6C 65 5C 70 69 64}  # \"handle\\pid\"\ncondition:\nany of them\n}\n```\n\n**Scan memory with YARA:**\n```bash\nvol -f memory.dmp windows.yarascan --yara-file mimikatz.yar\n```\n\n**Timeline Analysis**\n\nReconstruct attack timeline from memory artifacts.\n\n**Timeline Sources:**\n- Process creation times\n- DLL load times\n- Network connection timestamps\n- Registry last write times\n- File handle creation times\n\n**Example Timeline:**\n```\n2024-01-15 10:23:15 - outlook.exe opens malicious.doc\n2024-01-15 10:23:18 - winword.exe spawns powershell.exe (malicious macro)\n2024-01-15 10:23:22 - powershell.exe downloads payload from attacker.com\n2024-01-15 10:23:25 - rundll32.exe loads malicious DLL (fileless)\n2024-01-15 10:23:30 - network connection to C2 server (192.0.2.100:443)\n2024-01-15 10:23:35 - mimikatz.exe dumping credentials from LSASS\n2024-01-15 10:23:45 - lateral movement to DC via SMB\n```"
      }
    },
    {
      "type": "code_exercise",
      "title": "Hands-On Memory Forensics",
      "content": {
        "text": "**Exercise 1: Detect Process Injection**\n\n```bash\n# Scenario: Suspicious svchost.exe process\n\n# 1. List all svchost.exe processes\nvol -f memory.dmp windows.pslist | grep svchost\n\n# Output:\n# PID: 1234, Name: svchost.exe, PPID: 612 (services.exe) \u2713 Legitimate\n# PID: 5678, Name: svchost.exe, PPID: 2345 (cmd.exe) \u26a0\ufe0f SUSPICIOUS\n\n# 2. Analyze suspicious PID 5678\nvol -f memory.dmp windows.dlllist --pid 5678\n\n# Look for:\n# - DLLs from C:\\Users\\Public\n# - DLLs with random names (abc123.dll)\n# - DLLs from temp directories\n\n# 3. Check for code injection\nvol -f memory.dmp windows.malfind --pid 5678\n\n# Output shows executable memory at 0x12340000:\n# - Protection: PAGE_EXECUTE_READWRITE (suspicious)\n# - No corresponding file on disk\n# - Contains shellcode\n\n# 4. Dump suspicious memory region\nvol -f memory.dmp windows.memmap --pid 5678 --dump\n\n# 5. Analyze dumped memory\nstrings 5678.dmp | grep -E \"http://|https://\"  # Look for C2 URLs\nstrings 5678.dmp | grep -E \"[A-Za-z0-9+/]{32,}==?\"  # Look for base64\n```\n\n**Exercise 2: Rootkit Detection**\n\n```bash\n# 1. Check for hidden processes (DKOM)\nvol -f memory.dmp windows.pslist > pslist.txt\nvol -f memory.dmp windows.psscan > psscan.txt\n\n# Compare:\ndiff pslist.txt psscan.txt\n# Processes in psscan but not pslist = hidden\n\n# 2. Check SSDT hooks\nvol -f memory.dmp windows.ssdt | grep -v ntoskrnl\n\n# Suspicious entries:\n# Entry: NtCreateFile, Address: 0xf8a12000 (rootkit.sys) \u26a0\ufe0f HOOKED\n# Entry: NtOpenProcess, Address: 0xf8a13000 (rootkit.sys) \u26a0\ufe0f HOOKED\n\n# 3. Check loaded drivers\nvol -f memory.dmp windows.modules | grep -v \"C:\\\\Windows\"\n\n# Suspicious:\n# Base: 0xf8a10000, Name: rootkit.sys, Path: C:\\Temp\\rootkit.sys\n# - Loaded from C:\\Temp (not system32\\drivers)\n# - Unsigned\n# - Random name\n\n# 4. Dump rootkit driver for analysis\nvol -f memory.dmp windows.moddump --base 0xf8a10000\n\n# 5. Analyze driver\nstrings rootkit.sys.0xf8a10000.dll | grep -i hide\nstrings rootkit.sys.0xf8a10000.dll | grep -i hook\n```\n\n**Exercise 3: Mimikatz Credential Dumping Detection**\n\n```bash\n# 1. Find LSASS process\nvol -f memory.dmp windows.pslist | grep lsass\n# PID: 612, Name: lsass.exe\n\n# 2. Check which processes accessed LSASS\nvol -f memory.dmp windows.handles --pid 612 | grep Process\n\n# Suspicious:\n# PID: 3456, Name: powershell.exe, Handle: LSASS process (PROCESS_ALL_ACCESS)\n# \u26a0\ufe0f PowerShell with full access to LSASS = credential dumping\n\n# 3. Scan for Mimikatz patterns\nvol -f memory.dmp windows.yarascan --yara-file mimikatz.yar\n\n# Hit in PID 3456 (powershell.exe):\n# - String: \"sekurlsa::logonpasswords\"\n# - Address: 0x23450000\n\n# 4. Dump PowerShell process memory\nvol -f memory.dmp windows.memmap --pid 3456 --dump\n\n# 5. Extract credentials (if dumped by Mimikatz)\nstrings 3456.dmp | grep -A5 \"Username\"\nstrings 3456.dmp | grep -E \"[a-f0-9]{32}\"  # NTLM hashes\n\n# 6. Check PowerShell command line\nvol -f memory.dmp windows.cmdline --pid 3456\n\n# Output:\n# powershell.exe -ep bypass -enc <base64-encoded-mimikatz-script>\n\n# Decode:\necho \"<base64>\" | base64 -d\n# Reveals: Invoke-Mimikatz -DumpCreds\n```\n\n**Exercise 4: Network Connection Analysis**\n\n```bash\n# 1. List all network connections\nvol -f memory.dmp windows.netscan\n\n# Suspicious connection:\n# PID: 5678, Process: svchost.exe, Remote: 192.0.2.100:443 (ESTABLISHED)\n# - svchost.exe typically doesn't connect to external IPs\n# - Port 443 (HTTPS) - potential C2 communication\n\n# 2. Analyze the process\nvol -f memory.dmp windows.pslist --pid 5678\n\n# Output:\n# Parent: cmd.exe (PPID: 2345) \u26a0\ufe0f svchost should be child of services.exe\n# Creation time: 2024-01-15 10:23:18\n\n# 3. Check process command line\nvol -f memory.dmp windows.cmdline --pid 5678\n\n# Output:\n# C:\\Windows\\System32\\svchost.exe -k netsvcs -p -s malware\n# \u26a0\ufe0f \"-s malware\" is not a legitimate service\n\n# 4. Dump network traffic from memory (if captured)\nvol -f memory.dmp windows.netscan --dump-dir ./network/\n\n# 5. Analyze C2 communication\nstrings 5678.dmp | grep \"User-Agent:\"\n# Suspicious: \"Mozilla/5.0 (Windows NT 10.0; Cobalt Strike)\"\n```\n\n**Exercise 5: Timeline Reconstruction**\n\n```bash\n# Build comprehensive timeline from memory\n\n# 1. Process timeline\nvol -f memory.dmp windows.pslist --dump > processes.csv\n\n# 2. Network timeline\nvol -f memory.dmp windows.netscan --dump > network.csv\n\n# 3. Registry timeline\nvol -f memory.dmp windows.registry.userassist --dump > userassist.csv\n\n# 4. Combine and sort by timestamp\n# Use timeline tool or manual sorting\n\n# Example timeline output:\n# 10:23:15 | outlook.exe opens file handle: malicious.doc\n# 10:23:18 | winword.exe (PID 2000) spawns powershell.exe (PID 3456)\n# 10:23:22 | powershell.exe connects to 192.0.2.50:80 (download payload)\n# 10:23:25 | svchost.exe (PID 5678) created with parent cmd.exe (process injection)\n# 10:23:30 | svchost.exe connects to 192.0.2.100:443 (C2 server)\n# 10:23:35 | powershell.exe accesses LSASS (credential dumping)\n# 10:23:45 | svchost.exe connects to 192.168.1.10:445 (SMB - lateral movement)\n```\n\n**Exercise 6: Custom YARA Rule Creation**\n\n```yara\n# Detect Cobalt Strike Beacon in memory\nrule CobaltStrike_Beacon_Memory {\nmeta:\ndescription = \"Detects Cobalt Strike Beacon in process memory\"\nauthor = \"DFIR Team\"\nreference = \"https://www.cobaltstrike.com/\"\n\nstrings:\n// Cobalt Strike user agent patterns\n$ua1 = \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0; Cobalt Strike\" ascii\n$ua2 = \"User-Agent: Mozilla/5.0\" ascii\n\n// Beacon configuration markers\n$cfg1 = {00 01 00 01 00 02}  // Config structure\n$cfg2 = \"MSSE-\" ascii  // Named pipe prefix\n\n// Reflective DLL injection markers\n$rdll1 = \"ReflectiveLoader\" ascii\n$rdll2 = {4D 5A ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 50 45}  // PE header in memory\n\n// Sleep mask patterns (Cobalt Strike 4.0+)\n$sleep1 = {48 89 5C 24 ?? 48 89 74 24 ?? 57 48 83 EC 20 49 8B F8}\n\ncondition:\n(any of ($ua*) and any of ($cfg*)) or\n(any of ($rdll*) and $sleep1) or\n(2 of ($cfg*))\n}\n```\n\n**Scan with custom rule:**\n```bash\nvol -f memory.dmp windows.yarascan --yara-file cobaltstrike.yar\n```"
      }
    },
    {
      "type": "real_world",
      "title": "Real-World Memory Forensics Cases",
      "content": {
        "text": "**APT29 (Cozy Bear) - Fileless Attacks**\n\n**Technique:**\n- Exploited CVE in Microsoft Office\n- Dropped PowerShell script (no disk write)\n- PowerShell loaded .NET assembly reflectively (in-memory only)\n- Established C2 connection\n- Credential dumping via Mimikatz (loaded in memory)\n\n**Memory Forensics Findings:**\n1. Suspicious winword.exe \u2192 powershell.exe parent-child relationship\n2. PowerShell command line with base64-encoded payload\n3. Reflective DLL in PowerShell memory space (no file on disk)\n4. LSASS handle opened by PowerShell\n5. Network connection to known APT29 C2 infrastructure\n\n**Key Lesson:** Disk forensics found NOTHING. Only memory forensics revealed the attack.\n\n**NotPetya Ransomware (2017)**\n\n**Memory Analysis Revealed:**\n- Credential dumping using modified Mimikatz\n- LSASS memory access by system32\\rundll32.exe\n- SMB connections to internal network (lateral movement)\n- EternalBlue exploit artifacts in memory\n- Disk encryption key stored briefly in memory\n\n**Forensic Value:**\nMemory dumps captured encryption keys, allowing some organizations to recover data.\n\n**Stuxnet (2010) - Rootkit Analysis**\n\n**Memory Forensics Uncovered:**\n- SSDT hooks hiding malicious drivers\n- Kernel-mode rootkit components\n- Zero-day exploit code in memory\n- PLC (Programmable Logic Controller) communication in memory buffers\n\n**Technique:**\nStuxnet used DKOM to hide its drivers from standard enumeration. Memory analysis via psscan and driver scanning revealed hidden components."
      }
    },
    {
      "type": "reflection",
      "title": "Memory Forensics Mastery",
      "content": {
        "text": "**Critical Questions:**\n\n1. Why can't disk forensics detect fileless malware?\n2. How does process hollowing differ from DLL injection?\n3. What are the limitations of memory forensics (volatility, acquisition challenges)?\n4. Why is LSASS such a high-value target for attackers?\n5. How do rootkits use DKOM to hide processes?\n6. What makes Volatility 3 different from Volatility 2?\n\n**Career Application:**\n- Memory forensics is an advanced, high-demand skill\n- SANS FOR508 (Advanced Incident Response) focuses heavily on memory analysis\n- GREM (Reverse Engineering Malware) certification includes memory forensics\n- Average memory forensics specialist salary: $110,000-$150,000\n\n**Hands-On Challenge:**\nDownload a CTF memory dump (e.g., MemLabs) and:\n1. Identify the attack vector\n2. Extract malware artifacts\n3. Reconstruct the attack timeline\n4. Create a comprehensive forensic report"
      }
    },
    {
      "type": "memory_aid",
      "title": "Memory Forensics Quick Reference",
      "content": {
        "text": "**Volatility Essential Commands: \"PPNDMH\"**\n- **P**slist (processes)\n- **P**sscan (hidden processes)\n- **N**etscan (network connections)\n- **D**lllist (loaded DLLs)\n- **M**alfind (code injection)\n- **H**andles (open handles)\n\n**Process Injection Types: \"DHR\"**\n- **D**LL injection (LoadLibrary)\n- **H**ollowing (create suspended, replace, resume)\n- **R**eflective DLL (PE in memory, no disk)\n\n**Rootkit Detection: \"SDM\"**\n- **S**SDT hooks (system call interception)\n- **D**KOM (Direct Kernel Object Manipulation)\n- **M**odules (hidden drivers)\n\n**Suspicious Parent-Child Relationships:**\n```\n\u274c winword.exe \u2192 powershell.exe (malicious macro)\n\u274c excel.exe \u2192 cmd.exe (malicious VBA)\n\u274c chrome.exe \u2192 svchost.exe (browser exploit)\n\u274c explorer.exe \u2192 net.exe (lateral movement)\n\u2705 services.exe \u2192 svchost.exe (legitimate)\n\u2705 winlogon.exe \u2192 userinit.exe (legitimate)\n```\n\n**LSASS Credential Dumping Indicators:**\n```bash\n# Check LSASS handles\nvol -f mem.dmp windows.handles --pid $(pidof lsass)\n\n# Suspicious: non-system process with LSASS handle\n# PID 1234 (powershell.exe) \u2192 LSASS handle = CREDENTIAL DUMPING\n```\n\n**Quick YARA Scan:**\n```bash\nvol -f memory.dmp windows.yarascan --yara-file rules.yar\n```\n\n**Timeline One-Liner:**\n```bash\nvol -f mem.dmp windows.pslist | awk '{print $4, $2, $1}' | sort -n\n```"
      }
    },
    {
      "type": "video",
      "title": "Memory Forensics Learning Resources",
      "content": {
        "resources": "**Featured Video**: [Advanced Memory Forensics (Windows) - Threat_Hunting and Initial Malware_Analysis [part1]](https://www.youtube.com/watch?v=WB29XIUZjRU)\n\n**Training Courses:**\n- SANS FOR508: Advanced Incident Response, Threat Hunting, and Digital Forensics\n- SANS FOR610: Reverse-Engineering Malware: Malware Analysis Tools and Techniques\n- GREM: GIAC Reverse Engineering Malware (certification)\n\n**YouTube Channels:**\n- \"13Cubed\" (excellent Volatility tutorials)\n- \"SANS Digital Forensics\" (FOR508 previews)\n- \"OALabs\" (malware analysis and memory forensics)\n\n**Books:**\n- \"The Art of Memory Forensics\" (Michael Hale Ligh et al.) - THE definitive book\n- \"Practical Memory Forensics\" (Svetlana Ostrovskaya, Oleg Skulkin)\n\n**Practice:**\n- MemLabs (GitHub - memory forensics CTF challenges)\n- DFIR Madness (monthly forensics challenges)\n- CyberDefenders (Blue Team Labs with memory dumps)\n\n**Tools:**\n- Volatility 3 (https://github.com/volatilityfoundation/volatility3)\n- Rekall (alternative to Volatility)\n- WinDbg (Windows kernel debugging)\n- YARA (https://github.com/VirusTotal/yara)\n\n**Free Memory Dumps for Practice:**\n- https://github.com/stuxnet999/MemLabs\n- https://www.memoryanalysis.net/memory-dumps\n- https://cyberdefenders.org/"
      }
    }
  ],
  "post_assessment": [
    {
      "question": "You run 'vol -f mem.dmp windows.pslist' and 'vol -f mem.dmp windows.psscan'. Process PID 1234 appears in psscan but NOT in pslist. What does this indicate?",
      "options": [
        "Process 1234 has terminated and is in exit state",
        "Process 1234 is hidden by a rootkit using DKOM (Direct Kernel Object Manipulation)",
        "Process 1234 is a kernel-mode process not visible to pslist",
        "psscan is more accurate and pslist missed it due to parsing error"
      ],
      "correct_answer": 1,
      "explanation": "**Correct: Process is hidden by a rootkit using DKOM.**\n\n**How This Works:**\n\n`windows.pslist` walks the linked list of EPROCESS structures maintained by Windows. Rootkits can unlink a process from this list:\n\n```\nNormal linked list:\nProcess A \u2194 Process B \u2194 Process C \u2194 Process D\n\nAfter DKOM (hiding Process C):\nProcess A \u2194 Process B \u2194 Process D\n                \u2193\n           Process C (orphaned, but still in memory)\n```\n\n`windows.psscan` doesn't rely on linked lists. It scans ALL of physical memory looking for EPROCESS structure signatures:\n\n```python\n# Simplified logic:\nfor address in memory:\n    if looks_like_eprocess_structure(address):\n        parse_as_process(address)\n```\n\nEven if the process is unlinked from the list, the EPROCESS structure still exists in memory, so psscan finds it.\n\n**Detection Workflow:**\n```bash\nvol -f mem.dmp windows.pslist > pslist.txt\nvol -f mem.dmp windows.psscan > psscan.txt\ndiff pslist.txt psscan.txt\n\n# Hidden processes appear only in psscan\n```\n\n**Why Other Options Are Wrong:**\n\n**Terminated processes:** Would appear in neither (or only in psscan if recently terminated and memory not yet reclaimed).\n\n**Kernel-mode processes:** Both plugins detect kernel processes (e.g., System, PID 4).\n\n**Parsing error:** Volatility is robust. Consistent absence from pslist indicates intentional hiding, not parsing error.",
      "question_id": "c428802a-e9c3-4fe3-9d7c-4abb8255ab6c",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "During analysis, you find svchost.exe (PID 5678) with parent process cmd.exe. The process has an executable memory region at 0x12340000 with no backing file on disk. What attack technique is this?",
      "options": [
        "DLL injection",
        "Process hollowing",
        "Reflective DLL injection",
        "Shellcode injection"
      ],
      "correct_answer": 1,
      "explanation": "**Correct: Process hollowing.**\n\n**Process Hollowing Characteristics:**\n1. **Legitimate process name** (svchost.exe) - creates appearance of legitimacy\n2. **Unusual parent process** (cmd.exe instead of services.exe) - attacker launched it\n3. **Code in memory doesn't match disk** - original svchost.exe code replaced with malware\n4. **Entry point outside normal range** - execution starts from injected code\n\n**Process Hollowing Steps:**\n```bash\n# 1. Attacker creates legitimate process in SUSPENDED state\nCreateProcess(\"C:\\\\Windows\\\\System32\\\\svchost.exe\", CREATE_SUSPENDED)\n\n# 2. Unmaps original executable from memory\nNtUnmapViewOfSection(process_handle, base_address)\n\n# 3. Allocates new memory and writes malicious code\nVirtualAllocEx(process_handle, preferred_base, size, MEM_COMMIT)\nWriteProcessMemory(process_handle, base_address, malicious_code)\n\n# 4. Updates entry point to malicious code\nSetThreadContext(thread_handle, new_entry_point)\n\n# 5. Resumes process (now runs malware, but looks like svchost.exe)\nResumeThread(thread_handle)\n```\n\n**Detection with Volatility:**\n```bash\nvol -f mem.dmp windows.malfind --pid 5678\n\n# Output:\n# Process: svchost.exe (5678)\n# Address: 0x12340000\n# Protection: PAGE_EXECUTE_READWRITE\n# Disassembly:\n#   0x12340000: 55              PUSH EBP\n#   0x12340001: 8B EC           MOV EBP, ESP\n#   ...\n# Warning: No backing file for this memory region\n```\n\n**Why Other Options Are Wrong:**\n\n**DLL Injection:** Would show suspicious DLL in `windows.dlllist`, not unmapped memory.\n\n**Reflective DLL Injection:** Similar symptoms, but specifically involves loading a DLL entirely in memory. Process hollowing replaces the ENTIRE process.\n\n**Shellcode Injection:** Generic term. Process hollowing is a SPECIFIC type using create-unmap-write-resume pattern.",
      "question_id": "e796cdd4-1815-403b-a35d-a598542b5589",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "You find PowerShell process (PID 3456) with a handle to LSASS (PID 612) with PROCESS_ALL_ACCESS permissions. What attack is likely occurring?",
      "options": [
        "Process injection into LSASS",
        "Credential dumping (Mimikatz-style)",
        "LSASS crash dump analysis",
        "Normal Windows authentication flow"
      ],
      "correct_answer": 1,
      "explanation": "**Correct: Credential dumping (Mimikatz-style).**\n\n**Why This Indicates Credential Dumping:**\n\nLSASS (Local Security Authority Subsystem Service) stores:\n- Plaintext passwords (if WDigest enabled)\n- NTLM hashes\n- Kerberos tickets\n- Cached domain credentials\n\nTo extract these, attackers:\n1. Open LSASS process with PROCESS_ALL_ACCESS\n2. Read LSASS memory\n3. Parse authentication data structures\n4. Extract credentials\n\n**Detection:**\n```bash\n# Find LSASS PID\nvol -f mem.dmp windows.pslist | grep lsass\n# PID: 612\n\n# Check which processes have handles to LSASS\nvol -f mem.dmp windows.handles --pid 612 | grep Process\n\n# Output:\n# PID: 3456 (powershell.exe)\n# Handle Type: Process\n# Access: PROCESS_ALL_ACCESS (0x1FFFFF)\n# \u26a0\ufe0f SUSPICIOUS - PowerShell should NOT access LSASS\n```\n\n**Check PowerShell command line:**\n```bash\nvol -f mem.dmp windows.cmdline --pid 3456\n\n# Output:\npowershell.exe -ep bypass -enc SQBuAHYAbwBrAGUALQBNAGkAbQBpAGsAYQB0AHoA\n\n# Decode base64:\necho \"SQBuAHYAbwBrAGUALQBNAGkAbQBpAGsAYQB0AHoA\" | base64 -d\n# \"Invoke-Mimikatz\"\n```\n\n**YARA Scan:**\n```bash\nvol -f mem.dmp windows.yarascan --yara-file mimikatz.yar --pid 3456\n\n# Hit: \"sekurlsa::logonpasswords\" found in PowerShell memory\n```\n\n**Why Other Options Are Wrong:**\n\n**Process Injection INTO LSASS:** Rare (high risk of system crash). Attackers typically inject into other processes, not LSASS itself.\n\n**LSASS Crash Dump:** Legitimate tools (Task Manager, procdump) can create LSASS dumps, but:\n- Usually run by admins, not random PowerShell scripts\n- Different access pattern (create dump file, not just read memory)\n- Command line would show procdump.exe, not PowerShell script\n\n**Normal authentication:** LSASS is accessed by SYSTEM and core Windows services, NOT user-mode PowerShell.\n\n**Prevention:**\n- Credential Guard (Windows 10+) - isolates LSASS in virtualized container\n- LSA Protection - prevents non-PPL processes from opening LSASS\n- Monitor for SeDebugPrivilege usage\n- Alert on non-system processes accessing LSASS",
      "question_id": "33cb9bf9-9e20-4a9d-be4d-1043f16f7989",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "You scan memory with YARA and find a PE header (4D 5A) at address 0x23450000 in process memory, but no corresponding file exists on disk. What is this?",
      "options": [
        "Memory corruption or false positive",
        "Reflective DLL injection (DLL loaded entirely in memory)",
        "Packed executable that unpacks at runtime",
        "Windows system DLL cached in memory"
      ],
      "correct_answer": 1,
      "explanation": "**Correct: Reflective DLL injection.**\n\n**PE Header Signature:**\n```\n4D 5A = \"MZ\" (DOS header signature)\nFollowed by PE header at offset 0x3C-0x3F\n```\n\nAll Windows executables (EXE, DLL, SYS) start with \"MZ\".\n\n**Reflective DLL Injection:**\n\nNormal DLL loading:\n```\nLoadLibrary(\"C:\\\\malware.dll\")\n  \u2193\n1. Read DLL from disk\n2. Map into memory\n3. Resolve imports\n4. Execute DllMain\n```\n\nThis leaves disk artifacts (file on disk, prefetch entries, etc.).\n\n**Reflective DLL Loading:**\n```python\n# Attacker's process:\n1. Allocate memory: VirtualAlloc()\n2. Write DLL bytes directly to memory (no file I/O)\n3. Manually resolve imports (no Windows loader)\n4. Execute DLL's ReflectiveLoader function\n5. ReflectiveLoader fixes relocations and calls DllMain\n```\n\nResult: Fully functional DLL in memory, never touched disk.\n\n**Detection:**\n```bash\n# Scan for PE headers in memory\nvol -f mem.dmp windows.yarascan --yara-file pe_in_memory.yar\n\n# YARA rule:\nrule PE_In_Memory {\n    strings:\n        $mz = {4D 5A}\n        $pe = {50 45 00 00}  # PE\\0\\0\n    condition:\n        $mz at 0 and $pe\n}\n\n# Hit at 0x23450000 in PID 5678\n\n# Verify it's not a normal DLL:\nvol -f mem.dmp windows.dlllist --pid 5678 | grep 0x23450000\n# No match = reflective DLL (not loaded via LoadLibrary)\n\n# Dump the DLL:\nvol -f mem.dmp windows.memmap --pid 5678 --address 0x23450000 --dump\n\n# Analyze:\nfile 5678.0x23450000.dmp\n# Output: PE32 executable (DLL) (GUI) Intel 80386, for MS Windows\n\nstrings 5678.0x23450000.dmp | grep -i reflect\n# \"ReflectiveLoader\"\n# \"Reflective DLL Injection\"\n```\n\n**Why Other Options Are Wrong:**\n\n**Memory corruption:** Possible but unlikely. PE header is a very specific structure:\n```\nOffset  Value   Meaning\n0x00    4D 5A   DOS signature\n0x3C    XX XX   Offset to PE header\n0x??    50 45   PE signature\n```\nRandom corruption wouldn't create a valid PE structure.\n\n**Packed executable:** Packed executables START on disk, then unpack in memory. If there's NO file on disk, it's not a packed executable.\n\n**Cached system DLL:** Windows system DLLs would:\n1. Have a file on disk (C:\\Windows\\System32\\*.dll)\n2. Appear in `windows.dlllist` output\n3. Have known-good signatures\n\n**Real-World Example: Cobalt Strike Beacon**\n\nCobalt Strike uses reflective DLL injection:\n```\n1. Exploit delivers stager (small shellcode)\n2. Stager downloads Beacon DLL from C2\n3. Beacon DLL is loaded reflectively (never written to disk)\n4. Beacon DLL contains full C2 capabilities\n```\n\nMemory forensics finds:\n- PE header in memory (4D 5A)\n- No corresponding DLL in dlllist\n- String: \"ReflectiveLoader\"\n- Network connections to C2 server",
      "question_id": "022808c7-b8f2-446e-8e48-1629344929b8",
      "type": "multiple_choice",
      "difficulty": 3
    }
  ],
  "jim_kwik_principles": [
    "memory_hooks",
    "active_learning",
    "teach_like_im_10",
    "minimum_effective_dose",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ]
}
