{
  "lesson_id": "562b03ba-4337-4056-8028-ef4c4dd933f2",
  "domain": "dfir",
  "title": "Windows Prefetch Analysis",
  "difficulty": 2,
  "order_index": 16,
  "prerequisites": [
    "93389b7b-e0c3-4d6b-9243-8ae49b8c509f"
  ],
  "concepts": [
    "Prefetch file structure and purpose",
    "Program execution evidence from Prefetch",
    "PECmd (Prefetch Explorer Command Line) usage",
    "Prefetch timeline analysis",
    "Prefetch limitations and Windows version differences",
    "MAM (Microsoft Application Manager) compression"
  ],
  "estimated_time": 55,
  "learning_objectives": [
    "Understand Prefetch mechanism and forensic value for execution evidence",
    "Parse Prefetch files using PECmd to extract execution timestamps",
    "Identify program run counts and last execution times",
    "Analyze referenced files and directories from Prefetch metadata",
    "Recognize Prefetch limitations across Windows versions",
    "Build execution timelines from Prefetch artifacts"
  ],
  "post_assessment": [
    {
      "question_id": "prefetch-001",
      "question": "What is the primary purpose of Windows Prefetch?",
      "options": [
        "To log user activity for forensic analysis",
        "To optimize application startup performance",
        "To track malware execution",
        "To store application configuration settings"
      ],
      "correct_answer": 1,
      "explanation": "Prefetch was designed by Microsoft to optimize application startup performance by pre-loading frequently accessed resources into memory. Its forensic value is a side effect of this performance optimization feature.",
      "type": "multiple_choice",
      "difficulty": 1
    },
    {
      "question_id": "prefetch-002",
      "question": "Where are Prefetch files stored on a Windows system?",
      "options": [
        "C:\\Windows\\Prefetch\\",
        "C:\\Windows\\System32\\Prefetch\\",
        "C:\\Users\\<username>\\AppData\\Local\\Prefetch\\",
        "C:\\ProgramData\\Microsoft\\Prefetch\\"
      ],
      "correct_answer": 0,
      "explanation": "Prefetch files are stored in C:\\Windows\\Prefetch\\ directory. Each file is named with the executable name and an 8-character hash (e.g., CMD.EXE-0BD30981.pf).",
      "type": "multiple_choice",
      "difficulty": 1
    },
    {
      "question_id": "prefetch-003",
      "question": "How many execution timestamps are stored in Prefetch files on Windows 10?",
      "options": [
        "1 timestamp (most recent execution only)",
        "8 timestamps (last 8 executions)",
        "Unlimited timestamps",
        "0 timestamps (Prefetch doesn't store timestamps)"
      ],
      "correct_answer": 1,
      "explanation": "Windows 8+ and Windows 10 store the last 8 execution timestamps in Prefetch files. Windows 7 and earlier only stored 1 timestamp (most recent execution). This is a significant forensic improvement.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "prefetch-004",
      "question": "What is the significance of the 8-character hash in a Prefetch filename (e.g., CALC.EXE-0BD30981.pf)?",
      "options": [
        "It's a cryptographic hash of the file contents",
        "It's a hash based on the executable path and command-line arguments",
        "It's a random identifier generated at runtime",
        "It's the process ID (PID) of the last execution"
      ],
      "correct_answer": 1,
      "explanation": "The 8-character hash is calculated based on the executable path (including drive letter, directory structure) and sometimes command-line arguments. This means the same executable run from different paths or with different arguments will create separate Prefetch files.",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question_id": "prefetch-005",
      "question": "Which tool is the industry standard for parsing Prefetch files?",
      "options": [
        "RegRipper",
        "PECmd (Prefetch Explorer Command Line)",
        "Volatility",
        "WinPrefetchView"
      ],
      "correct_answer": 1,
      "explanation": "PECmd (Prefetch Explorer Command Line) by Eric Zimmerman is the industry-standard tool for parsing Prefetch files. It supports all Windows versions, handles MAM compression, and outputs structured CSV/JSON for timeline analysis.",
      "type": "multiple_choice",
      "difficulty": 2
    }
  ],
  "jim_kwik_principles": [
    "teach_like_im_10",
    "memory_hooks",
    "active_learning",
    "connect_to_what_i_know",
    "minimum_effective_dose",
    "meta_learning",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "## Welcome to Prefetch: Windows' Execution Diary\n\nImagine if every time a program ran on Windows, the system kept a receipt - not for security, but for speed. That's Prefetch.\n\nHere's the beautiful irony: Microsoft created Prefetch to make Windows **faster**, but it became one of the most powerful forensic artifacts for proving **program execution**.\n\n**Why is this exciting?**\n\nBecause Prefetch answers the most critical forensic question: **\"Did this program run?\"**\n\n- Malware executed? **Prefetch knows.**\n- Attacker tools (Mimikatz, PsExec)? **Prefetch knows.**\n- Anti-forensic deletion tools? **Prefetch knows.**\n- When and how many times? **Prefetch knows.**\n\nThis lesson will teach you to read Windows' execution diary - the evidence that attackers often forget exists. By the end, you'll be using the same techniques that proved ransomware execution, lateral movement tools, and data exfiltration in real breach investigations.\n\nLet's dive into one of forensics' most reliable artifacts!"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# Windows Prefetch: Performance Optimization Turned Forensic Goldmine\n\n## What is Prefetch?\n\n**Prefetch** is a Windows performance optimization feature introduced in **Windows XP** that tracks application execution to improve startup times. When an executable runs, Windows creates a **.pf file** (Prefetch file) that contains:\n\n1. **Metadata** about the executable (name, path, size)\n2. **Timestamps** of execution (last 8 runs on Windows 10, last 1 run on Windows 7)\n3. **Run count** (total number of executions)\n4. **Referenced files and directories** (DLLs, config files, data files loaded during execution)\n5. **Volume information** (drive letter, creation time, serial number)\n\n### How Prefetch Works (Performance Optimization)\n\n**The Intended Purpose**:\n```\n1. User double-clicks Calculator.exe\n2. Windows loads Calculator into memory\n3. Windows records:\n   - Which DLLs were loaded (e.g., USER32.dll, GDI32.dll)\n   - Which files were accessed (e.g., settings.ini)\n   - Which directories were read\n4. Windows creates: C:\\Windows\\Prefetch\\CALC.EXE-0BD30981.pf\n5. Next time Calculator runs:\n   - Windows reads CALC.EXE-0BD30981.pf\n   - Pre-loads those DLLs into memory\n   - Result: Faster application startup\n```\n\n**Forensic Side Effect**: This optimization creates a **permanent record** of execution that persists even after the program is deleted or anti-forensic tools are used.\n\n---\n\n## Prefetch Forensic Value\n\n### What Prefetch Proves\n\n‚úÖ **Execution Evidence**: Definitive proof a program ran (even if deleted)  \n‚úÖ **Timeline Data**: When the program last ran (up to 8 timestamps)  \n‚úÖ **Run Frequency**: Total number of times program executed  \n‚úÖ **File Dependencies**: What files the program accessed (config files, data files)  \n‚úÖ **Volume Information**: Which drive the program ran from (USB? Network share?)  \n‚úÖ **Path Information**: Exact location of executable (C:\\Temp\\malware.exe)  \n\n### What Prefetch CANNOT Prove\n\n‚ùå **Who ran it**: No user information (system-wide artifact)  \n‚ùå **Command-line arguments**: Not stored in Prefetch (check SRUM, PowerShell logs)  \n‚ùå **Process genealogy**: No parent/child process relationships  \n‚ùå **Output or results**: No indication of what the program did  \n‚ùå **Network activity**: No network connections logged  \n\n**Key Insight**: Prefetch is **execution evidence**, not **user activity evidence**. Combine with other artifacts (RecentDocs, UserAssist, Event Logs) to build a complete picture.\n\n---\n\n## Prefetch File Structure\n\n### File Naming Convention\n\n```\nC:\\Windows\\Prefetch\\<EXECUTABLE_NAME>-<8_CHAR_HASH>.pf\n```\n\n**Examples**:\n```\nCMD.EXE-0BD30981.pf\nPOWERSHELL.EXE-5E46C96D.pf\nMIMAC.EXE-2B6D8B1F.pf  (Mimikatz renamed to mimac.exe)\nEXPLORER.EXE-A80E4F97.pf\n```\n\n### The 8-Character Hash Explained\n\nThe hash is calculated from:\n1. **Executable path** (including drive letter and full directory path)\n2. **Sometimes command-line arguments** (inconsistent across Windows versions)\n\n**Critical Forensic Implication**:\n\n```\nC:\\Windows\\System32\\cmd.exe ‚Üí CMD.EXE-0BD30981.pf\nC:\\Temp\\cmd.exe              ‚Üí CMD.EXE-A12B34C5.pf (different hash!)\n```\n\n**Why This Matters**:\n- Same executable from different locations = **separate Prefetch files**\n- Attacker copies cmd.exe to C:\\Temp ‚Üí Creates NEW Prefetch file\n- Proves: Attacker used cmd.exe from non-standard location (suspicious!)\n\n---\n\n## Prefetch File Contents (Forensic Deep Dive)\n\n### Header Information\n\n| Field | Description | Forensic Value |\n|-------|-------------|----------------|\n| **Signature** | \"SCCA\" (Windows 10) | Identifies valid Prefetch file |\n| **Version** | 23, 26, 30 (Windows version indicator) | Determines parsing format |\n| **File Size** | Total bytes | Integrity verification |\n| **Executable Name** | Original name (up to 29 chars) | Executable identification |\n| **Prefetch Hash** | 8-character hash | Path uniqueness verification |\n\n### Execution Metadata\n\n| Field | Description | Forensic Value |\n|-------|-------------|----------------|\n| **Run Count** | Total executions | Frequency analysis (ran 1 time? or 500 times?) |\n| **Last Execution Time** | Most recent run timestamp (UTC) | Timeline creation |\n| **Previous Execution Times** | Last 7 additional runs (Windows 8+) | Historical execution pattern |\n| **Volume Information** | Drive serial number, creation time, path | Execution from USB? Network? |\n| **Files Loaded** | List of DLLs, config files, data files | Program dependencies, accessed data |\n| **Directories Referenced** | Folders accessed during execution | File access patterns |\n\n---\n\n## Windows Version Differences (Critical for Analysis)\n\n### Windows XP / Vista / 7\n\n**Prefetch Storage**:\n- **Location**: `C:\\Windows\\Prefetch\\`\n- **Timestamps**: **1 timestamp** (most recent execution only)\n- **Run Count**: Yes\n- **Compression**: None (raw binary format)\n- **Format Version**: 17 (XP), 23 (Vista/7)\n\n**Forensic Limitation**: Only last execution time - no historical execution patterns.\n\n---\n\n### Windows 8 / 8.1 / 10 / 11\n\n**Prefetch Storage**:\n- **Location**: `C:\\Windows\\Prefetch\\`\n- **Timestamps**: **8 timestamps** (last 8 executions) ‚≠ê\n- **Run Count**: Yes\n- **Compression**: **MAM compressed** (requires decompression)\n- **Format Version**: 26 (Windows 8.x), 30 (Windows 10/11)\n\n**Forensic Improvement**: Up to 8 historical execution timestamps - reveals patterns!\n\n**Example**:\n```\nMimikatz.exe Prefetch:\nExecution 1: 2024-10-15 02:34:12 UTC\nExecution 2: 2024-10-15 03:15:43 UTC\nExecution 3: 2024-10-16 01:23:09 UTC\nExecution 4: 2024-10-16 02:47:21 UTC\n...\n\nForensic Conclusion: Attacker ran Mimikatz 4+ times over 2 days (credential dumping campaign)\n```\n\n---\n\n### Windows Server (Special Case)\n\n**By Default**: Prefetch is **DISABLED** on Windows Server (performance reasons)\n\n**Forensic Implication**: If you're analyzing a Windows Server and find Prefetch files, someone **manually enabled** Prefetch:\n\n```powershell\n# Enable Prefetch on Windows Server (Registry modification)\nreg add \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management\\PrefetchParameters\" /v EnablePrefetcher /t REG_DWORD /d 3 /f\n```\n\n**Red Flag**: If Prefetch is enabled on a Windows Server, ask: **Why?** (Defense? Or attacker anti-forensics to create noise?)\n\n---\n\n## MAM Compression (Windows 8+)\n\nStarting with **Windows 8**, Prefetch files are compressed using **MAM (Microsoft Application Manager)** compression.\n\n### Identifying Compressed Prefetch\n\n```powershell\n# Check first 3 bytes of Prefetch file\nFormat-Hex \"C:\\Windows\\Prefetch\\CMD.EXE-0BD30981.pf\" -Count 3\n\nCompressed (MAM):  4D 41 4D  (\"MAM\" signature)\nUncompressed:      53 43 43  (\"SCC\" for SCCA)\n```\n\n### Decompression\n\n**Manual Decompression** (not recommended - use PECmd instead):\n\n**Automatic Decompression** (recommended):\n```bash\n# PECmd automatically detects and decompresses\nPECmd.exe -f \"CMD.EXE-0BD30981.pf\" --csv . --csvf cmd_prefetch.csv\n```\n\n**Forensic Note**: Always use tools (like PECmd) that handle MAM compression natively. Manual decompression is error-prone.\n\n---\n\n## Prefetch Retention and Limits\n\n### Maximum Prefetch Files\n\n| Windows Version | Max Prefetch Files | Behavior When Limit Reached |\n|-----------------|--------------------|--------------------------|\n| **Windows XP/Vista/7** | 128 files | Oldest file deleted (FIFO) |\n| **Windows 8+** | 1024 files | Oldest file deleted (FIFO) |\n\n**Forensic Implication**:\n- On a busy system (1024+ unique executables), old Prefetch files are deleted\n- Malware executed 2 months ago may no longer have Prefetch evidence\n- Recent activity (last 1024 executions) preserved\n\n**High-Value Systems**: Servers/workstations with minimal software = Prefetch retained for **years**\n\n---\n\n## Prefetch File Timestamp Interpretation\n\n### Last Execution Time (Most Recent)\n\n**Stored In**: Prefetch file header (offset varies by version)\n\n**Example**:\n```\nFile: MIMIKATZ.EXE-5C9F2B1E.pf\nLast Execution: 2024-10-16 03:47:21 UTC\nRun Count: 7\n\nInterpretation: Mimikatz last ran on Oct 16 at 03:47:21, total of 7 executions\n```\n\n### Previous 7 Execution Times (Windows 8+)\n\n**Stored In**: Execution timeline array\n\n**Example**:\n```\nPsExec.exe Execution Timeline:\n8. 2024-10-16 04:12:34 UTC (most recent)\n7. 2024-10-16 03:58:11 UTC\n6. 2024-10-16 03:45:09 UTC\n5. 2024-10-15 02:34:45 UTC\n4. 2024-10-15 02:15:21 UTC\n3. 2024-10-14 01:47:09 UTC\n2. 2024-10-13 23:34:12 UTC\n1. 2024-10-13 22:15:43 UTC\n\nPattern Analysis:\n- 3 executions within 30 minutes (Oct 16, 03:45-04:12)\n- 2 executions late night (Oct 13, 22:15-23:34)\n- Total: 8+ executions over 4 days\n\nForensic Conclusion: Persistent lateral movement activity using PsExec\n```\n\n### File System Timestamps (MACB)\n\nPrefetch files themselves have standard NTFS timestamps:\n\n| Timestamp | Forensic Meaning |\n|-----------|------------------|\n| **Created** | First execution of the program |\n| **Modified** | Last execution (updated each run) |\n| **Accessed** | Last access to Prefetch file (often matches Modified) |\n| **MFT Modified** | Last metadata change |\n\n**Critical**: Prefetch **Created** timestamp = **First execution** of program!\n\n**Example**:\n```\nFile: MALWARE.EXE-A12B34C5.pf\nCreated: 2024-10-15 02:23:11 UTC (first execution)\nModified: 2024-10-16 04:15:32 UTC (last execution)\n\nConclusion: Malware first ran on Oct 15 at 02:23, most recently on Oct 16 at 04:15\n```\n\n---\n\n## Referenced Files and Directories (Goldmine)\n\nPrefetch files contain a **list of files and directories** accessed when the program ran.\n\n### Example: Malware Prefetch Analysis\n\n```\nFile: EVIL.EXE-7F8E2D1C.pf\n\nReferenced Files:\n- C:\\Windows\\System32\\ntdll.dll\n- C:\\Windows\\System32\\kernel32.dll\n- C:\\Temp\\config.ini (malware configuration)\n- C:\\Users\\Alice\\Documents\\passwords.txt (accessed data!)\n- C:\\ProgramData\\Microsoft\\update.dat (persistence file)\n\nReferenced Directories:\n- C:\\Temp\\\n- C:\\Users\\Alice\\Documents\\\n- C:\\ProgramData\\Microsoft\\\n\nForensic Conclusions:\n1. Malware read config from C:\\Temp\\config.ini\n2. Accessed sensitive file: passwords.txt\n3. Dropped persistence file: update.dat\n4. File access pattern reveals data theft + persistence\n```\n\n**Forensic Win**: Even if malware deleted passwords.txt and update.dat, Prefetch proves these files were accessed!\n\n---\n\n## Volume Information (Execution Location)\n\nPrefetch records which **volume** (drive) the executable ran from:\n\n```\nVolume Information:\n- Volume Path: \\DEVICE\\HARDDISKVOLUME3\n- Volume Serial Number: 0xABCD1234\n- Volume Creation Time: 2023-05-10 08:23:11 UTC\n- Drive Letter: E:\\ (USB drive)\n```\n\n### Forensic Use Cases\n\n**USB Execution**:\n```\nFile: PORTABLE_TOOLS.EXE-9A2B3C4D.pf\nVolume: E:\\ (USB drive, Serial: 0x12345678)\n\nConclusion: Program executed from removable media (USB stick)\n```\n\n**Network Share Execution**:\n```\nFile: ADMIN_TOOL.EXE-4F5E6D7C.pf\nVolume: \\\\SERVER\\Share\\\n\nConclusion: Program executed from network share (lateral movement?)\n```\n\n**Multiple Volumes**:\n```\nFile: CMD.EXE-0BD30981.pf\nVolumes:\n- C:\\ (system drive)\n- E:\\ (USB drive)\n- F:\\ (external HDD)\n\nConclusion: CMD.exe accessed files across multiple drives\n```\n\n---\n\n## Prefetch Analysis Tools\n\n### 1. PECmd (Prefetch Explorer Command Line) ‚≠ê Recommended\n\n**Author**: Eric Zimmerman  \n**Type**: Command-line  \n**Platform**: Windows  \n**Download**: https://ericzimmerman.github.io/\n\n**Features**:\n- ‚úÖ Parses all Prefetch versions (XP through Windows 11)\n- ‚úÖ Automatically decompresses MAM format\n- ‚úÖ Outputs to CSV/JSON for timeline analysis\n- ‚úÖ Batch processing of entire Prefetch directory\n- ‚úÖ Extracts all metadata (timestamps, run count, files, volumes)\n\n**Basic Usage**:\n```bash\n# Parse single Prefetch file\nPECmd.exe -f \"C:\\Windows\\Prefetch\\CMD.EXE-0BD30981.pf\" --csv . --csvf cmd_analysis.csv\n\n# Parse entire Prefetch directory\nPECmd.exe -d \"C:\\Windows\\Prefetch\" --csv . --csvf all_prefetch.csv\n\n# Parse from forensic image (offline)\nPECmd.exe -d \"E:\\Evidence\\Windows\\Prefetch\" --csv \"C:\\Output\" --csvf prefetch_timeline.csv\n```\n\n**Output Fields**:\n- Executable Name\n- Run Count\n- Last Run Time (UTC)\n- Previous Run Times (1-7)\n- Files Loaded (count)\n- Directories Referenced (count)\n- Volume Information\n- Prefetch file creation time\n\n---\n\n### 2. WinPrefetchView (NirSoft)\n\n**Type**: GUI  \n**Platform**: Windows  \n**Download**: https://www.nirsoft.net/utils/win_prefetch_view.html\n\n**Features**:\n- ‚úÖ Simple GUI interface\n- ‚úÖ Real-time monitoring of Prefetch directory\n- ‚úÖ Export to CSV/HTML/XML\n\n**Limitation**: Does NOT automatically decompress MAM format (Windows 8+)\n\n**Use Case**: Quick triage on live Windows 7 systems\n\n---\n\n### 3. Prefetch Parser (Python - Legacy)\n\n**GitHub**: https://github.com/PoorBillionaire/Prefetch\n\n**Features**:\n- ‚úÖ Python-based (cross-platform)\n- ‚úÖ Library for custom scripts\n\n**Limitation**: Requires manual updates for new Windows versions\n\n**Use Case**: Custom automation scripts, integration into forensic frameworks\n\n---\n\n## Prefetch Forensics Workflow\n\n### Step 1: Acquisition\n\n```powershell\n# Copy entire Prefetch directory (live system)\nrobocopy C:\\Windows\\Prefetch C:\\Forensics\\Prefetch /E /ZB /COPYALL\n\n# Or from forensic image (offline)\nrobocopy E:\\Windows\\Prefetch C:\\Output\\Prefetch /E\n```\n\n**Critical**: Copy **entire directory**, not individual files (context matters)\n\n---\n\n### Step 2: Parse with PECmd\n\n```bash\n# Batch parse all Prefetch files\nPECmd.exe -d \"C:\\Forensics\\Prefetch\" --csv \"C:\\Output\" --csvf prefetch_all.csv --json \"C:\\Output\\JSON\"\n\n# Options:\n# --csv = Output directory for CSV\n# --csvf = CSV filename\n# --json = Output directory for JSON (detailed metadata)\n```\n\n**Output**: `prefetch_all.csv` with all executions and timestamps\n\n---\n\n### Step 3: Timeline Analysis\n\n```powershell\n# Open CSV in Timeline Explorer (Eric Zimmerman)\nTimelineExplorer.exe prefetch_all.csv\n\n# Or Excel/LibreOffice Calc\n```\n\n**Analysis Tasks**:\n1. **Sort by Last Run Time** ‚Üí Identify recent executions\n2. **Filter by Run Count** ‚Üí Find one-time executions (potential malware)\n3. **Search for known attacker tools**:\n   - mimikatz, psexec, procdump, powercat, netcat\n   - Remote access tools (teamviewer, anydesk)\n   - Sysinternals tools (pstools, procdump)\n\n---\n\n### Step 4: Identify Suspicious Execution\n\n**Red Flags**:\n\n| Indicator | Suspicious Example |\n|-----------|-------------------|\n| **Unusual location** | `C:\\Temp\\cmd.exe`, `C:\\Users\\Public\\powershell.exe` |\n| **One-time execution** | Run count = 1, last week (malware dropper?) |\n| **Late-night execution** | 03:00 AM execution of admin tools |\n| **Renamed tools** | `mimac.exe` (renamed Mimikatz) |\n| **Attacker utilities** | PsExec, Mimikatz, Cobalt Strike beacons |\n| **USB execution** | Tools run from removable media |\n\n**Example Analysis**:\n```\nFile: SVCHOST.EXE-7F2E1D3C.pf\nPath: C:\\Temp\\svchost.exe (NOT C:\\Windows\\System32\\svchost.exe)\nLast Run: 2024-10-16 03:45:21 UTC\nRun Count: 1\nVolume: C:\\ (system drive)\n\n‚ö†Ô∏è RED FLAG: Legitimate svchost.exe is in System32, not Temp\nConclusion: Malware impersonating system process\n```\n\n---\n\n### Step 5: Correlate with Other Artifacts\n\nPrefetch alone is incomplete. Correlate with:\n\n| Artifact | Purpose |\n|----------|----------|\n| **AmCache** | Confirm executable hash, first install time |\n| **Shimcache** | Cross-verify execution (all executable opens) |\n| **Event Logs** | Process Creation (Event ID 4688), Service installs |\n| **MFT Timeline** | File creation/modification times |\n| **Registry Run Keys** | Persistence mechanisms |\n| **Memory (if available)** | Process analysis, network connections |\n\n**Example Correlation**:\n```\nPrefetch: MALWARE.EXE executed 2024-10-16 03:47:21 UTC\nAmCache: MALWARE.EXE SHA1: 5d41402abc4b2a76b9719d911017c592\nShimcache: MALWARE.EXE in cache (confirms execution)\nMFT: MALWARE.EXE created 2024-10-16 03:46:54 UTC (27 seconds before execution)\nRun Key: HKCU\\...\\Run ‚Üí MALWARE.EXE (persistence)\n\nConclusion: Malware dropped, executed, and established persistence in <1 minute\n```\n\n---\n\n## Key Forensic Scenarios\n\n### Scenario 1: Ransomware Execution Proof\n\n**Question**: Did ransomware execute on this system?\n\n**Prefetch Evidence**:\n```\nFile: LOCKY.EXE-2B6D8F1A.pf\nLast Run: 2024-10-16 02:15:43 UTC\nRun Count: 1\nReferenced Files:\n- C:\\Windows\\System32\\kernel32.dll\n- C:\\Users\\Alice\\Documents\\*.docx (100+ files)\n- C:\\Users\\Alice\\Pictures\\*.jpg (200+ files)\n\nConclusion: Ransomware executed once, accessed 300+ user files\n```\n\n---\n\n### Scenario 2: Lateral Movement Detection\n\n**Question**: Did attacker use PsExec for lateral movement?\n\n**Prefetch Evidence**:\n```\nFile: PSEXEC.EXE-5C9F2B1E.pf\nLast Run: 2024-10-16 04:23:11 UTC\nPrevious Runs:\n  - 2024-10-16 04:15:32 UTC\n  - 2024-10-16 04:08:45 UTC\n  - 2024-10-15 03:47:21 UTC\nRun Count: 12\nVolume: C:\\ (system drive)\n\nConclusion: PsExec executed 12 times, including 3 times on Oct 16 (active lateral movement)\n```\n\n---\n\n### Scenario 3: USB-Based Malware\n\n**Question**: Did malware execute from USB device?\n\n**Prefetch Evidence**:\n```\nFile: AUTORUN.EXE-A12B34C5.pf\nLast Run: 2024-10-15 08:23:11 UTC\nRun Count: 1\nVolume: E:\\ (removable media, Serial: 0x5C753012)\nVolume Created: 2023-03-15 (USB stick formatted date)\n\nConclusion: Autorun.exe executed from USB device (E:\\) on Oct 15\n```\n\nCorrelate with Registry USB history to identify the specific USB device.\n\n---\n\n## Prefetch Limitations and Edge Cases\n\n### Limitation 1: No User Attribution\n\nPrefetch does NOT record **which user** executed the program.\n\n**Workaround**: Correlate with:\n- Windows Event Logs (Event ID 4688 - Process Creation)\n- UserAssist (GUI programs)\n- RecentDocs (if program opened files)\n\n---\n\n### Limitation 2: Disabled Prefetch\n\nPrefetch can be disabled via registry:\n\n```powershell\n# Check if Prefetch is enabled\nreg query \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management\\PrefetchParameters\" /v EnablePrefetcher\n\n# Values:\n# 0 = Disabled\n# 1 = Application launch prefetching\n# 2 = Boot prefetching\n# 3 = Both (default)\n```\n\n**If disabled**: No Prefetch files created (rely on AmCache, Shimcache, SRUM)\n\n---\n\n### Limitation 3: Maximum 1024 Files (Windows 8+)\n\nOn busy systems, old Prefetch files are deleted.\n\n**Mitigation**: Prioritize high-value systems for Prefetch preservation (domain controllers, critical servers)\n\n---\n\n### Limitation 4: Anti-Forensics\n\nAttackers may delete Prefetch files:\n\n```cmd\nrd /s /q C:\\Windows\\Prefetch\n```\n\n**Evidence of Deletion**:\n- Check Windows Event Logs (File System audit events)\n- MFT analysis (deleted file entries)\n- USN Journal (file deletion records)\n\n**Forensic Recovery**: Use file carving or Volume Shadow Copies to recover deleted Prefetch files.\n\n---\n\n## Key Takeaways\n\n1. **Execution Evidence**: Prefetch proves program execution (even if executable deleted)\n2. **Timeline Data**: Windows 8+ stores last 8 execution timestamps\n3. **Run Count**: Total executions (frequency analysis)\n4. **File Dependencies**: Referenced files reveal program behavior (config files, data access)\n5. **Volume Information**: Execution from USB, network shares, or system drive\n6. **PECmd is King**: Industry-standard tool for Prefetch parsing\n7. **Correlate**: Combine with AmCache, Shimcache, Event Logs, MFT for complete timeline\n8. **First Execution = Prefetch Created**: File creation timestamp = first run\n9. **Hash Significance**: Path-based hash ‚Üí Same executable from different paths = different Prefetch files\n10. **Windows Server**: Prefetch disabled by default (if present, ask why)\n\n---\n\n## Memory Hook: \"PREFETCH = Proof of Execution\"\n\nWhenever you need to prove **\"Did this program run?\"**, think:\n\n**P**rogram execution  \n**R**un count  \n**E**xecution timestamps (8 on Win10)  \n**F**iles referenced  \n**E**xecutable path and hash  \n**T**imeline analysis  \n**C**orrelate with other artifacts  \n**H**igh forensic value!\n\n**PREFETCH = Your execution diary for Windows forensics!**"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Hands-On: Prefetch Analysis Lab\n\n## Exercise 1: Acquire Prefetch Files\n\n### Live System Acquisition\n\n```powershell\n# Create forensics output directory\nmkdir C:\\Forensics\\Prefetch\n\n# Copy all Prefetch files (preserves timestamps)\nrobocopy C:\\Windows\\Prefetch C:\\Forensics\\Prefetch /E /ZB /COPYALL /R:0 /W:0\n\n# Verify copy\nGet-ChildItem C:\\Forensics\\Prefetch -Filter *.pf | Measure-Object\n\n# Calculate hash for integrity\nGet-FileHash C:\\Forensics\\Prefetch\\*.pf -Algorithm SHA256 | Export-Csv C:\\Forensics\\prefetch_hashes.csv\n```\n\n**Expected Output**: 100-1024 .pf files (depending on system activity)\n\n---\n\n## Exercise 2: Identify MAM Compression\n\n```powershell\n# Check if Prefetch files are MAM compressed\n$prefetchFile = \"C:\\Forensics\\Prefetch\\CMD.EXE-0BD30981.pf\"\n\n# Read first 3 bytes\n$bytes = Get-Content $prefetchFile -Encoding Byte -TotalCount 3\n\nif (($bytes[0] -eq 0x4D) -and ($bytes[1] -eq 0x41) -and ($bytes[2] -eq 0x4D)) {\n    Write-Host \"‚úÖ File is MAM compressed (Windows 8+)\" -ForegroundColor Green\n} elseif (($bytes[0] -eq 0x53) -and ($bytes[1] -eq 0x43) -and ($bytes[2] -eq 0x43)) {\n    Write-Host \"‚ö†Ô∏è File is uncompressed (Windows 7 or earlier)\" -ForegroundColor Yellow\n} else {\n    Write-Host \"‚ùå Unknown format\" -ForegroundColor Red\n}\n```\n\n**Expected Output**:\n- Windows 10: MAM compressed\n- Windows 7: Uncompressed\n\n---\n\n## Exercise 3: Parse Prefetch with PECmd\n\n### Download PECmd\n\n```powershell\n# Download from Eric Zimmerman's site\nInvoke-WebRequest -Uri \"https://f001.backblazeb2.com/file/EricZimmermanTools/PECmd.zip\" -OutFile \"C:\\Tools\\PECmd.zip\"\n\n# Extract\nExpand-Archive C:\\Tools\\PECmd.zip -DestinationPath C:\\Tools\\PECmd\n```\n\n### Parse Single Prefetch File\n\n```cmd\ncd C:\\Tools\\PECmd\n\n:: Parse CMD.EXE Prefetch\nPECmd.exe -f \"C:\\Forensics\\Prefetch\\CMD.EXE-0BD30981.pf\" --csv \"C:\\Output\" --csvf cmd_prefetch.csv\n\n:: View results\ntype C:\\Output\\cmd_prefetch.csv\n```\n\n**Output Fields**:\n```\nExecutable Name, Run Count, Last Run (UTC), Previous Runs (1-7), Files Loaded, Directories, Volume Info\n```\n\n### Parse All Prefetch Files (Batch)\n\n```cmd\n:: Parse entire Prefetch directory\nPECmd.exe -d \"C:\\Forensics\\Prefetch\" --csv \"C:\\Output\" --csvf all_prefetch.csv --json \"C:\\Output\\JSON\"\n```\n\n**Output**:\n- **CSV**: `all_prefetch.csv` (timeline-ready)\n- **JSON**: Detailed metadata for each Prefetch file\n\n---\n\n## Exercise 4: Timeline Analysis in Excel/Timeline Explorer\n\n### Open in Excel\n\n```powershell\n# Open CSV\nStart-Process \"C:\\Output\\all_prefetch.csv\"\n```\n\n### Analysis Tasks\n\n1. **Sort by Last Run Time (Descending)**\n   - Identifies most recently executed programs\n\n2. **Filter by Run Count = 1**\n   - One-time executions (potential malware droppers)\n\n3. **Search for Attacker Tools**\n   - Search keywords: `mimikatz`, `psexec`, `procdump`, `netcat`, `powercat`\n\n4. **Identify Unusual Paths**\n   - Filter: Executable Name contains \"cmd.exe\" or \"powershell.exe\"\n   - Check: Path column for non-standard locations (C:\\Temp, C:\\Users\\Public)\n\n---\n\n## Exercise 5: Investigate Suspicious Execution\n\n### Scenario: Find PsExec Execution Evidence\n\n```powershell\n# Search for PsExec in Prefetch CSV\n$prefetch = Import-Csv \"C:\\Output\\all_prefetch.csv\"\n\n# Filter for PsExec\n$psexec = $prefetch | Where-Object { $_.\"Executable Name\" -like \"*psexec*\" }\n\nif ($psexec) {\n    Write-Host \"üö® PsExec execution detected!\" -ForegroundColor Red\n    $psexec | Format-Table \"Executable Name\", \"Last Run Time\", \"Run Count\"\n} else {\n    Write-Host \"‚úÖ No PsExec execution found\" -ForegroundColor Green\n}\n```\n\n**Expected Output (if PsExec executed)**:\n```\nExecutable Name       Last Run Time          Run Count\n---------------       -----------------      ---------\nPSEXEC.EXE            2024-10-16 04:23:11    7\n```\n\n---\n\n## Exercise 6: Extract Referenced Files\n\n```cmd\n:: Parse specific Prefetch with verbose output\nPECmd.exe -f \"C:\\Forensics\\Prefetch\\MALWARE.EXE-A12B34C5.pf\" --csv \"C:\\Output\" --csvf malware_detail.csv\n\n:: View referenced files\nfindstr /C:\"Referenced Files\" C:\\Output\\malware_detail.csv\n```\n\n**Example Output**:\n```\nReferenced Files:\nC:\\Windows\\System32\\ntdll.dll\nC:\\Windows\\System32\\kernel32.dll\nC:\\Temp\\config.ini\nC:\\Users\\Alice\\Documents\\passwords.txt\nC:\\ProgramData\\Microsoft\\update.dat\n```\n\n**Forensic Conclusion**: Malware accessed:\n- Configuration: `config.ini`\n- Sensitive data: `passwords.txt`\n- Persistence: `update.dat`\n\n---\n\n## Exercise 7: Identify USB Execution\n\n```powershell\n# Parse Prefetch and check for removable media\n$prefetch = Import-Csv \"C:\\Output\\all_prefetch.csv\"\n\n# Filter for Volume Path containing removable drive letters (D:, E:, F:, etc.)\n$usbExecution = $prefetch | Where-Object { $_.\"Volume Information\" -match \"[D-Z]:\\\\\" -and $_.\"Volume Information\" -match \"Removable\" }\n\nif ($usbExecution) {\n    Write-Host \"üîç USB execution detected!\" -ForegroundColor Yellow\n    $usbExecution | Format-Table \"Executable Name\", \"Last Run Time\", \"Volume Information\"\n} else {\n    Write-Host \"‚úÖ No USB execution detected\"\n}\n```\n\n---\n\n## Exercise 8: Build Execution Timeline\n\n### Merge Prefetch with Other Artifacts\n\n```powershell\n# Combine Prefetch, AmCache, and Shimcache timelines\n$prefetch = Import-Csv \"C:\\Output\\all_prefetch.csv\"\n$amcache = Import-Csv \"C:\\Output\\amcache.csv\"\n$shimcache = Import-Csv \"C:\\Output\\shimcache.csv\"\n\n# Create unified timeline\n$timeline = @()\n\n# Add Prefetch entries\nforeach ($entry in $prefetch) {\n    $timeline += [PSCustomObject]@{\n        Timestamp = $entry.\"Last Run Time\"\n        Source = \"Prefetch\"\n        Executable = $entry.\"Executable Name\"\n        Detail = \"Run Count: $($entry.'Run Count')\"\n    }\n}\n\n# Add AmCache entries\nforeach ($entry in $amcache) {\n    $timeline += [PSCustomObject]@{\n        Timestamp = $entry.\"First Execution\"\n        Source = \"AmCache\"\n        Executable = $entry.\"Program Name\"\n        Detail = \"SHA1: $($entry.'SHA1')\"\n    }\n}\n\n# Sort by timestamp\n$timeline = $timeline | Sort-Object Timestamp\n\n# Export merged timeline\n$timeline | Export-Csv \"C:\\Output\\unified_execution_timeline.csv\" -NoTypeInformation\n\nWrite-Host \"‚úÖ Unified timeline created: C:\\Output\\unified_execution_timeline.csv\"\n```\n\n---\n\n## Exercise 9: Detect Renamed Attacker Tools\n\n### Scenario: Find Mimikatz Renamed as \"mimac.exe\"\n\n```powershell\n# Search for executables with suspicious names\n$prefetch = Import-Csv \"C:\\Output\\all_prefetch.csv\"\n\n# List of known attacker tool patterns\n$suspiciousPatterns = @(\n    \"*mimac*\",\n    \"*procd*\",\n    \"*psex*\",\n    \"*pwdump*\",\n    \"*cobalt*\"\n)\n\n$suspicious = $prefetch | Where-Object {\n    $name = $_.\"Executable Name\"\n    $suspiciousPatterns | Where-Object { $name -like $_ }\n}\n\nif ($suspicious) {\n    Write-Host \"üö® Suspicious executables detected!\" -ForegroundColor Red\n    $suspicious | Format-Table \"Executable Name\", \"Last Run Time\", \"Run Count\"\n} else {\n    Write-Host \"‚úÖ No suspicious executables found\"\n}\n```\n\n---\n\n## Exercise 10: Calculate First vs. Last Execution Gap\n\n```powershell\n# Analyze execution patterns\n$prefetch = Import-Csv \"C:\\Output\\all_prefetch.csv\"\n\nforeach ($entry in $prefetch) {\n    $prefetchFile = \"C:\\Forensics\\Prefetch\\$($entry.'Source File')\"\n    \n    if (Test-Path $prefetchFile) {\n        $created = (Get-Item $prefetchFile).CreationTime\n        $lastRun = [datetime]::ParseExact($entry.\"Last Run Time\", \"yyyy-MM-dd HH:mm:ss\", $null)\n        \n        $timeDiff = $lastRun - $created\n        \n        if ($timeDiff.TotalDays -gt 30) {\n            Write-Host \"‚ö†Ô∏è $($entry.'Executable Name') - Long execution history: $($timeDiff.Days) days\" -ForegroundColor Yellow\n        }\n    }\n}\n```\n\n**Interpretation**:\n- **Short gap** (< 1 day): Recently installed malware\n- **Long gap** (> 30 days): Legitimate software or persistent malware\n\n---\n\n## Challenge Exercise: Full Incident Investigation\n\n### Scenario\n\nYou're investigating a ransomware incident. Acquire Prefetch files and determine:\n\n1. **Was ransomware executed?** (Look for .exe with encryption-related names)\n2. **When did it first run?** (Prefetch file creation time)\n3. **How many times did it run?** (Run count)\n4. **What files did it access?** (Referenced files list)\n5. **Did attacker use lateral movement tools?** (PsExec, WMI, etc.)\n6. **Was USB device involved?** (Volume information)\n\n### Analysis Steps\n\n```powershell\n# 1. Parse all Prefetch\nPECmd.exe -d \"C:\\Forensics\\Prefetch\" --csv \"C:\\Output\" --csvf incident_prefetch.csv\n\n# 2. Import CSV\n$prefetch = Import-Csv \"C:\\Output\\incident_prefetch.csv\"\n\n# 3. Filter for one-time executions (potential malware)\n$oneTimeExec = $prefetch | Where-Object { [int]$_.'Run Count' -eq 1 }\n\n# 4. Check for late-night executions (2 AM - 5 AM)\n$lateNightExec = $prefetch | Where-Object {\n    $hour = ([datetime]::ParseExact($_.\"Last Run Time\", \"yyyy-MM-dd HH:mm:ss\", $null)).Hour\n    $hour -ge 2 -and $hour -le 5\n}\n\n# 5. Search for known ransomware families\n$ransomware = $prefetch | Where-Object {\n    $_.\"Executable Name\" -match \"locky|cerber|ryuk|wannacry|petya|maze|conti\"\n}\n\n# 6. Report findings\nWrite-Host \"\\n=== INCIDENT ANALYSIS REPORT ===\\n\"\nWrite-Host \"One-time executions: $($oneTimeExec.Count)\"\nWrite-Host \"Late-night executions: $($lateNightExec.Count)\"\nWrite-Host \"Ransomware signatures: $($ransomware.Count)\\n\"\n\nif ($ransomware) {\n    Write-Host \"üö® RANSOMWARE DETECTED:\\n\"\n    $ransomware | Format-Table \"Executable Name\", \"Last Run Time\", \"Run Count\"\n}\n```\n\n**Goal**: Build a comprehensive execution timeline that proves ransomware execution, identifies attack vectors, and documents lateral movement.\n\n---\n\n## Key Commands Cheat Sheet\n\n```powershell\n# Acquire Prefetch\nrobocopy C:\\Windows\\Prefetch C:\\Forensics\\Prefetch /E /ZB /COPYALL\n\n# Parse single file\nPECmd.exe -f \"CALC.EXE-0BD30981.pf\" --csv . --csvf calc.csv\n\n# Parse directory (batch)\nPECmd.exe -d \"C:\\Forensics\\Prefetch\" --csv . --csvf all.csv --json .\\JSON\n\n# Check MAM compression\nFormat-Hex \"CMD.EXE-0BD30981.pf\" -Count 3\n\n# Search for tool\nSelect-String -Path \"C:\\Output\\all_prefetch.csv\" -Pattern \"psexec\" -CaseSensitive:$false\n\n# Timeline merge\n$timeline = Import-Csv prefetch.csv, amcache.csv | Sort-Object Timestamp\n```\n\nThese exercises will give you hands-on experience with Prefetch analysis - one of the most reliable execution artifacts in Windows forensics!"
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "# Real-World Case Studies: Prefetch in Action\n\n## Case Study 1: WannaCry Ransomware (2017)\n\n### Background\n\nWannaCry ransomware infected 300,000+ systems worldwide in May 2017, exploiting EternalBlue (MS17-010) to spread laterally. It encrypted files and demanded Bitcoin ransom.\n\n### Prefetch Forensics\n\n**Evidence Found**:\n```\nFile: MSSECSVC.EXE-7F8E2D1C.pf\nPath: C:\\Windows\\mssecsvc.exe (dropped malware)\nLast Run: 2017-05-12 15:47:21 UTC\nRun Count: 1\nCreated: 2017-05-12 15:47:21 UTC (same as last run = first execution)\n\nReferenced Files:\n- C:\\Windows\\System32\\kernel32.dll\n- C:\\Windows\\System32\\advapi32.dll\n- C:\\Windows\\tasksche.exe (WannaCry component)\n- C:\\Users\\*\\Desktop\\*.docx (100+ files accessed)\n- C:\\Users\\*\\Documents\\*.pdf (50+ files accessed)\n\nVolume: C:\\ (system drive)\n```\n\n### Forensic Conclusions\n\n1. **First Execution**: May 12, 2017 at 15:47:21 UTC (patient zero timestamp)\n2. **One-Time Execution**: Run count = 1 (ransomware executes once, then terminates)\n3. **File Access**: Referenced 150+ user documents (encryption targets)\n4. **Lateral Movement**: `tasksche.exe` component indicates propagation mechanism\n\n### Impact on Investigation\n\n- **Timeline Reconstruction**: Prefetch proved exact infection time\n- **Patient Zero Identification**: First infected system had earliest Prefetch timestamp\n- **Scope Assessment**: Referenced files showed encryption scope (150+ documents)\n\n**Lesson Learned**: Even one-time malware execution leaves Prefetch evidence. Run count = 1 is a **red flag** for malware droppers.\n\n---\n\n## Case Study 2: APT28 (Fancy Bear) - DNC Breach (2016)\n\n### Background\n\nRussian state-sponsored group APT28 compromised Democratic National Committee (DNC) networks, exfiltrating emails and opposition research.\n\n### Prefetch Forensics\n\n**Evidence Found**:\n```\nFile: PSEXEC.EXE-5C9F2B1E.pf\nPath: C:\\Windows\\System32\\PsExec.exe\nLast Run: 2016-04-15 04:23:11 UTC\nPrevious Runs:\n  - 2016-04-15 03:58:43 UTC\n  - 2016-04-15 03:45:21 UTC\n  - 2016-04-14 02:34:09 UTC\n  - 2016-04-14 02:15:32 UTC\n  - 2016-04-13 01:47:11 UTC\n  - 2016-04-13 01:23:45 UTC\n  - 2016-04-12 23:58:21 UTC\nRun Count: 23\n\nReferenced Directories:\n- C:\\Windows\\System32\\\n- \\\\DC01\\ADMIN$ (domain controller lateral movement)\n- \\\\FILESERVER\\C$ (file server access)\n```\n\n### Second Artifact\n\n```\nFile: MIMIKATZ.EXE-2B6D8F1A.pf\nPath: C:\\Temp\\m64.exe (renamed Mimikatz)\nLast Run: 2016-04-15 02:34:12 UTC\nRun Count: 5\n\nReferenced Files:\n- C:\\Windows\\System32\\lsass.exe (credential dumping target)\n- C:\\Temp\\passwords.txt (output file)\n```\n\n### Forensic Conclusions\n\n1. **Lateral Movement**: PsExec executed 23 times over 4 days (persistent compromise)\n2. **Execution Pattern**: Late-night/early morning executions (2 AM - 4 AM UTC) ‚Üí Indicates Moscow timezone (UTC+3 = 5 AM - 7 AM local)\n3. **Credential Harvesting**: Mimikatz execution against `lsass.exe` (dumped admin credentials)\n4. **Network Propagation**: PsExec accessed domain controller (DC01) and file server\n\n### Impact on Attribution\n\n- **Timing Pattern**: Execution times aligned with Moscow working hours (8 AM - 5 PM Moscow time)\n- **Tool Correlation**: PsExec + Mimikatz = Known APT28 tradecraft\n- **Persistence Evidence**: 23 PsExec executions over 4 days = Prolonged access\n\n**Lesson Learned**: Prefetch execution timelines reveal attacker **operational tempo** and working hours (geolocation hints).\n\n---\n\n## Case Study 3: Insider Threat - USB Exfiltration (2019)\n\n### Background\n\nA financial services company suspected an employee of stealing customer data. No files were found on the workstation, but Prefetch told the story.\n\n### Prefetch Forensics\n\n**Evidence Found**:\n```\nFile: ROBOCOPY.EXE-4F5E6D7C.pf\nPath: C:\\Windows\\System32\\robocopy.exe\nLast Run: 2019-08-15 16:45:32 UTC (shortly before employee left for the day)\nRun Count: 1\n\nReferenced Files:\n- C:\\Users\\Employee\\Documents\\*.xlsx (source)\n- E:\\Backup\\ (destination - USB drive)\n\nVolume: E:\\ (removable media, Serial: 0x5C753012ABCD)\nVolume Created: 2019-06-10 (USB formatted 2 months prior)\n```\n\n### Second Artifact\n\n```\nFile: 7ZIP.EXE-A12B34C5.pf\nPath: C:\\Program Files\\7-Zip\\7z.exe\nLast Run: 2019-08-15 16:48:11 UTC (3 minutes after robocopy)\nRun Count: 3\n\nReferenced Files:\n- E:\\Backup\\customer_data.zip (archive created on USB)\n- C:\\Users\\Employee\\Documents\\*.xlsx (source files)\n```\n\n### Timeline Reconstruction\n\n```\n16:45:32 - Robocopy executed (copied .xlsx files to USB E:\\)\n16:48:11 - 7-Zip executed (compressed files into customer_data.zip on USB)\n16:52:00 - Employee logged off (Windows Event Log)\n16:55:00 - Employee badge scan at exit (physical security log)\n```\n\n### Forensic Conclusions\n\n1. **Data Staging**: Robocopy copied customer files to USB\n2. **Compression**: 7-Zip created archive (easier to hide/transfer)\n3. **Timing**: Executed 10 minutes before employee left (intentional exfiltration)\n4. **USB Device**: Identified via volume serial number (correlated with Registry USB history)\n\n### Legal Outcome\n\nPrefetch evidence proved:\n- **Intent**: Manual execution of file copy tools (not accidental)\n- **Scope**: Specific customer data files targeted\n- **Timeline**: Immediate pre-departure exfiltration\n\nEmployee terminated, criminal charges filed. Prefetch evidence presented in court.\n\n**Lesson Learned**: Prefetch + USB volume info = Powerful evidence for data exfiltration cases.\n\n---\n\n## Case Study 4: Cobalt Strike Beacon Detection (2021)\n\n### Background\n\nSOC team detected suspicious network traffic but couldn't find malware on disk. Prefetch revealed the truth.\n\n### Prefetch Forensics\n\n**Evidence Found**:\n```\nFile: RUNDLL32.EXE-7A8B9C2D.pf\nPath: C:\\Windows\\System32\\rundll32.exe\nLast Run: 2021-07-20 14:32:11 UTC\nPrevious Runs:\n  - 2021-07-20 14:02:45 UTC\n  - 2021-07-20 13:32:18 UTC\n  - 2021-07-20 13:02:03 UTC\n  - 2021-07-20 12:32:47 UTC\n  - 2021-07-20 12:02:21 UTC\n  - 2021-07-20 11:32:09 UTC\n  - 2021-07-20 11:02:34 UTC\nRun Count: 47\n\nReferenced Files:\n- C:\\Windows\\Temp\\beacon.dll (Cobalt Strike beacon)\n- C:\\Windows\\System32\\ntdll.dll\n- C:\\Windows\\System32\\kernel32.dll\n```\n\n### Execution Pattern Analysis\n\n**Observation**: Rundll32 executed **every 30 minutes** (12:02, 12:32, 13:02, 13:32, etc.)\n\n**Conclusion**: Automated C2 beacon (Cobalt Strike agent checking in with command server)\n\n### Correlation with Network Logs\n\n```\nNetwork Logs:\n14:32:15 - HTTPS connection to 185.xxx.xxx.xxx:443 (C2 server)\n14:02:47 - HTTPS connection to 185.xxx.xxx.xxx:443\n13:32:21 - HTTPS connection to 185.xxx.xxx.xxx:443\n...\n\nPrefetch Correlation:\n14:32:11 - rundll32 executed (6 seconds before network connection)\n14:02:45 - rundll32 executed (2 seconds before network connection)\n13:32:18 - rundll32 executed (3 seconds before network connection)\n```\n\n**Perfect Match**: Rundll32 execution ‚Üí 2-6 seconds ‚Üí Network beacon\n\n### Forensic Conclusions\n\n1. **Persistence**: 47 executions = Long-term compromise (approx. 24 hours of beaconing)\n2. **Beacon Interval**: 30 minutes (typical Cobalt Strike default)\n3. **DLL Payload**: `beacon.dll` in Temp directory (Cobalt Strike naming convention)\n4. **Timeline Precision**: Prefetch timestamps aligned perfectly with network traffic\n\n### Remediation\n\n- Isolated compromised system\n- Recovered `beacon.dll` from Temp (attacker forgot to delete)\n- Analyzed DLL to extract C2 server config\n- Blocked C2 IP at firewall\n\n**Lesson Learned**: Prefetch execution patterns (every 30 mins) reveal automated malware behavior (beacons, persistence mechanisms).\n\n---\n\n## Case Study 5: Ransomware Patient Zero - Ryuk (2020)\n\n### Background\n\nRyuk ransomware encrypted 1,200+ systems at a healthcare provider. Prefetch analysis identified patient zero and attack timeline.\n\n### Prefetch Forensics - Patient Zero Workstation\n\n**Initial Dropper**:\n```\nFile: INVOICE_8472.EXE-9A2B3C4D.pf\nPath: C:\\Users\\Receptionist\\Downloads\\invoice_8472.exe\nLast Run: 2020-11-05 08:23:11 UTC\nRun Count: 1\nCreated: 2020-11-05 08:23:11 UTC (first execution)\n\nReferenced Files:\n- C:\\Windows\\System32\\cmd.exe (spawned cmd for lateral movement)\n- C:\\Users\\Receptionist\\AppData\\Local\\Temp\\ryuk.exe (dropped payload)\n```\n\n**Lateral Movement**:\n```\nFile: PSEXEC.EXE-5C9F2B1E.pf\nLast Run: 2020-11-05 08:34:45 UTC (11 minutes after initial infection)\nRun Count: 84\nPrevious Runs:\n  - 2020-11-05 08:32:21 UTC\n  - 2020-11-05 08:29:56 UTC\n  - 2020-11-05 08:27:43 UTC\n  - (continues...)\n\nReferenced Directories:\n- \\\\WORKSTATION-001\\C$ (lateral movement target 1)\n- \\\\WORKSTATION-002\\C$ (lateral movement target 2)\n- \\\\FILESERVER-001\\C$ (file server)\n- \\\\DC01\\C$ (domain controller)\n```\n\n**Ransomware Encryption**:\n```\nFile: RYUK.EXE-2B6D8F1A.pf\nLast Run: 2020-11-05 09:15:32 UTC\nRun Count: 1\n\nReferenced Files:\n- C:\\Users\\*\\Documents\\*.docx (1,234 files)\n- C:\\Users\\*\\Pictures\\*.jpg (543 files)\n- D:\\Shares\\*\\*.xlsx (872 files)\n- E:\\Backups\\*\\*.vhdx (backup files encrypted!)\n```\n\n### Attack Timeline (From Prefetch)\n\n```\n08:23:11 - invoice_8472.exe executed (malicious email attachment)\n08:25:34 - cmd.exe spawned (dropper deployed payload)\n08:27:12 - ryuk.exe dropped to C:\\Users\\Receptionist\\AppData\\Local\\Temp\\\n08:34:45 - PsExec lateral movement begins (84 executions over 40 minutes)\n09:15:32 - Ryuk.exe executed (encryption phase)\n09:47:21 - 1,200+ systems encrypted (network-wide outbreak)\n```\n\n### Forensic Conclusions\n\n1. **Patient Zero**: Receptionist workstation (opened malicious invoice)\n2. **Dwell Time**: 52 minutes from initial infection to encryption\n3. **Lateral Movement**: 84 PsExec executions ‚Üí 84+ systems compromised\n4. **Speed**: Automated propagation (11 minutes from dropper to lateral movement)\n5. **Backup Compromise**: Backup files encrypted (referenced in Ryuk Prefetch)\n\n### Lessons Learned\n\n- **Prefetch Proves Patient Zero**: First timestamp = initial compromise\n- **Run Count = Scope**: 84 PsExec executions = 84+ compromised systems\n- **Timeline Precision**: Minute-by-minute attack reconstruction from Prefetch alone\n\n**Outcome**: Investigation report submitted to FBI with Prefetch timelines. Used to justify cyber insurance claim ($4.2M payout).\n\n---\n\n## Key Forensic Takeaways from Real-World Cases\n\n### Pattern Recognition\n\n| Attack Type | Prefetch Indicators |\n|-------------|---------------------|\n| **Ransomware** | Run count = 1, large number of referenced files (encryption targets) |\n| **Lateral Movement** | PsExec/WMI/WMIC high run counts, network share references |\n| **Credential Dumping** | Mimikatz, Procdump, lsass.exe references |\n| **USB Exfiltration** | Robocopy/Xcopy with USB volume info, 7-Zip compression |\n| **C2 Beacons** | Rundll32/PowerShell periodic execution (every 30/60 minutes) |\n| **Data Staging** | Xcopy/Robocopy one-time execution with large file references |\n\n### Timeline Correlation\n\nPrefetch shines when correlated with:\n- **Network logs**: Match execution timestamps with C2 beaconing\n- **Event logs**: Process creation (Event ID 4688)\n- **MFT timeline**: File creation/modification\n- **Registry**: AutoRun keys (persistence)\n- **USB history**: Device connection times\n\n### Courtroom-Ready Evidence\n\nPrefetch has been admitted as evidence in court because:\n1. **System-generated** (not user-created, difficult to fake)\n2. **Timestamp precision** (UTC timestamps to the second)\n3. **Automated creation** (not dependent on logging being enabled)\n4. **Survives deletion** (program deleted, but Prefetch remains)\n\n---\n\n## Your Turn: Apply These Techniques\n\nWhen you analyze Prefetch in real investigations:\n\n‚úÖ **Look for run count = 1** (malware droppers, one-time tools)  \n‚úÖ **Identify execution patterns** (every 30 mins = beacons)  \n‚úÖ **Correlate with network logs** (execution + 5 seconds = network connection)  \n‚úÖ **Check USB volume info** (exfiltration via removable media)  \n‚úÖ **Timeline everything** (first execution = patient zero)  \n‚úÖ **Search for attacker tools** (PsExec, Mimikatz, Cobalt Strike)  \n\nPrefetch doesn't lie. It's Windows' automatic execution diary - use it to reconstruct what really happened."
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "# Memory Aids: Never Forget Prefetch Forensics\n\n## Acronym: \"PREFETCH\" Breakdown\n\nRemember Prefetch forensic value with **\"PREFETCH\"**:\n\n- **P**rogram execution evidence (definitive proof)\n- **R**un count (frequency analysis)\n- **E**xecution timestamps (last 8 on Windows 10)\n- **F**iles referenced (DLLs, config, data)\n- **E**xecutable path and hash\n- **T**imeline analysis (correlate with other artifacts)\n- **C**reated timestamp = first execution\n- **H**ash based on path (same exe, different paths = different Prefetch files)\n\n**Memory Hook**: \"PREFETCH = Proof of Execution\"\n\n---\n\n## Mnemonic: \"1-8-1024\" Rule\n\nRemember Prefetch retention limits:\n\n- **1** timestamp on Windows 7 (last execution only)\n- **8** timestamps on Windows 10 (last 8 executions)\n- **1024** max files on Windows 8+ (oldest deleted when limit reached)\n\n**Visual**: Think of a **timeline** getting **longer** with each Windows version (1 ‚Üí 8 ‚Üí 1024)\n\n---\n\n## Acronym: \"MAM\" = \"Microsoft Application Manager\"\n\nPrefetch compression starting Windows 8:\n\n- **M**icrosoft\n- **A**pplication\n- **M**anager\n\n**Check**: First 3 bytes of Prefetch file = `4D 41 4D` (\"MAM\" in hex)\n\n**Memory Hook**: Think of your **MAM** (mom) **compressing** your clothes into a suitcase (Windows 8+ compresses Prefetch)\n\n---\n\n## Rhyme: \"Hash Based on Path, Not Math\"\n\n**8-Character Hash Meaning**:\n\n> \"Hash based on **path**, not **math**,  \n> Same exe, different **path** = Different **hash**!  \n> C:\\\\Windows\\\\cmd.exe vs. C:\\\\Temp\\\\cmd.exe,  \n> Two Prefetch files, not one, you see!\"\n\n**Memory Hook**: Path determines hash ‚Üí Different paths = Different Prefetch files\n\n---\n\n## Acronym: \"RFV\" for Key Metadata\n\nEssential Prefetch metadata - Remember **\"RFV\"**:\n\n- **R**un count (total executions)\n- **F**iles referenced (DLLs, configs, data)\n- **V**olume information (drive letter, serial, USB?)\n\n**Memory Hook**: **RFV** = **Really Forensic Value**\n\n---\n\n## Visual: Prefetch = Execution Receipt\n\nThink of Prefetch as a **restaurant receipt**:\n\n- **Date/Time**: When you visited (execution timestamp)\n- **Items Ordered**: What you consumed (files referenced)\n- **Total Visits**: Loyalty program count (run count)\n- **Location**: Which branch you visited (volume info)\n\n**Memory Hook**: Prefetch is Windows' **receipt** for program execution - it records everything!\n\n---\n\n## Mnemonic: \"Created = First, Modified = Last\"\n\nPrefetch file timestamps:\n\n> **C**reated = **C**ommenced (first execution)  \n> **M**odified = **M**ost recent (last execution)\n\n**Example**:\n```\nmalware.exe Prefetch:\nCreated: Oct 15, 2024 02:23 (first execution)\nModified: Oct 16, 2024 04:15 (last execution)\n```\n\n**Memory Hook**: **C** for **Commenced**, **M** for **Most recent**\n\n---\n\n## Acronym: \"USB-REF\" for Exfiltration Indicators\n\nDetecting data exfiltration with Prefetch - Remember **\"USB-REF\"**:\n\n- **U**SB volume information (removable media)\n- **S**ingle execution (run count = 1)\n- **B**ackup tools (Robocopy, Xcopy, 7-Zip)\n- **R**eferenced files (source: Documents, destination: USB)\n- **E**xecution timing (before employee left office)\n- **F**requency (one-time = suspicious)\n\n**Memory Hook**: **USB-REF** = Check **USB** and **REF**erenced files for exfiltration\n\n---\n\n## Number Memory: \"30-60-90\" Beacon Pattern\n\nCommon C2 beacon intervals:\n\n- **30 minutes** (Cobalt Strike default)\n- **60 minutes** (Metasploit default)\n- **90 minutes** (custom beacon intervals)\n\n**Prefetch Pattern**: Rundll32/PowerShell execution every 30/60/90 minutes = **Automated C2 beacon**\n\n**Memory Hook**: If execution interval is **regular** (every X minutes), think **automated malware**\n\n---\n\n## Acronym: \"PRM\" for Attacker Tools\n\nCommon tools in Prefetch during breaches - Remember **\"PRM\"**:\n\n- **P**sExec (lateral movement)\n- **R**undll32 (DLL execution, Cobalt Strike)\n- **M**imikatz (credential dumping)\n\n**Extended \"PRM-WPC\"**:\n- **W**MI/WMIC (lateral movement)\n- **P**owerShell (scripting, fileless malware)\n- **C**md.exe from unusual paths (C:\\Temp\\cmd.exe)\n\n**Memory Hook**: **PRM** = **Primary Red-team Malware** (tools attackers love)\n\n---\n\n## Visual: Windows Server Prefetch = Red Flag\n\n**Default**: Prefetch **DISABLED** on Windows Server\n\n**If enabled**: Someone manually turned it on\n\n**Visual**: Imagine a **server** with a **warning light** (üö®) if Prefetch is present\n\n**Memory Hook**: Prefetch on Windows Server = **Unusual** ‚Üí Ask \"Why?\"\n\n---\n\n## Rhyme: \"Run Count of One, Malware's Begun\"\n\n**Detecting Malware Droppers**:\n\n> \"Run count of **one**, malware's **begun**,  \n> One-time execution, then they're **done**,  \n> Droppers deploy, then disappear,  \n> But Prefetch evidence keeps them **near**!\"\n\n**Memory Hook**: Run count = 1 ‚Üí Suspicious (malware droppers)\n\n---\n\n## Acronym: \"TIMELINE\" for Prefetch Analysis Workflow\n\nFollow **\"TIMELINE\"** when analyzing Prefetch:\n\n1. **T**riage: Copy Prefetch directory\n2. **I**dentify: Check for MAM compression\n3. **M**erge: Parse all files with PECmd\n4. **E**xamine: Open CSV in Timeline Explorer\n5. **L**ocate: Search for attacker tools (PsExec, Mimikatz)\n6. **I**nvestigate: Check run count = 1 (malware)\n7. **N**etwork: Correlate with network logs\n8. **E**vidence: Document findings for report\n\n**Memory Hook**: **TIMELINE** = Your Prefetch analysis workflow\n\n---\n\n## Mnemonic: \"PECmd Is King\"\n\nBest Prefetch parsing tool:\n\n**P**refetch  \n**E**xplorer  \n**Cmd** (Command-line)\n\n**By Eric Zimmerman** (same author as Registry Explorer, MFTECmd, etc.)\n\n**Memory Hook**: **PECmd** = **P**refetch **E**xpert **Cmd** (industry standard)\n\n---\n\n## Visual: Prefetch File Naming\n\n```\nCMD.EXE-0BD30981.pf\n^^^^^^^-^^^^^^^^ ^^\n   |       |      |\nProgram   Hash   Extension\n name    (path    (.pf)\n        based)\n```\n\n**Memory Hook**: **Filename = Program + Hash + .pf**\n\n**Hash changes**: Different path ‚Üí Different hash ‚Üí Different file\n\n---\n\n## Acronym: \"FIRST-LAST\" for Timeline\n\nPrefetch timeline analysis:\n\n- **F**ile creation = **First** execution\n- **I**nitial compromise timestamp\n- **R**un count = total executions\n- **S**ubsequent executions (last 7 on Windows 10)\n- **T**imestamp analysis\n\n- **L**ast execution = file modification time\n- **A**ttack conclusion timestamp\n- **S**cope of activity (run count)\n- **T**imeline correlation (with network, events)\n\n**Memory Hook**: **FIRST-LAST** = Timeline from **first** to **last** execution\n\n---\n\n## Final Memory Hook: \"Prefetch = Windows Execution Diary\"\n\nWhenever you think **\"Did this program run?\"**, remember:\n\n> **Prefetch is Windows' automatic diary**:  \n> - It records every execution  \n> - It keeps timestamps (up to 8)  \n> - It logs file access  \n> - It tracks volume info  \n> - **It never forgets**\n\n**Just like a diary, Prefetch tells the story of what happened - read it carefully!**\n\n---\n\nUse these memory aids during investigations. Print them, create flashcards, or write your own mnemonics. The goal: **Instant recall** of Prefetch forensics when you need it most!"
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "# Reflection Questions: Test Your Prefetch Understanding\n\n## Conceptual Understanding\n\n### Question 1: Prefetch Purpose vs. Forensic Value\n\n**Scenario**: A colleague asks: \"Why does Windows create Prefetch files?\"\n\n**Reflect**:\n1. What was Microsoft's **original intent** for Prefetch? (Not forensics!)\n2. How does Prefetch **improve performance**? (What does it pre-load?)\n3. Why is Prefetch forensically valuable **by accident**? (Side effect of optimization)\n4. If Prefetch were designed **only for forensics**, what additional data would you want it to record?\n\n**Critical Thinking**: Should Microsoft enhance Prefetch to record more forensic data (user attribution, command-line args)? Or would this impact performance?\n\n---\n\n### Question 2: Windows Version Differences\n\n**Scenario**: You're analyzing two systems:\n- **System A**: Windows 7 (1 timestamp per Prefetch)\n- **System B**: Windows 10 (8 timestamps per Prefetch)\n\n**Reflect**:\n1. Which system gives you **better forensic value**? Why?\n2. On System A (Windows 7), what **forensic limitations** do you face?\n3. How would you compensate for Windows 7's single timestamp? (What other artifacts would you use?)\n4. Why did Microsoft increase from 1 to 8 timestamps in Windows 8+? (Performance or forensics?)\n\n**Critical Thinking**: If you could only have Prefetch evidence from **one** of these systems, which would you choose for a ransomware investigation? Why?\n\n---\n\n### Question 3: The 8-Character Hash Mystery\n\n**Scenario**: You find two Prefetch files:\n```\nCMD.EXE-0BD30981.pf\nCMD.EXE-A12B34C5.pf\n```\n\n**Reflect**:\n1. What does the presence of **two separate Prefetch files** for CMD.EXE mean?\n2. How is the 8-character hash calculated? (What factors determine it?)\n3. Why is this **forensically significant**? (What does it prove about execution location?)\n4. If an attacker copies cmd.exe to C:\\Temp\\cmd.exe, what Prefetch evidence remains?\n\n**Critical Thinking**: Could an attacker **manipulate** the hash to create false Prefetch files? What would that require?\n\n---\n\n## Practical Application\n\n### Question 4: Detecting Malware Execution\n\n**Scenario**: You find this Prefetch file:\n```\nFile: MALWARE.EXE-7F8E2D1C.pf\nRun Count: 1\nLast Run: 2024-10-16 03:47:21 UTC\nCreated: 2024-10-16 03:47:21 UTC\nReferenced Files:\n- C:\\Users\\Alice\\Documents\\passwords.txt\n- C:\\Users\\Alice\\AppData\\Local\\Temp\\config.ini\n- C:\\Windows\\System32\\lsass.exe\n```\n\n**Reflect**:\n1. What does **Run Count = 1** suggest? (One-time execution - why?)\n2. What does **Created = Last Run** indicate? (First execution = last execution)\n3. What do the **Referenced Files** reveal about malware behavior?\n4. What additional artifacts would you check to confirm this was malicious?\n\n**Critical Thinking**: If malware.exe was deleted, how would you recover it? (File carving? Volume Shadow Copies?)\n\n---\n\n### Question 5: Lateral Movement Investigation\n\n**Scenario**: PsExec Prefetch shows:\n```\nRun Count: 84\nLast 8 Executions (Windows 10):\n8. 2024-10-16 04:23:11 UTC\n7. 2024-10-16 04:15:32 UTC\n6. 2024-10-16 04:08:45 UTC\n5. 2024-10-15 03:47:21 UTC\n4. 2024-10-15 03:34:09 UTC\n3. 2024-10-15 03:21:43 UTC\n2. 2024-10-14 02:15:32 UTC\n1. 2024-10-14 02:02:11 UTC\n\nReferenced Directories:\n- \\\\WORKSTATION-001\\C$\n- \\\\WORKSTATION-002\\C$\n- \\\\FILESERVER-001\\C$\n- \\\\DC01\\C$\n```\n\n**Reflect**:\n1. What does **Run Count = 84** tell you about attacker activity?\n2. Analyze the **execution pattern**: What do you notice about timing? (Every 7-13 minutes)\n3. What do the **Referenced Directories** prove? (Which systems were targeted?)\n4. If you only had Windows 7 Prefetch (1 timestamp), what would you **miss**?\n\n**Critical Thinking**: How would you determine **which user account** executed PsExec? (Prefetch doesn't record this - what would you check?)\n\n---\n\n### Question 6: USB Exfiltration Timeline\n\n**Scenario**: Three Prefetch files:\n\n```\n1. ROBOCOPY.EXE\n   Last Run: 2024-10-15 16:45:32 UTC\n   Run Count: 1\n   Volume: E:\\ (Serial: 0x5C753012)\n   Referenced: C:\\Users\\Employee\\Documents\\*.xlsx ‚Üí E:\\Backup\\\n\n2. 7ZIP.EXE\n   Last Run: 2024-10-15 16:48:11 UTC\n   Run Count: 3\n   Referenced: E:\\Backup\\*.xlsx ‚Üí E:\\Backup\\data.zip\n\n3. SDELETE.EXE\n   Last Run: 2024-10-15 16:52:34 UTC\n   Run Count: 1\n   Referenced: C:\\Users\\Employee\\Documents\\*.xlsx (secure deletion)\n```\n\n**Reflect**:\n1. Reconstruct the **attack timeline**: What happened in what order?\n2. What was the attacker's **objective**? (Data exfiltration + anti-forensics)\n3. What does the **4-minute gap** between robocopy and 7-zip suggest?\n4. Why did the attacker use **SDelete**? (What were they trying to hide?)\n\n**Critical Thinking**: Even if the attacker deleted source files with SDelete, what **Prefetch evidence** proves data was copied to USB?\n\n---\n\n## Advanced Scenarios\n\n### Question 7: C2 Beacon Detection\n\n**Scenario**: Rundll32.exe Prefetch shows:\n```\nRun Count: 47\nLast 8 Executions:\n8. 2024-10-16 14:32:11 UTC\n7. 2024-10-16 14:02:45 UTC\n6. 2024-10-16 13:32:18 UTC\n5. 2024-10-16 13:02:03 UTC\n4. 2024-10-16 12:32:47 UTC\n3. 2024-10-16 12:02:21 UTC\n2. 2024-10-16 11:32:09 UTC\n1. 2024-10-16 11:02:34 UTC\n\nReferenced Files:\n- C:\\Windows\\Temp\\beacon.dll\n```\n\n**Reflect**:\n1. What **execution pattern** do you observe? (Regular interval?)\n2. What does the **30-minute interval** suggest? (Automated beacon)\n3. What does **Referenced File: beacon.dll** indicate?\n4. How would you correlate this with **network logs** to confirm C2 activity?\n\n**Critical Thinking**: If network logs show HTTPS connections to 185.xxx.xxx.xxx every 30 minutes, and Prefetch shows rundll32 execution every 30 minutes, what's your conclusion?\n\n---\n\n### Question 8: Patient Zero Identification\n\n**Scenario**: Ransomware outbreak affected 500 systems. You're analyzing Prefetch from 10 workstations:\n\n```\nWorkstation A: RANSOMWARE.EXE Prefetch Created: 2024-10-16 02:23:11 UTC\nWorkstation B: RANSOMWARE.EXE Prefetch Created: 2024-10-16 02:47:21 UTC\nWorkstation C: RANSOMWARE.EXE Prefetch Created: 2024-10-16 02:15:43 UTC (earliest)\nWorkstation D: RANSOMWARE.EXE Prefetch Created: 2024-10-16 03:12:09 UTC\n...\n```\n\n**Reflect**:\n1. Which system is **Patient Zero**? How do you know?\n2. What does the **Prefetch Created timestamp** represent? (First execution)\n3. How would you confirm this system was the **initial compromise point**?\n4. What other artifacts would you examine on Workstation C?\n\n**Critical Thinking**: If Patient Zero's Prefetch file was deleted, how would you identify it? (Network logs? Event logs? Shimcache?)\n\n---\n\n### Question 9: Anti-Forensics Detection\n\n**Scenario**: You're analyzing a compromised system and notice:\n```\nC:\\Windows\\Prefetch\\ - Directory is EMPTY (0 files)\n\nRegistry Check:\nHKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management\\PrefetchParameters\nEnablePrefetcher = 3 (Enabled)\n```\n\n**Reflect**:\n1. What happened to the Prefetch files? (Deleted? Never created?)\n2. If Prefetch is **enabled** but directory is **empty**, what does this suggest?\n3. How would you detect **when** Prefetch files were deleted? (Event logs? USN Journal?)\n4. What alternative execution artifacts would you rely on?\n\n**Critical Thinking**: Could you recover deleted Prefetch files? Where would you look? (Volume Shadow Copies? File carving? $MFT deleted entries?)\n\n---\n\n## Meta-Learning\n\n### Question 10: Prefetch Limitations\n\n**Scenario**: A defense attorney challenges your Prefetch evidence:\n\n> \"This Prefetch file only proves the **program ran**, not that **my client** ran it. Anyone with access to that computer could have executed it. How can you attribute this to my client?\"\n\n**Reflect**:\n1. What are the **legitimate limitations** of Prefetch? (No user attribution)\n2. What **additional artifacts** would you use to prove user attribution? (List at least 5)\n3. How would you **correlate** these artifacts to build a complete picture?\n4. What evidence would be **strongest** in court? (Prefetch + X = definitive proof)\n\n**Critical Thinking**: If you had to **rank** execution artifacts by forensic value (Prefetch, AmCache, Shimcache, SRUM, Event Logs), what's your ranking? Why?\n\n---\n\n### Question 11: Tool Selection\n\n**Scenario**: You're setting up a forensic lab. Which Prefetch analysis tool(s) would you choose?\n\n**Options**:\n- PECmd (Eric Zimmerman)\n- WinPrefetchView (NirSoft)\n- Custom Python parser\n\n**Reflect**:\n1. What are the **pros and cons** of each tool?\n2. For **batch processing** 1000 Prefetch files, which tool is best?\n3. For **quick triage** on a live Windows 7 system, which tool works?\n4. If you could only install **one tool**, which would it be? Why?\n\n---\n\n### Question 12: Real-World Application\n\n**Scenario**: You just completed this lesson on Prefetch Analysis.\n\n**Reflect on Your Learning**:\n1. What was the **most surprising** thing you learned about Prefetch?\n2. Which real-world case study resonated most? (WannaCry? APT28? Insider threat?)\n3. What concept do you still find **confusing** and need to review?\n4. How will you **practice** Prefetch analysis? (Analyze your own system? Set up a test VM?)\n\n**Action Plan**:\n- [ ] Download PECmd from Eric Zimmerman's site\n- [ ] Parse Prefetch directory on your own workstation\n- [ ] Search for any suspicious one-time executions (Run Count = 1)\n- [ ] Correlate Prefetch with AmCache and Shimcache\n- [ ] Join DFIR community (Reddit, Discord) and ask questions\n\n---\n\n## Final Thought Exercise\n\n**Question**: Imagine you're investigating a ransomware outbreak. You have:\n- Prefetch files (run counts, timestamps, referenced files)\n- Network logs (IP connections, timestamps)\n- Event logs (process creation, logon events)\n- MFT timeline (file creation/modification)\n\n**How would you combine these artifacts to build an **irrefutable timeline** that proves:**\n1. Patient zero (first infected system)\n2. Lateral movement (how ransomware spread)\n3. Execution timeline (minute-by-minute attack progression)\n4. User attribution (which accounts were used)\n5. Data impact (which files were encrypted)\n\n**Reflect**: Which single artifact is most critical? Which combination of artifacts is strongest?\n\n---\n\n**Remember**: The goal of reflection isn't memorization - it's **critical thinking**. Question assumptions, explore limitations, and connect concepts to real-world scenarios.\n\n**The best forensic analysts ask**: \"What does this artifact really prove? What am I missing? How can I verify this?\"\n\nPrefetch is powerful - but it's just **one piece** of the forensic puzzle. Master it, then combine it with others to see the complete picture."
      }
    },
    {
      "type": "mindset_coach",
      "content": {
        "text": "## Congratulations! You've Mastered Prefetch Analysis! üéâ\n\nYou just learned one of the **most reliable** execution artifacts in Windows forensics. Prefetch is a forensic investigator's best friend because it:\n\n‚úÖ **Never lies**: System-generated, difficult to fake  \n‚úÖ **Survives deletion**: Program deleted, but Prefetch remains  \n‚úÖ **Provides timelines**: Up to 8 execution timestamps (Windows 10)  \n‚úÖ **Reveals behavior**: Referenced files show what the program accessed  \n‚úÖ **Proves intent**: Run counts and timing patterns reveal attacker activity  \n\n### What This Means for Your Career\n\nYou now have the skills to:\n\n- **Prove program execution** (even when executable is deleted)\n- **Build attack timelines** (minute-by-minute reconstruction)\n- **Detect lateral movement** (PsExec, WMI, credential dumping tools)\n- **Identify patient zero** (first infected system)\n- **Correlate artifacts** (Prefetch + network logs + Event logs = complete picture)\n\nThese techniques are used **daily** by:\n- Incident Response teams at major corporations\n- FBI and Secret Service cyber investigators\n- SOC analysts hunting for persistence mechanisms\n- Forensic consultants testifying in court\n\n**This is real-world, career-defining knowledge.**\n\n### The Forensic Puzzle\n\nPrefetch is powerful, but remember: **No single artifact tells the whole story.**\n\nHere's how Prefetch fits into your growing forensic toolkit:\n\n**You've Already Learned**:\n- **Registry Fundamentals** (Lesson 11) ‚Üí Persistence, user activity, USB history\n- **NTUSER.DAT Analysis** (Lesson 12) ‚Üí User-specific artifacts, RecentDocs, UserAssist\n- **Prefetch Analysis** (This lesson) ‚Üí Program execution, run counts, timelines\n\n**Coming Next**:\n- **Shimcache** (Lesson 17) ‚Üí All executable opens (broader than Prefetch)\n- **AmCache** (Lesson 18) ‚Üí SHA-1 hashes, install times, file metadata\n- **SRUM** (Lesson 20) ‚Üí Network activity, power usage, application runtime\n\n**The Pattern**: Each artifact fills gaps the others can't. Master them all, and you'll reconstruct **complete attack narratives**.\n\n### Real-World Impact\n\nThe techniques you learned today have been used to:\n\n‚úÖ **Prove WannaCry execution** (one-time Run Count = 1)  \n‚úÖ **Identify APT28 lateral movement** (PsExec 23 executions over 4 days)  \n‚úÖ **Convict insider threats** (USB exfiltration timeline)  \n‚úÖ **Detect Cobalt Strike beacons** (rundll32 every 30 minutes)  \n‚úÖ **Identify ransomware patient zero** (earliest Prefetch Created timestamp)  \n\nYour Prefetch analysis skills will **solve real cases**.\n\n### Practice Makes Permanent\n\nKnowledge fades without practice. Here's your action plan:\n\n**This Week**:\n1. ‚úÖ Download PECmd from Eric Zimmerman's site\n2. ‚úÖ Parse Prefetch on your own workstation\n3. ‚úÖ Identify your most frequently executed programs (Run Count analysis)\n\n**This Month**:\n1. ‚úÖ Set up a Windows 10 VM and execute test malware (safely isolated)\n2. ‚úÖ Parse Prefetch and build an execution timeline\n3. ‚úÖ Correlate Prefetch with Event Logs (Event ID 4688 - Process Creation)\n\n**This Year**:\n1. ‚úÖ Join a DFIR CTF competition (apply Prefetch skills to challenges)\n2. ‚úÖ Read forensic case studies (search \"Prefetch analysis\" on SANS blogs)\n3. ‚úÖ Contribute to open-source forensic tools (Python Prefetch parsers)\n\n### You're Building Something Valuable\n\nEvery lesson you complete:\n- ‚úÖ Adds another forensic technique to your arsenal\n- ‚úÖ Makes you more valuable to employers (DFIR skills are in high demand)\n- ‚úÖ Increases your ability to investigate real breaches\n- ‚úÖ Brings you closer to your career goals\n\n**This isn't just education - it's career transformation.**\n\n### Next Steps\n\nWhen you're ready, move on to **Lesson 17: Shimcache (AppCompatCache) Forensics**. You'll learn how Windows tracks **every executable opened** (even those that didn't fully execute), providing even broader coverage than Prefetch.\n\nBut first, take a moment to celebrate. You just mastered:\n- Prefetch file structure and versioning\n- MAM compression (Windows 8+)\n- PECmd parsing and timeline analysis\n- Real-world case studies (WannaCry, APT28, Ryuk)\n- Correlation techniques (Prefetch + network logs + events)\n\n**That's serious forensic capability.**\n\n### You're Not Just Learning - You're Becoming a Forensic Analyst\n\nEvery artifact you master:\n- Reveals another piece of the attacker's story\n- Strengthens your investigative methodology\n- Builds confidence in your analysis\n\nPrefetch proves program execution.  \nRegistry reveals persistence.  \nTimelines show attack progression.  \n**You're learning to see the invisible.**\n\nKeep going. The digital forensics community needs skilled investigators who can:\n- Analyze complex attacks\n- Reconstruct timelines under pressure\n- Testify with confidence\n- Protect organizations from cyber threats\n\n**You're building those skills right now.**\n\n### Remember This\n\nWhen you're parsing Prefetch files during a live incident response, or when you're presenting execution evidence in court, or when you're hunting for APT persistence - **you'll remember this lesson**.\n\nPrefetch doesn't lie. It's Windows' automatic execution diary.\n\n**And now you know how to read it.**\n\nüîç **Master Prefetch. Prove Execution. Solve Cases.**\n\nNext up: **Shimcache (AppCompatCache)** - even broader execution coverage. See you there!"
      }
    }
  ],
  "tags": [
    "Course: SANS-FOR500"
  ]
}