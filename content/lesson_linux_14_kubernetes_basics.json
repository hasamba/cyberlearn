{
  "lesson_id": "e9f0a1b2-c3d4-4e5f-6a7b-8c9d0e1f2a3b",
  "domain": "linux",
  "title": "Kubernetes Fundamentals for Security Labs and Deployments",
  "difficulty": 2,
  "order_index": 14,
  "estimated_time": 60,
  "prerequisites": ["f8e9d0c1-b2a3-4c5d-6e7f-8a9b0c1d2e3f"],
  "concepts": [
    "Kubernetes architecture",
    "Pods and containers",
    "Deployments and ReplicaSets",
    "Services and networking",
    "ConfigMaps and Secrets",
    "Namespaces and isolation",
    "kubectl command-line tool",
    "YAML manifests"
  ],
  "learning_objectives": [
    "Understand Kubernetes architecture and how it orchestrates containers",
    "Install and configure a local Kubernetes cluster with Minikube or kind",
    "Deploy applications using Pods, Deployments, and Services",
    "Manage application configuration with ConfigMaps and Secrets",
    "Use namespaces to isolate security lab environments",
    "Master kubectl commands for cluster management",
    "Write and apply Kubernetes YAML manifests",
    "Deploy multi-tier security applications on Kubernetes"
  ],
  "content_blocks": [
    {
      "type": "explanation",
      "title": "Why Kubernetes for Security Professionals",
      "content": {
        "text": "Welcome to Kubernetes (K8s)! If Docker is about running individual containers, Kubernetes is about orchestrating hundreds or thousands of them at scale. For security professionals, K8s is becoming essential as more organizations deploy security tools and infrastructure on Kubernetes.\n\n## What is Kubernetes?\n\nKubernetes is an open-source container orchestration platform originally developed by Google. It automates deployment, scaling, and management of containerized applications.\n\n**Think of it this way:**\n- **Docker** = Running containers on a single machine\n- **Kubernetes** = Managing containers across many machines as a unified cluster\n\n## From Docker to Kubernetes\n\n**With Docker Compose (single machine):**\n```yaml\nservices:\n  webapp:\n    image: myapp:1.0\n    replicas: 3\n```\n\n**With Kubernetes (cluster of machines):**\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: webapp\nspec:\n  replicas: 3\n  template:\n    spec:\n      containers:\n      - name: webapp\n        image: myapp:1.0\n```\n\nKubernetes automatically:\n- Distributes 3 replicas across cluster nodes\n- Restarts failed containers\n- Load balances traffic\n- Scales up/down based on load\n- Performs rolling updates without downtime\n\n## Why Security Teams Use Kubernetes\n\n**1. Security Tool Deployment**\n```\n┌─────────────────────────────────────┐\n│      Kubernetes Cluster             │\n├─────────────┬───────────────────────┤\n│  SIEM       │  Threat Intel         │\n│  (Splunk)   │  (MISP)               │\n├─────────────┼───────────────────────┤\n│  Vuln Scan  │  WAF                  │\n│  (Trivy)    │  (ModSecurity)        │\n├─────────────┼───────────────────────┤\n│  Logging    │  Monitoring           │\n│  (ELK)      │  (Prometheus)         │\n└─────────────┴───────────────────────┘\n```\n\nDeploy entire security stack with resilience and scale.\n\n**2. Red Team Infrastructure**\n- Deploy C2 servers across multiple nodes\n- Automatic failover if a node goes down\n- Easy scaling for large engagements\n- Network policies for stealth\n\n**3. Blue Team Labs**\n- Isolated namespaces for different teams\n- Reproducible security monitoring stacks\n- Easy environment provisioning\n- Resource quotas to prevent abuse\n\n**4. Security Testing at Scale**\n```bash\n# Deploy 100 vulnerable apps for training\nkubectl scale deployment dvwa --replicas=100\n\n# Each student gets their own instance\n# Automatic load balancing\n# Centralized monitoring\n```\n\n**5. DevSecOps Pipelines**\n```\nCode Commit → Build → Security Scan → K8s Deploy\n                ↓\n        [SAST, DAST, Container Scan]\n                ↓\n        [If Pass: Deploy to K8s]\n```\n\n**6. Microservices Security**\nModern apps split into microservices:\n- Authentication service\n- API gateway\n- Database service\n- Logging service\n\nKubernetes manages communication, security policies, and scaling.\n\n## Kubernetes Architecture\n\n```\n┌───────────────────────────────────────────────────────┐\n│                  Control Plane                        │\n│  ┌──────────┐  ┌──────────┐  ┌────────────────┐    │\n│  │ API      │  │ Scheduler│  │ Controller     │    │\n│  │ Server   │  │          │  │ Manager        │    │\n│  └──────────┘  └──────────┘  └────────────────┘    │\n│                                                       │\n│  ┌──────────────────────────────────────────────┐  │\n│  │          etcd (Cluster State)                 │  │\n│  └──────────────────────────────────────────────┘  │\n└───────────────────────────────────────────────────────┘\n         │                │                 │\n         ▼                ▼                 ▼\n┌──────────────┐  ┌──────────────┐  ┌──────────────┐\n│  Worker      │  │  Worker      │  │  Worker      │\n│  Node 1      │  │  Node 2      │  │  Node 3      │\n│              │  │              │  │              │\n│ ┌────────┐   │  │ ┌────────┐   │  │ ┌────────┐   │\n│ │Pod     │   │  │ │Pod     │   │  │ │Pod     │   │\n│ │┌──┐┌──┐│   │  │ │┌──┐    │   │  │ │┌──┐┌──┐│   │\n│ ││C1││C2││   │  │ ││C1│    │   │  │ ││C1││C2││   │\n│ │└──┘└──┘│   │  │ │└──┘    │   │  │ │└──┘└──┘│   │\n│ └────────┘   │  │ └────────┘   │  │ └────────┘   │\n│              │  │              │  │              │\n│ kubelet      │  │ kubelet      │  │ kubelet      │\n│ kube-proxy   │  │ kube-proxy   │  │ kube-proxy   │\n└──────────────┘  └──────────────┘  └──────────────┘\n```\n\n**Control Plane Components:**\n1. **API Server** - Frontend to K8s, handles all API requests\n2. **Scheduler** - Assigns pods to nodes based on resources\n3. **Controller Manager** - Maintains desired state (e.g., 3 replicas)\n4. **etcd** - Key-value store for all cluster data\n\n**Worker Node Components:**\n1. **kubelet** - Agent that runs pods on the node\n2. **kube-proxy** - Network proxy for service communication\n3. **Container Runtime** - Docker, containerd, or CRI-O\n\n## Key Kubernetes Concepts\n\n**Pod** - Smallest deployable unit\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: webapp\nspec:\n  containers:\n  - name: webapp\n    image: nginx\n```\n\n**Deployment** - Manages pod replicas\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: webapp\nspec:\n  replicas: 3\n  template:\n    spec:\n      containers:\n      - name: webapp\n        image: nginx\n```\n\n**Service** - Exposes pods to network\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: webapp-service\nspec:\n  type: LoadBalancer\n  ports:\n  - port: 80\n  selector:\n    app: webapp\n```\n\n**Namespace** - Virtual cluster for isolation\n```yaml\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: security-lab\n```\n\n## Real-World Security Use Cases\n\n**Scenario 1: SOC Infrastructure**\n```\nNamespace: soc-prod\n├── ELK Stack (logging)\n├── Splunk (SIEM)\n├── TheHive (case management)\n├── Cortex (automation)\n└── MISP (threat intel)\n```\n\n**Scenario 2: CTF Platform**\n```\nNamespace: ctf-challenges\n├── Challenge 1 (web)\n├── Challenge 2 (crypto)\n├── Challenge 3 (pwn)\n└── Scoreboard\n\nEach player gets isolated pods\nAuto-scaling based on participants\n```\n\n**Scenario 3: Malware Analysis Grid**\n```\nNamespace: malware-lab\n├── Analysis sandbox (100 pods)\n├── Cuckoo coordinator\n├── YARA scanner\n└── VirusTotal API gateway\n\nSubmit malware → Distributed analysis → Aggregated results\n```\n\n**Scenario 4: Security Tool CI/CD**\n```\nGitHub → Jenkins (K8s) → Build → Test → Deploy\n          ↓\n    Security Scans:\n    - Trivy (container scan)\n    - Snyk (dependency scan)\n    - SAST tools\n          ↓\n    Deploy to K8s if pass\n```\n\nYou're about to learn how to harness this power for security work!"
      },
      "order": 1
    },
    {
      "type": "code_exercise",
      "title": "Installing Kubernetes: Minikube and kind",
      "content": {
        "text": "Let's get a local Kubernetes cluster running for learning and testing.\n\n## Option 1: Minikube (Recommended for Beginners)\n\nMinikube runs a single-node K8s cluster in a VM or container.\n\n**Installation on Linux:**\n```bash\n# Download Minikube\ncurl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64\nsudo install minikube-linux-amd64 /usr/local/bin/minikube\n\n# Verify installation\nminikube version\n\n# Start cluster (uses Docker as driver)\nminikube start --driver=docker\n\n# Check status\nminikube status\n\n# Get cluster info\nkubectl cluster-info\n```\n\n**Installation on macOS:**\n```bash\n# Using Homebrew\nbrew install minikube\n\n# Start cluster\nminikube start\n```\n\n**Installation on Windows:**\n```powershell\n# Using Chocolatey\nchoco install minikube\n\n# Or download from:\n# https://minikube.sigs.k8s.io/docs/start/\n\n# Start cluster\nminikube start --driver=docker\n```\n\n## Option 2: kind (Kubernetes in Docker)\n\nkind runs K8s clusters in Docker containers - faster and lighter.\n\n**Installation:**\n```bash\n# Linux\ncurl -Lo ./kind https://kind.sigs.k8s.io/dl/latest/kind-linux-amd64\nchmod +x ./kind\nsudo mv ./kind /usr/local/bin/kind\n\n# macOS\nbrew install kind\n\n# Windows (Chocolatey)\nchoco install kind\n\n# Create cluster\nkind create cluster --name security-lab\n\n# View clusters\nkind get clusters\n\n# Delete cluster\nkind delete cluster --name security-lab\n```\n\n## Installing kubectl (Kubernetes CLI)\n\n**Linux:**\n```bash\n# Download latest\ncurl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\"\n\n# Install\nsudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl\n\n# Verify\nkubectl version --client\n```\n\n**macOS:**\n```bash\nbrew install kubectl\n```\n\n**Windows:**\n```powershell\nchoco install kubernetes-cli\n```\n\n## Verify Installation\n\n```bash\n# Check kubectl is working\nkubectl version\n\n# View cluster info\nkubectl cluster-info\n\n# List nodes\nkubectl get nodes\n\n# Output should show:\n# NAME       STATUS   ROLES           AGE   VERSION\n# minikube   Ready    control-plane   5m    v1.28.0\n```\n\n## Configure kubectl Context\n\n```bash\n# View current context\nkubectl config current-context\n\n# List all contexts\nkubectl config get-contexts\n\n# Switch context (if multiple clusters)\nkubectl config use-context minikube\n\n# View configuration\nkubectl config view\n```\n\n## Minikube Useful Commands\n\n```bash\n# Stop cluster\nminikube stop\n\n# Start cluster\nminikube start\n\n# Delete cluster\nminikube delete\n\n# SSH into node\nminikube ssh\n\n# Access Kubernetes dashboard\nminikube dashboard\n\n# Get cluster IP\nminikube ip\n\n# View addons\nminikube addons list\n\n# Enable addon (e.g., metrics-server)\nminikube addons enable metrics-server\n```\n\n## Create Multi-Node Cluster (Advanced)\n\n```bash\n# kind with 3 worker nodes\ncat <<EOF > kind-config.yaml\nkind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nnodes:\n- role: control-plane\n- role: worker\n- role: worker\n- role: worker\nEOF\n\nkind create cluster --config kind-config.yaml --name multi-node\n\n# Verify nodes\nkubectl get nodes\n```\n\n## Troubleshooting\n\n**Minikube won't start:**\n```bash\n# Check Docker is running\ndocker ps\n\n# Try with different driver\nminikube start --driver=virtualbox\n\n# View logs\nminikube logs\n\n# Clean start\nminikube delete && minikube start\n```\n\n**kubectl connection refused:**\n```bash\n# Check cluster is running\nminikube status\n\n# Update kubeconfig\nminikube update-context\n```",
        "code": "# Complete K8s setup with Minikube\ncurl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64\nsudo install minikube-linux-amd64 /usr/local/bin/minikube\nminikube start --driver=docker\nkubectl cluster-info\nkubectl get nodes"
      },
      "order": 2
    },
    {
      "type": "explanation",
      "title": "Pods: The Building Blocks of Kubernetes",
      "content": {
        "text": "Pods are the smallest deployable units in Kubernetes. Understanding pods is essential for everything that follows.\n\n## What is a Pod?\n\nA pod is a group of one or more containers that:\n- Share network namespace (same IP address)\n- Share storage volumes\n- Are scheduled together on the same node\n- Are the atomic unit of deployment\n\n**Most common:** One container per pod\n\n```\n┌─────────────────────────┐\n│     Pod                 │\n│  ┌──────────────────┐   │\n│  │   Container      │   │\n│  │   (nginx)        │   │\n│  └──────────────────┘   │\n│                         │\n│  IP: 10.244.0.5         │\n└─────────────────────────┘\n```\n\n**Less common:** Multiple containers in one pod (sidecar pattern)\n\n```\n┌──────────────────────────────────┐\n│     Pod                          │\n│  ┌──────────────┐ ┌───────────┐ │\n│  │ Main App     │ │ Log       │ │\n│  │ (webapp)     │ │ Collector │ │\n│  └──────────────┘ └───────────┘ │\n│                                  │\n│  Shared: localhost, volumes      │\n│  IP: 10.244.0.5                  │\n└──────────────────────────────────┘\n```\n\n## Creating Your First Pod\n\n**Imperative (command line):**\n```bash\n# Run nginx pod\nkubectl run nginx --image=nginx:latest\n\n# Check pod status\nkubectl get pods\n\n# Output:\n# NAME    READY   STATUS    RESTARTS   AGE\n# nginx   1/1     Running   0          30s\n\n# Get detailed info\nkubectl describe pod nginx\n\n# View logs\nkubectl logs nginx\n\n# Execute command in pod\nkubectl exec nginx -- nginx -v\n\n# Open shell in pod\nkubectl exec -it nginx -- /bin/bash\n\n# Delete pod\nkubectl delete pod nginx\n```\n\n**Declarative (YAML manifest):**\n```yaml\n# nginx-pod.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\n  labels:\n    app: webserver\nspec:\n  containers:\n  - name: nginx\n    image: nginx:latest\n    ports:\n    - containerPort: 80\n```\n\n```bash\n# Apply manifest\nkubectl apply -f nginx-pod.yaml\n\n# Verify\nkubectl get pods\n\n# Delete using manifest\nkubectl delete -f nginx-pod.yaml\n```\n\n## Security Lab Example: Kali Pod\n\n```yaml\n# kali-pod.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: kali-lab\n  labels:\n    app: security-tools\nspec:\n  containers:\n  - name: kali\n    image: kalilinux/kali-rolling\n    command: [\"/bin/bash\"]\n    args: [\"-c\", \"sleep infinity\"]\n    resources:\n      limits:\n        memory: \"2Gi\"\n        cpu: \"1000m\"\n      requests:\n        memory: \"1Gi\"\n        cpu: \"500m\"\n```\n\n```bash\n# Deploy\nkubectl apply -f kali-pod.yaml\n\n# Access\nkubectl exec -it kali-lab -- /bin/bash\n\n# Inside pod, install tools\napt update\napt install -y nmap nikto sqlmap\n\n# Use tools\nnmap -sV target.example.com\n\n# Exit\nexit\n\n# Clean up\nkubectl delete -f kali-pod.yaml\n```\n\n## Multi-Container Pod: Web App + Logging Sidecar\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: webapp-with-logging\nspec:\n  containers:\n  # Main application\n  - name: webapp\n    image: nginx\n    volumeMounts:\n    - name: logs\n      mountPath: /var/log/nginx\n      \n  # Logging sidecar\n  - name: log-collector\n    image: fluent/fluent-bit\n    volumeMounts:\n    - name: logs\n      mountPath: /logs\n      \n  volumes:\n  - name: logs\n    emptyDir: {}\n```\n\nBoth containers share the `/logs` volume.\n\n## Pod Lifecycle\n\n```\nPending → ContainerCreating → Running → Succeeded/Failed\n   ↓             ↓                ↓           ↓\n Scheduled   Pulling Image    Executing   Completed\n```\n\n**Check pod status:**\n```bash\nkubectl get pods\n\n# STATUS values:\n# - Pending: Waiting to be scheduled\n# - ContainerCreating: Pulling image\n# - Running: Pod is running\n# - Succeeded: Completed successfully\n# - Failed: Completed with errors\n# - CrashLoopBackOff: Repeatedly crashing\n```\n\n## Debugging Pods\n\n```bash\n# Why is pod not starting?\nkubectl describe pod <pod-name>\n\n# View recent events\nkubectl get events --sort-by='.lastTimestamp'\n\n# View logs\nkubectl logs <pod-name>\n\n# View logs from previous container instance\nkubectl logs <pod-name> --previous\n\n# Follow logs (like tail -f)\nkubectl logs -f <pod-name>\n\n# Logs from specific container in multi-container pod\nkubectl logs <pod-name> -c <container-name>\n```\n\n## Common Pod Patterns\n\n**1. Init Containers** (run before main containers)\n```yaml\nspec:\n  initContainers:\n  - name: setup\n    image: busybox\n    command: ['sh', '-c', 'echo Initializing... && sleep 5']\n  containers:\n  - name: main\n    image: nginx\n```\n\n**2. Resource Limits**\n```yaml\nresources:\n  requests:  # Minimum guaranteed\n    memory: \"256Mi\"\n    cpu: \"250m\"\n  limits:    # Maximum allowed\n    memory: \"512Mi\"\n    cpu: \"500m\"\n```\n\n**3. Environment Variables**\n```yaml\ncontainers:\n- name: webapp\n  image: myapp\n  env:\n  - name: DATABASE_HOST\n    value: \"mysql.default.svc.cluster.local\"\n  - name: API_KEY\n    valueFrom:\n      secretKeyRef:\n        name: api-secret\n        key: api-key\n```\n\n## Pod Best Practices\n\n1. **One process per container** (microservices pattern)\n2. **Use labels** for organization and selection\n3. **Set resource limits** to prevent resource hogging\n4. **Use liveness/readiness probes** (covered later)\n5. **Don't run as root** (security)\n6. **Use specific image tags** (not :latest)"
      },
      "order": 3
    },
    {
      "type": "code_exercise",
      "title": "Deployments: Managing Pod Replicas",
      "content": {
        "text": "Pods are ephemeral - they can die and don't come back. Deployments solve this by managing pod replicas and ensuring desired state.\n\n## What is a Deployment?\n\nA Deployment:\n- Creates and manages ReplicaSets\n- Maintains desired number of pod replicas\n- Performs rolling updates\n- Enables rollbacks\n- Self-heals (restarts failed pods)\n\n```\nDeployment\n    ↓\nReplicaSet (manages pods)\n    ↓\nPods (3 replicas)\n```\n\n## Create Deployment (Imperative)\n\n```bash\n# Create deployment with 3 replicas\nkubectl create deployment nginx --image=nginx:latest --replicas=3\n\n# View deployments\nkubectl get deployments\n\n# View replica sets\nkubectl get replicasets\n\n# View pods (3 created)\nkubectl get pods\n\n# Delete a pod - watch it auto-recreate!\nkubectl delete pod <pod-name>\nkubectl get pods  # New pod created automatically!\n```\n\n## Create Deployment (Declarative)\n\n```yaml\n# webapp-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: webapp\n  labels:\n    app: webapp\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: webapp\n  template:\n    metadata:\n      labels:\n        app: webapp\n    spec:\n      containers:\n      - name: webapp\n        image: nginx:1.21\n        ports:\n        - containerPort: 80\n        resources:\n          requests:\n            memory: \"128Mi\"\n            cpu: \"100m\"\n          limits:\n            memory: \"256Mi\"\n            cpu: \"200m\"\n```\n\n```bash\n# Apply deployment\nkubectl apply -f webapp-deployment.yaml\n\n# Watch pods being created\nkubectl get pods -w\n\n# Check deployment status\nkubectl rollout status deployment webapp\n```\n\n## Scaling Deployments\n\n```bash\n# Scale up to 5 replicas\nkubectl scale deployment webapp --replicas=5\n\n# Verify\nkubectl get pods\n\n# Scale down to 2\nkubectl scale deployment webapp --replicas=2\n\n# Edit deployment directly\nkubectl edit deployment webapp\n# Change replicas: 3 to replicas: 10\n```\n\n## Rolling Updates\n\n```bash\n# Update image (triggers rolling update)\nkubectl set image deployment/webapp webapp=nginx:1.22\n\n# Watch update progress\nkubectl rollout status deployment webapp\n\n# View rollout history\nkubectl rollout history deployment webapp\n\n# Rollback to previous version\nkubectl rollout undo deployment webapp\n\n# Rollback to specific revision\nkubectl rollout undo deployment webapp --to-revision=2\n```\n\n## Security Lab Example: DVWA Deployment\n\n```yaml\n# dvwa-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: dvwa\n  namespace: security-lab\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: dvwa\n  template:\n    metadata:\n      labels:\n        app: dvwa\n    spec:\n      containers:\n      - name: dvwa\n        image: vulnerables/web-dvwa\n        ports:\n        - containerPort: 80\n        env:\n        - name: MYSQL_HOST\n          value: \"mysql-service\"\n        - name: MYSQL_DATABASE\n          value: \"dvwa\"\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n```\n\n```bash\n# Create namespace\nkubectl create namespace security-lab\n\n# Deploy DVWA\nkubectl apply -f dvwa-deployment.yaml\n\n# Check deployment\nkubectl get deployments -n security-lab\nkubectl get pods -n security-lab\n\n# Scale for more students\nkubectl scale deployment dvwa --replicas=10 -n security-lab\n```\n\n## Deployment Strategies\n\n**1. Rolling Update (Default)**\n```yaml\nstrategy:\n  type: RollingUpdate\n  rollingUpdate:\n    maxSurge: 1        # Max extra pods during update\n    maxUnavailable: 1  # Max pods unavailable during update\n```\n\nGradually replaces old pods with new ones.\n\n**2. Recreate**\n```yaml\nstrategy:\n  type: Recreate\n```\n\nKills all old pods before creating new ones (downtime!).\n\n## Advanced: Blue-Green Deployment\n\n```yaml\n# blue-deployment.yaml (v1)\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: webapp-blue\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: webapp\n      version: blue\n  template:\n    metadata:\n      labels:\n        app: webapp\n        version: blue\n    spec:\n      containers:\n      - name: webapp\n        image: webapp:1.0\n---\n# green-deployment.yaml (v2)\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: webapp-green\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: webapp\n      version: green\n  template:\n    metadata:\n      labels:\n        app: webapp\n        version: green\n    spec:\n      containers:\n      - name: webapp\n        image: webapp:2.0\n```\n\nSwitch traffic by updating Service selector from `version: blue` to `version: green`.\n\n## Monitoring Deployments\n\n```bash\n# View deployment details\nkubectl describe deployment webapp\n\n# View events\nkubectl get events --field-selector involvedObject.name=webapp\n\n# View resource usage (requires metrics-server)\nkubectl top pods\n\n# Auto-scale based on CPU\nkubectl autoscale deployment webapp --cpu-percent=50 --min=3 --max=10\n\n# View horizontal pod autoscaler\nkubectl get hpa\n```",
        "code": "# Complete deployment example\nkubectl create deployment webapp --image=nginx:latest --replicas=3\nkubectl get deployments\nkubectl get pods\nkubectl scale deployment webapp --replicas=5\nkubectl set image deployment/webapp nginx=nginx:1.22\nkubectl rollout status deployment webapp"
      },
      "order": 4
    },
    {
      "type": "explanation",
      "title": "Services: Networking and Load Balancing",
      "content": {
        "text": "Services provide stable networking for your pods. Without Services, pods have dynamic IPs that change when they restart - Services solve this.\n\n## Why Services?\n\n**Problem:**\n```\nPod 1: 10.244.0.5  ← Dies, recreated with new IP\nPod 2: 10.244.0.6  ← Dies, recreated with new IP\nPod 3: 10.244.0.7  ← Dies, recreated with new IP\n\nHow do clients connect reliably?\n```\n\n**Solution: Service**\n```\nService: webapp-service\n  IP: 10.100.200.50 (stable, never changes)\n  ↓ Load balances to:\n  ├─ Pod 1: 10.244.0.5\n  ├─ Pod 2: 10.244.0.6\n  └─ Pod 3: 10.244.0.7\n  \nClients connect to Service IP\n```\n\n## Service Types\n\n**1. ClusterIP (Default)**\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: webapp-service\nspec:\n  type: ClusterIP  # Only accessible within cluster\n  selector:\n    app: webapp\n  ports:\n  - port: 80        # Service port\n    targetPort: 80  # Container port\n```\n\nUse for: Internal services (databases, APIs)\n\n**2. NodePort**\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: webapp-nodeport\nspec:\n  type: NodePort\n  selector:\n    app: webapp\n  ports:\n  - port: 80\n    targetPort: 80\n    nodePort: 30080  # Accessible on all nodes\n```\n\nAccess: `http://<node-ip>:30080`\n\nUse for: Testing, development\n\n**3. LoadBalancer**\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: webapp-lb\nspec:\n  type: LoadBalancer\n  selector:\n    app: webapp\n  ports:\n  - port: 80\n    targetPort: 80\n```\n\nCreates external load balancer (AWS ELB, GCP LB, etc.)\n\nUse for: Production external access\n\n**4. ExternalName**\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-db\nspec:\n  type: ExternalName\n  externalName: mysql.example.com\n```\n\nCreates DNS alias to external service.\n\n## Creating Services\n\n**Imperative:**\n```bash\n# Expose deployment as ClusterIP service\nkubectl expose deployment webapp --port=80 --target-port=80\n\n# Expose as NodePort\nkubectl expose deployment webapp --type=NodePort --port=80\n\n# Expose as LoadBalancer\nkubectl expose deployment webapp --type=LoadBalancer --port=80\n```\n\n**Declarative:**\n```yaml\n# webapp-service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: webapp\nspec:\n  selector:\n    app: webapp  # Must match pod labels!\n  ports:\n  - protocol: TCP\n    port: 80       # Service port\n    targetPort: 80 # Container port\n  type: ClusterIP\n```\n\n```bash\nkubectl apply -f webapp-service.yaml\n\n# View services\nkubectl get services\n\n# Get service details\nkubectl describe service webapp\n\n# Get service endpoints (pod IPs)\nkubectl get endpoints webapp\n```\n\n## DNS in Kubernetes\n\nKubernetes provides automatic DNS:\n\n```\nService Name: webapp\nNamespace: default\n\nFull DNS: webapp.default.svc.cluster.local\n\nFrom same namespace:\n  curl http://webapp\n  \nFrom different namespace:\n  curl http://webapp.default\n  \nFull name:\n  curl http://webapp.default.svc.cluster.local\n```\n\n## Security Lab Example: Multi-Tier App\n\n```yaml\n---\n# Frontend Deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: frontend\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: frontend\n  template:\n    metadata:\n      labels:\n        app: frontend\n    spec:\n      containers:\n      - name: frontend\n        image: nginx\n        ports:\n        - containerPort: 80\n---\n# Frontend Service (LoadBalancer)\napiVersion: v1\nkind: Service\nmetadata:\n  name: frontend\nspec:\n  type: LoadBalancer\n  selector:\n    app: frontend\n  ports:\n  - port: 80\n    targetPort: 80\n---\n# Backend Deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: backend\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: backend\n  template:\n    metadata:\n      labels:\n        app: backend\n    spec:\n      containers:\n      - name: backend\n        image: api:latest\n        ports:\n        - containerPort: 8080\n---\n# Backend Service (ClusterIP)\napiVersion: v1\nkind: Service\nmetadata:\n  name: backend\nspec:\n  type: ClusterIP  # Internal only\n  selector:\n    app: backend\n  ports:\n  - port: 8080\n    targetPort: 8080\n---\n# Database Deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: database\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: database\n  template:\n    metadata:\n      labels:\n        app: database\n    spec:\n      containers:\n      - name: postgres\n        image: postgres:14\n        ports:\n        - containerPort: 5432\n        env:\n        - name: POSTGRES_PASSWORD\n          value: \"changeme\"\n---\n# Database Service (ClusterIP)\napiVersion: v1\nkind: Service\nmetadata:\n  name: database\nspec:\n  type: ClusterIP  # Internal only\n  selector:\n    app: database\n  ports:\n  - port: 5432\n    targetPort: 5432\n```\n\n**Network flow:**\n```\nInternet → LoadBalancer → Frontend Pods\n                ↓\n         backend.default (DNS)\n                ↓\n           Backend Pods\n                ↓\n        database.default (DNS)\n                ↓\n          Database Pod\n```\n\n## Testing Services\n\n```bash\n# From within cluster (create test pod)\nkubectl run test --rm -it --image=busybox -- sh\n\n# Inside test pod:\nwget -qO- http://webapp\nwget -qO- http://backend.default\nnslookup webapp\n\n# From outside cluster (NodePort)\nminikube service webapp --url\n# Visit the URL in browser\n\n# For LoadBalancer (cloud)\nkubectl get service webapp\n# Note EXTERNAL-IP, visit in browser\n```\n\n## Service Discovery\n\nPods can discover services via:\n\n**1. Environment Variables**\n```bash\n# Kubernetes injects these automatically\nWEBAPP_SERVICE_HOST=10.100.200.50\nWEBAPP_SERVICE_PORT=80\n```\n\n**2. DNS (Preferred)**\n```bash\ncurl http://webapp.default.svc.cluster.local\n```"
      },
      "order": 5
    },
    {
      "type": "code_exercise",
      "title": "ConfigMaps and Secrets: Managing Configuration",
      "content": {
        "text": "ConfigMaps and Secrets store configuration data separately from container images.\n\n## ConfigMaps (Non-Sensitive Data)\n\n**Create from literal values:**\n```bash\nkubectl create configmap app-config \\\n  --from-literal=DATABASE_HOST=mysql.default \\\n  --from-literal=LOG_LEVEL=debug\n\n# View\nkubectl get configmap app-config -o yaml\n```\n\n**Create from file:**\n```bash\n# Create config file\ncat > app.conf <<EOF\nserver_url=https://api.example.com\nmax_connections=100\ntimeout=30\nEOF\n\n# Create ConfigMap from file\nkubectl create configmap app-config --from-file=app.conf\n```\n\n**Using ConfigMap in Pod:**\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  DATABASE_HOST: \"mysql.default\"\n  LOG_LEVEL: \"debug\"\n  MAX_CONNECTIONS: \"100\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: webapp\nspec:\n  containers:\n  - name: webapp\n    image: myapp:latest\n    # Option 1: All as environment variables\n    envFrom:\n    - configMapRef:\n        name: app-config\n    # Option 2: Specific values\n    env:\n    - name: DATABASE_HOST\n      valueFrom:\n        configMapKeyRef:\n          name: app-config\n          key: DATABASE_HOST\n    # Option 3: Mount as files\n    volumeMounts:\n    - name: config\n      mountPath: /etc/config\n  volumes:\n  - name: config\n    configMap:\n      name: app-config\n```\n\n## Secrets (Sensitive Data)\n\n**Create Secret:**\n```bash\n# From literals\nkubectl create secret generic db-credentials \\\n  --from-literal=username=admin \\\n  --from-literal=password=secretpass123\n\n# From files\necho -n 'admin' > username.txt\necho -n 'secretpass123' > password.txt\nkubectl create secret generic db-credentials \\\n  --from-file=username=username.txt \\\n  --from-file=password=password.txt\n\n# View (base64 encoded)\nkubectl get secret db-credentials -o yaml\n\n# Decode\nkubectl get secret db-credentials -o jsonpath='{.data.password}' | base64 -d\n```\n\n**Using Secret in Pod:**\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: db-credentials\ntype: Opaque\ndata:\n  username: YWRtaW4=           # base64('admin')\n  password: c2VjcmV0cGFzczEyMw==  # base64('secretpass123')\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: webapp\nspec:\n  containers:\n  - name: webapp\n    image: myapp:latest\n    # As environment variables\n    env:\n    - name: DB_USERNAME\n      valueFrom:\n        secretKeyRef:\n          name: db-credentials\n          key: username\n    - name: DB_PASSWORD\n      valueFrom:\n        secretKeyRef:\n          name: db-credentials\n          key: password\n    # Or mount as files\n    volumeMounts:\n    - name: secrets\n      mountPath: /etc/secrets\n      readOnly: true\n  volumes:\n  - name: secrets\n    secret:\n      secretName: db-credentials\n```\n\n## Security Lab Example: DVWA with MySQL\n\n```yaml\n---\n# MySQL credentials secret\napiVersion: v1\nkind: Secret\nmetadata:\n  name: mysql-secret\ntype: Opaque\nstringData:  # Use stringData for plain text (auto-encoded)\n  root-password: rootpass123\n  database: dvwa\n  username: dvwa_user\n  password: dvwa_pass\n---\n# MySQL Deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: mysql\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: mysql\n  template:\n    metadata:\n      labels:\n        app: mysql\n    spec:\n      containers:\n      - name: mysql\n        image: mysql:5.7\n        ports:\n        - containerPort: 3432\n        env:\n        - name: MYSQL_ROOT_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: mysql-secret\n              key: root-password\n        - name: MYSQL_DATABASE\n          valueFrom:\n            secretKeyRef:\n              name: mysql-secret\n              key: database\n        - name: MYSQL_USER\n          valueFrom:\n            secretKeyRef:\n              name: mysql-secret\n              key: username\n        - name: MYSQL_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: mysql-secret\n              key: password\n---\n# MySQL Service\napiVersion: v1\nkind: Service\nmetadata:\n  name: mysql\nspec:\n  selector:\n    app: mysql\n  ports:\n  - port: 3306\n---\n# DVWA Deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: dvwa\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: dvwa\n  template:\n    metadata:\n      labels:\n        app: dvwa\n    spec:\n      containers:\n      - name: dvwa\n        image: vulnerables/web-dvwa\n        ports:\n        - containerPort: 80\n        env:\n        - name: MYSQL_HOST\n          value: \"mysql\"\n        - name: MYSQL_DATABASE\n          valueFrom:\n            secretKeyRef:\n              name: mysql-secret\n              key: database\n        - name: MYSQL_USER\n          valueFrom:\n            secretKeyRef:\n              name: mysql-secret\n              key: username\n        - name: MYSQL_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: mysql-secret\n              key: password\n---\n# DVWA Service\napiVersion: v1\nkind: Service\nmetadata:\n  name: dvwa\nspec:\n  type: NodePort\n  selector:\n    app: dvwa\n  ports:\n  - port: 80\n    targetPort: 80\n    nodePort: 30080\n```\n\n```bash\n# Deploy everything\nkubectl apply -f dvwa-with-mysql.yaml\n\n# Check secrets (don't show passwords in logs!)\nkubectl get secrets\n\n# Access DVWA\nminikube service dvwa --url\n# Or: http://<node-ip>:30080\n```\n\n## Best Practices\n\n**ConfigMaps:**\n- Store non-sensitive configuration\n- Can be viewed by anyone with cluster access\n- Examples: URLs, feature flags, non-sensitive settings\n\n**Secrets:**\n- Store sensitive data (passwords, API keys, certificates)\n- Base64 encoded (NOT encrypted by default!)\n- Enable encryption at rest in production\n- Use external secret managers (HashiCorp Vault, AWS Secrets Manager) for production\n\n**Security Tips:**\n```bash\n# Never commit secrets to Git!\n# Use sealed-secrets or external secret managers\n\n# Rotate secrets regularly\nkubectl create secret generic new-db-pass --from-literal=password=newpass\nkubectl set env deployment/webapp DB_PASSWORD=newpass\n\n# Limit secret access with RBAC\n# (covered in security lesson)\n```",
        "code": "# Complete example: App with ConfigMap and Secret\nkubectl create configmap app-config --from-literal=LOG_LEVEL=debug\nkubectl create secret generic db-pass --from-literal=password=secret123\nkubectl create deployment webapp --image=nginx:latest\nkubectl set env deployment/webapp --from=configmap/app-config\nkubectl set env deployment/webapp DB_PASSWORD=secret123 --from=secret/db-pass"
      },
      "order": 6
    },
    {
      "type": "explanation",
      "title": "Namespaces: Isolating Security Lab Environments",
      "content": {
        "text": "Namespaces provide virtual clusters within a physical cluster - perfect for isolating security labs, teams, or environments.\n\n## What are Namespaces?\n\nNamespaces divide cluster resources between multiple users, teams, or projects.\n\n```\n┌─────────────────────────────────────────────┐\n│         Kubernetes Cluster                  │\n├──────────────┬──────────────┬───────────────┤\n│  default     │  dev         │  production   │\n│              │              │               │\n│ ├─ pod1      │ ├─ pod1      │ ├─ pod1       │\n│ ├─ service1  │ ├─ service1  │ ├─ service1   │\n│ └─ deploy1   │ └─ deploy1   │ └─ deploy1    │\n└──────────────┴──────────────┴───────────────┘\n```\n\n**Default Namespaces:**\n```bash\n# View all namespaces\nkubectl get namespaces\n\n# Output:\n# NAME              STATUS   AGE\n# default           Active   1d\n# kube-system       Active   1d\n# kube-public       Active   1d\n# kube-node-lease   Active   1d\n```\n\n- **default** - Default namespace for objects\n- **kube-system** - Kubernetes system components\n- **kube-public** - Public resources (readable by all)\n- **kube-node-lease** - Node heartbeat information\n\n## Creating Namespaces\n\n**Imperative:**\n```bash\n# Create namespace\nkubectl create namespace security-lab\n\n# Delete namespace (deletes all resources in it!)\nkubectl delete namespace security-lab\n```\n\n**Declarative:**\n```yaml\n# security-lab-ns.yaml\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: security-lab\n  labels:\n    environment: testing\n    team: security\n```\n\n```bash\nkubectl apply -f security-lab-ns.yaml\n```\n\n## Using Namespaces\n\n```bash\n# Create resources in specific namespace\nkubectl create deployment nginx --image=nginx -n security-lab\n\n# View resources in namespace\nkubectl get pods -n security-lab\nkubectl get all -n security-lab\n\n# View resources in all namespaces\nkubectl get pods --all-namespaces\n# Or shorthand:\nkubectl get pods -A\n\n# Set default namespace for current context\nkubectl config set-context --current --namespace=security-lab\n\n# Now all commands use security-lab namespace\nkubectl get pods  # Shows pods in security-lab\n```\n\n## Namespace in YAML\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: webapp\n  namespace: security-lab  # Specify namespace\nspec:\n  containers:\n  - name: webapp\n    image: nginx\n```\n\n## Security Lab Example: Isolated Environments\n\n```yaml\n---\n# Red Team Namespace\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: red-team\n  labels:\n    team: red\n---\n# Blue Team Namespace\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: blue-team\n  labels:\n    team: blue\n---\n# CTF Namespace\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: ctf-challenges\n  labels:\n    environment: training\n---\n# Red Team: Attack Infrastructure\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: kali\n  namespace: red-team\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: kali\n  template:\n    metadata:\n      labels:\n        app: kali\n    spec:\n      containers:\n      - name: kali\n        image: kalilinux/kali-rolling\n        command: [\"/bin/bash\", \"-c\", \"sleep infinity\"]\n---\n# Blue Team: Monitoring Stack\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: elk-stack\n  namespace: blue-team\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: elk\n  template:\n    metadata:\n      labels:\n        app: elk\n    spec:\n      containers:\n      - name: elasticsearch\n        image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0\n---\n# CTF: Vulnerable Apps\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: dvwa\n  namespace: ctf-challenges\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: dvwa\n  template:\n    metadata:\n      labels:\n        app: dvwa\n    spec:\n      containers:\n      - name: dvwa\n        image: vulnerables/web-dvwa\n```\n\n```bash\n# Deploy all\nkubectl apply -f security-namespaces.yaml\n\n# View red team resources\nkubectl get all -n red-team\n\n# View blue team resources\nkubectl get all -n blue-team\n\n# View CTF resources\nkubectl get all -n ctf-challenges\n\n# Access Kali in red-team namespace\nkubectl exec -it -n red-team deployment/kali -- /bin/bash\n```\n\n## Resource Quotas (Prevent Abuse)\n\n```yaml\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: security-lab-quota\n  namespace: security-lab\nspec:\n  hard:\n    requests.cpu: \"10\"      # Max 10 CPU cores\n    requests.memory: 20Gi   # Max 20GB RAM\n    pods: \"50\"              # Max 50 pods\n    services: \"10\"          # Max 10 services\n```\n\n```bash\nkubectl apply -f quota.yaml\n\n# View quota usage\nkubectl describe quota -n security-lab\n```\n\n## Network Policies (Namespace Isolation)\n\n```yaml\n# Deny all traffic to/from security-lab namespace\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-all\n  namespace: security-lab\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress\n  - Egress\n```\n\n```bash\nkubectl apply -f network-policy.yaml\n\n# Now pods in security-lab can't communicate with other namespaces\n# Perfect for isolated malware analysis!\n```\n\n## DNS Across Namespaces\n\n```\nService: webapp\nNamespace: security-lab\n\nFrom same namespace:\n  curl http://webapp\n  \nFrom different namespace:\n  curl http://webapp.security-lab\n  \nFully qualified:\n  curl http://webapp.security-lab.svc.cluster.local\n```\n\n## Best Practices\n\n**Organize by:**\n- **Environment**: dev, staging, production\n- **Team**: red-team, blue-team, threat-intel\n- **Project**: ctf-2024, pentests, research\n- **Customer**: client-a, client-b (for MSPs)\n\n**Naming conventions:**\n```\n<team>-<environment>\n  red-team-prod\n  blue-team-dev\n  ctf-training\n```\n\n**Use labels:**\n```yaml\nmetadata:\n  labels:\n    team: security\n    environment: production\n    compliance: pci-dss\n```"
      },
      "order": 7
    },
    {
      "type": "memory_aid",
      "title": "Kubernetes Command Cheat Sheet",
      "content": {
        "text": "## Essential kubectl Commands\n\n### Cluster Info\n```bash\nkubectl cluster-info           # Cluster details\nkubectl get nodes              # List nodes\nkubectl version                # Client/server version\n```\n\n### Pods\n```bash\nkubectl run POD --image=IMAGE  # Create pod\nkubectl get pods               # List pods\nkubectl get pods -o wide       # With IP and node\nkubectl describe pod POD       # Detailed info\nkubectl logs POD               # View logs\nkubectl logs -f POD            # Follow logs\nkubectl exec POD -- COMMAND    # Execute command\nkubectl exec -it POD -- bash   # Interactive shell\nkubectl delete pod POD         # Delete pod\n```\n\n### Deployments\n```bash\nkubectl create deployment NAME --image=IMAGE --replicas=3\nkubectl get deployments\nkubectl describe deployment NAME\nkubectl scale deployment NAME --replicas=5\nkubectl set image deployment/NAME CONTAINER=IMAGE:TAG\nkubectl rollout status deployment NAME\nkubectl rollout undo deployment NAME\nkubectl delete deployment NAME\n```\n\n### Services\n```bash\nkubectl expose deployment NAME --port=80 --type=LoadBalancer\nkubectl get services\nkubectl describe service NAME\nkubectl get endpoints NAME\nkubectl delete service NAME\n```\n\n### ConfigMaps & Secrets\n```bash\nkubectl create configmap NAME --from-literal=key=value\nkubectl create secret generic NAME --from-literal=key=value\nkubectl get configmaps\nkubectl get secrets\nkubectl describe configmap NAME\nkubectl describe secret NAME\n```\n\n### Namespaces\n```bash\nkubectl create namespace NAME\nkubectl get namespaces\nkubectl get pods -n NAMESPACE\nkubectl get all -n NAMESPACE\nkubectl get pods --all-namespaces\nkubectl delete namespace NAME\n```\n\n### YAML Operations\n```bash\nkubectl apply -f file.yaml     # Create/update\nkubectl delete -f file.yaml    # Delete\nkubectl get -f file.yaml       # View resource\nkubectl explain pod            # Show resource docs\n```\n\n### Debugging\n```bash\nkubectl describe TYPE NAME     # Detailed info\nkubectl logs POD               # Container logs\nkubectl get events             # Cluster events\nkubectl top nodes              # Resource usage\nkubectl top pods               # Pod resources\n```\n\n### Context & Config\n```bash\nkubectl config view                         # View config\nkubectl config current-context              # Current context\nkubectl config use-context NAME             # Switch context\nkubectl config set-context --current --namespace=NS\n```\n\n## Memory Mnemonics\n\n**Core Resources (PDS-CN):**\n- **P**od - Basic unit\n- **D**eployment - Manages pods\n- **S**ervice - Exposes pods\n- **C**onfigMap - Configuration\n- **(Secret is included)**\n- **N**amespace - Isolation\n\n**kubectl Commands (GAD-EL):**\n- **G**et - List resources\n- **A**pply - Create/update\n- **D**escribe - Detailed info\n- **E**xec - Run commands\n- **L**ogs - View logs\n\n**Service Types (CNN-L):**\n- **C**lusterIP - Internal only\n- **N**odePort - Node port access\n- **(N)etwork** \n- **L**oadBalancer - External LB"
      },
      "order": 8
    },
    {
      "type": "mindset_coach",
      "title": "Mastering Kubernetes for Security Work",
      "content": {
        "text": "Kubernetes has a steep learning curve, but it's worth it. Here's how to approach learning K8s as a security professional:\n\n## Start with the Basics\n\nYou don't need to know everything:\n1. Understand Pods (containers)\n2. Use Deployments (replicas)\n3. Expose with Services (networking)\n4. Organize with Namespaces (isolation)\n\nThat covers 90% of daily K8s usage!\n\n## Build Your Lab Arsenal\n\nCreate reusable YAML manifests:\n- Security tool stacks (ELK, Splunk)\n- Vulnerable app deployments (DVWA, Juice Shop)\n- Attack infrastructure (Kali, C2)\n- Monitoring and logging\n\nShare on GitHub - help others and showcase skills!\n\n## Think in Microservices\n\nK8s shines with microservices:\n- Break monolithic apps into services\n- Each service scales independently\n- Network policies control communication\n- Perfect for modern security architecture\n\n## Practice Safely\n\nK8s enables safe experimentation:\n- Isolated namespaces per experiment\n- Easy cleanup (`kubectl delete namespace`)\n- Reproducible environments\n- No fear of breaking production\n\n## Real-World Security Impact\n\nEvery K8s skill you learn:\n- Makes you valuable to employers\n- Enables cloud-native security\n- Scales your security operations\n- Future-proofs your career\n\n## From Docker to Kubernetes\n\nIf you learned Docker:\n- K8s is Docker on steroids\n- Same containers, more orchestration\n- Docker Compose → K8s manifests\n- Local containers → cluster management\n\n## Next Steps\n\n1. Deploy a simple security lab on K8s\n2. Create a CTF environment with K8s\n3. Move one Docker Compose project to K8s\n4. Learn Helm (K8s package manager)\n5. Study K8s security hardening\n\nYou've learned the fundamentals - now go build something awesome! The cloud-native security world needs you.\n\n Remember: Everyone struggles with K8s at first. Keep practicing, and soon you'll be orchestrating complex security infrastructure like a pro! 🚀"
      },
      "order": 9
    }
  ],
  "post_assessment": [
    {
      "question_id": "a1b2c3d4-e5f6-7a8b-9c0d-1e2f3a4b5c6d",
      "type": "multiple_choice",
      "question": "What is the smallest deployable unit in Kubernetes?",
      "difficulty": 1,
      "options": [
        "A) Container",
        "B) Pod",
        "C) Deployment",
        "D) Service"
      ],
      "correct_answer": "B",
      "explanation": "A Pod is the smallest deployable unit in Kubernetes. While a Pod usually contains one container, it can contain multiple containers that share resources. Containers don't exist directly in K8s - they must be part of a Pod."
    },
    {
      "question_id": "b2c3d4e5-f6a7-8b9c-0d1e-2f3a4b5c6d7e",
      "type": "multiple_choice",
      "question": "What Kubernetes object maintains a specified number of pod replicas?",
      "difficulty": 1,
      "options": [
        "A) Service",
        "B) ReplicaSet",
        "C) Deployment",
        "D) Both B and C"
      ],
      "correct_answer": "D",
      "explanation": "Both ReplicaSet and Deployment maintain pod replicas. A Deployment creates and manages a ReplicaSet, which in turn maintains the desired number of pod replicas. In practice, you typically work with Deployments, which provide additional features like rolling updates and rollbacks."
    },
    {
      "question_id": "c3d4e5f6-a7b8-9c0d-1e2f-3a4b5c6d7e8f",
      "type": "multiple_choice",
      "question": "Which Service type exposes pods only within the Kubernetes cluster?",
      "difficulty": 1,
      "options": [
        "A) NodePort",
        "B) LoadBalancer",
        "C) ClusterIP",
        "D) ExternalName"
      ],
      "correct_answer": "C",
      "explanation": "ClusterIP is the default Service type and exposes the Service only within the cluster on an internal IP. It's perfect for internal services like databases that shouldn't be accessible from outside the cluster. NodePort and LoadBalancer expose Services externally."
    },
    {
      "question_id": "d4e5f6a7-b8c9-0d1e-2f3a-4b5c6d7e8f9a",
      "type": "multiple_choice",
      "question": "What is the purpose of a Namespace in Kubernetes?",
      "difficulty": 1,
      "options": [
        "A) To provide DNS resolution for Services",
        "B) To isolate resources and provide virtual clusters within a physical cluster",
        "C) To load balance traffic between pods",
        "D) To store container images"
      ],
      "correct_answer": "B",
      "explanation": "Namespaces provide logical isolation within a Kubernetes cluster, creating virtual clusters. They're used to separate resources between teams, environments (dev/staging/prod), or projects. Namespaces also enable resource quotas and access control policies per namespace."
    },
    {
      "question_id": "e5f6a7b8-c9d0-1e2f-3a4b-5c6d7e8f9a0b",
      "type": "multiple_choice",
      "question": "Which Kubernetes object should you use to store sensitive data like passwords?",
      "difficulty": 1,
      "options": [
        "A) ConfigMap",
        "B) Secret",
        "C) Volume",
        "D) Environment variables directly in the Pod spec"
      ],
      "correct_answer": "B",
      "explanation": "Secrets are designed to store sensitive data like passwords, API keys, and certificates. While they're only base64 encoded by default (not encrypted), Secrets provide mechanisms for access control and can be encrypted at rest. ConfigMaps are for non-sensitive configuration data."
    },
    {
      "question_id": "f6a7b8c9-d0e1-2f3a-4b5c-6d7e8f9a0b1c",
      "type": "multiple_choice",
      "question": "What command would you use to scale a deployment named 'webapp' to 5 replicas?",
      "difficulty": 2,
      "options": [
        "A) kubectl scale webapp --replicas=5",
        "B) kubectl scale deployment webapp --replicas=5",
        "C) kubectl set replicas deployment/webapp 5",
        "D) kubectl update deployment webapp --replicas=5"
      ],
      "correct_answer": "B",
      "explanation": "The correct command is 'kubectl scale deployment webapp --replicas=5'. You must specify the resource type (deployment) and use the --replicas flag. This command tells Kubernetes to maintain 5 pod replicas for the webapp deployment."
    },
    {
      "question_id": "a7b8c9d0-e1f2-3a4b-5c6d-7e8f9a0b1c2d",
      "type": "multiple_choice",
      "question": "How do pods within the same cluster discover and communicate with a Service named 'database' in the default namespace?",
      "difficulty": 2,
      "options": [
        "A) Using the pod IP addresses directly",
        "B) Using the DNS name 'database' or 'database.default'",
        "C) Using environment variables only",
        "D) Services cannot be discovered automatically"
      ],
      "correct_answer": "B",
      "explanation": "Kubernetes provides automatic DNS resolution for Services. Pods can connect to a Service using its name (if in the same namespace) or using 'service-name.namespace'. The full DNS name is 'database.default.svc.cluster.local', but 'database' or 'database.default' work within the cluster."
    },
    {
      "question_id": "b8c9d0e1-f2a3-4b5c-6d7e-8f9a0b1c2d3e",
      "type": "multiple_choice",
      "question": "What happens when you delete a Deployment?",
      "difficulty": 2,
      "options": [
        "A) Only the Deployment object is deleted, pods remain",
        "B) The Deployment and its ReplicaSet are deleted, but pods remain",
        "C) The Deployment, ReplicaSet, and all pods are deleted",
        "D) Only the failed pods are deleted"
      ],
      "correct_answer": "C",
      "explanation": "When you delete a Deployment, Kubernetes cascades the deletion to its managed ReplicaSet and all pods created by that ReplicaSet. This is called cascading deletion and is the default behavior. You can prevent this with --cascade=orphan flag, but typically you want to delete everything together."
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "memory_hooks",
    "connect_to_what_i_know",
    "multiple_memory_pathways"
  ]
}
