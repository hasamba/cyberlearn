{
  "lesson_id": "9a8b7c6d-5e4f-3a2b-1c0d-9e8f7a6b5c4d",
  "domain": "system",
  "title": "Windows Processes and Threads Deep Dive",
  "difficulty": 2,
  "order_index": 3,
  "prerequisites": [
    "3ad9d1e7-f1b9-49fc-b0e6-2df0d8614aff"
  ],
  "concepts": [
    "Process Architecture",
    "Thread Execution",
    "Process Creation",
    "Parent-Child Relationships",
    "Process Injection",
    "Token Impersonation",
    "Process Hollowing",
    "Critical Processes",
    "Process Monitoring"
  ],
  "content_blocks": [
    {
      "block_id": "1a2b3c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d",
      "type": "mindset_coach",
      "content": {
        "text": "Understanding Windows processes and threads is absolutely fundamental to both offensive and defensive security. Here's why this matters more than almost any other Windows topic:\n\nEvery attack, every piece of malware, every exploitation ultimately happens within a process. Process injection, privilege escalation, credential dumping, lateral movement - all of these require deep process knowledge. Defenders who don't understand processes are essentially blind to the most critical attack vectors.\n\nHere's the reality: Most people think a process is just 'a running program.' This oversimplification misses 90% of what's actually happening. A process is a complex ecosystem:\n- Memory space with executable code, data, heap, stack\n- Security context (what user/privileges)\n- Handles to resources (files, registry, network)\n- Threads executing code\n- Parent-child relationships creating execution chains\n\nWhen you truly understand processes, you can:\n- **As an attacker**: Inject code into legitimate processes, escalate privileges, hide malware, dump credentials\n- **As a defender**: Detect process injection, identify suspicious parent-child relationships, catch privilege escalation attempts\n- **As an incident responder**: Reconstruct attack chains, identify patient zero, understand lateral movement paths\n\nMany people find process internals intimidating - Virtual Address Descriptors, Thread Execution Blocks, security tokens, handles. Here's the secret: Start with the core concepts (what is a process, what is a thread), then build outward. Each concept connects logically to the next.\n\nThink of processes like a factory:\n- The **process** is the factory building (contains everything)\n- **Threads** are workers executing tasks\n- **Memory** is the warehouse storing materials and products\n- **Security token** is the factory's business license (what they're authorized to do)\n- **Handles** are keys to external resources (loading docks, utility connections)\n\nOnce you see this architecture, everything about Windows security becomes clearer. Let's build your process mastery."
      },
      "simplified_explanation": "Process = running program with its own memory space, security context, and resources. Thread = execution unit within a process (does the actual work). Understanding processes reveals how malware operates, how to detect attacks, and how to investigate incidents.",
      "memory_aids": [
        "Process = Container, Thread = Worker inside container",
        "PID = Process ID (unique number identifying each process)",
        "Critical processes (System, csrss, lsass, services) always running - if missing, system compromised",
        "Parent-Child: legitimate parents (explorer→chrome), suspicious parents (word→cmd→powershell)"
      ],
      "teach_like_im_10": "Imagine Windows is a big office building. Each process is a separate office. Inside each office, there are workers (threads) doing tasks. The office has its own workspace (memory), keys to shared resources (handles), and an ID badge showing who they are and what they're allowed to do (security token). The building manager (Windows kernel) makes sure everyone follows the rules and doesn't interfere with other offices."
    },
    {
      "block_id": "2b3c4d5e-6f7a-8b9c-0d1e-2f3a4b5c6d7e",
      "type": "explanation",
      "content": {
        "text": "## Process Architecture\n\n### What is a Process?\n\nA **process** is an instance of a running program. It's not just the executable code - it's a complete execution environment containing:\n\n**1. Executable Code**\n- The program's instructions (loaded from .exe file)\n- Located in virtual memory address space\n- Shared across threads (all threads execute same code)\n\n**2. Virtual Address Space**\n- Private memory region for the process (typically 2GB user mode on 32-bit, up to 128TB on 64-bit)\n- Isolated from other processes (can't directly access other process memory)\n- Contains:\n- **Code section**: Executable instructions\n- **Data section**: Global variables\n- **Heap**: Dynamically allocated memory (malloc, new)\n- **Stack**: Local variables, function call chain (one per thread)\n\n**3. Security Context (Access Token)**\n- Identifies who the process is running as\n- Contains:\n- User SID (Security Identifier)\n- Group memberships\n- Privileges (SeDebugPrivilege, SeBackupPrivilege, etc.)\n- Integrity level (Low, Medium, High, System)\n- Determines what resources the process can access\n\n**4. Process Identifier (PID)**\n- Unique number identifying the process (e.g., 1234)\n- Assigned when process created\n- Reused after process terminates\n\n**5. Handles**\n- References to system resources:\n- Files (handle to open file)\n- Registry keys\n- Mutexes, events, semaphores (synchronization)\n- Threads\n- Other processes\n- Each handle has permissions (read, write, execute)\n\n**6. Threads**\n- Execution units within the process\n- At least one thread (primary thread)\n- Can have many threads (multithreading)\n\n### Process vs Program\n\n**Program**: Static code on disk (notepad.exe file)\n**Process**: Running instance of program (notepad.exe loaded into memory and executing)\n\nYou can have multiple processes from same program:\n- Open 3 Notepad windows = 3 separate notepad.exe processes\n- Each has own PID, memory space, handles\n\n### Viewing Processes\n\n**Task Manager**:\n- Ctrl+Shift+Esc\n- Details tab shows all processes with PIDs\n- Columns: CPU, Memory, Disk, Network usage\n\n**Command Line**:\n```cmd\ntasklist\n# Output:\nImage Name                     PID Session Name        Session#    Mem Usage\n========================= ======== ================ =========== ============\nSystem Idle Process              0 Services                   0          8 K\nSystem                           4 Services                   0      1,456 K\nsmss.exe                       316 Services                   0      1,088 K\ncsrss.exe                      424 Services                   0      4,512 K\n```\n\n**PowerShell**:\n```powershell\nGet-Process\n\n# More detailed info\nGet-Process -Id 1234 | Format-List *\n\n# Find process by name\nGet-Process -Name chrome\n\n# Show process owners\nGet-Process | Select-Object Name, Id, @{Name=\"Owner\";Expression={(Get-WmiObject Win32_Process -Filter \"ProcessId=$($_.Id)\").GetOwner().User}}\n```\n\n**Process Explorer (Sysinternals)**:\n- Enhanced Task Manager\n- Shows:\n- Parent-child process tree\n- Handles and DLLs loaded\n- Security context\n- Network connections\n- VirusTotal integration\n\n## Critical Windows Processes\n\nUnderstanding normal processes is essential for detecting anomalies.\n\n### System (PID 4)\n- **Purpose**: Windows kernel and drivers\n- **Parent**: None (kernel-level, not started by user-mode process)\n- **Path**: N/A (not a file, it's the kernel itself)\n- **User**: NT AUTHORITY\\SYSTEM\n- **Suspicious signs**:\n- Running from a file path (should have no path)\n- PID other than 4\n- Multiple instances\n\n### smss.exe (Session Manager Subsystem)\n- **Purpose**: Starts user sessions, creates csrss.exe and wininit.exe\n- **Parent**: System (PID 4)\n- **Path**: C:\\Windows\\System32\\smss.exe\n- **User**: NT AUTHORITY\\SYSTEM\n- **Instances**: Usually 1 (one per session)\n- **Suspicious signs**:\n- Parent other than System\n- Running from different path\n- Multiple instances (unless multiple sessions)\n\n### csrss.exe (Client/Server Runtime Subsystem)\n- **Purpose**: Critical Windows subsystem, manages console windows, processes, threads\n- **Parent**: smss.exe (for first instance) or itself (for additional sessions)\n- **Path**: C:\\Windows\\System32\\csrss.exe\n- **User**: NT AUTHORITY\\SYSTEM\n- **Instances**: At least 2 (one for services, one for user session)\n- **Note**: Cannot be terminated (blue screen if killed)\n- **Suspicious signs**:\n- Running from different path (malware often mimics csrss.exe)\n- Parent other than smss.exe\n- Only 1 instance (should be at least 2)\n\n### wininit.exe (Windows Initialization)\n- **Purpose**: Starts key system processes (services.exe, lsass.exe)\n- **Parent**: smss.exe\n- **Path**: C:\\Windows\\System32\\wininit.exe\n- **User**: NT AUTHORITY\\SYSTEM\n- **Instances**: 1\n- **Suspicious signs**:\n- Multiple instances\n- Parent other than smss.exe\n\n### services.exe (Service Control Manager)\n- **Purpose**: Starts, stops, manages Windows services\n- **Parent**: wininit.exe\n- **Path**: C:\\Windows\\System32\\services.exe\n- **User**: NT AUTHORITY\\SYSTEM\n- **Child processes**: svchost.exe instances (service hosts)\n- **Suspicious signs**:\n- Parent other than wininit.exe\n- Multiple instances\n- Children other than svchost.exe or service executables\n\n### svchost.exe (Service Host)\n- **Purpose**: Generic host for Windows services (runs DLLs as services)\n- **Parent**: services.exe\n- **Path**: C:\\Windows\\System32\\svchost.exe\n- **User**: Various (SYSTEM, LOCAL SERVICE, NETWORK SERVICE, or user accounts)\n- **Instances**: Many (normal to see 10-50+ instances)\n- **Command line**: `svchost.exe -k [ServiceGroup]`\n- Example: `svchost.exe -k netsvcs` (network services group)\n- **Suspicious signs**:\n- Parent other than services.exe\n- Running from different path (C:\\Temp\\svchost.exe)\n- No -k parameter\n- Unexpected network connections\n\n### lsass.exe (Local Security Authority Subsystem Service)\n- **Purpose**: Enforces security policy, handles authentication, stores credentials\n- **Parent**: wininit.exe\n- **Path**: C:\\Windows\\System32\\lsass.exe\n- **User**: NT AUTHORITY\\SYSTEM\n- **Instances**: 1 (always exactly one)\n- **Note**: Targeted by credential dumping tools (Mimikatz)\n- **Suspicious signs**:\n- Multiple instances (lsass.exe vs Isass.exe with capital I)\n- Parent other than wininit.exe\n- Running from different path\n- Unexpected processes accessing lsass.exe memory (credential dumping)\n\n### explorer.exe (Windows Explorer)\n- **Purpose**: Desktop, taskbar, file explorer GUI\n- **Parent**: userinit.exe (during logon, but userinit.exe exits immediately)\n- **Path**: C:\\Windows\\explorer.exe\n- **User**: Logged-in user\n- **Instances**: 1 per logged-in user\n- **Child processes**: User-launched applications (chrome.exe, notepad.exe, etc.)\n- **Suspicious signs**:\n- Multiple instances per user (possible, but unusual)\n- Unexpected child processes (explorer.exe → cmd.exe → powershell.exe from startup folder)\n\n### winlogon.exe (Windows Logon)\n- **Purpose**: Handles user logon/logoff, Ctrl+Alt+Del screen\n- **Parent**: smss.exe\n- **Path**: C:\\Windows\\System32\\winlogon.exe\n- **User**: NT AUTHORITY\\SYSTEM\n- **Instances**: 1 per session\n- **Suspicious signs**:\n- Parent other than smss.exe\n- Multiple instances (unless multiple user sessions)\n\n## Threads: The Actual Executors\n\n### What is a Thread?\n\nA **thread** is the basic unit of execution. Processes don't execute code - threads do.\n\n**Thread Components**:\n\n**1. Thread ID (TID)**\n- Unique identifier for the thread\n- Different from PID\n\n**2. Execution Context**\n- Processor registers (instruction pointer, stack pointer, etc.)\n- Defines current execution state\n\n**3. Stack**\n- Private memory for thread's local variables\n- Function call chain (call stack)\n- Each thread has its own stack\n\n**4. Priority**\n- Determines scheduling (which thread runs when)\n- Range: 0 (lowest) to 31 (highest)\n- Higher priority threads execute before lower priority\n\n**5. State**\n- **Running**: Currently executing on CPU\n- **Ready**: Ready to execute, waiting for CPU time\n- **Waiting**: Blocked waiting for resource (I/O, synchronization)\n- **Terminated**: Finished execution\n\n### Single-Threaded vs Multi-Threaded Processes\n\n**Single-Threaded**:\n- Process has only one thread (primary thread)\n- Executes one task at a time\n- Simple applications (hello_world.exe)\n\n**Multi-Threaded**:\n- Process has multiple threads\n- Can execute multiple tasks simultaneously (on multi-core CPU)\n- Benefits:\n- Responsiveness (UI thread separate from worker threads)\n- Performance (parallel processing)\n- Examples:\n- Chrome: Separate thread per tab\n- Windows Explorer: One thread for UI, others for file operations\n- Malware: Separate threads for payload, communication, persistence\n\n### Viewing Threads\n\n**Process Explorer**:\n- Select process → View → Lower Pane View → Threads\n- Shows:\n- TID (Thread ID)\n- CPU usage per thread\n- Start address (where thread began executing)\n- State (Running, Waiting)\n- Stack (call chain)\n\n**PowerShell**:\n```powershell\n# Get threads for process\n(Get-Process -Id 1234).Threads\n\n# Output:\nBasePriority           : 8\nCurrentPriority        : 8\nId                     : 5678\nPriorityLevel          : Normal\nPrivilegedProcessorTime : 00:00:00.0156001\nStartAddress           : 140698425147392\n```\n\n**WinDbg (Debugger)**:\n```bash\n# Attach to process\n.attach 1234\n\n# List threads\n~\n\n# Switch to thread\n~0s\n\n# View call stack\nk\n```bash\n\n## Process Creation\n\n### How Processes Are Created\n\nIn Windows, processes create other processes (parent-child relationship).\n\n**CreateProcess API**:\n```c\nCREATEPROCESS_MANIFEST_RESOURCE_ID\nBOOL CreateProcessA(\nLPCSTR                lpApplicationName,    // Program to execute\nLPSTR                 lpCommandLine,         // Command line arguments\nLPSECURITY_ATTRIBUTES lpProcessAttributes,   // Security descriptor\nLPSECURITY_ATTRIBUTES lpThreadAttributes,    // Thread security\nBOOL                  bInheritHandles,       // Inherit parent handles?\nDWORD                 dwCreationFlags,       // Creation flags\nLPVOID                lpEnvironment,         // Environment variables\nLPCSTR                lpCurrentDirectory,    // Working directory\nLPSTARTUPINFOA        lpStartupInfo,         // Window properties\nLPPROCESS_INFORMATION lpProcessInformation   // Out: PID, TID, handles\n);\n```\n\n**Example**:\n```c\n// Parent process creates child process\nCREATEPROCESS_MANIFEST_RESOURCE_ID\nSTARTUPINFO si;\nPROCESS_INFORMATION pi;\nZeroMemory(&si, sizeof(si));\nZeroMemory(&pi, sizeof(pi));\n\nCreateProcess(\n\"C:\\\\Windows\\\\System32\\\\notepad.exe\",  // Application\nNULL,                                    // Command line\nNULL, NULL,                               // Security attributes\nFALSE,                                    // Inherit handles\n0,                                        // Creation flags\nNULL, NULL,                               // Environment, directory\n&si,                                      // Startup info\n&pi                                       // Process info (out)\n);\n\n// pi.dwProcessId = new process PID\n// pi.dwThreadId = primary thread TID\n```bash\n\n### Parent-Child Relationships\n\nEvery process (except System) has a parent process that created it.\n\n**Normal Chains**:\n```\nservices.exe → svchost.exe\n(Service Control Manager starts service hosts)\n\nexplorer.exe → chrome.exe\n(User clicked Chrome icon in desktop/taskbar)\n\ncmd.exe → python.exe\n(User ran Python script from command prompt)\n\npowershell.exe → msbuild.exe\n(PowerShell script executed MSBuild)\n```\n\n**Suspicious Chains**:\n```\nwinword.exe → cmd.exe → powershell.exe\n(Word document spawning command shells = likely macro malware)\n\nchrome.exe → wscript.exe\n(Browser spawning Windows Script Host = suspicious download execution)\n\nlsass.exe → [anything]\n(lsass.exe should never create child processes)\n\nsvchost.exe → cmd.exe\n(Service host spawning interactive shell = very suspicious)\n```\n\n**Why This Matters**:\n- Attackers inject into processes or spawn unexpected children\n- Monitoring parent-child relationships reveals attack chains\n- Process tree shows how malware spreads through system\n\n**Viewing Process Tree**:\n```powershell\n# PowerShell (shows PID and parent PID)\nGet-CimInstance Win32_Process | Select-Object ProcessId, ParentProcessId, Name, CommandLine | Format-Table\n\n# Process Explorer: View → Show Process Tree\n```bash\n\n## Process Security Context (Access Tokens)\n\n### What is an Access Token?\n\nWhen a process is created, it receives an **access token** from its parent. This token determines the process's security context.\n\n**Access Token Contains**:\n\n**1. User SID (Security Identifier)**\n```\nS-1-5-21-3623811015-3361044348-30300820-1013\n(Identifies the user the process runs as)\n```\n\n**2. Group SIDs**\n```\nS-1-5-32-544 (Administrators)\nS-1-5-32-545 (Users)\nS-1-5-21-...-513 (Domain Users)\n```\n\n**3. Privileges**\n```\nSeDebugPrivilege         (Debug programs, read any process memory)\nSeBackupPrivilege        (Backup files, bypass file permissions)\nSeRestorePrivilege       (Restore files)\nSeImpersonatePrivilege   (Impersonate clients)\nSeLoadDriverPrivilege    (Load kernel drivers)\n```\n\n**4. Integrity Level**\n- **Low**: Sandboxed processes (Chrome renderer, IE Protected Mode)\n- **Medium**: Standard user processes (default)\n- **High**: Elevated administrator processes\n- **System**: Services, kernel-mode\n\n**Viewing Access Token**:\n```powershell\n# Using Sysinternals AccessChk\naccesschk.exe -p 1234\n\n# Shows:\nUser: DOMAIN\\username\nGroups: Administrators, Users, ...\nPrivileges: SeDebugPrivilege (Disabled), ...\nIntegrity: Medium\n```\n\n**Process Explorer**:\n- Select process → Properties → Security tab\n- Shows user, groups, integrity level\n\n### Token Impersonation\n\n**Concept**: A process can temporarily impersonate another user's token (if it has SeImpersonatePrivilege).\n\n**Legitimate Use**:\n- Web server (IIS) runs as NETWORK SERVICE\n- User authenticates to web app\n- IIS impersonates user's token to access user's files\n- Reverts to NETWORK SERVICE after operation\n\n**Malicious Use** (Token Theft):\n```\n1. Attacker compromises process with SeImpersonatePrivilege (service account)\n2. Attacker finds process running as SYSTEM (winlogon.exe, lsass.exe)\n3. Attacker steals SYSTEM token from that process\n4. Attacker impersonates SYSTEM token → privilege escalation\n```\n\n**Tools**:\n- **Incognito (Metasploit)**: Steal and impersonate tokens\n- **Potato exploits**: Trick SYSTEM process to connect, steal token\n\n**Example (Mimikatz)**:\n```bash\n# List available tokens\ntoken::list\n\n# Impersonate SYSTEM token\ntoken::elevate /system\n\n# Now running as SYSTEM\n```\n\n**Defense**:\n- Minimize processes running with SeImpersonatePrivilege\n- Monitor for token impersonation (Event ID 4672: Special privileges assigned)\n- Restrict SYSTEM process access\n\n## Process Injection Techniques\n\nProcess injection is a stealth technique where malware injects code into a legitimate process to hide and execute.\n\n### Why Inject?\n\n**Advantages for Attackers**:\n1. **Evasion**: Malicious code runs inside legitimate process (explorer.exe, svchost.exe)\n2. **Persistence**: Even if malware executable deleted, injected code persists\n3. **Privilege Escalation**: Inject into higher-privilege process\n4. **Defensive Evasion**: Antivirus may not scan legitimate process memory\n\n### Classic DLL Injection\n\n**Steps**:\n1. Attacker's process opens target process (OpenProcess)\n2. Allocates memory in target process (VirtualAllocEx)\n3. Writes malicious DLL path into target's memory (WriteProcessMemory)\n4. Creates thread in target to load DLL (CreateRemoteThread → LoadLibrary)\n5. Target process loads malicious DLL, executes its code\n\n**Code Example**:\n```c\n// Open target process\nHANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetPID);\n\n// Allocate memory in target\nLPVOID pRemoteBuf = VirtualAllocEx(hProcess, NULL, strlen(dllPath), MEM_COMMIT, PAGE_READWRITE);\n\n// Write DLL path to target memory\nWriteProcessMemory(hProcess, pRemoteBuf, dllPath, strlen(dllPath), NULL);\n\n// Create remote thread to load DLL\nHANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, \n(LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(\"kernel32.dll\"), \"LoadLibraryA\"),\npRemoteBuf, 0, NULL);\n```\n\n**Detection**:\n- Monitor CreateRemoteThread API calls (Sysmon Event ID 8)\n- Scan processes for unexpected DLLs\n- Check for memory regions with RWX (Read-Write-Execute) permissions\n\n### Process Hollowing (RunPE)\n\n**Steps**:\n1. Create legitimate process in suspended state (CreateProcess with CREATE_SUSPENDED)\n2. Unmap legitimate code from process memory (NtUnmapViewOfSection)\n3. Allocate new memory in process (VirtualAllocEx)\n4. Write malicious code into allocated memory (WriteProcessMemory)\n5. Set entry point to malicious code (SetThreadContext)\n6. Resume process (ResumeThread)\n7. Process appears legitimate (svchost.exe) but executes malicious code\n\n**Example**:\n```c\n// Create suspended legitimate process\nCreateProcess(\"C:\\\\Windows\\\\System32\\\\svchost.exe\", NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);\n\n// Unmap original code\nNtUnmapViewOfSection(pi.hProcess, pImageBase);\n\n// Allocate new memory\nVirtualAllocEx(pi.hProcess, pImageBase, imageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n\n// Write malicious executable\nWriteProcessMemory(pi.hProcess, pImageBase, maliciousCode, imageSize, NULL);\n\n// Update entry point\nSetThreadContext(pi.hThread, &ctx);\n\n// Resume\nResumeThread(pi.hThread);\n```\n\n**Detection**:\n- Process created in suspended state (unusual)\n- NtUnmapViewOfSection call (rarely used legitimately)\n- Memory regions with unusual protections (RWX)\n- Process execution doesn't match on-disk executable\n\n### Reflective DLL Injection\n\n**Concept**: Inject DLL into memory without writing to disk (fileless).\n\n**Steps**:\n1. Read DLL into memory (in attacker's process)\n2. Allocate memory in target process\n3. Write DLL to target memory (WriteProcessMemory)\n4. Create remote thread executing DLL's reflective loader (not LoadLibrary)\n5. Reflective loader manually loads DLL (parses PE, resolves imports, fixes relocations)\n6. DLL executes entirely from memory\n\n**Advantage**: No DLL file on disk (evades file-based detection)\n\n**Detection**:\n- Unusual memory allocations (large RWX regions)\n- CreateRemoteThread with start address in unnamed memory region\n- Memory forensics (analyze memory dumps for injected code)\n\n### APC (Asynchronous Procedure Call) Injection\n\n**Concept**: Queue malicious code to execute when thread enters alertable state.\n\n**Steps**:\n1. Open target process, enumerate threads\n2. Allocate memory in target process, write shellcode\n3. Queue APC to thread (QueueUserAPC)\n4. When thread enters alertable state (SleepEx, WaitForSingleObjectEx), APC executes\n\n**Advantage**: Stealthier than CreateRemoteThread (no new thread created)\n\n**Detection**:\n- Monitor QueueUserAPC calls\n- Unusual thread behavior (thread suddenly executing different code)\n\n### Process Doppelgänging (Advanced)\n\n**Concept**: Use NTFS transactions to load malicious executable as legitimate process.\n\n**Steps**:\n1. Create NTFS transaction\n2. Write malicious executable to file within transaction\n3. Create process from transacted file (process loads malicious code)\n4. Rollback transaction (file deleted)\n5. Process running with malicious code, but no file on disk\n\n**Advantage**: Bypasses many security products (process creation appears normal)\n\n**Detection**:\n- Monitor NTFS transaction usage (rare)\n- Memory forensics (process memory doesn't match any on-disk file)\n\n## Detecting Malicious Processes\n\n### Behavioral Indicators\n\n**1. Unusual Parent-Child Relationships**\n```powershell\n# Check for Office apps spawning shells\nGet-CimInstance Win32_Process | Where-Object {\n$_.ParentProcessId -and \n(Get-Process -Id $_.ParentProcessId -ErrorAction SilentlyContinue).Name -match \"winword|excel|powerpnt\" -and\n$_.Name -match \"cmd|powershell|wscript|cscript\"\n}\n```\n\n**2. Processes from Unusual Locations**\n```powershell\n# Find processes running from temp directories\nGet-Process | Where-Object {\n$_.Path -match \"Temp|AppData\\\\Local|Users\\\\Public\"\n}\n```\n\n**3. Unsigned or Mismatched Signatures**\n```powershell\n# Check if process executable is signed\nGet-Process | ForEach-Object {\nif ($_.Path) {\n$sig = Get-AuthenticodeSignature $_.Path\nif ($sig.Status -ne \"Valid\") {\nWrite-Host \"Unsigned or invalid signature: $($_.Name) - $($_.Path)\"\n}\n}\n}\n```\n\n**4. Processes with Network Connections**\n```powershell\n# Find processes with external network connections\nGet-NetTCPConnection | Where-Object {\n$_.RemoteAddress -notmatch \"^(127\\.|0\\.0\\.0\\.0|::1)\" -and\n$_.RemoteAddress -notmatch \"^(10\\.|172\\.(1[6-9]|2[0-9]|3[01])\\.|192\\.168\\.)\"\n} | ForEach-Object {\n$proc = Get-Process -Id $_.OwningProcess -ErrorAction SilentlyContinue\n[PSCustomObject]@{\nProcess = $proc.Name\nPID = $_.OwningProcess\nLocalPort = $_.LocalPort\nRemoteAddress = $_.RemoteAddress\nRemotePort = $_.RemotePort\nState = $_.State\n}\n} | Sort-Object RemoteAddress | Format-Table\n```\n\n**5. Suspicious Command Lines**\n```powershell\n# Check for encoded PowerShell commands\nGet-CimInstance Win32_Process | Where-Object {\n$_.CommandLine -match \"EncodedCommand|FromBase64String|DownloadString|IEX|Invoke-Expression\"\n} | Select ProcessId, Name, CommandLine\n```bash\n\n### Sysmon Monitoring\n\n**Event ID 1: Process Creation**\n```xml\n<Sysmon schemaversion=\"4.90\">\n<EventFiltering>\n<ProcessCreate onmatch=\"include\">\n<!-- Office spawning shells -->\n<ParentImage condition=\"contains\">\\Microsoft Office\\</ParentImage>\n<Image condition=\"contains any\">cmd.exe;powershell.exe;wscript.exe</Image>\n</ProcessCreate>\n<ProcessCreate onmatch=\"include\">\n<!-- Processes from temp directories -->\n<Image condition=\"contains any\">\\Temp\\;\\AppData\\Local\\;\\Users\\Public\\</Image>\n</ProcessCreate>\n</EventFiltering>\n</Sysmon>\n```\n\n**Event ID 8: CreateRemoteThread**\n```xml\n<CreateRemoteThread onmatch=\"exclude\">\n<!-- Whitelist known-good remote thread creation -->\n<SourceImage condition=\"is\">C:\\Windows\\System32\\svchost.exe</SourceImage>\n</CreateRemoteThread>\n```\n\n**Event ID 10: ProcessAccess**\n```xml\n<ProcessAccess onmatch=\"include\">\n<!-- Detect lsass.exe access (credential dumping) -->\n<TargetImage condition=\"is\">C:\\Windows\\System32\\lsass.exe</TargetImage>\n</ProcessAccess>\n```bash\n\n## Practical Exercises\n\n### Exercise 1: Process Tree Analysis\n\n**Task**: Build process tree and identify anomalies\n\n```powershell\n# Get all processes with parent information\n$processes = Get-CimInstance Win32_Process | Select ProcessId, ParentProcessId, Name, ExecutablePath, CommandLine\n\n# Find orphans (parent no longer exists)\n$processes | ForEach-Object {\n$parent = $processes | Where-Object ProcessId -eq $_.ParentProcessId\nif (-not $parent -and $_.ParentProcessId -ne 0) {\nWrite-Host \"Orphaned process: $($_.Name) (PID $($_.ProcessId))\"\n}\n}\n```\n\n**Questions**:\n- What processes have unexpected parents?\n- Are any critical processes missing?\n- Any processes running from unusual locations?\n\n### Exercise 2: Detect Process Injection\n\n**Task**: Find processes with suspicious memory regions\n\n**Using Process Hacker**:\n1. Download Process Hacker\n2. Select process → Memory tab\n3. Look for:\n- Memory regions with RWX protection (Read-Write-Execute)\n- Unnamed memory regions (injected code often doesn't have associated file)\n- Inconsistencies (memory doesn't match loaded modules)\n\n**Questions**:\n- Which processes have RWX memory regions?\n- Are these regions associated with loaded DLLs?\n- Does the process have unexpected network connections?\n\n### Exercise 3: Monitor Process Creation\n\n**Task**: Use Sysmon to log all process creation events\n\n1. Install Sysmon:\n```cmd\nsysmon.exe -accepteula -i config.xml\n```\n\n2. Review Event Viewer → Applications and Services Logs → Microsoft → Windows → Sysmon → Operational\n\n3. Analyze Event ID 1 (Process Creation):\n- Parent process\n- Command line\n- Hashes\n- User\n\n**Questions**:\n- What processes are being created most frequently?\n- Any unexpected parent-child relationships?\n- Any processes with suspicious command lines?\n\n### Exercise 4: Hunt for Malicious Processes\n\n**Task**: Identify potentially malicious processes\n\n```powershell\n# Comprehensive process analysis\nGet-Process | ForEach-Object {\n$proc = $_\n$path = $proc.Path\n$parent = (Get-CimInstance Win32_Process -Filter \"ProcessId=$($proc.Id)\").ParentProcessId\n$cmdLine = (Get-CimInstance Win32_Process -Filter \"ProcessId=$($proc.Id)\").CommandLine\n\n$issues = @()\n\n# Check if unsigned\nif ($path) {\n$sig = Get-AuthenticodeSignature $path -ErrorAction SilentlyContinue\nif ($sig.Status -ne \"Valid\") { $issues += \"Unsigned\" }\n}\n\n# Check if from temp\nif ($path -match \"Temp|AppData\\\\Local|Users\\\\Public\") { $issues += \"TempLocation\" }\n\n# Check for suspicious command line\nif ($cmdLine -match \"EncodedCommand|DownloadString|IEX\") { $issues += \"SuspiciousCmd\" }\n\nif ($issues.Count -gt 0) {\n[PSCustomObject]@{\nName = $proc.Name\nPID = $proc.Id\nParentPID = $parent\nPath = $path\nIssues = $issues -join \", \"\nCommandLine = $cmdLine\n}\n}\n} | Format-Table -AutoSize\n```bash\n\n## Key Takeaways\n\n1. **Process = execution environment** with code, memory, security token, handles, threads\n2. **Thread = execution unit** doing actual work within process\n3. **Critical processes** (System, csrss, lsass, services, svchost) have expected parents, paths, behaviors\n4. **Parent-child relationships** reveal attack chains (Word → cmd → PowerShell = malware)\n5. **Access tokens** define security context (user, groups, privileges, integrity level)\n6. **Process injection** hides malware in legitimate processes (DLL injection, process hollowing, reflective DLL)\n7. **Detection methods**: Process tree analysis, parent-child validation, memory forensics, Sysmon monitoring\n8. **Sysmon Event IDs**: 1 (ProcessCreate), 8 (CreateRemoteThread), 10 (ProcessAccess to lsass)\n9. **Suspicious indicators**: Unusual parents, temp directories, unsigned binaries, encoded commands, RWX memory\n10. **Defenders must baseline normal** process behavior to detect anomalies\n\nProcesses and threads are the foundation of Windows security. Master them and you'll see attacks that others miss."
      },
      "ascii_art": "PROCESS ARCHITECTURE\n\n+----------------------------------+\n|          PROCESS                 |\n|  PID: 1234                       |\n|  User: DOMAIN\\user               |\n|  Integrity: Medium               |\n+----------------------------------+\n|  Virtual Address Space           |\n|  +----------------------------+  |\n|  | Code Section               |  |\n|  | (executable instructions)  |  |\n|  +----------------------------+  |\n|  | Data Section               |  |\n|  | (global variables)         |  |\n|  +----------------------------+  |\n|  | Heap                       |  |\n|  | (dynamic allocations)      |  |\n|  +----------------------------+  |\n|  | Stack (Thread 1)           |  |\n|  | Stack (Thread 2)           |  |\n|  | Stack (Thread 3)           |  |\n|  +----------------------------+  |\n+----------------------------------+\n|  Handles                         |\n|  - File handle 0x100             |\n|  - Registry key handle 0x200     |\n|  - Event handle 0x300            |\n+----------------------------------+\n|  Threads                         |\n|  - Thread 1 (TID: 5001) [Running]|\n|  - Thread 2 (TID: 5002) [Waiting]|\n|  - Thread 3 (TID: 5003) [Ready]  |\n+----------------------------------+\n\nPROCESS TREE (Normal)\n\nSystem (PID 4)\n└── smss.exe (316)\n    ├── csrss.exe (424)\n    └── wininit.exe (488)\n        ├── services.exe (592)\n        │   ├── svchost.exe (800)\n        │   ├── svchost.exe (900)\n        │   └── svchost.exe (1000)\n        └── lsass.exe (600)\n\nexplorer.exe (2000)\n├── chrome.exe (3000)\n├── notepad.exe (3100)\n└── cmd.exe (3200)\n    └── python.exe (3300)\n\nPROCESS TREE (Suspicious)\n\nwinword.exe (4000)\n└── cmd.exe (4100) [SUSPICIOUS]\n    └── powershell.exe (4200) [SUSPICIOUS]\n        └── malware.exe (4300) [MALICIOUS]",
      "examples": [
        {
          "scenario": "Detecting Macro Malware via Process Tree",
          "explanation": "SOC analyst sees alert: winword.exe (PID 2500) spawned cmd.exe (PID 2600), which spawned powershell.exe (PID 2700) with command line 'powershell.exe -WindowStyle Hidden -EncodedCommand [base64]'. Process tree shows: Word → Command Prompt → PowerShell with encoded command. This chain indicates macro malware: user opened malicious Word doc, macro executed PowerShell to download additional payload. Analyst quarantines system, extracts Word doc for analysis, scans for similar patterns across environment."
        },
        {
          "scenario": "Process Injection Detection",
          "explanation": "Incident responder investigating compromised web server. Uses Process Explorer to examine w3wp.exe (IIS worker process). Finds unusual memory region: RWX permissions, size 2MB, not associated with any loaded DLL. Dumps memory region, finds Metasploit Meterpreter payload. Attacker exploited web vulnerability, injected Meterpreter into legitimate IIS process for stealth. Responder terminates process, patches vulnerability, hunts for similar injection across other servers."
        },
        {
          "scenario": "Privilege Escalation via Token Theft",
          "explanation": "Attacker compromises service account (has SeImpersonatePrivilege). Uses token listing tool, finds winlogon.exe running as SYSTEM. Steals SYSTEM token from winlogon.exe, impersonates it. Attacker now operates with SYSTEM privileges (highest available). Creates new admin account, installs persistence backdoor, dumps all credentials. Defender reviewing logs sees Event ID 4672 (Special privileges assigned) showing SeImpersonatePrivilege used to obtain SYSTEM. Correlates with suspicious admin account creation. Implements mitigation: restricts SeImpersonatePrivilege, enables protected process light for critical processes."
        }
      ]
    },
    {
      "type": "video",
      "content": {
        "title": "Video: Windows Processes and Threads Deep Dive Overview",
        "url": "https://www.youtube.com/embed/DXYkqtfI3uE",
        "description": "Watch this video for a visual introduction to the concepts covered in this lesson."
      }
    },
    {
      "block_id": "3c4d5e6f-7a8b-9c0d-1e2f-3a4b5c6d7e8f",
      "type": "code_exercise",
      "content": {
        "text": "## Hands-On: Process Analysis PowerShell Script\n\nCreate a PowerShell script to analyze all running processes for security anomalies.\n\n```powershell\n# process_analyzer.ps1\n# Comprehensive process security analysis\n\nfunction Get-ProcessSecurityAnalysis {\nWrite-Host \"[*] Starting process security analysis...\" -ForegroundColor Cyan\n\n$suspiciousProcesses = @()\n\n# Get all processes with detailed information\n$processes = Get-CimInstance Win32_Process | Select-Object ProcessId, ParentProcessId, Name, ExecutablePath, CommandLine\n\nforeach ($proc in $processes) {\n$findings = @()\n\n# Check 1: Unsigned executable\nif ($proc.ExecutablePath) {\n$signature = Get-AuthenticodeSignature $proc.ExecutablePath -ErrorAction SilentlyContinue\nif ($signature -and $signature.Status -ne \"Valid\") {\n$findings += \"Unsigned or invalid signature\"\n}\n}\n\n# Check 2: Running from suspicious location\nif ($proc.ExecutablePath -match \"\\\\Temp\\\\ |\\\\AppData\\\\Local\\\\|\\\\Users\\\\Public\\\\\") {\n$findings += \"Suspicious location (Temp/AppData/Public)\"\n}\n\n# Check 3: Suspicious command line\nif ($proc.CommandLine -match \"EncodedCommand|FromBase64String|DownloadString|IEX|Invoke-Expression|-nop|-w hidden\") {\n$findings += \"Suspicious command line (obfuscation/download)\"\n}\n\n# Check 4: Unexpected parent-child relationship\n$parent = $processes | Where-Object { $_.ProcessId -eq $proc.ParentProcessId }\nif ($parent) {\n# Office apps spawning shells\nif ($parent.Name -match \"winword|excel|powerpnt\" -and $proc.Name -match \"cmd|powershell|wscript|cscript\") {\n$findings += \"Office app spawned shell (likely macro malware)\"\n}\n\n# System processes spawning unusual children\nif ($parent.Name -eq \"lsass.exe\") {\n$findings += \"lsass.exe spawned child process (highly suspicious)\"\n}\n}\n\n# Check 5: Misspelled critical processes\n$criticalProcesses = @(\"csrss.exe\", \"lsass.exe\", \"smss.exe\", \"services.exe\", \"svchost.exe\")\nforeach ($critical in $criticalProcesses) {\nif ($proc.Name -like \"*$($critical.Substring(0, $critical.Length - 4))*\" -and \n$proc.Name -ne $critical -and\n$proc.ExecutablePath -notmatch \"C:\\\\Windows\\\\System32\") {\n$findings += \"Possible critical process impersonation\"\n}\n}\n\n# If any findings, add to suspicious list\nif ($findings.Count -gt 0) {\n$suspiciousProcesses += [PSCustomObject]@{\nName = $proc.Name\nPID = $proc.ProcessId\nParentPID = $proc.ParentProcessId\nParentName = if ($parent) { $parent.Name } else { \"N/A\" }\nPath = $proc.ExecutablePath\nCommandLine = $proc.CommandLine\nFindings = $findings -join \"; \"\n}\n}\n}\n\n# Display results\nWrite-Host \"`n[*] Analysis complete. Found $($suspiciousProcesses.Count) suspicious processes.`n\" -ForegroundColor Yellow\n\nif ($suspiciousProcesses.Count -gt 0) {\n$suspiciousProcesses | Format-Table Name, PID, ParentName, Findings -AutoSize\n\nWrite-Host \"`n[*] Detailed suspicious process information:\" -ForegroundColor Yellow\nforeach ($proc in $suspiciousProcesses) {\nWrite-Host \"`nProcess: $($proc.Name) (PID: $($proc.PID))\" -ForegroundColor Red\nWrite-Host \"  Parent: $($proc.ParentName) (PID: $($proc.ParentPID))\"\nWrite-Host \"  Path: $($proc.Path)\"\nWrite-Host \"  Command Line: $($proc.CommandLine)\"\nWrite-Host \"  Findings: $($proc.Findings)\" -ForegroundColor Yellow\n}\n} else {\nWrite-Host \"[+] No suspicious processes detected!\" -ForegroundColor Green\n}\n}\n\n# Run analysis\nGet-ProcessSecurityAnalysis\n```\n\n**Exercise Tasks**:\n\n1. **Run the script** on your system:\n```powershell\n.\\process_analyzer.ps1\n```\n\n2. **Enhance the script**:\n- Add check for processes with network connections to non-private IPs\n- Add check for processes consuming excessive CPU/memory (resource abuse)\n- Add check for multiple instances of processes that should be singular (lsass.exe)\n- Export results to CSV for analysis\n\n3. **Test with simulations**:\n- Create test process from Temp directory (should trigger alert)\n- Run PowerShell with encoded command (should trigger alert)\n- Check if your legitimate processes trigger false positives\n\n4. **Integrate with Sysmon**:\n- Modify script to query Sysmon Event Log (Event ID 1: ProcessCreate)\n- Correlate Sysmon data with running processes\n- Identify processes that created network connections (Sysmon Event ID 3)\n\n**Expected Output**:\n```\n[*] Starting process security analysis...\n\n[*] Analysis complete. Found 2 suspicious processes.\n\nName           PID  ParentName Findings\n----           ---  ---------- --------\ntest.exe       3456 explorer   Suspicious location (Temp/AppData/Public); Unsigned or invalid signature\npowershell.exe 3789 winword    Office app spawned shell (likely macro malware); Suspicious command line\n\n[*] Detailed suspicious process information:\n\nProcess: test.exe (PID: 3456)\nParent: explorer.exe (PID: 2000)\nPath: C:\\Users\\User\\AppData\\Local\\Temp\\test.exe\nCommand Line: C:\\Users\\User\\AppData\\Local\\Temp\\test.exe\nFindings: Suspicious location (Temp/AppData/Public); Unsigned or invalid signature\n```\n\nThis script provides a foundation for automated process security analysis. Extend it based on your organization's threat landscape."
      }
    },
    {
      "block_id": "4d5e6f7a-8b9c-0d1e-2f3a-4b5c6d7e8f9a",
      "type": "quiz",
      "content": {
        "text": "Test your process and thread knowledge",
        "questions": [
          {
            "question": "What is the difference between a process and a thread?",
            "options": [
              "Process is a running program, thread is a suspended program",
              "Process is the execution environment with memory and resources, thread is the execution unit doing work within the process",
              "Process runs in user mode, thread runs in kernel mode",
              "Process and thread are the same thing with different names"
            ],
            "correct_answer": 1,
            "explanation": "A process is the execution environment containing memory space, handles, security context, and resources. A thread is the basic unit of execution that actually runs code within the process. A process can have multiple threads sharing the same memory space but executing different code paths."
          },
          {
            "question": "Which parent-child process relationship is MOST suspicious?",
            "options": [
              "explorer.exe → chrome.exe",
              "services.exe → svchost.exe",
              "winword.exe → powershell.exe",
              "cmd.exe → ping.exe"
            ],
            "correct_answer": 2,
            "explanation": "winword.exe (Microsoft Word) spawning powershell.exe is highly suspicious and typically indicates macro malware. Legitimate document editing should not spawn PowerShell. Other options are normal: explorer launches user applications, services.exe starts service hosts, cmd.exe runs command-line utilities."
          },
          {
            "question": "An attacker wants to hide malware by injecting it into a legitimate process. Which technique allows injecting a DLL without writing it to disk?",
            "options": [
              "Classic DLL Injection (LoadLibrary)",
              "Process Hollowing",
              "Reflective DLL Injection",
              "Registry Run Key Persistence"
            ],
            "correct_answer": 2,
            "explanation": "Reflective DLL Injection loads a DLL entirely from memory without requiring a file on disk. The injected DLL contains a reflective loader that manually performs the loading process (parsing PE, resolving imports). Classic DLL injection requires a DLL file path. Process hollowing injects executables, not DLLs. Registry Run keys execute files from disk."
          },
          {
            "question": "What does lsass.exe do, and why is it targeted by attackers?",
            "options": [
              "Manages Windows services; attackers modify it to create malicious services",
              "Handles authentication and stores credentials; attackers dump it to steal passwords",
              "Controls network connections; attackers use it for command and control",
              "Manages registry operations; attackers modify it to achieve persistence"
            ],
            "correct_answer": 1,
            "explanation": "lsass.exe (Local Security Authority Subsystem Service) handles authentication and stores credentials in memory. Tools like Mimikatz read lsass.exe memory to extract plaintext passwords, NTLM hashes, and Kerberos tickets. This is one of the most common credential theft techniques. lsass.exe doesn't manage services (services.exe does that) or primarily handle networking/registry."
          },
          {
            "question": "Which Sysmon Event ID detects process injection via CreateRemoteThread?",
            "options": [
              "Event ID 1: ProcessCreate",
              "Event ID 3: NetworkConnect",
              "Event ID 8: CreateRemoteThread",
              "Event ID 13: RegistryValueSet"
            ],
            "correct_answer": 2,
            "explanation": "Sysmon Event ID 8 (CreateRemoteThread) specifically detects when one process creates a thread in another process - a key indicator of process injection. Event ID 1 is process creation, Event ID 3 is network connections, Event ID 13 is registry value changes. Only Event ID 8 reveals cross-process thread creation used in injection attacks."
          }
        ]
      }
    },
    {
      "block_id": "5e6f7a8b-9c0d-1e2f-3a4b-5c6d7e8f9a0b",
      "type": "reflection",
      "content": {
        "text": "## Reflect on Process Mastery\n\n**Question 1**: You're analyzing a compromised system and find this process tree:\n```\nexplorer.exe (PID 2000)\n└── chrome.exe (PID 3000)\n└── wscript.exe (PID 3100)\n└── powershell.exe (PID 3200, CommandLine: -EncodedCommand [base64])\n└── rundll32.exe (PID 3300)\n```\nWalk through this chain. What happened? What's suspicious? How did the infection likely occur?\n\n**Question 2**: You use Process Explorer to examine svchost.exe (PID 1500) and find:\n- Memory region at 0x02A00000, size 4MB, protection: RWX\n- Region not associated with any loaded DLL\n- Process has unexpected network connection to unknown IP\nWhat attack technique does this indicate? What would you do next?\n\n**Question 3**: Sysmon alert shows:\n```\nEvent ID: 10 (ProcessAccess)\nSource Process: mimikatz.exe (PID 4000)\nTarget Process: lsass.exe (PID 600)\nGranted Access: 0x1010 (PROCESS_QUERY_INFORMATION | PROCESS_VM_READ)\n```\nWhat is the attacker doing? What credentials might be at risk? How would you respond?\n\n**Question 4**: You discover a service running with these properties:\n- Service Name: WindowsUpdateAssistant\n- ImagePath: C:\\Windows\\Temp\\svchost.exe\n- User: SYSTEM\n- Start Type: Automatic\nWhat's wrong here? (Multiple issues!) How would an attacker have created this?\n\n**Question 5**: Design a detection strategy for process injection in your environment:\n- What Sysmon events would you monitor?\n- What behavioral indicators would you alert on?\n- How would you distinguish false positives from true attacks?\n- What response actions would you automate?\n\nThinking through these scenarios builds incident response instincts."
      }
    }
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand process architecture including memory space, security tokens, handles, and threads",
    "Identify critical Windows processes and recognize normal parent-child relationships",
    "Analyze process trees to detect malicious execution chains",
    "Recognize process injection techniques (DLL injection, hollowing, reflective DLL, APC)",
    "Detect malicious processes using behavioral analysis and Sysmon monitoring",
    "Understand access tokens and privilege escalation via token impersonation",
    "Perform hands-on process analysis using PowerShell, Process Explorer, and Sysmon"
  ],
  "post_assessment": [
    {
      "question": "What components make up a Windows process?",
      "type": "multiple_choice",
      "options": [
        "Only executable code and a process ID",
        "Executable code, virtual address space, security token, handles, threads, and process ID",
        "Just threads and memory",
        "Registry keys and network connections"
      ],
      "correct_answer": "Executable code, virtual address space, security token, handles, threads, and process ID",
      "explanation": "A complete Windows process consists of executable code (program instructions), virtual address space (memory regions), security token (user/privileges), handles (resources), one or more threads (execution units), and a unique process ID. This is more than just code and memory - it's a complete execution environment.",
      "question_id": "ff73559d-1fd1-4dae-9487-f26da5382d1e",
      "difficulty": 2
    },
    {
      "question": "Why is the parent-child process relationship important for security monitoring?",
      "type": "multiple_choice",
      "options": [
        "It determines process priority and CPU scheduling",
        "It reveals execution chains and can identify suspicious process spawning patterns",
        "It controls network access permissions",
        "It has no security relevance"
      ],
      "correct_answer": "It reveals execution chains and can identify suspicious process spawning patterns",
      "explanation": "Parent-child relationships show how processes were created and reveal attack chains. For example, winword.exe→cmd.exe→powershell.exe indicates macro malware. Normal chains like explorer.exe→chrome.exe are expected. Monitoring these relationships detects malicious execution patterns. It's unrelated to CPU scheduling or network permissions.",
      "question_id": "2b28e56f-ef17-4f54-bc34-f6e5267886bd",
      "difficulty": 2
    },
    {
      "question": "What is process hollowing and why is it effective for malware?",
      "type": "multiple_choice",
      "options": [
        "Deleting process memory to cause crashes",
        "Creating a legitimate process, unmapping its code, injecting malicious code, so the process appears legitimate but runs malware",
        "Removing processes from Task Manager visibility",
        "Encrypting process memory to evade detection"
      ],
      "correct_answer": "Creating a legitimate process, unmapping its code, injecting malicious code, so the process appears legitimate but runs malware",
      "explanation": "Process hollowing creates a legitimate process (e.g., svchost.exe) in suspended state, unmaps the original code, injects malicious code, then resumes. The process appears as legitimate svchost.exe in Task Manager but executes malware. This evades detection because the process name/path seem normal, but the actual executing code is malicious.",
      "question_id": "8eea9404-17a1-40c8-b627-eacb2913d909",
      "difficulty": 2
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "meta_learning",
    "minimum_effective_dose",
    "teach_like_im_10",
    "memory_hooks",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ]
}