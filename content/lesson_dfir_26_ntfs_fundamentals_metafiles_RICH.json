{
  "lesson_id": "e5d18e0d-9cda-4769-9589-395cbadcafed",
  "domain": "dfir",
  "title": "NTFS Fundamentals and Metafiles",
  "difficulty": 2,
  "order_index": 26,
  "prerequisites": [
    "562b03ba-4337-4056-8028-ef4c4dd933f2"
  ],
  "concepts": [
    "NTFS File System Structure",
    "Master File Table (MFT)",
    "NTFS Metafiles",
    "File System Metadata",
    "Cluster and Sector Basics",
    "NTFS Attributes",
    "Resident vs Non-Resident Data",
    "$MFT, $MFTMirr, $LogFile",
    "$Bitmap, $Boot, $BadClus",
    "NTFS Journaling"
  ],
  "estimated_time": 40,
  "learning_objectives": [
    "Understand NTFS file system architecture and core concepts",
    "Identify and explain critical NTFS metafiles ($MFT, $LogFile, $Bitmap)",
    "Distinguish between resident and non-resident file data",
    "Analyze NTFS attributes ($STANDARD_INFORMATION, $FILE_NAME, $DATA)",
    "Understand cluster allocation and file fragmentation",
    "Explain NTFS journaling for change tracking",
    "Locate and interpret $MFT entries",
    "Use NTFS knowledge for forensic timeline analysis",
    "Identify deleted files through MFT analysis",
    "Apply NTFS fundamentals to filesystem forensics"
  ],
  "post_assessment": [
    {
      "question_id": "q26_1",
      "type": "multiple_choice",
      "difficulty": 2,
      "question": "A file is 500 bytes. NTFS cluster size is 4096 bytes. How much disk space does this file consume?",
      "options": [
        "500 bytes",
        "512 bytes (one sector)",
        "4096 bytes (one cluster)",
        "8192 bytes (two clusters)"
      ],
      "correct_answer": 2,
      "explanation": "NTFS allocates space in CLUSTERS (default 4096 bytes = 4 KB), not individual bytes. Even a 1-byte file consumes an entire 4 KB cluster (slack space = 4095 bytes unused). This is critical for forensics: (1) **Slack space** may contain remnants of previously deleted files, (2) **Actual file size** vs. **size on disk** differs (500 bytes file = 4096 bytes on disk), (3) Small files (<~700 bytes on NTFS) can be **resident** (stored entirely within MFT entry, consuming ZERO clusters). Forensic implications: File carving must account for cluster boundaries, slack space analysis reveals deleted data, resident files don't appear in $Bitmap (cluster allocation map). Exception: If file is resident (stored in MFT), it consumes 0 clusters but still takes MFT entry space."
    },
    {
      "question_id": "q26_2",
      "type": "multiple_choice",
      "difficulty": 2,
      "question": "What is the PRIMARY forensic value of the $LogFile metafile?",
      "options": [
        "Lists all files and directories on the volume",
        "Records recent filesystem transactions for recovery and forensic timeline reconstruction",
        "Stores deleted file content",
        "Maps bad sectors on the hard drive"
      ],
      "correct_answer": 1,
      "explanation": "$LogFile is NTFS's transaction journal recording ALL filesystem changes: (1) File creation, modification, deletion, (2) Directory changes, (3) Metadata updates (timestamps, permissions). Forensic value: **Timeline reconstruction** - $LogFile can show file activity BETWEEN volume shadow copies or after MFT entries are overwritten. Example: Attacker deletes malware at 14:30, but MFT entry is reallocated at 14:35. MFT shows NO evidence (overwritten), but $LogFile retains transaction record showing file deletion at 14:30 with original filename. Limitations: (1) $LogFile is circular (overwrites old entries, typically retains hours to days), (2) Contains metadata changes, not file content, (3) Complex binary format requires specialized parsers (LogFileParser, NTFS Log Tracker). Don't confuse with Event Logs (application/security events) - $LogFile is purely filesystem changes."
    },
    {
      "question_id": "q26_3",
      "type": "multiple_choice",
      "difficulty": 3,
      "question": "MFT entry shows: $STANDARD_INFORMATION Modified=2024-03-18 14:30:00, $FILE_NAME Modified=2024-03-15 10:00:00 (3 days earlier). What does this indicate?",
      "options": [
        "MFT corruption requiring repair",
        "File was timestomped (anti-forensics)",
        "Normal behavior when file is moved between directories",
        "Volume Shadow Copy restoration occurred"
      ],
      "correct_answer": 1,
      "explanation": "Discrepancy between $STANDARD_INFORMATION (SI) and $FILE_NAME (FN) timestamps = TIMESTOMPING DETECTION: (1) $SI timestamps are EASY to modify (SetFileTime API, touch commands, timestomp tools), (2) $FN timestamps are HARD to modify (require direct NTFS manipulation or driver-level access), (3) Attackers typically only modify $SI, leaving $FN original. Forensic workflow: ALWAYS compare both attributes. If $SI Modified < $FN Modified (SI shows OLDER timestamp) = definite timestomping. In this example: File truly modified March 18 (FN reflects reality), but attacker changed $SI to March 15 (fake older timestamp to hide recent changes). Why attackers timestomp: Hide malware creation dates, make files appear legitimate/old, evade timeline-based detection. Legitimate scenarios where SI ‚â† FN: File COPY (FN preserves source timestamps, SI updates to copy time), but copy shows SI NEWER, not older. Always trust $FILE_NAME for original timestamps."
    },
    {
      "question_id": "q26_4",
      "type": "multiple_choice",
      "difficulty": 2,
      "question": "A file's $DATA attribute is 'non-resident'. What does this mean?",
      "options": [
        "File data is stored in external storage (USB, cloud)",
        "File data is stored in clusters on disk (outside MFT entry)",
        "File has been deleted",
        "File is encrypted"
      ],
      "correct_answer": 1,
      "explanation": "**Non-resident** data = file content stored in CLUSTERS on disk (separate from MFT entry), MFT entry contains POINTERS (data runs) to cluster locations. **Resident** data = file content stored DIRECTLY inside MFT entry (small files < ~700 bytes). Forensic implications: (1) **Resident files**: Entire file recoverable from MFT even if clusters are overwritten (MFT is more persistent), (2) **Non-resident files**: Must locate clusters using data runs, clusters may be reallocated to other files (harder recovery), (3) **Deleted files**: Resident data often survives longer (MFT entries reused slower than clusters). Example: 200-byte text file (malware config) stored resident = recoverable from MFT carving even after 'secure delete'. 5 MB executable stored non-resident = requires cluster recovery (file carving from unallocated space). Tool: MFTECmd shows resident/non-resident status in output CSV."
    },
    {
      "question_id": "q26_5",
      "type": "scenario",
      "difficulty": 3,
      "question": "You're analyzing $MFT. Entry #42 shows: InUse=FALSE, FileName='malware.exe', $SI Created=2024-03-18 09:45. What can you conclude?",
      "options": [
        "malware.exe currently exists on the filesystem",
        "malware.exe was deleted, but MFT entry persists with metadata (recoverable evidence)",
        "MFT entry is corrupted and unreliable",
        "This is a false positive from MFT parser"
      ],
      "correct_answer": 1,
      "explanation": "**InUse=FALSE** (or FILE_RECORD_SEGMENT_IN_USE flag = 0) = DELETED FILE with MFT entry still allocated. This is forensic GOLD: (1) Filename preserved ('malware.exe'), (2) Timestamps preserved ($SI Created = 2024-03-18 09:45 shows when file was created), (3) File size, attributes, data run pointers may be intact. Recovery potential: (A) If resident file: Content still in MFT entry (immediate recovery), (B) If non-resident: Data run pointers show which clusters contained file - check if clusters are unallocated (recoverable via file carving), (C) If clusters reallocated: File content lost, but METADATA (name, timestamps, size) proves file existed. Investigative value: Proves 'malware.exe' existed on 2024-03-18 at 09:45 even if attacker deleted it. Cross-reference: Check Prefetch for MALWARE.EXE execution, AmCache for SHA-1 hash, ShimCache for path. MFT entry reallocation: Eventually, InUse flag will be set to TRUE for NEW file, overwriting malware.exe metadata (race against time for evidence collection). Parse ENTIRE $MFT to find all InUse=FALSE entries (deleted file catalog)."
    }
  ],
  "jim_kwik_principles": [
    "teach_like_im_10",
    "memory_hooks",
    "connect_to_what_i_know",
    "active_learning",
    "meta_learning",
    "minimum_effective_dose",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "explanation",
      "content": {
        "text": "# NTFS Fundamentals and Metafiles\n\n## Opening: The Foundation of Filesystem Forensics\n\nYou've mastered execution artifacts (Prefetch, Registry, SRUM). Now you're learning the FILESYSTEM layer‚Äîwhere files actually live, how they're stored, and what happens when they're deleted.\n\n**Why NTFS matters**:\n- **Every file operation** leaves NTFS metadata (creation, modification, deletion)\n- **Deleted files** persist in MFT (Master File Table) long after deletion\n- **Timestamps** in NTFS reveal file history and detect anti-forensics\n- **Slack space** and unallocated clusters contain remnants of deleted data\n\n**Real-world impact**: In a 2023 ransomware case, MFT analysis revealed 12,000 deleted files with original timestamps, reconstructing the complete encryption timeline‚Äîeven though files were 'permanently' deleted.\n\nLet's master NTFS.\n\n---\n\n## Part 1: NTFS Architecture Basics\n\n### Storage Hierarchy\n\n**Physical structure** (bottom-up):\n\n1. **Sector**: Smallest physical unit (512 bytes traditional, 4096 bytes Advanced Format)\n2. **Cluster**: NTFS allocation unit (default 4096 bytes = 8 sectors on 512-byte drives)\n3. **File**: Consumes one or more clusters\n4. **Volume**: Entire partition (C:, D:, E:)\n\n**Memory hook**: **\"S-C-F-V\"** = Sector ‚Üí Cluster ‚Üí File ‚Üí Volume\n\n### Cluster Allocation\n\n**Example**: File sizes vs. disk consumption\n\n| File Size | Clusters Used | Disk Space | Slack Space |\n|---|---|---|---|\n| 100 bytes | 1 | 4096 bytes | 3996 bytes |\n| 4096 bytes | 1 | 4096 bytes | 0 bytes |\n| 4097 bytes | 2 | 8192 bytes | 4095 bytes |\n| 10,000 bytes | 3 | 12,288 bytes | 2288 bytes |\n\n**Slack space** = Unused portion of final cluster\n\n**Forensic value**: Slack space may contain:\n- Fragments of previously deleted files\n- Remnants of wiped data\n- RAM dumps (pagefile slack)\n\n### Resident vs. Non-Resident Files\n\n**Resident files** (small files):\n- **Size**: < ~700 bytes (depends on MFT entry overhead)\n- **Storage**: Entire file content stored INSIDE MFT entry\n- **Benefit**: Faster access (no cluster reads needed)\n- **Forensic**: File recoverable from MFT even if clusters overwritten\n\n**Non-resident files** (large files):\n- **Size**: > ~700 bytes\n- **Storage**: Content in clusters, MFT entry contains POINTERS (data runs)\n- **Benefit**: Efficient for large files\n- **Forensic**: Must locate clusters using data runs\n\n**Example**:\n```\nFile: config.txt (200 bytes)\nStorage: Resident (entire content in MFT entry)\nRecovery: Parse MFT, extract $DATA attribute ‚Üí instant recovery\n\nFile: malware.exe (2.5 MB)\nStorage: Non-resident (clusters 1000-1500)\nRecovery: Parse MFT for data runs ‚Üí locate clusters ‚Üí carve file\n```\n\n---\n\n## Part 2: The Master File Table (MFT)\n\n### What is the MFT?\n\n**MFT** = Master File Table = Database of ALL files and directories on NTFS volume\n\n**Structure**:\n- **Entry size**: 1024 bytes (fixed)\n- **Entry #0**: $MFT (the MFT file itself - meta!)\n- **Entry #1-15**: System metafiles ($MFTMirr, $LogFile, $Bitmap, etc.)\n- **Entry #16+**: User files and directories\n\n**Location**: Typically at the beginning of volume, but can be fragmented\n\n**MFT entry format**:\n```\n[Header: 42 bytes]\n  Signature: FILE\n  Flags: InUse (0x01 = active, 0x00 = deleted)\n  Sequence Number: Increments each time entry is reused\n  \n[Attributes: Variable]\n  $STANDARD_INFORMATION (timestamps, permissions)\n  $FILE_NAME (filename, parent directory, timestamps)\n  $DATA (file content or pointers to clusters)\n  [... other attributes ...]\n```\n\n### Critical MFT Attributes\n\n**$STANDARD_INFORMATION** ($SI):\n```\nCreated: 2024-03-18 09:45:00\nModified: 2024-03-18 14:30:00\nAccessed: 2024-03-18 15:20:00\nMFT Modified: 2024-03-18 14:30:00\nPermissions: 0x20 (Archive)\nOwner SID: S-1-5-21-...\n```\n\n**Easy to modify** (timestomping target)\n\n**$FILE_NAME** ($FN):\n```\nFilename: malware.exe\nParent Directory: MFT Entry #500 (C:\\Users\\Public)\nCreated: 2024-03-18 09:45:00\nModified: 2024-03-18 14:30:00\nAccessed: 2024-03-18 15:20:00\nMFT Modified: 2024-03-18 14:30:00\nFile Size: 2,560,000 bytes\n```\n\n**Hard to modify** (trusted for forensics)\n\n**$DATA**:\n- **Resident**: Contains actual file content\n- **Non-resident**: Contains data runs (cluster locations)\n\n**Data runs example**:\n```\nRun 1: Clusters 1000-1050 (50 clusters = 204,800 bytes)\nRun 2: Clusters 2000-2100 (100 clusters = 409,600 bytes)\nTotal: 614,400 bytes\n```\n\nFile is fragmented (stored in non-contiguous clusters).\n\n---\n\n## Part 3: NTFS Metafiles\n\n### The Critical 16\n\nFirst 16 MFT entries are RESERVED for system metafiles:\n\n**$MFT** (Entry 0):\n- The Master File Table file itself\n- Contains all MFT entries (including itself - recursive!)\n- **Forensic use**: Parse to enumerate ALL files (including deleted)\n\n**$MFTMirr** (Entry 1):\n- Mirror/backup of first 4 MFT entries\n- Located in middle of volume\n- **Forensic use**: Recovery if $MFT corrupted\n\n**$LogFile** (Entry 2):\n- Transaction journal (filesystem changes)\n- Records: File creation, deletion, modification, renames\n- **Forensic use**: Timeline reconstruction, deleted file recovery\n- **Retention**: Circular buffer (hours to days)\n\n**$Volume** (Entry 3):\n- Volume information (name, version, NTFS version)\n\n**$AttrDef** (Entry 4):\n- Attribute definitions (describes attribute types)\n\n**. (dot)** (Entry 5):\n- Root directory (C:\\)\n\n**$Bitmap** (Entry 6):\n- Cluster allocation map (1 bit per cluster)\n- **0** = Unallocated (available)\n- **1** = Allocated (in use)\n- **Forensic use**: Identify unallocated space for file carving\n\n**$Boot** (Entry 7):\n- Boot sector (bootloader code)\n- **Forensic use**: Detect bootkits, MBR malware\n\n**$BadClus** (Entry 8):\n- List of bad clusters (physical disk errors)\n- **Forensic use**: Attackers sometimes hide data in 'bad' clusters\n\n**$Secure** (Entry 9):\n- Security descriptors (ACLs for all files)\n\n**$UpCase** (Entry 10):\n- Uppercase conversion table (for case-insensitive filenames)\n\n**$Extend** (Entry 11):\n- Extended attributes directory\n- Contains: $UsnJrnl, $Quota, $ObjId, $Reparse\n\n---\n\n## Part 4: NTFS Journaling ($LogFile)\n\n### How $LogFile Works\n\n**Purpose**: Ensure filesystem consistency after crashes\n\n**Mechanism**: \n1. Before filesystem change (file creation, delete, modify), write to $LogFile\n2. Perform actual filesystem operation\n3. Mark transaction complete in $LogFile\n4. If crash occurs, replay $LogFile on reboot to complete/rollback incomplete operations\n\n**Forensic value**: $LogFile preserves evidence of filesystem operations even after files are deleted and MFT entries are reused.\n\n### $LogFile Structure\n\n**Two areas**:\n1. **$DATA:$Restart**: Restart area (recovery metadata)\n2. **$DATA:$LogFile**: Actual transaction log\n\n**Transaction records**:\n```\nLSN (Log Sequence Number): 0x12345678\nOperation: CreateFile\nFilename: C:\\Users\\Public\\malware.exe\nMFT Entry: 42\nTimestamp: 2024-03-18 09:45:00.123\nRecord Length: 512 bytes\n```\n\n**Retention**: Circular buffer (oldest entries overwritten)\n- Small volumes: Hours\n- Large volumes: Days to weeks\n\n### Parsing $LogFile\n\n**Tools**:\n- **NTFS Log Tracker** (commercial)\n- **LogFileParser** (Python, open-source)\n- **MFTECmd** (Eric Zimmerman, limited $LogFile support)\n\n**Forensic workflow**:\n1. Extract $LogFile from evidence image\n2. Parse with LogFileParser\n3. Filter by operation type (CreateFile, DeleteFile, SetInformation)\n4. Correlate timestamps with MFT, Prefetch, Event Logs\n\n**Example findings**:\n```\n09:45:00 | CreateFile | C:\\Users\\Public\\malware.exe (MFT #42)\n09:47:00 | SetInformation | C:\\Users\\Public\\malware.exe (timestamp change)\n14:30:00 | DeleteFile | C:\\Users\\Public\\malware.exe (MFT #42)\n14:35:00 | CreateFile | C:\\Users\\Public\\document.txt (MFT #42 reused)\n```\n\nMFT #42 now shows document.txt (malware.exe metadata overwritten), but $LogFile proves malware.exe existed and was deleted at 14:30:00.\n\n---\n\n## Part 5: $Bitmap and Unallocated Space\n\n### Understanding $Bitmap\n\n**$Bitmap** = Map of cluster allocation status\n\n**Structure**: Bit array (1 bit per cluster)\n- **Bit 0**: Cluster 0 status (1=allocated, 0=free)\n- **Bit 1**: Cluster 1 status\n- **Bit N**: Cluster N status\n\n**Size calculation**:\n```\nVolume: 500 GB\nCluster size: 4096 bytes\nTotal clusters: 500 GB / 4 KB = 128,000,000 clusters\nBitmap size: 128,000,000 bits / 8 = 16,000,000 bytes = 15.26 MB\n```\n\n### Forensic Use Cases\n\n**1. Identify unallocated space**\n\nFor file carving:\n```\nClusters 0-999: Allocated (1s in bitmap)\nClusters 1000-5000: Unallocated (0s in bitmap) ‚Üê Carve this region\nClusters 5001-10000: Allocated\n```\n\nFile carving tools (PhotoRec, Scalpel) scan unallocated clusters for file signatures.\n\n**2. Detect wiping tools**\n\nSecure delete tools (sdelete, BleachBit) overwrite clusters and mark as unallocated. Timeline:\n```\n14:30:00 | File deleted (MFT InUse=FALSE)\n14:30:05 | Clusters 1000-1050 marked unallocated (bitmap 1‚Üí0)\n14:30:10 | Clusters overwritten with zeros (anti-forensics)\n```\n\n**3. Identify sparse files**\n\nFiles with 'holes' (unallocated clusters in middle):\n```\nFile: database.db (10 GB logical size)\nAllocated clusters: 1000-2000, 5000-6000\nUnallocated clusters: 2001-4999 (sparse region - never written)\nActual disk usage: 8 GB\n```\n\nForensic implication: Sparse regions contain zeros or remnants of previous files.\n\n---\n\n## Part 6: Practical NTFS Analysis\n\n### Extracting $MFT\n\n**Method 1: Live system** (RawCopy)\n```cmd\nRawCopy.exe /FileNamePath:C:\\$MFT /OutputPath:C:\\Evidence\n```\n\nExtracts $MFT even though it's in-use.\n\n**Method 2: Forensic image** (FTK Imager, dd)\n```bash\nicat evidence.dd 0 > MFT\n```\n\nicat (Sleuth Kit) extracts MFT using entry #0.\n\n**Method 3: Mounted image** (Arsenal Image Mounter)\n```\nMount: evidence.E01 as X:\nCopy: X:\\$MFT to Evidence folder\n```\n\n### Parsing $MFT\n\n**Tool: MFTECmd** (Eric Zimmerman)\n\n```cmd\nMFTECmd.exe -f \"C:\\Evidence\\$MFT\" --csv \"C:\\Output\" --csvf MFT_parsed.csv\n```\n\n**Output columns** (key fields):\n```csv\nEntryNumber,InUse,FileName,ParentPath,FileSize,Created,Modified,Accessed,MFTModified,IsDirectory\n42,FALSE,malware.exe,C:\\Users\\Public,2560000,2024-03-18 09:45:00,2024-03-18 14:30:00,2024-03-18 15:20:00,2024-03-18 14:30:00,FALSE\n```\n\n**Analysis**:\n- **InUse=FALSE**: Deleted file\n- **Created**: 09:45:00 (infection time)\n- **Modified**: 14:30:00 (last activity before deletion)\n- **Size**: 2.56 MB (helps identify file type)\n\n### Finding Deleted Files\n\n**Filter MFT output**:\n```\nInUse = FALSE\nAND FileName NOT LIKE '$%'  (exclude system files)\nAND FileSize > 0\n```\n\n**Sort by Modified descending** (recently deleted files first)\n\n**Example findings**:\n```\nEntry 42: malware.exe (2.56 MB, deleted 14:30:00)\nEntry 105: credentials.txt (1.2 KB, deleted 14:32:00)\nEntry 201: exfil.zip (450 MB, deleted 14:45:00)\n```\n\n**Cross-reference**:\n- Prefetch for malware.exe execution\n- AmCache for credentials.txt hash\n- SRUM for network transfer matching exfil.zip size\n\n---\n\n## Part 7: Timestomping Detection\n\n### Comparing $SI vs. $FN Timestamps\n\n**Normal scenario** (file modified legitimately):\n```\n$STANDARD_INFORMATION:\n  Modified: 2024-03-18 14:30:00\n  \n$FILE_NAME:\n  Modified: 2024-03-18 14:30:00\n```\n\nTimestamps match (no tampering).\n\n**Timestomping scenario** (attacker fakes timestamps):\n```\n$STANDARD_INFORMATION:\n  Modified: 2024-01-15 10:00:00  ‚Üê Fake (3 months old)\n  \n$FILE_NAME:\n  Modified: 2024-03-18 14:30:00  ‚Üê Real (recent)\n```\n\n$SI shows older timestamp (attacker tried to hide recent modification).\n\n**Detection rule**:\n```\nIF $SI.Modified < $FN.Modified THEN\n  Flag = Timestomping suspected\nEND IF\n```\n\n**Investigative steps**:\n1. Export MFT with MFTECmd (includes both $SI and $FN timestamps)\n2. Calculate difference: $FN.Modified - $SI.Modified\n3. Filter for differences > 1 hour (allow for clock skew)\n4. Review flagged files for suspicious names/paths\n\n**Timestomping tools** (attackers use):\n- timestomp.exe (Metasploit)\n- PowerShell Set-ItemProperty -Path file.exe -Name LastWriteTime\n- touch command (Unix-like)\n\n---\n\n## Closing: You've Mastered NTFS Fundamentals\n\nCongratulations! You now understand:\n\n‚úÖ NTFS architecture (sectors, clusters, allocation)\n‚úÖ Master File Table structure and attributes\n‚úÖ Critical metafiles ($MFT, $LogFile, $Bitmap)\n‚úÖ Resident vs. non-resident data\n‚úÖ $LogFile transaction journaling\n‚úÖ Deleted file detection (InUse=FALSE)\n‚úÖ Timestomping detection ($SI vs. $FN comparison)\n‚úÖ MFT extraction and parsing (MFTECmd)\n\n**Foundation built**: This lesson is the prerequisite for:\n- **Lesson 27**: MFT Analysis (deep dive into timeline analysis)\n- **Lesson 28**: MACB Timestamps (Modified, Accessed, Changed, Born)\n- **Lesson 29**: USN Journal (detailed change tracking)\n\n**Next lesson**: **Master File Table (MFT) Analysis** - Apply NTFS knowledge to build comprehensive file timelines and detect deleted evidence.\n\n**Practice**: Extract $MFT from your own C: drive (RawCopy), parse with MFTECmd, explore your filesystem metadata. Find deleted files in your MFT!\n\nYou're building world-class filesystem forensics skills. Keep going! üìÅ"
      }
    }
  ],
  "tags": [
    "Course: 13Cubed-Investigating Windows Endpoints"
  ]
}