{
  "lesson_id": "d7e6b4c3-a9f8-4e2d-9b1c-7f8a3d5e6c92",
  "domain": "malware",
  "title": "Advanced Static Analysis: Reverse Engineering Malware",
  "difficulty": 3,
  "order_index": 4,
  "prerequisites": [
    "malware_02"
  ],
  "concepts": [
    "IDA Pro and Ghidra Deep Dive",
    "Assembly Language (x86/x64)",
    "Function Call Conventions",
    "API Hooking Detection",
    "String Obfuscation Techniques",
    "Packed Malware Analysis",
    "Control Flow Graph Analysis",
    "Cryptographic Algorithm Identification",
    "Malware Configuration Extraction",
    "YARA Rule Development"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Master IDA Pro and Ghidra for disassembly and decompilation of malware",
    "Read and understand x86/x64 assembly code in malware samples",
    "Identify common malware behaviors through static code analysis",
    "Detect and analyze code obfuscation and packing techniques",
    "Extract malware configurations (C2 servers, encryption keys, persistence mechanisms)",
    "Develop YARA rules for malware family detection",
    "Analyze control flow graphs to understand malware logic",
    "Identify cryptographic algorithms in malware binaries"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "🔬 **Welcome to Advanced Static Analysis: The Art of Reading Malware's Mind**\n\nImagine you've captured a burglar, but they won't talk. You can't interrogate them (that would be dynamic analysis), but you CAN examine their tools, read their notes, and study their planning documents. **Static analysis** is exactly that—examining malware *without executing it*, reading its code like a detective reading a criminal's diary.\n\n**Why This Matters**: Static analysis allows you to:\n- Understand malware capabilities WITHOUT the risk of execution\n- Extract IOCs (C2 servers, file paths, registry keys) for threat hunting\n- Identify malware families and attribute attacks\n- Develop detection signatures (YARA rules) to protect your organization\n- Find vulnerabilities in the malware itself (for takedowns or countermeasures)\n\n**The Challenge**: Malware authors don't want you reading their code. They use:\n- **Obfuscation**: Scrambling strings and logic\n- **Packing**: Compressing/encrypting the entire binary\n- **Anti-disassembly**: Tricks to break reverse engineering tools\n\n**Jim Kwik Principle - The Power of Persistence**: Reverse engineering is hard. Your first malware sample might take 8 hours to analyze. Your 50th might take 1 hour. The key is persistence—keep analyzing, keep learning assembly patterns, and you'll develop an intuition for spotting malicious code instantly.\n\n**Your Mission Today**: You'll learn to use IDA Pro and Ghidra (the industry's top reverse engineering tools), read assembly code like prose, defeat obfuscation, and extract secrets from malware binaries. By the end, you'll be able to open a malware sample and answer: \"What does it do? Where does it connect? How can we stop it?\" Let's reverse engineer like pros! 🚀"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## What is Advanced Static Analysis?\n\n**Advanced static analysis** is the deep examination of malware binaries using disassemblers and decompilers to understand their functionality without executing them.\n\n### Static vs Dynamic Analysis\n\n| Aspect | Static Analysis | Dynamic Analysis |\n|--------|----------------|------------------|\n| **Execution** | No execution | Malware runs in sandbox |\n| **Safety** | Very safe | Risk of sandbox escape |\n| **Speed** | Can be slow (manual) | Fast (automated) |\n| **Depth** | Complete code coverage | Only executed paths |\n| **Obfuscation** | Harder (can't unpack easily) | Easier (self-unpacking) |\n| **Anti-Analysis** | Immune to VM detection | Can be detected |\n| **Tools** | IDA Pro, Ghidra, Binary Ninja | Cuckoo, ANY.RUN, REMnux |\n\n**Best Practice**: Use BOTH. Static analysis for deep understanding, dynamic analysis for quick triage and unpacking.\n\n### The Reverse Engineering Toolchain\n\n#### 1. Disassemblers\n\n**IDA Pro** (Industry Standard, Commercial):\n- Best-in-class decompiler (Hex-Rays)\n- Supports 50+ processor architectures\n- Interactive analysis (rename functions, add comments)\n- Plugin ecosystem (IDAPython scripting)\n- **Cost**: $1,800+ (Pro), free version available (IDA Free)\n\n**Ghidra** (Free, Open-Source, NSA-developed):\n- Powerful decompiler (rivals Hex-Rays)\n- Cross-platform (Windows, Linux, macOS)\n- Collaborative reverse engineering (multi-user)\n- Scripting (Java, Python)\n- **Cost**: FREE\n\n**Binary Ninja** (Commercial, Modern UI):\n- Fast analysis engine\n- Beautiful UI/UX\n- Intermediate Language (BNIL) for analysis\n- **Cost**: $399+ (Personal)\n\n**Recommendation for Learning**: Start with Ghidra (free, powerful). Learn IDA Pro if your employer provides a license.\n\n#### 2. Hex Editors\n\n- **HxD** (Windows): View/edit raw binary data\n- **010 Editor**: Templates for parsing file formats (PE, ELF, etc.)\n- **ImHex**: Modern, cross-platform hex editor\n\n#### 3. PE Analyzers (Windows Executables)\n\n- **PE-bear**: Interactive PE header viewer\n- **CFF Explorer**: In-depth PE structure analysis\n- **PEview**: Lightweight PE viewer\n- **Detect It Easy (DIE)**: Packer/compiler detection\n\n#### 4. String Extractors\n\n- **FLOSS** (FireEye Labs Obfuscated String Solver): Decodes obfuscated strings\n- **strings** (Unix command): Extract ASCII/Unicode strings\n- **BinText**: Windows strings viewer\n\n#### 5. Debuggers (For Dynamic Static Hybrid)\n\n- **x64dbg**: Modern Windows debugger\n- **WinDbg**: Microsoft's kernel debugger\n- **OllyDbg**: Classic Windows debugger (32-bit)\n\n### x86/x64 Assembly Crash Course\n\nYou don't need to be an assembly expert, but you MUST recognize common patterns.\n\n#### Essential Registers (x86)\n\n```\nEAX - Accumulator (return values, arithmetic)\nEBX - Base (general purpose)\nECX - Counter (loops)\nEDX - Data (I/O, arithmetic overflow)\nESI - Source Index (string ops)\nEDI - Destination Index (string ops)\nESP - Stack Pointer (current stack position)\nEBP - Base Pointer (stack frame base)\nEIP - Instruction Pointer (next instruction address)\n```\n\n**x64 Extensions**: RAX, RBX, RCX, RDX (64-bit versions), plus R8-R15 (additional registers)\n\n#### Common Instructions\n\n**Data Movement**:\n```assembly\nmov eax, 5         ; EAX = 5 (load immediate value)\nmov eax, [ebx]     ; EAX = value at memory address EBX (load from memory)\nmov [ebx], eax     ; Memory at EBX = EAX (store to memory)\npush eax           ; Push EAX onto stack\npop ebx            ; Pop top of stack into EBX\n```\n\n**Arithmetic**:\n```assembly\nadd eax, 10        ; EAX = EAX + 10\nsub eax, 5         ; EAX = EAX - 5\nimul eax, 2        ; EAX = EAX * 2\nidiv ebx           ; EAX = EAX / EBX (quotient), EDX = remainder\ninc eax            ; EAX = EAX + 1\ndec eax            ; EAX = EAX - 1\n```\n\n**Logical Operations**:\n```assembly\nand eax, 0xFF      ; EAX = EAX & 0xFF (bitwise AND, often used for masking)\nor eax, 1          ; EAX = EAX | 1 (bitwise OR)\nxor eax, eax       ; EAX = 0 (XOR reg with itself = zero, faster than mov eax, 0)\nnot eax            ; EAX = ~EAX (bitwise NOT)\nshl eax, 2         ; EAX = EAX << 2 (shift left, multiply by 4)\nshr eax, 1         ; EAX = EAX >> 1 (shift right, divide by 2)\n```\n\n**Control Flow**:\n```assembly\njmp 0x401000       ; Unconditional jump to address 0x401000\ncall 0x402000      ; Call function at 0x402000 (push return address, jump)\nret                ; Return from function (pop return address, jump to it)\ncmp eax, 10        ; Compare EAX with 10 (sets flags)\nje 0x403000        ; Jump if Equal (ZF=1)\njne 0x404000       ; Jump if Not Equal (ZF=0)\njg 0x405000        ; Jump if Greater (signed)\njl 0x406000        ; Jump if Less (signed)\n```\n\n**Function Calls**:\n```assembly\n; Calling convention (cdecl - C calling convention)\npush 20            ; Push parameter 2\npush 10            ; Push parameter 1 (right-to-left)\ncall MyFunction    ; Call function\nadd esp, 8         ; Clean up stack (2 params * 4 bytes)\n\n; Inside MyFunction:\npush ebp           ; Save old base pointer\nmov ebp, esp       ; Set new base pointer\nsub esp, 16        ; Allocate 16 bytes for local variables\n; ... function code ...\nmov esp, ebp       ; Restore stack pointer\npop ebp            ; Restore old base pointer\nret                ; Return to caller\n```\n\n### Reading Decompiled Code\n\n**Ghidra/IDA Decompilers** translate assembly back to C-like pseudocode:\n\n**Assembly**:\n```assembly\nmov eax, [ebp+8]   ; Load parameter 1\nadd eax, [ebp+12]  ; Add parameter 2\nret                ; Return (result in EAX)\n```\n\n**Decompiled (Ghidra)**:\n```c\nint add_numbers(int param_1, int param_2) {\n  return param_1 + param_2;\n}\n```\n\n**Much easier to read!** But decompilers aren't perfect—sometimes you need to read assembly."
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "## Hands-On: Analyzing Malware with Ghidra\n\n### Setup: Install Ghidra\n\n```bash\n# Download from https://ghidra-sre.org/\n# Extract and run\ncd ghidra_10.4_PUBLIC\n./ghidraRun\n\n# Windows:\nghidraRun.bat\n```\n\n### Scenario: Analyze Unknown Malware Sample\n\n**Sample**: `suspicious.exe` (hypothetical banking trojan)\n\n### Step 1: Import Binary into Ghidra\n\n1. Create new project: File → New Project → Non-Shared Project\n2. Import file: File → Import File → Select `suspicious.exe`\n3. Analyze: Yes, analyze now → Use default analyzers → Analyze\n\n**Ghidra Analysis**:\n```\n[*] PE Loader: Detected Windows PE executable\n[*] Found entry point: 0x00401000\n[*] Identified 247 functions\n[*] Found 1,523 strings\n[*] Detected imports: kernel32.dll, ws2_32.dll, advapi32.dll\n```\n\n### Step 2: Examine Imports (What APIs Does It Use?)\n\n**Window → Symbol Tree → Imports**\n\n**Suspicious Imports**:\n```\nkernel32.dll:\n  - CreateRemoteThread  ← Injection!\n  - VirtualAllocEx      ← Injection!\n  - WriteProcessMemory  ← Injection!\n  - CreateMutexA        ← Mutex for single instance\n  \nws2_32.dll:\n  - WSAStartup          ← Network functionality\n  - socket, connect     ← Creates network connections\n  - send, recv          ← Sends/receives data (C2?)\n  \nadvapi32.dll:\n  - RegSetValueExA      ← Registry modification (persistence?)\n  - CryptEncrypt        ← Encryption (data exfil or ransomware?)\n```\n\n**Initial Assessment**: Malware likely performs:\n1. Process injection (CreateRemoteThread, VirtualAllocEx)\n2. Network communication (socket, connect - C2?)\n3. Registry persistence (RegSetValueExA)\n4. Data encryption (CryptEncrypt)\n\n### Step 3: Analyze Entry Point\n\n**CodeBrowser → Functions → entry**\n\nDouble-click `entry` to see disassembly and decompiled code.\n\n**Decompiled Code**:\n```c\nvoid entry(void) {\n  HANDLE hMutex;\n  DWORD dwResult;\n  \n  // Check if already running (mutex)\n  hMutex = CreateMutexA(NULL, FALSE, \"Global\\\\BankTrojan_Mutex_2025\");\n  if (GetLastError() == ERROR_ALREADY_EXISTS) {\n    return; // Exit if already running\n  }\n  \n  // Establish persistence\n  set_registry_persistence();\n  \n  // Decrypt configuration\n  decrypt_config();\n  \n  // Connect to C2\n  connect_to_c2();\n  \n  // Inject into browser\n  inject_into_process(\"firefox.exe\");\n  inject_into_process(\"chrome.exe\");\n}\n```\n\n**Key Findings**:\n1. **Mutex**: `Global\\\\BankTrojan_Mutex_2025` (IOC!)\n2. **Persistence**: Calls `set_registry_persistence()`\n3. **C2**: Calls `connect_to_c2()`\n4. **Injection**: Targets Firefox and Chrome (web injects for banking)\n\n### Step 4: Extract C2 Server (Decrypt Configuration)\n\n**Navigate to**: `decrypt_config()` function\n\n**Decompiled Code**:\n```c\nvoid decrypt_config(void) {\n  char encrypted_config[256] = {\n    0x47, 0x15, 0x33, 0x52, 0x1a, 0x3f, 0x62, 0x11,\n    // ... (encrypted bytes)\n  };\n  char decrypted_config[256];\n  int i;\n  \n  // XOR decryption with key 0x42\n  for (i = 0; i < 256; i++) {\n    decrypted_config[i] = encrypted_config[i] ^ 0x42;\n  }\n  \n  // decrypted_config now contains C2 URL\n}\n```\n\n**Manual Decryption** (Python):\n```python\nencrypted = bytes([0x47, 0x15, 0x33, 0x52, 0x1a, 0x3f, 0x62, 0x11, ...])\nkey = 0x42\n\ndecrypted = bytes([b ^ key for b in encrypted])\nprint(decrypted.decode('ascii', errors='ignore'))\n\n# Output: http://45.142.212.61:8080/gate.php\n```\n\n**IOC Extracted**: C2 server = `http://45.142.212.61:8080/gate.php`\n\n### Step 5: Analyze Injection Function\n\n**Navigate to**: `inject_into_process()` function\n\n**Decompiled Code**:\n```c\nvoid inject_into_process(char *process_name) {\n  HANDLE hProcess;\n  DWORD pid;\n  LPVOID remote_buffer;\n  char shellcode[1024] = { /* shellcode bytes */ };\n  \n  // Find target process\n  pid = find_process_by_name(process_name);\n  if (pid == 0) return;\n  \n  // Open process\n  hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);\n  \n  // Allocate memory in target\n  remote_buffer = VirtualAllocEx(hProcess, NULL, 1024, \n                                 MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n  \n  // Write shellcode to target\n  WriteProcessMemory(hProcess, remote_buffer, shellcode, 1024, NULL);\n  \n  // Execute shellcode via remote thread\n  CreateRemoteThread(hProcess, NULL, 0, \n                     (LPTHREAD_START_ROUTINE)remote_buffer, NULL, 0, NULL);\n}\n```\n\n**Analysis**: Classic DLL injection technique using CreateRemoteThread.\n\n**Extract Shellcode** (for analysis):\n```python\n# In Ghidra, right-click on shellcode array → Copy Special → Python Byte String\nshellcode = b\"\\x90\\x90\\x90\\x90...\"  # Extracted from Ghidra\n\n# Save to file for further analysis\nwith open('shellcode.bin', 'wb') as f:\n    f.write(shellcode)\n\n# Analyze with disassembler or emulator (e.g., Unicorn Engine)\n```\n\n### Step 6: Analyze Persistence Mechanism\n\n**Navigate to**: `set_registry_persistence()` function\n\n**Decompiled Code**:\n```c\nvoid set_registry_persistence(void) {\n  HKEY hKey;\n  char exe_path[MAX_PATH];\n  \n  // Get current executable path\n  GetModuleFileNameA(NULL, exe_path, MAX_PATH);\n  \n  // Copy to System32 (if admin)\n  CopyFileA(exe_path, \"C:\\\\Windows\\\\System32\\\\svchost32.exe\", FALSE);\n  \n  // Create Run key\n  RegOpenKeyExA(HKEY_LOCAL_MACHINE, \n                \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\",\n                0, KEY_WRITE, &hKey);\n  RegSetValueExA(hKey, \"WindowsUpdate\", 0, REG_SZ, \n                 (BYTE*)\"C:\\\\Windows\\\\System32\\\\svchost32.exe\", \n                 strlen(\"C:\\\\Windows\\\\System32\\\\svchost32.exe\") + 1);\n  RegCloseKey(hKey);\n}\n```\n\n**Findings**:\n1. **Copies itself** to `C:\\\\Windows\\\\System32\\\\svchost32.exe` (typosquatting `svchost.exe`)\n2. **Persistence**: Registry Run key `HKLM\\\\...\\\\Run\\\\WindowsUpdate`\n3. **Requires admin** (writes to System32 and HKLM)\n\n**IOCs**:\n- File: `C:\\\\Windows\\\\System32\\\\svchost32.exe`\n- Registry: `HKLM\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\\WindowsUpdate`\n\n### Step 7: Create YARA Rule\n\n```yara\nrule BankTrojan_2025 {\n  meta:\n    description = \"Detects banking trojan from Oct 2025 analysis\"\n    author = \"YourName\"\n    date = \"2025-10-27\"\n    \n  strings:\n    $mutex = \"Global\\\\BankTrojan_Mutex_2025\" ascii\n    $c2 = \"http://45.142.212.61:8080/gate.php\" ascii\n    $file = \"C:\\\\Windows\\\\System32\\\\svchost32.exe\" ascii wide\n    $reg = \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\" ascii wide\n    \n    // API sequence (injection pattern)\n    $api1 = \"VirtualAllocEx\" ascii\n    $api2 = \"WriteProcessMemory\" ascii\n    $api3 = \"CreateRemoteThread\" ascii\n    \n    // XOR decryption loop signature\n    $xor_decrypt = { 8A 04 0E 34 42 88 04 0F 41 81 F9 00 01 00 00 7C F0 }\n    // Translation: mov al, [esi+ecx]; xor al, 0x42; mov [edi+ecx], al; inc ecx; cmp ecx, 0x100; jl -0x10\n    \n  condition:\n    uint16(0) == 0x5A4D and  // MZ header\n    (\n      $mutex or\n      ($c2 and 2 of ($api*)) or\n      ($file and $reg) or\n      $xor_decrypt\n    )\n}\n```\n\n**Test YARA Rule**:\n```bash\nyara -s BankTrojan_2025.yar suspicious.exe\n\n# Output:\nBankTrojan_2025 suspicious.exe\n0x1234:$mutex: Global\\BankTrojan_Mutex_2025\n0x5678:$c2: http://45.142.212.61:8080/gate.php\n```\n\n### Summary of Findings\n\n```\n┌────────────────────────────────────────────────────────┐\n│           MALWARE ANALYSIS REPORT                      │\n├────────────────────────────────────────────────────────┤\n│ Sample: suspicious.exe                                 │\n│ Type: Banking Trojan (Process Injection)               │\n│                                                        │\n│ CAPABILITIES:                                          │\n│  - Process injection (Firefox, Chrome)                 │\n│  - C2 communication (HTTP)                             │\n│  - Registry persistence                                │\n│  - Data encryption                                     │\n│                                                        │\n│ IOCS:                                                  │\n│  - Mutex: Global\\BankTrojan_Mutex_2025                 │\n│  - C2: http://45.142.212.61:8080/gate.php              │\n│  - File: C:\\Windows\\System32\\svchost32.exe             │\n│  - Registry: HKLM\\...\\Run\\WindowsUpdate                │\n│                                                        │\n│ DETECTION:                                             │\n│  - YARA rule created (BankTrojan_2025.yar)             │\n│  - Network signature: HTTP POST to /gate.php           │\n│  - Behavioral: CreateRemoteThread + VirtualAllocEx     │\n└────────────────────────────────────────────────────────┘\n```"
      }
    },
    {
      "type": "quiz",
      "content": {
        "text": "## Knowledge Check: Advanced Static Analysis\n\n**Question 1**: You see assembly code: `xor eax, eax`. What does this do, and why do malware authors use it?\n\nA) EAX = EAX XOR EAX = 0 (it zeros the register, faster/smaller than mov eax, 0)  \nB) It encrypts the EAX register  \nC) It's a NOP (no operation) instruction  \nD) It causes an exception\n\n**Answer**: A) XOR of any value with itself = 0. Malware authors use this because it's 2 bytes (`31 C0`) vs 5 bytes for `mov eax, 0` (`B8 00 00 00 00`), making code smaller and potentially harder to detect.\n\n---\n\n**Question 2**: In Ghidra, you find imports for `CreateRemoteThread`, `VirtualAllocEx`, and `WriteProcessMemory`. What malware technique does this indicate?\n\nA) Keylogging  \nB) Process injection (DLL injection or code injection)  \nC) Network communication  \nD) File encryption\n\n**Answer**: B) This is the classic API sequence for process injection: VirtualAllocEx (allocate memory in target process) → WriteProcessMemory (write malicious code to target) → CreateRemoteThread (execute the code). This allows malware to run inside legitimate processes.\n\n---\n\n**Question 3**: You find encrypted strings in malware that are decrypted with a simple XOR loop (key = 0x42). How would you decrypt them?\n\nA) Run the malware in a debugger and dump memory after decryption  \nB) Write a Python script: `decrypted = [byte ^ 0x42 for byte in encrypted]`  \nC) Use a dedicated XOR bruteforce tool  \nD) All of the above\n\n**Answer**: D) All methods work! Option B (Python script) is fastest for static analysis if you've identified the key. Option A is useful if you don't know the key (let malware decrypt, then dump). Option C helps if you don't know the key and want to try all possibilities.\n\n---\n\n**Question 4**: What is the PRIMARY advantage of static analysis over dynamic analysis?\n\nA) It's faster  \nB) It can analyze code paths that aren't executed during dynamic analysis  \nC) It doesn't require reverse engineering skills  \nD) It automatically unpacks packed malware\n\n**Answer**: B) Static analysis lets you see ALL code in the binary, including conditional logic that might not execute in a sandbox (e.g., \"if date == Dec 25, activate payload\"). Dynamic analysis only shows what actually runs. Static is NOT faster (it's often slower), DOES require RE skills, and does NOT auto-unpack (though dynamic does).\n\n---\n\n**Question 5**: You're writing a YARA rule to detect malware. Which condition is MOST specific (least false positives)?\n\nA) `uint16(0) == 0x5A4D` (MZ header)  \nB) `$api = \"CreateProcess\" ascii`  \nC) `$mutex = \"Global\\\\MalwareXYZ_Mutex_UniqueString_12345\"` and `$c2 = \"http://specific-malware-c2.com\"`  \nD) `filesize < 100KB`\n\n**Answer**: C) Unique mutex names and specific C2 domains are highly specific to malware families. Option A (MZ header) matches ALL Windows executables. Option B (CreateProcess) matches many legitimate programs. Option D (filesize) is too generic. Best YARA rules combine unique strings, API patterns, and code signatures."
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "## Real-World Case Study: Stuxnet Static Analysis\n\n### The Attack: Cyber Weapon Against Iran's Nuclear Program (2010)\n\n**Attacker**: Believed to be US/Israel (Operation Olympic Games)  \n**Target**: Iran's Natanz nuclear enrichment facility  \n**Impact**: Destroyed 1,000 centrifuges, set back Iran's program by years  \n**Sophistication**: Most advanced malware ever discovered (as of 2010)\n\n### How Static Analysis Uncovered Stuxnet's Secrets\n\nWhen Stuxnet was discovered in June 2010, it was unlike anything security researchers had seen. **Static analysis revealed it was a precision cyber weapon**, not typical malware.\n\n#### Phase 1: Initial Triage\n\n**File**: `~wtr4141.tmp` (445 KB)\n\n**Basic Analysis**:\n```bash\nfile ~wtr4141.tmp\n# Output: PE32 executable (DLL)\n\nstrings ~wtr4141.tmp | grep -i \"http\\|dll\\|sys\"\n# Output:\n# mrxcls.sys\n# mrxnet.sys\n# http://www.mypremierfutbol.com\n# http://www.todaysfutbol.com\n```\n\n**Red Flags**:\n- Contains driver files (.sys) embedded in DLL (unusual)\n- Two suspicious domains (C2 servers?)\n- Large size for a temp file\n\n#### Phase 2: PE Analysis (Packer Detection)\n\n**Tool**: Detect It Easy (DIE)\n```\n[*] Packer: None detected\n[*] Compiler: Microsoft Visual C++ 6.0\n[*] Sections: .text, .data, .rsrc (normal)\n[*] Digital Signature: INVALID (signed but signature is fake)\n```\n\n**Finding**: File is NOT packed, but has FAKE digital signature (signed with stolen Realtek certificate—discovered later).\n\n#### Phase 3: Imports Analysis (What APIs?)\n\n**IDA Pro → Imports Window**:\n```\nkernel32.dll:\n  CreateFileA, WriteFile (file operations)\n  LoadLibrary, GetProcAddress (dynamic loading)\n  CreateRemoteThread (injection!)\n  \nadvapi32.dll:\n  RegSetValueEx (registry modification)\n  CreateServiceA (service installation)\n  \ns7otbxdx.dll:  ← SUSPICIOUS! (Siemens SCADA library)\n  s7ag_read_szl\n  s7db_open\n  s7blk_write\n```\n\n**KEY FINDING**: `s7otbxdx.dll` is Siemens Step 7 SCADA software library. This malware targets **industrial control systems**, not typical PCs!\n\n#### Phase 4: Resource Analysis (Embedded Files)\n\n**IDA Pro → Resources**:\n```\nResource 207 (PE): mrxcls.sys (24 KB) - Rootkit driver\nResource 208 (PE): mrxnet.sys (18 KB) - Rootkit driver\nResource 209 (DATA): Encrypted payload (50 KB)\n```\n\n**Extracting Embedded Drivers**:\n```bash\n# Use Resource Hacker or CFF Explorer to dump resources\n# Analyze mrxcls.sys with IDA Pro\n```\n\n**mrxcls.sys Analysis**:\n```c\n// Decompiled (simplified)\nvoid DriverEntry() {\n  // Hook kernel functions\n  hook_ZwQueryDirectoryFile();  // Hide files\n  hook_ZwQuerySystemInformation();  // Hide processes\n  \n  // Load main payload\n  decrypt_payload();\n  execute_payload();\n}\n```\n\n**Conclusion**: Rootkit driver hides Stuxnet's presence (files, processes, registry keys).\n\n#### Phase 5: Payload Decryption\n\n**Static Analysis of Decryption Routine**:\n```c\nvoid decrypt_payload(void) {\n  unsigned char encrypted_data[51200] = { /* resource 209 */ };\n  unsigned char key[32] = {\n    0x19, 0xDB, 0x15, 0x20, 0x56, 0xF4, 0x7E, 0x31,\n    // ... AES-256 key (hardcoded)\n  };\n  \n  AES_decrypt(encrypted_data, key, 51200);\n  // Result: Decrypted payload contains PLC rootkit\n}\n```\n\n**Manual Decryption** (Python with PyCryptodome):\n```python\nfrom Crypto.Cipher import AES\n\nkey = bytes([0x19, 0xDB, 0x15, 0x20, 0x56, 0xF4, 0x7E, 0x31, ...])\nencrypted = open('resource_209.bin', 'rb').read()\n\ncipher = AES.new(key, AES.MODE_CBC, iv=bytes(16))\ndecrypted = cipher.decrypt(encrypted)\n\nopen('decrypted_payload.bin', 'wb').write(decrypted)\n```\n\n**Decrypted Payload Analysis**: Contains code to infect Siemens S7-300 PLCs (industrial controllers for uranium centrifuges).\n\n#### Phase 6: PLC Infection Code (The Weapon)\n\n**Decompiled Payload**:\n```c\nvoid infect_plc(void) {\n  // Connect to PLC via s7otbxdx.dll\n  s7db_open(PLC_IP);\n  \n  // Read current PLC program\n  s7ag_read_szl(BLOCK_ID, original_code, 2048);\n  \n  // Inject malicious code\n  char malicious_code[2048] = {\n    // Code to manipulate centrifuge speed:\n    // - Normal operation: 1,064 Hz (safe speed)\n    // - Attack: 1,410 Hz (overspeed) or 2 Hz (too slow)\n    // - Cycle between speeds to destroy centrifuges\n  };\n  \n  s7blk_write(BLOCK_ID, malicious_code, 2048);\n  \n  // Hide attack from operators (report fake normal speeds)\n  hook_s7ag_read_szl();  // Return fake data when operators query PLC\n}\n```\n\n**CRITICAL DISCOVERY**: Stuxnet doesn't destroy computers—it **physically destroys uranium centrifuges** by manipulating their rotation speeds, while hiding the attack from operators.\n\n#### Phase 7: Propagation Mechanisms (4 Zero-Days!)\n\nStatic analysis revealed Stuxnet used **4 zero-day exploits** (previously unknown vulnerabilities):\n\n**1. LNK Exploit (CVE-2010-2568)**:\n```c\n// Malicious .lnk file that auto-executes when USB is viewed in Explorer\n// (no need to click anything!)\nLNK_file.icon_location = \"malware.dll,exploit_function\";\n```\n\n**2. Print Spooler Exploit (CVE-2010-2729)**:\n```c\n// Remote code execution via network printer spooler\nRpcOpenPrinter(\"\\\\\\\\target_pc\\\\printer\", shellcode);\n```\n\n**3. Task Scheduler Exploit (CVE-2010-3338)**:\n```c\n// Local privilege escalation\nSchRpcSetSecurity(malicious_task, NULL, SYSTEM_DACL);\n```\n\n**4. SMB Exploit (CVE-2010-2743)**:\n```c\n// Network worm propagation\nSMB_exploit(\"\\\\\\\\target\\\\IPC$\", shellcode);\n```\n\n**Finding**: Stuxnet could spread via USB drives AND network shares, using exploits that had never been seen before (zero-days are worth $100K+ each on black market).\n\n### Reconstructed Attack Flow\n\n```\n1. DELIVERY: USB stick infected with Stuxnet inserted into contractor's PC\n2. EXPLOITATION: LNK zero-day auto-executes malware\n3. INSTALLATION: Rootkit drivers installed (mrxcls.sys, mrxnet.sys)\n4. PERSISTENCE: Service created (fake \"Windows Update\" service)\n5. PROPAGATION: Spreads via network (SMB exploit) to other PCs\n6. RECONNAISSANCE: Searches for Siemens Step 7 software (SCADA)\n7. C2 COMMUNICATION: Beacons to mypremierfutbol.com (for updates)\n8. LATERAL MOVEMENT: Uses stolen credentials to access PLC network\n9. PLC INFECTION: Injects malicious code into Siemens S7-300 PLCs\n10. SABOTAGE: Manipulates centrifuge speeds (1,410 Hz → destroy)\n11. COVER-UP: Reports fake normal speeds to operators\n```\n\n### Impact of Static Analysis\n\n**What Static Analysis Revealed**:\n- ✅ Target: Siemens PLCs controlling uranium centrifuges (not PCs)\n- ✅ Method: Physical sabotage via speed manipulation\n- ✅ Sophistication: 4 zero-days, stolen digital certificates, rootkit\n- ✅ Attribution: Code quality, resources (zero-days) suggest nation-state\n- ✅ Precision: Only activates if specific PLC model + configuration detected\n\n**What Dynamic Analysis ALONE Would Have Missed**:\n- ❌ PLC infection code (requires actual SCADA hardware to execute)\n- ❌ Precision targeting logic (checks for specific centrifuge configuration)\n- ❌ All 4 propagation exploits (sandbox might not have vulnerable systems)\n- ❌ AES encryption key (found by reading code, not watching execution)\n\n### Lessons Learned\n\n1. **Static analysis is essential for nation-state malware**: Stuxnet wouldn't fully execute in a sandbox (requires Siemens SCADA hardware).\n2. **Resource extraction is critical**: Embedded drivers and encrypted payloads require manual extraction and analysis.\n3. **API imports reveal capabilities**: s7otbxdx.dll imports immediately flagged this as SCADA-targeting malware.\n4. **Reverse engineering takes time**: Full Stuxnet analysis took Symantec's team 6+ months.\n5. **Collaboration amplifies impact**: Symantec, Kaspersky, and academic researchers shared findings.\n\n**Your Role**: As a malware analyst, static analysis skills would have been essential for uncovering Stuxnet's true purpose. The ability to read assembly, decrypt payloads, and understand industrial control system APIs made the difference between \"this is strange malware\" and \"this is a cyber weapon designed to destroy centrifuges.\""
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "## Reflection: Mastering Reverse Engineering\n\n**Take 5 minutes to reflect:**\n\n1. **Assembly Reading**: When you see assembly code like `push ebp; mov ebp, esp; sub esp, 0x20`, what does this tell you? (Hint: Function prologue—setting up stack frame for local variables). How comfortable are you reading assembly?\n\n2. **Tool Selection**: If you could only use ONE reverse engineering tool (IDA Pro, Ghidra, or Binary Ninja), which would you choose and why? (Consider: Cost, features, learning curve, community support)\n\n3. **Obfuscation Challenge**: You find malware where all strings are encrypted with XOR. You identify the decryption function but don't know the key. What are 3 ways you could find it? (Think: Static analysis of key variable, dynamic analysis with debugger, XOR bruteforce)\n\n4. **IOC Extraction**: When analyzing malware, what are the TOP 5 IOCs you prioritize extracting? (Consider: C2 domains/IPs, file paths, registry keys, mutexes, network signatures)\n\n5. **Learning Path**: What's the biggest challenge you face in reverse engineering? (Assembly syntax? Tool usage? Obfuscation? Time constraints?) How will you improve this skill?\n\n**Action Items**:\n\n1. **This Week**: Download a sample from MalwareBazaar (https://bazaar.abuse.ch/) and analyze it with Ghidra. Try to answer:\n   - What does it do?\n   - Where does it connect?\n   - How does it persist?\n   - What files does it create?\n\n2. **Practice Assembly**: Work through microcorruption.com (CTF game teaching assembly/reverse engineering) or Practical Malware Analysis book exercises.\n\n3. **Build Your Toolkit**: Set up a malware analysis VM with:\n   - Ghidra (or IDA Free)\n   - Detect It Easy (packer detection)\n   - PE-bear (PE analysis)\n   - FLOSS (string deobfuscation)\n   - x64dbg (debugger)\n\n**Mindset Note**: Reverse engineering feels impossibly hard at first. You'll stare at assembly code feeling lost. That's NORMAL. But here's the secret: You don't need to understand EVERY instruction. You need to recognize PATTERNS. \"Oh, this is a loop. This is a function call. This looks like string decryption.\" With practice (10-20 samples), these patterns become obvious. Persistence beats talent in reverse engineering!"
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "## Memory Aids for Static Analysis\n\n### Assembly Instructions Quick Reference\n\n**Data Movement (MOVE)**:\n- **M**ov: Move data\n- **O**r: Bitwise OR (set bits)\n- **V**irtualAllocEx: Allocate memory (injection indicator)\n- **E**xchange: Swap register values\n\n**Arithmetic (MIDAS)**:\n- **M**ul/iMul: Multiply\n- **I**nc/Dec: Increment/Decrement\n- **D**iv/iDiv: Divide\n- **A**dd/Sub: Add/Subtract\n- **S**hl/Shr: Shift left/right (multiply/divide by 2)\n\n**Control Flow (JCRC)**:\n- **J**mp: Unconditional jump\n- **C**all: Call function\n- **R**et: Return from function\n- **C**mp: Compare (sets flags for conditional jumps)\n\n### Common Malware API Patterns\n\n**Injection (VWCR)**:\n- **V**irtualAllocEx\n- **W**riteProcessMemory\n- **C**reateRemoteThread\n- **(Optional)** **R**esumeThread\n\n**Persistence (RCS)**:\n- **R**egSetValueEx (registry Run keys)\n- **C**reateService (Windows services)\n- **S**cheduled Task APIs\n\n**Network (WSCR)**:\n- **W**SAStartup\n- **S**ocket\n- **C**onnect\n- **R**ecv/Send\n\n**Evasion (HVID)**:\n- **H**ook detection (GetProcAddress, inline hooks)\n- **V**M detection (CPUID, SIDT checks)\n- **I**sDebuggerPresent\n- **D**elay execution (Sleep, GetTickCount)\n\n### Ghidra Workflow (IDEAL)\n\n1. **I**mport binary and analyze\n2. **D**iscover entry point and main functions\n3. **E**xamine imports (APIs used)\n4. **A**nalyze strings and resources\n5. **L**abel functions and variables (rename for clarity)\n\n### YARA Rule Structure (MSSC)\n\n- **M**eta: Description, author, date\n- **S**trings: Unique identifiers ($mutex, $c2, etc.)\n- **S**ignatures: Hex patterns of code ($injection_pattern)\n- **C**ondition: Logic combining above (e.g., \"$mutex and 2 of ($api*)\")\n\n### Packing Detection (ESDAP)\n\n- **E**ntropy (high entropy = likely packed/encrypted)\n- **S**ection names (UPX0, .packed, .data with high entropy)\n- **D**etect It Easy (tool detects known packers)\n- **A**PI imports (very few imports = likely packed)\n- **P**E structure anomalies (Entry Point in .data section)\n\n### String Obfuscation Types (XBC)\n\n- **X**OR: Encrypted with XOR key (most common)\n- **B**ase64: Encoded (not encrypted, just obfuscated)\n- **C**ustom cipher: AES, RC4, or custom algorithm\n\n### x86 Calling Conventions (CSTF)\n\n- **C**decl: Caller cleans stack, params right-to-left\n- **S**tdcall: Callee cleans stack (Windows API default)\n- **T**hiscall: ECX = \"this\" pointer (C++ methods)\n- **F**astcall: First 2 params in ECX/EDX, rest on stack\n\n### Control Flow Graph Analysis (IDOM)\n\n- **I**dentify entry and exit blocks\n- **D**ominators: Which blocks always execute before others?\n- **O**bfuscation: Excessive branching, opaque predicates?\n- **M**alicious logic: Loops (encryption?), conditionals (checks?)\n\n### Malware Capabilities Checklist (PRICE)\n\n- **P**ersistence (registry, services, scheduled tasks)\n- **R**econnaissance (enumerate processes, files, users)\n- **I**njection (CreateRemoteThread, reflective DLL)\n- **C**ommunication (C2 servers, protocols)\n- **E**vasion (VM detection, debugger checks, anti-AV)"
      }
    }
  ],
  "post_assessment": [
    {
      "question": "You see this assembly in malware: `xor eax, eax; test eax, eax; jz 0x401050`. What does this code do?",
      "options": [
        "Checks if EAX is zero, then jumps (but EAX is always zero after xor eax,eax, so it ALWAYS jumps)",
        "Encrypts EAX then conditionally jumps",
        "This is dead code that never executes",
        "Calls a function at 0x401050"
      ],
      "correct_answer": 0,
      "explanation": "`xor eax, eax` sets EAX to 0. `test eax, eax` checks if EAX is zero (it is). `jz` (jump if zero) always jumps to 0x401050. This is effectively an unconditional jump disguised as conditional logic—a simple obfuscation technique. Malware uses this to confuse automated analysis tools.",
      "question_id": "f21fd2f6-705e-4d30-8f47-d88e34907b1e",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "In Ghidra, you find imports for VirtualAllocEx, WriteProcessMemory, and CreateRemoteThread from a process targeting firefox.exe. What's the malware doing?",
      "options": [
        "Downloading Firefox updates",
        "Injecting code into Firefox process (likely web inject for credential theft)",
        "Monitoring Firefox network traffic without injection",
        "Crashing Firefox"
      ],
      "correct_answer": 1,
      "explanation": "This API sequence = classic DLL/code injection into Firefox. Banking trojans use this to inject malicious JavaScript that steals login credentials when users access banking websites. VirtualAllocEx allocates memory in Firefox → WriteProcessMemory writes malicious code → CreateRemoteThread executes it.",
      "question_id": "3b3b932f-3f8f-4de0-a696-580e14975539",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "You find encrypted strings in malware decrypted with a XOR loop (key unknown). What's the FASTEST way to find the key during static analysis?",
      "options": [
        "Try all 256 possible XOR keys and look for readable strings",
        "Search for where the key is loaded (e.g., `mov al, 0x42`) before the XOR loop",
        "Run the malware in a debugger and watch the decryption",
        "Use FLOSS to automatically extract obfuscated strings"
      ],
      "correct_answer": 1,
      "explanation": "In static analysis, look at the disassembly BEFORE the XOR loop. You'll often find `mov al, 0x42` (or similar) loading the key into a register. This is faster than bruteforce (option A) or switching to dynamic analysis (option C). Option D (FLOSS) works but doesn't teach you the technique. Understanding the code is always best.",
      "question_id": "bf711de8-e0fd-46e3-a342-8a5080d66d6a",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "When writing a YARA rule, which condition provides the BEST balance of specificity and coverage?",
      "options": [
        "`filesize < 1MB` (file size only)",
        "`uint16(0) == 0x5A4D` (MZ header only)",
        "`$mutex = \"UniqueMalwareMutex\" and 2 of ($api*)` (unique string + API pattern)",
        "`all of them` (requires ALL strings to match)"
      ],
      "correct_answer": 2,
      "explanation": "Option C combines a unique identifier (mutex) with a broader pattern (2 of 3+ API imports). This catches variants where APIs might change but the mutex remains. Option A/B are too generic (matches many files). Option D (`all of them`) is too strict—if malware changes one string, the rule fails. Best rules balance specificity (unique strings) with flexibility (partial API matches).",
      "question_id": "ef9fd0f0-69e7-42f2-9d4d-43fdcfad7382",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "You're analyzing packed malware. Ghidra shows only 5 imports (LoadLibrary, GetProcAddress, VirtualProtect, VirtualAlloc, and the entry point). What does this indicate?",
      "options": [
        "The malware is very simple with minimal functionality",
        "The malware is packed/encrypted and will dynamically resolve APIs at runtime",
        "Ghidra failed to analyze the file correctly",
        "The malware doesn't use Windows APIs"
      ],
      "correct_answer": 1,
      "explanation": "Packed malware has very few static imports because most APIs are resolved dynamically at runtime (using GetProcAddress). The packer unpacks the real malware in memory, then uses LoadLibrary + GetProcAddress to load needed APIs (CreateFile, RegSetValue, etc.). To analyze, you must unpack (dynamically or manually) first. This is why static analysis alone isn't enough for packed malware.",
      "question_id": "a2781f2d-0202-4e62-9503-4c862a8e1ae2",
      "type": "multiple_choice",
      "difficulty": 3
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "memory_hooks",
    "minimum_effective_dose",
    "teach_like_im_10",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ]
}