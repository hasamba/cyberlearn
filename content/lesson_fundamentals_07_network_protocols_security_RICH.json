{
  "lesson_id": "c3d4e5f6-a7b8-4c1d-2e3f-4a5b6c7d8e9f",
  "domain": "fundamentals",
  "title": "Network Protocols and Security",
  "difficulty": 1,
  "order_index": 7,
  "prerequisites": [],
  "concepts": [
    "TCP/IP Model",
    "DNS Security",
    "HTTP vs HTTPS",
    "TLS/SSL",
    "ARP Spoofing",
    "Man-in-the-Middle",
    "Network Sniffing",
    "Port Scanning",
    "Firewalls"
  ],
  "content_blocks": [
    {
      "block_id": "1a2b3c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d",
      "type": "mindset_coach",
      "content": {
        "text": "Network protocols are the language computers speak to communicate. Understanding how these protocols work - and more importantly, how they fail - is absolutely fundamental to cybersecurity. Every network attack, every lateral movement technique, every data exfiltration relies on exploiting or abusing network protocols.\n\nHere's what changes everything: Most network protocols were designed in the 1970s-1990s when security wasn't a primary concern. They prioritized functionality and interoperability over security. DNS has no built-in authentication. HTTP transmits everything in plaintext. ARP trusts any response. These fundamental design flaws persist today, and attackers exploit them constantly.\n\nMany people think networking is just for network engineers. Wrong. As a security professional, you need to understand:\n- **As a defender**: How to detect network-based attacks (ARP spoofing, DNS poisoning, port scans)\n- **As a pentester**: How to perform reconnaissance (port scanning, service enumeration), lateral movement (exploiting trust relationships)\n- **As an analyst**: How to read packet captures, investigate incidents, identify command and control traffic\n- **As a developer**: How to secure communications (TLS properly, certificate validation, secure APIs)\n\nThe beautiful part: Network protocols follow predictable patterns. Once you understand the TCP/IP model and how each layer works, you can reason about any network security issue. DNS cache poisoning? Layer 7 (Application). ARP spoofing? Layer 2 (Data Link). TCP SYN flood? Layer 4 (Transport).\n\nThis lesson covers the essential protocols every security professional must know: TCP/IP, DNS, HTTP/HTTPS, TLS/SSL, ARP. We'll explore how they work, how they're attacked, and how to defend them. This isn't abstract networking theory - these are the protocols you'll work with every single day in security.\n\nLet's build your network security foundation."
      },
      "simplified_explanation": "Network protocols = Rules for how computers communicate. TCP/IP = Core internet protocol suite. DNS = Converts names to IPs. HTTP = Web traffic (plaintext). HTTPS = Encrypted web traffic. TLS/SSL = Encryption layer. Understanding protocols reveals attack vectors and defense strategies.",
      "memory_aids": [
        "TCP/IP Layers (from bottom): Physical, Data Link, Network, Transport, Application",
        "DNS = Phone book of the internet (converts google.com to 142.250.80.46)",
        "HTTP = Insecure (plaintext), HTTPS = Secure (encrypted with TLS)",
        "Port numbers: 80=HTTP, 443=HTTPS, 22=SSH, 21=FTP, 25=SMTP, 53=DNS"
      ],
      "teach_like_im_10": "Imagine the internet is like sending letters. TCP/IP is the postal system (rules for addressing and delivery). DNS is the address book (converts names to addresses). HTTP is a postcard (anyone can read it). HTTPS is a sealed envelope with a lock (only recipient can read it). Hackers try to intercept letters, read postcards, or pretend to be the post office."
    },
    {
      "block_id": "2b3c4d5e-6f7a-8b9c-0d1e-2f3a4b5c6d7e",
      "type": "explanation",
      "content": {
        "text": "## TCP/IP Network Model\n\n### The Five Layers\n\nThe TCP/IP model organizes networking into 5 layers, each with specific responsibilities:\n\n**Layer 1: Physical**\n- **Purpose**: Transmit raw bits over physical medium\n- **Examples**: Ethernet cables, fiber optics, Wi-Fi radio waves\n- **Security**: Physical access (tap cables, wireless eavesdropping)\n\n**Layer 2: Data Link**\n- **Purpose**: Node-to-node data transfer (same network segment)\n- **Protocol**: Ethernet, Wi-Fi (802.11)\n- **Addressing**: MAC addresses (48-bit, e.g., AA:BB:CC:DD:EE:FF)\n- **Security Risks**: ARP spoofing, MAC flooding, rogue access points\n\n**Layer 3: Network**\n- **Purpose**: Routing packets across networks\n- **Protocol**: IP (Internet Protocol)\n- **Addressing**: IP addresses (IPv4: 192.168.1.1, IPv6: 2001:db8::1)\n- **Security Risks**: IP spoofing, routing attacks, ICMP attacks\n\n**Layer 4: Transport**\n- **Purpose**: End-to-end communication, reliability\n- **Protocols**: TCP (reliable, connection-oriented), UDP (unreliable, connectionless)\n- **Addressing**: Ports (0-65535)\n- **Security Risks**: Port scanning, SYN floods, session hijacking\n\n**Layer 5: Application**\n- **Purpose**: Application-specific protocols\n- **Protocols**: HTTP, HTTPS, DNS, SMTP, SSH, FTP\n- **Security Risks**: Application-specific vulnerabilities (SQL injection, XSS, etc.)\n\n### How Data Flows Through Layers\n\n**Sending Data (Encapsulation)**:\n```\nApplication Layer:    [HTTP Request]\n↓ Add TCP header\nTransport Layer:      [TCP][HTTP Request]\n↓ Add IP header\nNetwork Layer:        [IP][TCP][HTTP Request]\n↓ Add Ethernet header\nData Link Layer:      [Ethernet][IP][TCP][HTTP Request]\n↓ Convert to bits\nPhysical Layer:       10110010... (transmitted over wire/wireless)\n```\n\n**Receiving Data (De-encapsulation)**:\n```\nPhysical Layer:       10110010... (received bits)\n↓ Convert to frame\nData Link Layer:      [Ethernet][IP][TCP][HTTP Request]\n↓ Remove Ethernet header\nNetwork Layer:        [IP][TCP][HTTP Request]\n↓ Remove IP header\nTransport Layer:      [TCP][HTTP Request]\n↓ Remove TCP header\nApplication Layer:    [HTTP Request]\n```bash\n\n## IP (Internet Protocol)\n\n### IPv4 Addresses\n\n**Format**: 32-bit address, written as 4 octets (192.168.1.1)\n\n**Private IP Ranges** (not routable on internet):\n```\n10.0.0.0 - 10.255.255.255      (10.0.0.0/8)\n172.16.0.0 - 172.31.255.255    (172.16.0.0/12)\n192.168.0.0 - 192.168.255.255  (192.168.0.0/16)\n127.0.0.0 - 127.255.255.255    (Loopback, localhost)\n```\n\n**Public IP Ranges**: Everything else (routable on internet)\n\n**Special Addresses**:\n- **0.0.0.0**: Default route, \"this network\"\n- **255.255.255.255**: Broadcast (all hosts on local network)\n- **127.0.0.1**: Loopback (localhost, this computer)\n\n### Subnets and CIDR Notation\n\n**CIDR (Classless Inter-Domain Routing)**: IP/prefix_length\n\n**Examples**:\n```\n192.168.1.0/24\n- Network: 192.168.1.0\n- Subnet mask: 255.255.255.0 (24 bits for network, 8 bits for hosts)\n- Usable IPs: 192.168.1.1 - 192.168.1.254 (254 hosts)\n- Broadcast: 192.168.1.255\n\n10.0.0.0/16\n- Network: 10.0.0.0\n- Subnet mask: 255.255.0.0 (16 bits network, 16 bits hosts)\n- Usable IPs: 10.0.0.1 - 10.0.255.254 (65,534 hosts)\n- Broadcast: 10.0.255.255\n```\n\n**Security Use**: Network segmentation (isolate sensitive systems on separate subnets)\n\n## TCP (Transmission Control Protocol)\n\n### TCP Three-Way Handshake\n\n**Establishing Connection**:\n```\nClient                          Server\n│                                │\n│──────── SYN ─────────────────→│  (Client initiates, seq=100)\n│                                │\n│←─────── SYN-ACK ─────────────│  (Server responds, seq=200, ack=101)\n│                                │\n│──────── ACK ─────────────────→│  (Client confirms, ack=201)\n│                                │\n│      Connection Established     │\n│                                │\n│───── Data Transfer ────────→  │\n│←──── Data Transfer ──────────│\n│                                │\n```\n\n**Closing Connection (Four-Way)**:\n```\nClient                          Server\n│──────── FIN ─────────────────→│  (Client wants to close)\n│←─────── ACK ─────────────────│  (Server acknowledges)\n│←─────── FIN ─────────────────│  (Server wants to close)\n│──────── ACK ─────────────────→│  (Client acknowledges)\n│                                │\n│      Connection Closed         │\n```bash\n\n### TCP vs UDP\n\n| Feature | TCP | UDP |\n|---------|-----|-----|\n| Connection | Connection-oriented (handshake) | Connectionless |\n| Reliability | Guaranteed delivery, ordering | No guarantee |\n| Speed | Slower (overhead) | Faster (minimal overhead) |\n| Use Cases | Web (HTTP), Email (SMTP), File Transfer (FTP) | Streaming, DNS, VoIP, Gaming |\n| Header Size | 20 bytes | 8 bytes |\n\n**When to Use**:\n- **TCP**: When reliability matters (file transfer, web pages, email)\n- **UDP**: When speed matters more than reliability (video streaming, online games, DNS)\n\n### Port Numbers\n\nPorts identify specific services/applications on a host.\n\n**Port Ranges**:\n- **0-1023**: Well-known ports (privileged, require root/admin)\n- **1024-49151**: Registered ports (assigned by IANA)\n- **49152-65535**: Dynamic/private ports (temporary connections)\n\n**Common Ports**:\n```\n20/21   - FTP (File Transfer)\n22      - SSH (Secure Shell)\n23      - Telnet (Insecure remote access)\n25      - SMTP (Email sending)\n53      - DNS (Domain Name System)\n80      - HTTP (Web traffic)\n110     - POP3 (Email retrieval)\n143     - IMAP (Email retrieval)\n443     - HTTPS (Secure web traffic)\n445     - SMB (Windows file sharing)\n3306    - MySQL\n3389    - RDP (Remote Desktop)\n5432    - PostgreSQL\n8080    - HTTP alternate (often proxy)\n```\n\n**Security Implication**: Open ports = attack surface. Close unnecessary ports.\n\n## DNS (Domain Name System)\n\n### What DNS Does\n\nDNS translates human-readable domain names to IP addresses:\n```\nUser types: google.com\nDNS resolves: 142.250.80.46\nBrowser connects to: 142.250.80.46\n```bash\n\n### DNS Record Types\n\n**A Record**: Maps domain to IPv4 address\n```\nexample.com  →  192.0.2.1\n```\n\n**AAAA Record**: Maps domain to IPv6 address\n```\nexample.com  →  2001:db8::1\n```\n\n**CNAME Record**: Alias (canonical name)\n```\nwww.example.com  →  example.com\n```\n\n**MX Record**: Mail exchange servers\n```\nexample.com  →  mail.example.com (priority 10)\n```\n\n**TXT Record**: Text information (often SPF, DKIM for email)\n```\nexample.com  →  \"v=spf1 include:_spf.google.com ~all\"\n```\n\n**NS Record**: Name servers for domain\n```\nexample.com  →  ns1.example.com, ns2.example.com\n```bash\n\n### DNS Query Process\n\n```\n1. User types: example.com\n↓\n2. Check local DNS cache (browser, OS)\nIf cached → return IP (done)\nIf not cached → continue\n↓\n3. Query recursive DNS resolver (ISP or 8.8.8.8)\n↓\n4. Resolver checks cache\nIf cached → return IP (done)\nIf not cached → continue\n↓\n5. Resolver queries root DNS server (.)\nRoot responds: \"Ask .com TLD server\"\n↓\n6. Resolver queries .com TLD server\nTLD responds: \"Ask example.com authoritative server\"\n↓\n7. Resolver queries example.com authoritative server\nAuthoritative responds: \"192.0.2.1\"\n↓\n8. Resolver caches result, returns to user\n↓\n9. User's computer connects to 192.0.2.1\n```bash\n\n### DNS Security Issues\n\n**1. DNS Cache Poisoning**\n```\nAttacker sends fake DNS response:\n\"google.com = 198.51.100.50\" (attacker's server)\nDNS resolver caches fake response\nUsers redirected to attacker's server (phishing site)\n```\n\n**Prevention**: DNSSEC (cryptographic signatures verify authenticity)\n\n**2. DNS Tunneling (Data Exfiltration)**\n```\nMalware encodes stolen data in DNS queries:\nstolen-data-here.attacker.com\nDNS query sent to attacker's DNS server\nAttacker extracts data from query\nBypass firewall (DNS usually allowed)\n```\n\n**Detection**: Unusual DNS query patterns (long subdomain names, high volume)\n\n**3. DNS Amplification DDoS**\n```\nAttacker sends DNS query with spoofed source IP (victim's IP)\nDNS server responds to victim with large response\nAttacker sends millions of queries → millions of large responses to victim\nVictim overwhelmed (amplification: small query → large response)\n```\n\n**Prevention**: Disable open DNS resolvers, rate limiting\n\n**Tools**:\n```bash\n# Query DNS\nnslookup example.com\ndig example.com\n\n# Query specific record type\ndig example.com MX\ndig example.com TXT\n\n# Query specific DNS server\ndig @8.8.8.8 example.com\n\n# Reverse DNS (IP to domain)\ndig -x 192.0.2.1\n```bash\n\n## HTTP vs HTTPS\n\n### HTTP (Hypertext Transfer Protocol)\n\n**Characteristics**:\n- **Port**: 80\n- **Encryption**: NONE (plaintext)\n- **Security**: Zero confidentiality, integrity, or authenticity\n\n**HTTP Request Example**:\n```http\nGET /login HTTP/1.1\nHost: example.com\nUser-Agent: Mozilla/5.0\nCookie: session=abc123\n\nusername=admin&password=secret123\n```\n\n**Problem**: Entire request sent in plaintext:\n- Attacker on network can read passwords, session cookies, personal data\n- Attacker can modify requests/responses (man-in-the-middle)\n- No way to verify server is legitimate (no authentication)\n\n### HTTPS (HTTP Secure)\n\n**Characteristics**:\n- **Port**: 443\n- **Encryption**: TLS/SSL (encrypts all traffic)\n- **Security**: Confidentiality, integrity, authentication\n\n**What HTTPS Protects**:\n- **Confidentiality**: Encrypted (eavesdropper sees gibberish)\n- **Integrity**: Tampering detected (cryptographic checksums)\n- **Authentication**: Certificate proves server identity\n\n**HTTPS Handshake (TLS 1.3 Simplified)**:\n```\nClient                             Server\n│                                   │\n│─── ClientHello ─────────────────→│\n│    (Supported ciphers, random)    │\n│                                   │\n│←── ServerHello ──────────────────│\n│    (Selected cipher, certificate, │\n│     random, server key exchange)  │\n│                                   │\n│─── Client Key Exchange ─────────→│\n│    (Client key exchange)          │\n│                                   │\n│    Both derive session keys       │\n│                                   │\n│═══ Encrypted Traffic ═══════════→│\n│←══ Encrypted Traffic ═══════════ │\n```bash\n\n### TLS/SSL Certificates\n\n**Certificate Contains**:\n- Domain name (example.com)\n- Organization name\n- Public key\n- Expiration date\n- Issuer (Certificate Authority)\n- Digital signature\n\n**Certificate Validation**:\n```\n1. Browser connects to https://example.com\n2. Server sends certificate\n3. Browser checks:\n✓ Certificate signed by trusted CA?\n✓ Certificate domain matches example.com?\n✓ Certificate not expired?\n✓ Certificate not revoked?\n4. If all checks pass → Trust server, establish encrypted connection\n5. If any check fails → Show warning (\"Your connection is not private\")\n```\n\n**Certificate Authorities (CAs)**:\n- Trusted organizations that issue certificates\n- Examples: Let's Encrypt, DigiCert, Comodo\n- Browsers/OS have list of trusted root CAs\n\n**Certificate Pinning**: \n- Application hardcodes expected certificate/public key\n- Prevents MITM even with rogue CA\n- Used by mobile apps, high-security applications\n\n### Common TLS/SSL Attacks\n\n**1. SSL Stripping (Downgrade Attack)**\n```\nUser types: example.com (not https://)\nAttacker intercepts, proxies connection\nUser ↔ Attacker: HTTP (unencrypted)\nAttacker ↔ Server: HTTPS (encrypted)\nAttacker reads/modifies plaintext traffic from user\n```\n\n**Prevention**: HSTS (HTTP Strict Transport Security) forces HTTPS\n\n**2. Man-in-the-Middle with Rogue Certificate**\n```\nAttacker has certificate from compromised/rogue CA\nAttacker intercepts connection, presents rogue certificate\nIf user accepts certificate → Encrypted to attacker (not real server)\n```\n\n**Prevention**: Certificate pinning, reject invalid certificates\n\n**3. Weak Cipher Suites**\n```\nServer supports outdated encryption (RC4, DES, export ciphers)\nAttacker forces downgrade to weak cipher\nAttacker breaks weak encryption\n```\n\n**Prevention**: Disable weak ciphers, use TLS 1.2+\n\n## ARP (Address Resolution Protocol)\n\n### What ARP Does\n\nARP resolves IP addresses to MAC addresses on local network:\n```\nComputer knows: \"I need to send to 192.168.1.5\"\nComputer doesn't know: \"What's the MAC address of 192.168.1.5?\"\nARP resolves: 192.168.1.5 → AA:BB:CC:DD:EE:FF\nComputer sends data to MAC address AA:BB:CC:DD:EE:FF\n```bash\n\n### ARP Process\n\n```\n1. Host A wants to send to Host B (192.168.1.5)\n2. Host A broadcasts: \"Who has 192.168.1.5? Tell 192.168.1.2\"\n3. Host B responds: \"192.168.1.5 is at MAC AA:BB:CC:DD:EE:FF\"\n4. Host A caches: 192.168.1.5 → AA:BB:CC:DD:EE:FF\n5. Host A sends data to MAC AA:BB:CC:DD:EE:FF\n```bash\n\n### ARP Spoofing (ARP Poisoning)\n\n**Attack**:\n```\nNormal:\nHost A (192.168.1.2)  ←→  Router (192.168.1.1)\n\nAttack:\nAttacker sends fake ARP responses:\nTo Host A: \"192.168.1.1 is at Attacker-MAC\" (pretend to be router)\nTo Router: \"192.168.1.2 is at Attacker-MAC\" (pretend to be Host A)\n\nResult:\nHost A → Attacker → Router\nRouter → Attacker → Host A\n\nAttacker in the middle (MITM):\n- Reads all traffic\n- Can modify traffic\n- Can drop packets (DoS)\n```\n\n**Detection**:\n```bash\n# Monitor ARP table for changes\narp -a\n\n# Look for duplicate IPs with different MACs\n# Tools: arpwatch, XArp\n```\n\n**Prevention**:\n- Static ARP entries (manual, doesn't scale)\n- Dynamic ARP Inspection (DAI) on switches\n- 802.1X network access control\n- Network segmentation\n\n## Port Scanning\n\n### Purpose\n\nDiscover what services are running on target system:\n```\nPort 22 open  → SSH server running\nPort 80 open  → Web server running\nPort 445 open → Windows file sharing (SMB) running\nPort 3306 open → MySQL database running\n```bash\n\n### Scan Types\n\n**1. TCP Connect Scan**\n```\nComplete three-way handshake with each port\nIf handshake succeeds → Port open\nIf RST received → Port closed\nLoud (logged by target)\n```\n\n**2. SYN Scan (Stealth Scan)**\n```\nSend SYN\nIf SYN-ACK received → Port open (send RST, don't complete handshake)\nIf RST received → Port closed\nStealthier (connection never fully established)\nRequires raw socket access (root/admin)\n```\n\n**3. UDP Scan**\n```\nSend UDP packet to port\nIf no response → Likely open (UDP doesn't ack)\nIf ICMP port unreachable → Closed\nSlow and unreliable\n```bash\n\n### Nmap Examples\n\n```bash\n# Basic scan (1000 common ports)\nnmap 192.168.1.100\n\n# Scan all 65535 ports\nnmap -p- 192.168.1.100\n\n# SYN scan (stealthy)\nsudo nmap -sS 192.168.1.100\n\n# Service version detection\nnmap -sV 192.168.1.100\n\n# OS detection\nsudo nmap -O 192.168.1.100\n\n# Aggressive scan (OS, version, scripts, traceroute)\nnmap -A 192.168.1.100\n\n# Scan entire subnet\nnmap 192.168.1.0/24\n\n# Fast scan (100 most common ports)\nnmap -F 192.168.1.100\n\n# Output to file\nnmap -oN scan_results.txt 192.168.1.100\n```\n\n**Defense**:\n- Firewall (block unnecessary ports)\n- IDS/IPS (detect scanning activity)\n- Monitor logs for scanning patterns\n- Rate limiting (slow down scans)\n\n## Firewalls\n\n### Purpose\n\nControl network traffic based on rules (allow/deny).\n\n### Firewall Types\n\n**1. Packet Filter (Stateless)**\n- Examines individual packets\n- Decisions based on: source IP, destination IP, source port, destination port, protocol\n- Fast but limited (can't track connections)\n\n**Example Rule**:\n```\nALLOW TCP from 0.0.0.0/0 to 192.168.1.10 port 80\nALLOW TCP from 0.0.0.0/0 to 192.168.1.10 port 443\nDENY all other traffic\n```\n\n**2. Stateful Firewall**\n- Tracks connection state (remember established connections)\n- More intelligent (allow responses to outbound requests)\n\n**Example**:\n```\nUser inside network makes outbound request to google.com:443\nFirewall remembers connection\nGoogle's response allowed back through (part of established connection)\nUnsolicited inbound traffic blocked\n```\n\n**3. Application Layer Firewall (WAF)**\n- Understands application protocols (HTTP, SQL, etc.)\n- Can block application-specific attacks (SQL injection, XSS)\n- Example: ModSecurity, AWS WAF, Cloudflare WAF\n\n### Firewall Rules Best Practices\n\n**Default Deny**:\n```\nRULE 1: ALLOW necessary traffic (explicit)\nRULE 2: ALLOW necessary traffic (explicit)\n...\nRULE N: DENY all other traffic (implicit)\n```\n\n**Principle of Least Privilege**:\n- Only allow necessary traffic\n- Specific source → specific destination → specific port\n\n**Example**:\n```bash\n# Bad: Too permissive\nALLOW TCP from 0.0.0.0/0 to 0.0.0.0/0 port 22\n(Allows SSH from anywhere to anywhere)\n\n# Good: Specific\nALLOW TCP from 203.0.113.0/24 to 192.168.1.10 port 22\n(Allows SSH only from specific admin network to specific server)\n```bash\n\n## Network Sniffing\n\n### What is Sniffing?\n\nCapturing and analyzing network traffic.\n\n**Tools**: Wireshark, tcpdump, tshark\n\n### Wireshark Basics\n\n**Capture Filters** (applied during capture):\n```\nhost 192.168.1.100         (Traffic to/from specific IP)\nport 80                     (HTTP traffic)\ntcp port 443                (HTTPS traffic)\nsrc host 192.168.1.100      (Traffic from specific IP)\ndst port 22                 (Traffic to port 22)\n```\n\n**Display Filters** (applied after capture):\n```\nhttp.request                (HTTP requests)\nhttp.response.code == 404   (HTTP 404 errors)\ntcp.port == 22              (SSH traffic)\nip.addr == 192.168.1.100    (Traffic involving specific IP)\nhttp.request.method == \"POST\" (HTTP POST requests)\nhttp contains \"password\"     (HTTP traffic containing \"password\")\n```\n\n**Security Use Cases**:\n```bash\n# Detect cleartext passwords\nhttp.request.method == \"POST\" && http contains \"password\"\n\n# Identify devices on network\narp\n\n# Find DNS queries\ndns\n\n# SSL/TLS handshakes\nssl.handshake\n\n# Suspicious traffic patterns\ntcp.flags.syn==1 && tcp.flags.ack==0  (SYN packets - port scanning?)\n```bash\n\n### Switched Network Sniffing\n\n**Problem**: Switches send traffic only to destination MAC (not broadcast like hubs)\n**Solution for Attackers**:\n\n**1. ARP Spoofing** (explained earlier)\n**2. MAC Flooding**\n```\nFlood switch with fake MAC addresses\nSwitch MAC table full\nSwitch fails open (acts like hub, broadcasts all traffic)\nAttacker receives all traffic\n```\n\n**3. Port Mirroring** (Legitimate)\n```\nSwitch configured to mirror port traffic\nSecurity team monitors mirrored traffic\nUsed for IDS, network monitoring\n```bash\n\n## Key Takeaways\n\n1. **TCP/IP has 5 layers** - Physical, Data Link, Network, Transport, Application\n2. **TCP is reliable** (handshake, guaranteed delivery), **UDP is fast** (no handshake, no guarantee)\n3. **DNS translates domains to IPs** - Vulnerable to cache poisoning, tunneling, amplification DDoS\n4. **HTTP is insecure** (plaintext), **HTTPS is secure** (TLS encryption)\n5. **TLS/SSL provides** confidentiality, integrity, authentication via encryption and certificates\n6. **ARP resolves IP to MAC** on local network - Vulnerable to spoofing (MITM attacks)\n7. **Port scanning reveals services** - Nmap is industry standard tool\n8. **Firewalls control traffic** - Stateful firewalls track connections, default deny recommended\n9. **Network sniffing captures traffic** - Wireshark for analysis, useful for defense and attack\n10. **Most protocols designed without security** - Retrofitted security (TLS, DNSSEC, IPsec) compensates\n\nNetwork protocols are the foundation of all internet communication. Understand them and you understand 80% of network security."
      },
      "ascii_art": "TCP THREE-WAY HANDSHAKE\n\nClient                    Server\n  │                          │\n  │──── SYN (seq=100) ─────→│  Step 1: Client initiates\n  │                          │\n  │←─ SYN-ACK (seq=200, ────│  Step 2: Server responds\n  │    ack=101)              │\n  │                          │\n  │──── ACK (ack=201) ─────→│  Step 3: Client confirms\n  │                          │\n  │   CONNECTION ESTABLISHED │\n  │                          │\n  │════ DATA TRANSFER ══════│\n  │                          │\n\nTCP/IP LAYERS & PROTOCOLS\n\n┌──────────────────────────────┐\n│   APPLICATION LAYER          │  HTTP, HTTPS, DNS, SMTP,\n│   (Layer 5)                  │  SSH, FTP, Telnet\n├──────────────────────────────┤\n│   TRANSPORT LAYER            │  TCP (reliable),\n│   (Layer 4)                  │  UDP (fast)\n├──────────────────────────────┤\n│   NETWORK LAYER              │  IP, ICMP, Routing\n│   (Layer 3)                  │\n├──────────────────────────────┤\n│   DATA LINK LAYER            │  Ethernet, Wi-Fi (802.11),\n│   (Layer 2)                  │  ARP, MAC addresses\n├──────────────────────────────┤\n│   PHYSICAL LAYER             │  Cables, Radio waves,\n│   (Layer 1)                  │  Fiber optics\n└──────────────────────────────┘\n\nDNS QUERY FLOW\n\nUser: \"What's the IP of example.com?\"\n  │\n  ↓\n[Local DNS Cache]\n  │ Not found\n  ↓\n[Recursive Resolver] (8.8.8.8)\n  │ Not in cache\n  ↓\n[Root DNS Server] (.)\n  │ Response: \"Ask .com TLD\"\n  ↓\n[.com TLD Server]\n  │ Response: \"Ask example.com NS\"\n  ↓\n[example.com Authoritative]\n  │ Response: \"192.0.2.1\"\n  ↓\n[User's Computer]\n  │ Caches result\n  ↓\nConnects to 192.0.2.1\n\nARP SPOOFING ATTACK\n\nNormal:\n┌──────┐         ┌────────┐\n│Host A│←───────→│ Router │\n└──────┘         └────────┘\n192.168.1.2      192.168.1.1\n\nAttack:\n┌──────┐    ┌─────────┐    ┌────────┐\n│Host A│←──→│Attacker │←──→│ Router │\n└──────┘    └─────────┘    └────────┘\n             │ MITM!  │\n             │Reads/  │\n             │Modifies│\n             │Traffic │\n\nAttacker sends:\n  To Host A: \"Router IP (192.168.1.1)\n              is at Attacker-MAC\"\n  To Router: \"Host A IP (192.168.1.2)\n              is at Attacker-MAC\"\n\nHTTP vs HTTPS\n\nHTTP (Port 80):\n┌────────┐  GET /login?user=admin&pass=secret  ┌────────┐\n│Browser │──────────────────────────────────→│ Server │\n└────────┘         PLAINTEXT                 └────────┘\n              Anyone can read!\n\nHTTPS (Port 443):\n┌────────┐  �㊙�♦☺�♣�♠�  ┌────────┐\n│Browser │══════════════════════════════════→│ Server │\n└────────┘     ENCRYPTED with TLS            └────────┘\n              Attacker sees gibberish",
      "examples": [
        {
          "scenario": "SSL Stripping Attack on Banking Site",
          "explanation": "User at coffee shop connects to public Wi-Fi. Types 'bank.com' (not https://). Attacker performs ARP spoofing (MITM). User's browser sends HTTP request for bank.com. Attacker intercepts, forwards as HTTPS to real bank, receives HTTPS response. Attacker downgrades to HTTP, sends to user. User sees http://bank.com (not https://), may not notice. Enters credentials over HTTP. Attacker captures plaintext username/password. Prevention: HSTS (HTTP Strict Transport Security) forces browser to always use HTTPS for that domain. Bank implements HSTS, user's browser refuses HTTP, attack fails. Lesson: Always verify HTTPS (padlock icon), be cautious on public Wi-Fi."
        },
        {
          "scenario": "DNS Cache Poisoning Attack",
          "explanation": "Attacker wants to redirect users from bank.com to phishing site. Sends fake DNS responses to recursive resolver with spoofed source (authoritative server). Fake response: 'bank.com = 198.51.100.50' (attacker's server). Resolver caches fake entry. All users querying that resolver get fake IP. Users visit bank.com, redirected to perfect phishing site at 198.51.100.50. Credentials stolen. Real-world example: Kaminsky DNS vulnerability (2008) made cache poisoning trivial. Prevention: DNSSEC provides cryptographic signatures verifying DNS responses are authentic. Recursive resolvers validate signatures, reject fake responses. Modern internet increasingly adopts DNSSEC."
        },
        {
          "scenario": "Network Reconnaissance Before Attack",
          "explanation": "Pentester hired to test company network. Phase 1 (Passive): Examines DNS records (dig company.com ANY), finds mail servers, web servers, name servers. Searches Shodan for exposed services. Phase 2 (Active Scanning): Port scans external IPs (nmap -sV -A ip_range), identifies web server (Apache 2.4.41), mail server (Exchange), VPN gateway. Phase 3 (Enumeration): Runs Nmap scripts for version detection, finds vulnerable Apache version (CVE-2021-41773 - path traversal RCE). Phase 4 (Exploitation): Exploits vulnerability, gains initial access. From internal network, ARP scans to discover internal hosts, finds domain controller, file servers, database servers. Lesson: Network reconnaissance is critical first step. Defenders should perform same scans, close unnecessary ports, patch vulnerabilities before attackers find them."
        }
      ]
    },
    {
      "type": "video",
      "content": {
        "title": "Video: Network Protocols and Security Overview",
        "url": "https://www.youtube.com/embed/AJTJN4wDBM8",
        "description": "Watch this video for a visual introduction to the concepts covered in this lesson."
      }
    },
    {
      "block_id": "3c4d5e6f-7a8b-9c0d-1e2f-3a4b5c6d7e8f",
      "type": "quiz",
      "content": {
        "text": "Test your network protocol knowledge",
        "questions": [
          {
            "question": "Which layer of the TCP/IP model is responsible for routing packets across networks using IP addresses?",
            "options": [
              "Data Link Layer (Layer 2)",
              "Network Layer (Layer 3)",
              "Transport Layer (Layer 4)",
              "Application Layer (Layer 5)"
            ],
            "correct_answer": 1,
            "explanation": "Layer 3 (Network Layer) handles routing packets across networks using IP addresses. It determines the best path from source to destination across multiple networks. Data Link (Layer 2) handles node-to-node transfer on same network using MAC addresses. Transport (Layer 4) provides end-to-end communication using ports. Application (Layer 5) provides application-specific protocols."
          },
          {
            "question": "What is the primary security difference between HTTP and HTTPS?",
            "options": [
              "HTTPS uses different port numbers",
              "HTTPS encrypts traffic with TLS/SSL providing confidentiality, integrity, and authentication",
              "HTTPS is faster than HTTP",
              "HTTPS prevents all attacks"
            ],
            "correct_answer": 1,
            "explanation": "HTTPS encrypts all traffic using TLS/SSL, providing: (1) Confidentiality - attackers can't read data, (2) Integrity - tampering detected, (3) Authentication - certificate proves server identity. HTTP sends everything in plaintext (zero security). While HTTPS uses port 443 vs HTTP's 80, the port difference is not the security feature - encryption is. HTTPS doesn't prevent all attacks (application vulnerabilities still exist) but protects data in transit."
          },
          {
            "question": "An attacker sends fake ARP responses claiming the router's IP is at the attacker's MAC address. What attack is this?",
            "options": [
              "DNS Spoofing",
              "ARP Spoofing (ARP Poisoning)",
              "IP Spoofing",
              "MAC Flooding"
            ],
            "correct_answer": 1,
            "explanation": "This is ARP Spoofing (also called ARP Poisoning). Attacker sends fake ARP responses to poison the victim's ARP cache, making victim think router's IP is at attacker's MAC address. All traffic from victim intended for router goes to attacker instead - Man-in-the-Middle attack. Attacker can read, modify, or drop traffic. Prevention: Dynamic ARP Inspection (DAI), static ARP entries, network access control."
          },
          {
            "question": "What tool would you use to capture and analyze network traffic packets?",
            "options": [
              "nmap (port scanner)",
              "Wireshark (packet analyzer)",
              "netstat (connection viewer)",
              "ping (connectivity tester)"
            ],
            "correct_answer": 1,
            "explanation": "Wireshark is a packet analyzer (network sniffer) that captures and displays network traffic in detail. You can see every packet, decode protocols, filter traffic, and analyze patterns. Used for troubleshooting, forensics, and understanding network behavior. Nmap is for port scanning (discovering services), netstat shows current connections, ping tests connectivity. Only Wireshark captures and analyzes raw packets."
          },
          {
            "question": "Why is DNS vulnerable to cache poisoning attacks?",
            "options": [
              "DNS runs on UDP which is unreliable",
              "DNS was designed without authentication, so resolvers accept responses without verifying they're from legitimate source",
              "DNS uses weak encryption",
              "DNS servers are always misconfigured"
            ],
            "correct_answer": 1,
            "explanation": "DNS was designed in the 1980s without authentication mechanisms. Resolvers accept DNS responses without cryptographic verification of authenticity. Attacker can send fake responses that get cached and trusted. DNSSEC was developed to fix this by adding cryptographic signatures, but adoption is still incomplete. While DNS commonly uses UDP (not the vulnerability itself), and some servers may be misconfigured, the fundamental issue is lack of authentication in the original protocol design."
          }
        ]
      }
    },
    {
      "block_id": "4d5e6f7a-8b9c-0d1e-2f3a-4b5c6d7e8f9a",
      "type": "reflection",
      "content": {
        "text": "## Reflect on Network Security\n\n**Question 1**: You're investigating suspicious network activity. Wireshark capture shows:\n```\n192.168.1.50 → 192.168.1.1-192.168.1.254 (TCP SYN to port 22)\n192.168.1.50 → 192.168.1.1-192.168.1.254 (TCP SYN to port 80)\n192.168.1.50 → 192.168.1.1-192.168.1.254 (TCP SYN to port 443)\n192.168.1.50 → 192.168.1.1-192.168.1.254 (TCP SYN to port 3389)\n```\nWhat's happening? What's the attacker's goal? How would you respond?\n\n**Question 2**: Design network segmentation for a company with:\n- Public web servers\n- Internal employee workstations\n- Database servers with customer PII\n- Payment processing systems\n- Guest Wi-Fi\n\nCreate network diagram showing subnets, firewalls, and rules. Explain your security reasoning.\n\n**Question 3**: You notice these DNS queries from a workstation:\n```\naGVsbG8.attacker.com\nd29ybGQ.attacker.com\ndGhpcw.attacker.com\naXNz.attacker.com\nZWNyZQ.attacker.com\n```\nWhat attack is this? Decode the subdomains (hint: Base64). What data is being exfiltrated? How would you detect and prevent this?\n\n**Question 4**: Compare these HTTPS implementations:\n\n**Site A**:\n- Certificate from Let's Encrypt (free CA)\n- TLS 1.2, strong cipher suites\n- HSTS enabled\n- Certificate pinning in mobile app\n\n**Site B**:\n- Self-signed certificate\n- TLS 1.0 enabled for \"compatibility\"\n- No HSTS\n- Accepts any certificate in app\n\nAnalyze security of each. What attacks are possible? Which would you trust?\n\n**Question 5**: You're configuring a firewall for a web server (192.168.1.100). Write firewall rules allowing:\n- Inbound HTTPS from anywhere\n- Inbound SSH from admin network (10.0.0.0/24) only\n- Outbound DNS to 8.8.8.8\n- Outbound HTTPS for updates\n- Deny everything else\n\nThink about default deny, least privilege, and specific rules."
      }
    }
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand the TCP/IP five-layer model and responsibilities of each layer",
    "Explain how TCP, UDP, IP, DNS, HTTP/HTTPS, and ARP protocols work",
    "Identify security vulnerabilities in network protocols (ARP spoofing, DNS poisoning, SSL stripping)",
    "Differentiate between HTTP and HTTPS and understand TLS/SSL security benefits",
    "Perform basic network reconnaissance using Nmap and traffic analysis with Wireshark",
    "Configure firewall rules following security best practices (default deny, least privilege)",
    "Recognize network-based attacks through traffic patterns and protocol anomalies"
  ],
  "post_assessment": [
    {
      "question": "What are the five layers of the TCP/IP model?",
      "type": "multiple_choice",
      "options": [
        "Application, Presentation, Session, Transport, Network",
        "Physical, Data Link, Network, Transport, Application",
        "Hardware, Software, Network, Internet, Cloud",
        "Client, Server, Router, Switch, Firewall"
      ],
      "correct_answer": "Physical, Data Link, Network, Transport, Application",
      "explanation": "The TCP/IP model has 5 layers (bottom to top): Physical (cables, signals), Data Link (MAC addresses, Ethernet/Wi-Fi), Network (IP routing), Transport (TCP/UDP ports), Application (HTTP, DNS, etc.). The first option lists OSI model layers (7 layers). The others are not network models.",
      "question_id": "ac10c99e-ddf1-4174-873d-404432043e9b",
      "difficulty": 1
    },
    {
      "question": "How does HTTPS protect against man-in-the-middle attacks?",
      "type": "multiple_choice",
      "options": [
        "By using a different port number (443)",
        "By encrypting traffic with TLS and verifying server identity with digital certificates",
        "By blocking all attackers at the firewall",
        "By using stronger passwords"
      ],
      "correct_answer": "By encrypting traffic with TLS and verifying server identity with digital certificates",
      "explanation": "HTTPS uses TLS/SSL to: (1) Encrypt traffic so attacker can't read it, (2) Verify server identity via certificate (browser checks certificate is from trusted CA and matches domain name), (3) Detect tampering via cryptographic checksums. This prevents attacker from reading or modifying traffic. Port number alone provides no security. Passwords are application-level, not transport-level protection.",
      "question_id": "4e18c276-a0f1-4cc2-ba1c-e637dc234090",
      "difficulty": 1
    },
    {
      "question": "What is ARP spoofing and what attack does it enable?",
      "type": "multiple_choice",
      "options": [
        "Spoofing IP addresses to bypass firewalls",
        "Sending fake ARP responses to redirect traffic through attacker, enabling man-in-the-middle attacks",
        "Flooding network with ARP packets to cause denial of service",
        "Stealing ARP cache to discover network topology"
      ],
      "correct_answer": "Sending fake ARP responses to redirect traffic through attacker, enabling man-in-the-middle attacks",
      "explanation": "ARP spoofing involves sending fake ARP responses to poison victim's ARP cache. Attacker claims router's IP is at attacker's MAC address. Victim sends all traffic to attacker thinking it's the router. Attacker forwards traffic to real router, sitting in the middle reading/modifying everything - Man-in-the-Middle attack. Not about IP spoofing, DoS via flooding, or topology discovery.",
      "question_id": "0c17f71a-493a-4a5a-ac2f-f073ace6b20e",
      "difficulty": 1
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "meta_learning",
    "minimum_effective_dose",
    "teach_like_im_10",
    "memory_hooks",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ]
}