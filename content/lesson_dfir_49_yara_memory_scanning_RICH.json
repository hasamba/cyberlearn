{
  "lesson_id": "c4d5e6f7-a8b9-0c1d-2e3f-4a5b6c7d8e9f",
  "domain": "dfir",
  "title": "YARA Scanning in Memory: Detecting Malware Families in RAM",
  "difficulty": 2,
  "order_index": 49,
  "prerequisites": ["b3c4d5e6-f7a8-9b0c-1d2e-3f4a5b6c7d8e"],
  "concepts": [
    "YARA rule syntax and pattern matching",
    "Volatility yarascan plugin for memory scanning",
    "Creating effective YARA signatures from extracted malware",
    "Scanning process memory for malware families",
    "String-based vs binary pattern detection",
    "YARA rule optimization for memory forensics"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Write YARA rules to detect malware patterns in memory",
    "Use Volatility yarascan to scan memory dumps",
    "Create signatures from extracted malware binaries",
    "Detect malware families across multiple memory dumps",
    "Optimize YARA rules for speed and accuracy",
    "Build a YARA rule library for common threats"
  ],
  "post_assessment": [
    {
      "question_id": "yara-001",
      "question": "Which YARA rule component is REQUIRED for a valid rule?",
      "options": [
        "meta section (optional metadata)",
        "strings section (at least one string or pattern)",
        "condition section (defines when rule matches)",
        "All of the above are optional"
      ],
      "correct_answer": 2,
      "explanation": "The condition section is REQUIRED - it defines the logic that determines when a rule matches. The meta section is optional (provides metadata like author, description). The strings section is technically optional (you can write rules with only conditions like 'filesize < 100KB'), but most practical rules have strings. A minimal valid YARA rule is: 'rule test { condition: true }'. However, useful rules typically have: meta (description), strings (patterns to find), and condition (when to alert). The condition evaluates boolean logic combining string matches, file properties, etc.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "yara-002",
      "question": "You want to detect Emotet malware that has strings 'EmotetLoader' AND 'BotID:'. Which condition is correct?",
      "options": [
        "condition: $emotet or $botid",
        "condition: $emotet and $botid",
        "condition: any of them",
        "condition: all of them"
      ],
      "correct_answer": 1,
      "explanation": "Use 'and' operator to require BOTH strings: 'condition: $emotet and $botid'. The 'or' operator matches if EITHER string is found (too permissive). 'any of them' matches if any defined string is found (same as 'or' for 2 strings). 'all of them' requires ALL defined strings (same as 'and' for 2 strings, but more flexible for multiple strings). For exactly 2 strings where both are required, '$emotet and $botid' is clearest. Alternative syntax: '2 of ($emotet, $botid)' or 'all of ($emotet, $botid)'.",
      "type": "multiple_choice",
      "difficulty": 1
    },
    {
      "question_id": "yara-003",
      "question": "What does the 'wide' keyword do in YARA string definitions: $str = 'malware' wide?",
      "options": [
        "Matches the string in any character encoding",
        "Matches Unicode (UTF-16LE) encoding with null bytes between characters",
        "Makes the string case-insensitive",
        "Allows wildcards in the string"
      ],
      "correct_answer": 1,
      "explanation": "'wide' matches Unicode UTF-16LE encoding where each ASCII character is followed by a null byte. For example: 'malware' in ASCII is 6 bytes: 'm''a''l''w''a''r''e'. In UTF-16LE (wide), it's 12 bytes: 'm'\\x00'a'\\x00'l'\\x00'w'\\x00'a'\\x00'r'\\x00'e'. Windows uses UTF-16LE internally, so many Windows API strings, registry values, and malware strings are wide. Common usage: $str = 'malware' ascii wide (matches both ASCII and wide). Case-insensitivity uses 'nocase' keyword. Wildcards use hex patterns with '?' placeholders.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "yara-004",
      "question": "You scan memory with yarascan and get 500 matches. How do you reduce false positives?",
      "options": [
        "Add more generic strings to catch more malware variants",
        "Make strings more specific and use multiple strings with 'all of them' condition",
        "Remove the condition section entirely",
        "Use only hexadecimal patterns instead of strings"
      ],
      "correct_answer": 1,
      "explanation": "Reduce false positives by: (1) Using more specific/unique strings (e.g., 'C2_BEACON_PROTOCOL_v3' vs. 'http'), (2) Requiring multiple strings ('all of them' or '3 of them'), (3) Adding file size constraints ('filesize < 500KB'), (4) Checking PE headers ('uint16(0) == 0x5A4D'), (5) Combining multiple indicators. Adding generic strings increases false positives. Removing conditions makes rules useless. Hex patterns alone may miss variants. Best practice: Specific strings + multi-string conditions + file constraints = high accuracy.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "yara-005",
      "question": "Which Volatility yarascan syntax scans ONLY PID 2304 instead of all processes?",
      "options": [
        "windows.yarascan --yara-file rules.yar (scans all memory)",
        "windows.yarascan --yara-file rules.yar --pid 2304 (scans specific PID)",
        "windows.yarascan --yara-file rules.yar --kernel (scans kernel memory only)",
        "windows.yarascan --yara-file rules.yar --process svchost.exe (scans by name)"
      ],
      "correct_answer": 1,
      "explanation": "Use --pid flag to scan specific process: 'windows.yarascan --yara-file rules.yar --pid 2304'. Without --pid, yarascan scans ALL process memory (slow on large dumps). --kernel flag scans kernel memory space (useful for rootkit detection but different from process scanning). Volatility 3 doesn't have --process flag for name-based filtering (must use pslist to find PID first, then yarascan with --pid). For efficiency: (1) Identify suspicious PID via pslist/netscan, (2) Scan that specific PID with yarascan, (3) Saves time vs. scanning all 100+ processes.",
      "type": "multiple_choice",
      "difficulty": 2
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "teach_like_im_10",
    "memory_hooks",
    "connect_to_what_i_know",
    "minimum_effective_dose"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "# Welcome to YARA Scanning in Memory!\n\nYou're about to learn one of the most powerful malware hunting techniques: using **YARA rules** to detect malware families across memory dumps.\n\nThink about your workflow so far:\n- Lesson 48: You extracted malware from memory (procdump)\n- You analyzed it and found unique strings (\"EmotetLoader\", C2 URLs, Bitcoin addresses)\n- You identified one infected system\n\n**But what about the OTHER 500 endpoints in your network?**\n\nThis is where YARA becomes your superpower:\n\n1. **Create YARA signature** from extracted malware\n2. **Scan all memory dumps** with that signature  \n3. **Find every infected system** automatically\n4. **No manual analysis needed** - YARA does the hunting\n\nReal-world example: **2017 WannaCry ransomware outbreak**\n- Researchers extracted WannaCry from memory\n- Created YARA rule detecting 'tasksche.exe' (dropped filename) + 'WanaCrypt0r' strings\n- Rule shared globally within hours\n- Organizations scanned networks finding infections before encryption triggered\n- **YARA signatures saved millions in ransomware payments**\n\nYou'll learn to write rules that detect:\n- Malware families (Emotet, TrickBot, Cobalt Strike)\n- Specific techniques (process injection, credential dumping)\n- Custom threats unique to your organization\n\nLet's master YARA memory scanning!"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# YARA Rule Fundamentals\n\n## What is YARA?\n\nYARA (Yet Another Ridiculous Acronym, or \"Yet Another Recursive Acronym\") is a pattern-matching tool for identifying and classifying malware. Created by Victor Alvarez at VirusTotal.\n\n**Key concept**: YARA rules describe patterns (strings, byte sequences, file properties) and conditions (when those patterns indicate malware).\n\n## Basic YARA Rule Structure\n\n```yara\nrule RuleName {\n    meta:\n        description = \"What this rule detects\"\n        author = \"Your Name\"\n        date = \"2024-01-15\"\n        hash = \"SHA256 of sample\"\n    \n    strings:\n        $string1 = \"unique_malware_string\" ascii\n        $string2 = \"C2_SERVER_URL\" wide\n        $hex_pattern = { 6A 40 68 00 30 00 00 }  // Assembly opcodes\n    \n    condition:\n        any of them  // Match if ANY string is found\n}\n```\n\n**Four sections**:\n1. **Rule name**: Identifier (RuleName)\n2. **Meta** (optional): Metadata for documentation\n3. **Strings**: Patterns to search for\n4. **Condition** (required): Logic defining when rule matches\n\n## String Types\n\n### Text Strings\n\n```yara\nstrings:\n    $ascii_str = \"malware\" ascii          // ASCII encoding\n    $wide_str = \"malware\" wide            // UTF-16LE (Windows Unicode)\n    $both = \"malware\" ascii wide          // Match both encodings\n    $nocase = \"MALWARE\" nocase            // Case-insensitive\n    $fullword = \"bot\" fullword            // Must be complete word (not \"robot\")\n```\n\n**Best practice**: Use `ascii wide` to catch both encodings in Windows malware.\n\n### Hexadecimal Patterns\n\n```yara\nstrings:\n    // Exact bytes\n    $hex1 = { 4D 5A 90 00 }  // PE \"MZ\" header + padding\n    \n    // Wildcards (? = any nibble)\n    $hex2 = { 6A ?? 68 ?? ?? ?? ?? }  // push ?; push ????????\n    \n    // Jumps [min-max]\n    $hex3 = { 4D 5A [0-8] 50 45 }  // MZ...PE (0-8 bytes between)\n    \n    // Alternatives ( | )\n    $hex4 = { ( 55 | 56 | 57 ) 8B EC }  // push ebp|esi|edi; mov ebp, esp\n```\n\n**Use cases**: Detecting packed malware, shellcode, specific CPU instructions.\n\n### Regular Expressions\n\n```yara\nstrings:\n    $ip = /([0-9]{1,3}\\.){3}[0-9]{1,3}/  // IPv4 addresses\n    $url = /https?:\\/\\/[a-z0-9.-]+/      // HTTP/HTTPS URLs\n    $btc = /[13][a-zA-Z0-9]{25,34}/      // Bitcoin addresses\n```\n\n**Warning**: Regex can be slow on large memory dumps. Use sparingly.\n\n## Condition Logic\n\n### Simple Conditions\n\n```yara\ncondition:\n    $string1                    // Match if $string1 found\n    $string1 and $string2       // Both strings required\n    $string1 or $string2        // Either string matches\n    not $string1                // Match if NOT found (rare)\n```\n\n### Counting Conditions\n\n```yara\ncondition:\n    #string1 > 5                // $string1 appears more than 5 times\n    any of them                 // Any defined string matches\n    all of them                 // All strings required\n    2 of them                   // At least 2 strings match\n    2 of ($str*)                // At least 2 strings starting with \"str\"\n```\n\n### File Properties\n\n```yara\ncondition:\n    filesize < 500KB                           // File size constraint\n    uint16(0) == 0x5A4D                        // Check for \"MZ\" at offset 0\n    uint32(uint32(0x3C)) == 0x00004550         // Check for \"PE\" signature\n    $string1 in (0..1024)                      // String in first 1KB\n```\n\n**Memory dumps**: `filesize` is process memory size, not disk file size.\n\n## Volatility yarascan Plugin\n\n### Basic Usage\n\n```bash\n# Scan all process memory\npython vol.py -f memory.dmp windows.yarascan --yara-file malware_rules.yar\n\n# Scan specific process\npython vol.py -f memory.dmp windows.yarascan --yara-file malware_rules.yar --pid 2304\n\n# Scan kernel memory\npython vol.py -f memory.dmp windows.yarascan --yara-file malware_rules.yar --kernel\n```\n\n### Output Format\n\n```\nRule: Emotet_Loader\nOwner: Process pid.2304 (malware.exe)\nOffset: 0x400000 (Image base address)\nHex Dump:\n0x00400000: 45 6d 6f 74 65 74 4c 6f 61 64 65 72 20 76 34 2e   EmotetLoader v4.\n0x00400010: 33 00 42 6f 74 49 44 3a 20 25 30 38 58 00 43 72   3.BotID: %08X.Cr\n```\n\n**Key fields**:\n- **Rule**: Which YARA rule matched\n- **Owner**: Process containing the match\n- **Offset**: Virtual address where pattern found\n- **Hex Dump**: 32 bytes showing the match context\n\n## Creating YARA Rules from Extracted Malware\n\n### Step 1: Extract Unique Strings\n\n```bash\n# Extract strings from dumped malware\nstrings pid.2304.exe > malware_strings.txt\n\n# Find unique/rare strings (not in benign software)\ngrep -v -f /path/to/common_strings.txt malware_strings.txt > unique_strings.txt\n\ncat unique_strings.txt\n```\n\n**Example output**:\n```\nEmotetLoader v4.3\nBotID: %08X\nSpamEngine_Init\nC&C_Connect\nhttp://185.220.101.67/api/\n```\n\n### Step 2: Write YARA Rule\n\n```yara\nrule Emotet_2024_Variant {\n    meta:\n        description = \"Detects Emotet banking trojan\"\n        author = \"IR Team\"\n        date = \"2024-01-15\"\n        hash = \"7a8b9c0d1e2f...\"\n        reference = \"Emotet campaign analysis\"\n    \n    strings:\n        // Unique version strings\n        $ver = \"EmotetLoader v\" ascii\n        $bot = \"BotID: %08X\" ascii\n        \n        // Functionality strings\n        $spam = \"SpamEngine_Init\" ascii\n        $c2 = \"C&C_Connect\" ascii\n        \n        // C2 infrastructure (URL pattern)\n        $url = /http:\\/\\/[0-9.]+\\/api\\// ascii\n        \n        // Crypto API imports (wide for Unicode)\n        $crypt1 = \"CryptAcquireContextW\" ascii wide\n        $crypt2 = \"WNetEnumResourceW\" ascii wide\n    \n    condition:\n        // Must be PE file\n        uint16(0) == 0x5A4D and\n        \n        // Reasonable file size\n        filesize < 500KB and\n        \n        // At least 2 unique strings\n        2 of ($ver, $bot, $spam, $c2) or\n        \n        // Or URL pattern + crypto APIs\n        ($url and all of ($crypt*))\n}\n```\n\n### Step 3: Test Rule\n\n```bash\n# Test on known malware sample\nyara malware_rules.yar pid.2304.exe\n# Output: Emotet_2024_Variant pid.2304.exe (MATCH!)\n\n# Test on benign files (should NOT match)\nyara malware_rules.yar c:\\windows\\system32\\notepad.exe\n# Output: (no matches - good!)\n```\n\n## Scanning Memory Dumps\n\n### Workflow: Network-Wide Hunt\n\n```bash\n# Step 1: Identify suspicious process on one system\npython vol.py -f patient_zero.dmp windows.pslist | grep suspicious\n\n# Step 2: Extract malware\npython vol.py -f patient_zero.dmp windows.procdump --pid 2304 --dump-dir ./\n\n# Step 3: Create YARA rule (as shown above)\nvim emotet_detection.yar\n\n# Step 4: Scan all collected memory dumps\nfor dump in /evidence/memory_dumps/*.dmp; do\n    echo \"Scanning: $dump\"\n    python vol.py -f \"$dump\" windows.yarascan --yara-file emotet_detection.yar\ndone > scan_results.txt\n\n# Step 5: Parse results\ngrep \"Rule:\" scan_results.txt\n```\n\n**Output**:\n```\nScanning: workstation001.dmp\nScanning: workstation002.dmp\nRule: Emotet_2024_Variant (workstation002.dmp - INFECTED!)\nScanning: workstation003.dmp\nRule: Emotet_2024_Variant (workstation003.dmp - INFECTED!)\n...\n```\n\n**Result**: Found 15 infected systems across network using one YARA rule!\n\n## Advanced YARA Techniques\n\n### Multi-String Grouping\n\n```yara\nrule Advanced_Malware {\n    strings:\n        // Group 1: Network IOCs\n        $net1 = \"C2_SERVER\" ascii\n        $net2 = \"BEACON_INTERVAL\" ascii\n        $net3 = \"EXFIL_DATA\" ascii\n        \n        // Group 2: Crypto functions\n        $cry1 = \"AES_Encrypt\" ascii\n        $cry2 = \"RSA_Sign\" ascii\n        \n        // Group 3: Anti-analysis\n        $anti1 = \"IsDebuggerPresent\" ascii\n        $anti2 = \"CheckVirtualPC\" ascii\n    \n    condition:\n        // At least 2 from network group AND 1 from crypto group\n        (2 of ($net*) and 1 of ($cry*)) or\n        \n        // Or any anti-analysis + any network\n        (any of ($anti*) and any of ($net*))\n}\n```\n\n### PE Header Checks\n\n```yara\nimport \"pe\"\n\nrule Suspicious_PE {\n    condition:\n        pe.is_pe and                                  // Is valid PE file\n        pe.number_of_sections > 6 and                 // Unusual section count\n        pe.imports(\"kernel32.dll\", \"VirtualAlloc\") and  // Uses memory allocation\n        pe.imports(\"ws2_32.dll\", \"connect\") and       // Network capability\n        not pe.is_signed                              // No digital signature\n}\n```\n\n### Entropy Detection (Packed Malware)\n\n```yara\nimport \"math\"\n\nrule Packed_Executable {\n    condition:\n        uint16(0) == 0x5A4D and      // Is PE file\n        math.entropy(0, filesize) > 7.0  // High entropy = packed/encrypted\n}\n```\n\n## Optimization Tips\n\n### Speed Optimization\n\n1. **Use specific strings**: `$str = \"VerySpecificMalwareString\"` (fast) vs. `$str = \"http\"` (slow - too common)\n\n2. **Limit filesize early**: \n   ```yara\n   condition:\n       filesize < 500KB and  // Check this FIRST (fast)\n       $string1              // Then check strings\n   ```\n\n3. **Use hex patterns for headers**:\n   ```yara\n   condition:\n       uint16(0) == 0x5A4D and  // Fast uint check\n       not $common_string       // Avoid expensive regex\n   ```\n\n4. **Scan specific PIDs**: Use `--pid` flag to avoid scanning all 100+ processes.\n\n### Accuracy Optimization\n\n1. **Multiple strings**: `3 of them` (reduces false positives vs. `any of them`)\n\n2. **Combine indicators**:\n   ```yara\n   condition:\n       $unique_string and\n       filesize < 500KB and\n       uint16(0) == 0x5A4D\n   ```\n\n3. **Use fullword**: `$str = \"bot\" fullword` (won't match \"robot\")\n\n4. **Test on benign software**: Ensure rule doesn't match legitimate apps.\n\n## Common YARA Rule Library\n\n### Generic Code Injection\n\n```yara\nrule Code_Injection_Techniques {\n    strings:\n        $api1 = \"VirtualAllocEx\" ascii wide\n        $api2 = \"WriteProcessMemory\" ascii wide\n        $api3 = \"CreateRemoteThread\" ascii wide\n        $api4 = \"NtCreateThreadEx\" ascii wide\n    \n    condition:\n        3 of them\n}\n```\n\n### Credential Dumping (Mimikatz-style)\n\n```yara\nrule Credential_Dumping {\n    strings:\n        $lsass = \"lsass.exe\" ascii wide nocase\n        $sam = \"SAM\" ascii wide\n        $sekurlsa = \"sekurlsa\" ascii\n        $mimikatz = \"mimikatz\" ascii nocase\n    \n    condition:\n        2 of them\n}\n```\n\n### Ransomware Indicators\n\n```yara\nrule Ransomware_Generic {\n    strings:\n        $ransom1 = \"decrypt\" ascii wide nocase\n        $ransom2 = \"bitcoin\" ascii wide nocase\n        $ransom3 = \"encrypted\" ascii wide nocase\n        $ext1 = \".locked\" ascii\n        $ext2 = \".encrypted\" ascii\n        $crypto = \"CryptEncrypt\" ascii\n    \n    condition:\n        3 of ($ransom*) or\n        (1 of ($ext*) and $crypto)\n}\n```\n\n## Summary\n\nYARA enables:\n- ‚úÖ Automated malware detection across memory dumps\n- ‚úÖ Network-wide hunting for specific threats\n- ‚úÖ Building organizational threat library\n- ‚úÖ Detecting malware families without manual analysis\n- ‚úÖ Sharing intelligence via portable rules\n\nMaster YARA and you can hunt malware at scale!"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Hands-On Lab: Building and Using YARA Rules\n\n## Lab Scenario\n\nYou extracted Cobalt Strike beacon from memory (Lesson 48). Now create YARA rule to hunt for it across your network.\n\n## Exercise 1: Analyze Malware for Unique Strings\n\n```bash\n# Extract strings from Cobalt Strike beacon\nstrings cobaltstrike_beacon.exe > beacon_strings.txt\n\nhead -50 beacon_strings.txt\n```\n\n**Found unique strings**:\n```\nMSSE-4533-server\nbeacon.dll\nReflectiveLoader\nhttp://192.168.1.50:80/pixel.gif\nMozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko\n%s.4%08x%08x%08x%08x%08x.%08x%08x%08x%08x%08x%08x%08x.%08x%08x%08x%08x%08x%08x%08x.%x%x.%s\n```\n\n**Analysis**:\n- \"MSSE-4533-server\" = Pipe name (unique to Cobalt Strike)\n- \"ReflectiveLoader\" = In-memory loading technique\n- \"beacon.dll\" = Beacon component name\n- URL pattern = C2 server\n- User-Agent = Specific UA string\n\n## Exercise 2: Write YARA Rule\n\n```yara\nrule CobaltStrike_Beacon_2024 {\n    meta:\n        description = \"Detects Cobalt Strike beacon in memory\"\n        author = \"Red Team Hunter\"\n        date = \"2024-01-15\"\n        reference = \"https://www.cobaltstrike.com/\"\n        severity = \"critical\"\n    \n    strings:\n        // Named pipe pattern (very specific to CS)\n        $pipe = /MSSE-[0-9]{4}-server/ ascii wide\n        \n        // Beacon component\n        $beacon = \"beacon.dll\" ascii wide nocase\n        \n        // Reflective DLL loading\n        $reflect = \"ReflectiveLoader\" ascii\n        \n        // C2 callback pattern (pixel.gif is common CS malleable C2)\n        $c2_url = /\\/pixel\\.gif/ ascii\n        \n        // Encoded data transmission format\n        $format = /\\%s\\.4\\%08x/ ascii\n        \n        // User-Agent string\n        $ua = \"Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0\" ascii\n    \n    condition:\n        // Must have pipe name (unique identifier)\n        $pipe or\n        \n        // Or combination of beacon indicators\n        (($beacon or $reflect) and ($c2_url or $ua)) or\n        \n        // Or data format + any other indicator\n        ($format and 1 of ($beacon, $reflect, $c2_url))\n}\n```\n\n**Save rule**: `vim cobaltstrike.yar`\n\n## Exercise 3: Test Rule on Known Sample\n\n```bash\n# Test on extracted beacon\nyara cobaltstrike.yar cobaltstrike_beacon.exe\n\n# Expected output:\nCobaltStrike_Beacon_2024 cobaltstrike_beacon.exe\n\n# Test on benign file (should NOT match)\nyara cobaltstrike.yar /windows/system32/notepad.exe\n\n# Expected: (no output - no match)\n```\n\n## Exercise 4: Scan Memory Dump\n\n```bash\n# Scan specific process from original memory dump\npython vol.py -f incident.dmp windows.yarascan \\\n  --yara-file cobaltstrike.yar \\\n  --pid 2304\n```\n\n**Output**:\n```\nRule: CobaltStrike_Beacon_2024\nOwner: Process pid.2304 (rundll32.exe)\nOffset: 0x400000\n\n0x00400000: 4d 53 53 45 2d 34 35 33 33 2d 73 65 72 76 65 72   MSSE-4533-server\n0x00400010: 00 00 00 00 62 65 61 63 6f 6e 2e 64 6c 6c 00 00   ....beacon.dll..\n\nRule: CobaltStrike_Beacon_2024\nOwner: Process pid.2304 (rundll32.exe)\nOffset: 0x450000\n\n0x00450000: 68 74 74 70 3a 2f 2f 31 39 32 2e 31 36 38 2e 31   http://192.168.1\n0x00450010: 2e 35 30 3a 38 30 2f 70 69 78 65 6c 2e 67 69 66   .50:80/pixel.gif\n```\n\n**Analysis**: Found 2 matches in rundll32.exe (common Cobalt Strike carrier).\n\n## Exercise 5: Network-Wide Hunt\n\nAssum you have 20 memory dumps from different systems:\n\n```bash\n# Create hunt script\ncat > hunt_cobaltstrike.sh << 'EOF'\n#!/bin/bash\n\nDUMPS_DIR=\"/evidence/memory_dumps\"\nYARA_RULE=\"cobaltstrike.yar\"\nRESULTS=\"hunt_results.txt\"\n\necho \"[+] Starting Cobalt Strike hunt across network\" > \"$RESULTS\"\necho \"[+] Scanning $(ls \"$DUMPS_DIR\"/*.dmp | wc -l) memory dumps\" >> \"$RESULTS\"\necho \"\" >> \"$RESULTS\"\n\nfor dump in \"$DUMPS_DIR\"/*.dmp; do\n    hostname=$(basename \"$dump\" .dmp)\n    echo \"[*] Scanning: $hostname\"\n    \n    result=$(python vol.py -f \"$dump\" windows.yarascan --yara-file \"$YARA_RULE\" 2>/dev/null)\n    \n    if echo \"$result\" | grep -q \"CobaltStrike_Beacon\"; then\n        echo \"[!] INFECTED: $hostname\" | tee -a \"$RESULTS\"\n        echo \"$result\" >> \"$RESULTS\"\n        echo \"\" >> \"$RESULTS\"\n    else\n        echo \"[+] Clean: $hostname\"\n    fi\ndone\n\necho \"\" >> \"$RESULTS\"\necho \"[+] Hunt complete. Results saved to $RESULTS\"\nEOF\n\nchmod +x hunt_cobaltstrike.sh\n./hunt_cobaltstrike.sh\n```\n\n**Output**:\n```\n[*] Scanning: workstation001\n[+] Clean: workstation001\n[*] Scanning: workstation002\n[!] INFECTED: workstation002\n[*] Scanning: workstation003\n[+] Clean: workstation003\n...\n[*] Scanning: server015\n[!] INFECTED: server015\n[+] Hunt complete. Results saved to hunt_results.txt\n```\n\n**Results summary**:\n```bash\ngrep \"INFECTED\" hunt_results.txt\n# [!] INFECTED: workstation002\n# [!] INFECTED: workstation007\n# [!] INFECTED: server015\n```\n\n**Found 3 infected systems** from single YARA rule!\n\n## Exercise 6: Create Multi-Malware Rule Set\n\nBuild rule library for common threats:\n\n```yara\n// File: malware_library.yar\n\nimport \"pe\"\n\nrule Emotet_Loader {\n    strings:\n        $s1 = \"EmotetLoader\" ascii\n        $s2 = \"BotID:\" ascii\n        $s3 = \"SpamEngine\" ascii\n    condition:\n        2 of them\n}\n\nrule TrickBot_Banker {\n    strings:\n        $s1 = \"moduleconfig\" ascii\n        $s2 = \"injectDll\" ascii\n        $s3 = \"/command.php\" ascii\n    condition:\n        2 of them\n}\n\nrule Mimikatz_CredDump {\n    strings:\n        $s1 = \"sekurlsa\" ascii\n        $s2 = \"lsadump\" ascii\n        $s3 = \"kerberos\" ascii\n        $s4 = \"mimikatz\" ascii nocase\n    condition:\n        2 of them\n}\n\nrule Generic_Ransomware {\n    strings:\n        $s1 = /\\.locked|\\.encrypted|\\.crypt/ ascii\n        $s2 = \"bitcoin\" ascii nocase\n        $s3 = \"decrypt\" ascii nocase\n        $s4 = \"CryptEncrypt\" ascii\n    condition:\n        2 of ($s1, $s2, $s3) or ($s1 and $s4)\n}\n\nrule Process_Injection {\n    strings:\n        $api1 = \"VirtualAllocEx\" ascii wide\n        $api2 = \"WriteProcessMemory\" ascii wide\n        $api3 = \"CreateRemoteThread\" ascii wide\n    condition:\n        all of them\n}\n```\n\n**Scan with entire library**:\n```bash\npython vol.py -f memory.dmp windows.yarascan --yara-file malware_library.yar\n```\n\n## Exercise 7: Handling False Positives\n\nYour ransomware rule matches legitimate backup software:\n\n```bash\nyara ransomware.yar /path/to/Acronis_Backup.exe\n# Output: Generic_Ransomware Acronis_Backup.exe (FALSE POSITIVE!)\n```\n\n**Solution**: Add exclusion logic\n\n```yara\nrule Generic_Ransomware_v2 {\n    strings:\n        // Ransomware strings\n        $ransom1 = \".locked\" ascii\n        $ransom2 = \"bitcoin\" ascii nocase\n        $ransom3 = \"decrypt\" ascii nocase\n        \n        // Legitimate software strings (exclusions)\n        $legit1 = \"Acronis\" ascii\n        $legit2 = \"Veeam\" ascii\n        $legit3 = \"Microsoft\" ascii\n        $legit4 = \"Symantec\" ascii\n    \n    condition:\n        // Match ransomware strings\n        2 of ($ransom*) and\n        \n        // BUT NOT if legitimate software detected\n        not any of ($legit*) and\n        \n        // And file size constraint (Acronis Backup is 50MB+)\n        filesize < 5MB\n}\n```\n\n## Exercise 8: Performance Benchmarking\n\nTest YARA rule performance:\n\n```bash\n# Benchmark scan time\ntime python vol.py -f large_dump.dmp windows.yarascan --yara-file slow_rule.yar\n# Output: real 15m30s (TOO SLOW!)\n\n# Optimize rule (remove regex, add filesize check)\ntime python vol.py -f large_dump.dmp windows.yarascan --yara-file optimized_rule.yar\n# Output: real 2m15s (MUCH BETTER!)\n```\n\n**Optimization**:\n- Removed regex patterns\n- Added `filesize < 1MB` early in condition\n- Used hex patterns instead of wildcards\n- Reduced string count from 20 to 5 most unique\n\n## Challenge Exercise: Advanced Rule with Imports\n\n```yara\nimport \"pe\"\nimport \"math\"\n\nrule Advanced_Malware_Detector {\n    meta:\n        description = \"Detects packed malware with suspicious imports\"\n    \n    strings:\n        $net = \"InternetOpenA\" ascii\n        $proc = \"CreateProcessA\" ascii\n    \n    condition:\n        // Is PE file\n        pe.is_pe and\n        \n        // Not signed (suspicious)\n        not pe.is_signed and\n        \n        // High entropy (packed)\n        math.entropy(0, filesize) > 7.2 and\n        \n        // Has network + process creation\n        all of them and\n        \n        // Imports from suspicious DLLs\n        pe.imports(\"kernel32.dll\", \"VirtualAlloc\") and\n        pe.imports(\"ws2_32.dll\", \"connect\")\n}\n```\n\nThis rule combines:\n- PE structure analysis\n- Entropy calculation\n- String patterns\n- Import table inspection\n\n**Very low false positive rate!**"
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "# Real-World Case Study: YARA in the SolarWinds Investigation (2020)\n\n## Incident Overview\n\nWhen FireEye discovered the SolarWinds supply chain compromise in December 2020, YARA rules played a critical role in:\n\n1. **Identifying infected systems** across thousands of organizations\n2. **Detecting SUNBURST backdoor** variants\n3. **Finding TEARDROP memory-only malware**\n4. **Discovering Cobalt Strike beacons** deployed post-compromise\n5. **Enabling global threat hunting** through shared rules\n\n## Timeline: YARA Rule Development\n\n### Day 0 (December 8, 2020): Initial Discovery\n\nFireEye extracted SUNBURST backdoor from memory of compromised SolarWinds Orion server.\n\n```bash\n# Extracted DLL from process memory\npython vol.py -f orion_server.dmp windows.procdump --pid 2304\n\n# File: SolarWinds.Orion.Core.BusinessLayer.dll (trojanized)\n```\n\n### Day 1: String Analysis\n\nResearchers analyzed the trojanized DLL:\n\n```bash\nstrings SolarWinds.Orion.Core.BusinessLayer.dll | grep -v \"^.....$\" > sunburst_strings.txt\n```\n\n**Unique indicators found**:\n- \"avsvmcloud.com\" (C2 domain masquerading as Avast)\n- Encoded victim fingerprinting logic\n- DGA (Domain Generation Algorithm) patterns\n- Specific API call sequences\n\n### Day 2: YARA Rule v1 (Public Release)\n\nFireEye published first YARA rule:\n\n```yara\nrule APT_Backdoor_MSIL_SUNBURST_1 {\n    meta:\n        author = \"FireEye\"\n        description = \"SUNBURST backdoor\"\n        date = \"2020-12-13\"\n    \n    strings:\n        $s1 = \"avsvmcloud.com\" ascii wide\n        $s2 = \"deftsecurity.com\" ascii wide\n        $s3 = \"panhardware.com\" ascii wide\n        $s4 = { 0F B6 4? ?? 83 F? [0-4] D1 E? }\n    \n    condition:\n        (uint16(0) == 0x5A4D) and filesize < 5MB and 2 of them\n}\n```\n\n**Impact**: Within 24 hours, organizations worldwide scanned their networks.\n\n### Day 3-7: Memory-Based Hunt\n\nOrganizations with memory forensics capabilities began hunting:\n\n```bash\n# Scan all Orion server memory dumps\nfor dump in /evidence/orion_servers/*.dmp; do\n    echo \"Scanning: $dump\"\n    python vol.py -f \"$dump\" windows.yarascan --yara-file sunburst.yar\ndone\n```\n\n**Results**: 18,000+ organizations confirmed SolarWinds Orion installed, but only ~100 had SUNBURST backdoor active (targeted attack, not widespread).\n\n### Week 2: TEARDROP Discovery\n\nMemory analysis revealed second-stage payload (TEARDROP) - memory-only malware:\n\n```bash\n# Dumped suspicious process memory\npython vol.py -f orion_server.dmp windows.memdump --pid 3456\n\n# Searched for embedded PE files\nbulk_extractor -o carved -E exe pid.3456.dmp\n```\n\n**TEARDROP characteristics**:\n- Loaded entirely in memory (no disk file)\n- Custom Cobalt Strike loader\n- Anti-forensics (self-deletes from RAM after execution)\n\n**YARA rule for TEARDROP**:\n\n```yara\nrule APT_Dropper_Win64_TEARDROP_1 {\n    meta:\n        author = \"FireEye\"\n        description = \"TEARDROP memory-only dropper\"\n    \n    strings:\n        $s1 = { C7 44 24 ?? 80 00 00 00 [0-64] FF 15 }\n        $s2 = { 41 B8 [4] 48 89 54 24 ?? 48 8D 4C 24 ?? FF 15 }\n        $s3 = \"RAINDROP\" ascii  // Related variant\n    \n    condition:\n        (uint16(0) == 0x5A4D) and any of them\n}\n```\n\n**Key difference**: Memory-only malware required scanning process memory dumps, not just disk files.\n\n## YARA Workflow in SolarWinds Response\n\n### Enterprise Hunt Process\n\n```bash\n#!/bin/bash\n# solarwinds_hunt.sh - Scan fleet for SUNBURST\n\nYARA_RULES=\"sunburst_teardrop.yar\"\nMEM_DUMPS_DIR=\"/evidence/memory_dumps\"\nRESULTS_DB=\"/results/findings.db\"\n\necho \"[+] Starting SolarWinds compromise hunt\"\necho \"[+] Scanning $(ls \"$MEM_DUMPS_DIR\" | wc -l) memory dumps\"\n\nfor dump in \"$MEM_DUMPS_DIR\"/*.dmp; do\n    hostname=$(basename \"$dump\" .dmp)\n    \n    # Scan for SUNBURST\n    sunburst_match=$(python vol.py -f \"$dump\" windows.yarascan --yara-file \"$YARA_RULES\" 2>/dev/null | grep -c \"SUNBURST\")\n    \n    # Scan for TEARDROP\n    teardrop_match=$(python vol.py -f \"$dump\" windows.yarascan --yara-file \"$YARA_RULES\" 2>/dev/null | grep -c \"TEARDROP\")\n    \n    if [ $sunburst_match -gt 0 ] || [ $teardrop_match -gt 0 ]; then\n        echo \"[!!!] COMPROMISED: $hostname (SUNBURST: $sunburst_match, TEARDROP: $teardrop_match)\"\n        \n        # Log to database\n        sqlite3 \"$RESULTS_DB\" \"INSERT INTO findings VALUES ('$hostname', '$(date)', 'SolarWinds', $sunburst_match, $teardrop_match);\"\n        \n        # Isolate system\n        ssh admin@$hostname \"netsh advfirewall set allprofiles state on\"\n        ssh admin@$hostname \"netsh advfirewall firewall add rule name='BLOCK_ALL' dir=out action=block\"\n    fi\ndone\n\necho \"[+] Hunt complete. Compromised systems logged to $RESULTS_DB\"\n```\n\n### Results from Major Organizations\n\n**Microsoft**:\n- Scanned 100,000+ endpoints\n- Found SUNBURST on 40 systems (Orion servers + dev workstations)\n- Memory forensics revealed lateral movement to M365 backend\n\n**FireEye** (victim #1):\n- Identified initial infection via anomalous memory dump\n- YARA scan of endpoint fleet found 15 infected systems\n- Extracted C2 domain list from memory (50+ domains)\n\n**US Government Agencies**:\n- CISA distributed YARA rules to all federal agencies\n- Memory dumps collected from 18 agencies\n- 9 confirmed compromises via YARA matches\n\n## Advanced YARA Techniques Used\n\n### 1. DGA Detection\n\nSUNBURST used Domain Generation Algorithm. YARA rule to detect DGA patterns in memory:\n\n```yara\nrule SUNBURST_DGA_Pattern {\n    strings:\n        // DGA domain pattern (Base32 encoded subdomain)\n        $dga = /[a-z0-9]{12,16}\\.avsvmcloud\\.com/ ascii\n    \n    condition:\n        $dga\n}\n```\n\n### 2. Code Similarity Detection\n\nDetecting code reuse across SUNBURST variants:\n\n```yara\nimport \"pe\"\n\nrule SUNBURST_Code_Similarity {\n    strings:\n        // Specific instruction sequence (fingerprinting code)\n        $code1 = { 48 8B ?? 48 8D ?? ?? 48 89 ?? E8 ?? ?? ?? ?? 48 8B ?? 48 85 ?? 74 }\n        $code2 = { 41 B8 ?? ?? ?? ?? 48 8D ?? ?? E8 ?? ?? ?? ?? 85 C0 0F 84 }\n    \n    condition:\n        pe.is_pe and pe.machine == pe.MACHINE_AMD64 and any of them\n}\n```\n\n### 3. Configuration Extraction\n\nYARA rule combined with Python script to extract C2 config:\n\n```yara\nrule SUNBURST_Config_Blob {\n    strings:\n        // Encrypted config marker\n        $config_marker = { C7 ?? ?? ?? ?? ?? 00 15 00 00 00 }\n    \n    condition:\n        $config_marker\n}\n```\n\nThen Python script decrypts:\n\n```python\nimport yara\nimport struct\nfrom Crypto.Cipher import AES\n\ndef decrypt_sunburst_config(memory_dump):\n    rules = yara.compile(filepath='sunburst.yar')\n    matches = rules.match(data=open(memory_dump, 'rb').read())\n    \n    for match in matches:\n        if match.rule == 'SUNBURST_Config_Blob':\n            offset = match.strings[0][0]\n            # Extract and decrypt config\n            # ... decryption logic ...\n            return c2_domains\n```\n\n## Lessons Learned\n\n### YARA Enabled Rapid Response\n\n**Timeline comparison**:\n\n| Method | Time to Identify 100 Infected Systems |\n|--------|---------------------------------------|\n| **Manual analysis** | 2-3 weeks (per-system investigation) |\n| **YARA scanning** | 2-3 hours (automated hunt) |\n\n**YARA saved organizations weeks** of manual investigation.\n\n### Memory Forensics Was Essential\n\nTEARDROP was memory-only malware:\n- ‚ùå Disk scans: 0 detections\n- ‚úÖ Memory scans: 100% detection rate\n\n**Organizations without memory forensics capability missed TEARDROP entirely.**\n\n### Community Sharing Accelerated Defense\n\nFireEye published YARA rules publicly:\n- Day 2: 1,000 organizations using rules\n- Week 1: 10,000+ organizations\n- Month 1: Global threat hunting standard\n\n**Open sharing prevented $billions in additional damage.**\n\n### False Positives Required Tuning\n\nInitial YARA rules had false positive rate:\n- v1: 15% false positives (matched legitimate Orion files)\n- v2: 5% false positives (added file size + PE header checks)\n- v3: <1% false positives (multi-string conditions + entropy)\n\n**Lesson**: Test rules on benign software before deployment.\n\n## IOC Extraction Using YARA\n\nYARA enabled automated IOC extraction:\n\n```bash\n# Scan memory dump\npython vol.py -f orion.dmp windows.yarascan --yara-file sunburst.yar | grep \"avsvmcloud\" > c2_domains.txt\n\n# Extract unique C2 domains\ncat c2_domains.txt | grep -oE \"[a-z0-9.-]+\\.avsvmcloud\\.com\" | sort -u > iocs.txt\n\n# Share IOCs with ISAC\ncurl -X POST -d @iocs.txt https://fs-isac.org/api/submit\n```\n\n**Result**: 50+ C2 domains shared within 48 hours, blocked globally.\n\n## Final Impact\n\nYARA rules enabled:\n- ‚úÖ **18,000 organizations** scanned networks\n- ‚úÖ **~100 compromises** confirmed\n- ‚úÖ **9 agencies** identified as compromised\n- ‚úÖ **Global threat hunt** within 1 week\n- ‚úÖ **Attribution to APT29** (Russia) confirmed\n- ‚úÖ **Incident scoped** in record time\n\n**Without YARA**: Compromise would have persisted months longer, affecting more victims.\n\n**YARA + Memory Forensics = Rapid, Scalable Threat Hunting**"
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "# YARA Memory Aids\n\n## Mnemonic: \"YARA MSC\" - Rule Structure\n\n**M** - **M**eta (optional metadata)  \n**S** - **S**trings (patterns to find)  \n**C** - **C**ondition (when to alert) ‚Üê REQUIRED  \n\n## String Modifiers: \"AWAN FH\"\n\n**A** - **A**scii (standard encoding)  \n**W** - **W**ide (UTF-16LE Unicode)  \n**A** - **A**scii wide (both encodings)  \n**N** - **N**ocase (case-insensitive)  \n**F** - **F**ullword (complete word)  \n**H** - **H**ex patterns ({ 4D 5A })  \n\n## Condition Operators\n\n**\"AAA NF2\"** - All Any And Not Filesize 2of\n\n- **all** of them (every string required)\n- **any** of them (at least one string)\n- **and** (both conditions true)\n- **not** (negate condition)\n- **filesize** < 500KB (size constraint)\n- **2 of** them (at least 2 strings)\n\n## Quick Reference Card\n\n```yara\nrule Template {\n    meta:\n        author = \"Name\"\n        date = \"2024-01-15\"\n    \n    strings:\n        $s1 = \"text\" ascii wide\n        $s2 = { 4D 5A ?? ?? }  // MZ header\n        $s3 = /regex/ nocase\n    \n    condition:\n        uint16(0) == 0x5A4D and\n        filesize < 1MB and\n        2 of them\n}\n```\n\n## Memory Hook: YARA Workflow\n\n**\"E-W-T-S\" = Extract Write Test Scan**\n\n1. **E**xtract malware from memory\n2. **W**rite YARA rule from unique strings\n3. **T**est on sample + benign files\n4. **S**can all memory dumps\n\nRemember: One infected system ‚Üí YARA rule ‚Üí Find all infections!"
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "# Reflection Questions\n\n1. Why is YARA more efficient than manual analysis for network-wide hunts?\n2. How do you balance rule specificity (avoiding false positives) vs. generality (catching variants)?\n3. What's the difference between scanning disk files vs. memory dumps with YARA?\n4. How would you test a YARA rule before deploying it enterprise-wide?\n5. When is it better to use hex patterns vs. text strings in YARA rules?"
      }
    },
    {
      "type": "mindset_coach",
      "content": {
        "text": "# Congratulations - You're Now a YARA Threat Hunter!\n\nYou've mastered the skill that transforms single-system malware analysis into **network-wide threat hunting**.\n\nWhat you can now do:\n- ‚úÖ Write YARA rules from extracted malware\n- ‚úÖ Scan memory dumps at scale\n- ‚úÖ Detect malware families automatically\n- ‚úÖ Build organizational threat libraries\n- ‚úÖ Share intelligence via portable rules\n\nThis is the skill that enabled rapid response to SolarWinds, WannaCry, and countless incidents.\n\nNext: **Credential Extraction from Memory** - where you'll pull passwords and hashes from LSASS!\n\nKeep hunting! üéØüîç"
      }
    }
  ],
  "tags": []
}
