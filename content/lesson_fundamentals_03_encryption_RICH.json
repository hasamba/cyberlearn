{
  "lesson_id": "76d20bae-6b4c-483c-a485-c851e1a1f1b8",
  "domain": "fundamentals",
  "title": "Encryption Fundamentals",
  "difficulty": 2,
  "order_index": 3,
  "prerequisites": [],
  "concepts": [
    "Symmetric encryption",
    "Asymmetric encryption",
    "Hashing",
    "Keys",
    "AES",
    "RSA"
  ],
  "content_blocks": [
    {
      "block_id": "574d7bc8-3fa9-4ab6-b0d6-1e21a5a5b701",
      "type": "mindset_coach",
      "content": {
        "text": "Welcome to encryption - the mathematics that protects the world's secrets. Every secure website, every encrypted message, every protected file relies on the concepts you're about to learn. This isn't just theory - this is the foundation of digital security.\n\nHere's the beautiful truth: Encryption is the ONE security control that protects data even when everything else fails. Firewalls can be bypassed. Access controls can be broken. Passwords can be stolen. But properly encrypted data remains secure even in attacker hands. That's power.\n\nMany people find encryption intimidating because of the mathematics involved. Here's the secret: You don't need to understand the complex math to USE encryption effectively. You need to understand the CONCEPTS - when to use symmetric vs asymmetric, how key management works, the difference between encryption and hashing.\n\nThink of encryption like a lock and key system for data. You're learning which locks exist, when to use each type, and how to manage the keys. The internal mechanism of the lock (the math) is less important than knowing how to use it properly.\n\nHere's what makes this exciting: Understanding encryption means understanding how HTTPS works, how passwords are stored, how VPNs protect traffic, how files are secured. You'll see encryption everywhere once you know what to look for.\n\nCritical mindset: Encryption is only as strong as its weakest link - and that's usually key management, not the algorithm. The strongest encryption in the world is worthless if you write the key on a sticky note. We'll focus heavily on proper usage, not just algorithms.\n\nLet's demystify encryption and turn you into someone who understands how the digital world stays secure."
      },
      "simplified_explanation": "Encryption = scrambling data so only people with the 'key' can unscramble it. Like putting a message in a locked box - only someone with the right key can open it and read the message. You'll learn the different types of locks and when to use each.",
      "memory_aids": [
        "Symmetric = Same key locks and unlocks (like house key)",
        "Asymmetric = Different keys (public locks, private unlocks)",
        "Hashing = One-way scrambling (can't unscramble, only verify)"
      ],
      "teach_like_im_10": "Imagine you write a secret message and lock it in a box. Encryption is the lock. The key is... well, the key! There are locks where the same key locks and unlocks (symmetric), locks where you need different keys (asymmetric), and special magic that scrambles messages forever so you can only check if someone knows the original (hashing)."
    },
    {
      "block_id": "f527f6c9-e67a-4cc6-88fe-c910e586bb18",
      "type": "explanation",
      "content": {
        "text": "## The Three Pillars of Cryptography\n\nCryptography has three fundamental concepts. Master these and you understand how digital security works.\n\n### 1. Symmetric Encryption (Secret Key Encryption)\n\n**Concept**: Same key encrypts and decrypts data.\n\n**The Lock Analogy**: Think of a traditional house key. The same key locks the door and unlocks it. That's symmetric encryption - one secret key does both jobs.\n\n**How It Works**:\n1. You have plaintext (readable data): \"Attack at dawn\"\n2. You have a secret key: \"MySecretKey123\"\n3. Algorithm (like AES) combines them: Encryption(plaintext, key) = ciphertext\n4. Result is ciphertext (scrambled): \"X7$mK2@pL9#qR4\"\n5. To decrypt: Decryption(ciphertext, key) = plaintext\n\n**Key Characteristics**:\n- Fast and efficient (great for large data)\n- Same key for encryption and decryption\n- Key must be kept secret\n- Key distribution is the challenge (how do both parties get the key securely?)\n\n**Common Symmetric Algorithms**:\n\n**AES (Advanced Encryption Standard)**:\n- Current gold standard\n- Used everywhere: HTTPS, VPNs, disk encryption, file encryption\n- Key sizes: 128-bit, 192-bit, 256-bit (bigger = more secure)\n- AES-256 is considered unbreakable with current technology\n- Fast enough to encrypt entire hard drives in real-time\n\n**DES/3DES (Data Encryption Standard)**:\n- Old standard (1970s)\n- DES is broken (56-bit key too small)\n- 3DES still used in legacy systems but deprecated\n- Don't use DES for new projects\n\n**ChaCha20**:\n- Modern alternative to AES\n- Better performance on mobile devices\n- Used in TLS, VPNs, Signal messenger\n\n**Use Cases**:\n- Disk encryption (BitLocker, FileVault)\n- File encryption (encrypting sensitive documents)\n- Database encryption\n- VPN tunnels (once key exchange happens)\n- WiFi encryption (WPA2/WPA3)\n\n**The Key Distribution Problem**:\nSymmetric encryption is fast and secure, but has one major challenge: How do two parties securely share the secret key?\n\n- In-person exchange (not scalable)\n- Secure channel (but if you have secure channel, why need encryption?)\n- Asymmetric encryption for key exchange (we'll cover this)\n\n### 2. Asymmetric Encryption (Public Key Cryptography)\n\n**Concept**: Two different but mathematically related keys. Public key encrypts, private key decrypts.\n\n**The Mailbox Analogy**: Imagine a mailbox with a slot. Anyone can drop mail IN (public key), but only the owner with the key can take mail OUT (private key). That's asymmetric encryption.\n\n**How It Works**:\n1. Generate key pair: Public key + Private key\n2. Public key can be shared with everyone (not secret)\n3. Private key must be kept secret (NEVER share)\n4. What public key encrypts, only private key can decrypt\n5. What private key signs, public key can verify\n\n**Key Characteristics**:\n- Solves key distribution problem\n- Slower than symmetric (100-1000x slower)\n- Used for small data or key exchange\n- Enables digital signatures\n\n**Common Asymmetric Algorithms**:\n\n**RSA (Rivest-Shamir-Adleman)**:\n- Most widely used asymmetric algorithm\n- Based on difficulty of factoring large prime numbers\n- Key sizes: 2048-bit, 3072-bit, 4096-bit\n- Used in: HTTPS certificates, SSH keys, PGP email encryption\n- 2048-bit minimum recommended (4096-bit for long-term security)\n\n**ECC (Elliptic Curve Cryptography)**:\n- More efficient than RSA\n- Smaller keys, same security (256-bit ECC ≈ 3072-bit RSA)\n- Better for mobile/IoT devices\n- Used in: Bitcoin, modern TLS, Signal\n\n**Diffie-Hellman**:\n- Key exchange protocol (not encryption)\n- Allows two parties to create shared secret over insecure channel\n- Foundation of modern secure communications\n- Used in: TLS, SSH, VPNs\n\n**Two Main Use Cases**:\n\n**Use Case 1: Encryption (Confidentiality)**:\n```\nAlice wants to send Bob a secret message:\n1. Bob generates key pair (public + private)\n2. Bob shares public key with Alice\n3. Alice encrypts message with Bob's public key\n4. Alice sends encrypted message to Bob\n5. Bob decrypts with his private key\n6. Only Bob can decrypt (only he has private key)\n```\n\n**Use Case 2: Digital Signatures (Authentication + Integrity)**:\n```\nAlice wants to prove a message is really from her:\n1. Alice generates key pair (public + private)\n2. Alice shares public key publicly\n3. Alice creates message\n4. Alice signs message with her private key (creates signature)\n5. Anyone can verify signature using Alice's public key\n6. If signature verifies, message is authentic and unmodified\n```\n\n**Real-World Example - HTTPS**:\n1. You visit https://bank.com\n2. Bank sends its public key (in SSL certificate)\n3. Your browser verifies certificate is valid\n4. Browser generates random symmetric key (session key)\n5. Browser encrypts session key with bank's public key\n6. Bank decrypts session key with its private key\n7. Now both have same session key (symmetric encryption from here)\n8. Fast symmetric encryption protects the rest of session\n\nThis is **hybrid encryption** - asymmetric to exchange keys, symmetric for bulk data.\n\n### 3. Hashing (One-Way Functions)\n\n**Concept**: Convert data into fixed-size fingerprint. Can't reverse it.\n\n**The Meat Grinder Analogy**: Put meat into grinder, get ground meat out. Can you put ground meat back in and get original meat? No. That's hashing - one-way transformation.\n\n**How It Works**:\n1. Input any data: \"password123\"\n2. Hash function processes it: SHA256(\"password123\")\n3. Output fixed-size hash: \"ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f\"\n4. Same input ALWAYS produces same hash\n5. Cannot reverse hash to get original input\n6. Tiny input change = completely different hash\n\n**Key Properties**:\n- **Deterministic**: Same input always produces same hash\n- **One-way**: Cannot reverse hash to get input\n- **Fixed size**: Any input size → fixed output size\n- **Avalanche effect**: One bit change → completely different hash\n- **Collision resistant**: Hard to find two inputs with same hash\n\n**Common Hash Algorithms**:\n\n**SHA-256 (Secure Hash Algorithm)**:\n- Part of SHA-2 family\n- 256-bit output (64 hex characters)\n- Current standard for secure hashing\n- Used in: Bitcoin, SSL certificates, file integrity\n\n**SHA-3**:\n- Newest SHA family member\n- Different internal structure than SHA-2\n- Not widely adopted yet but very secure\n\n**MD5 (Message Digest 5)**:\n- OLD and BROKEN\n- Collisions found (two different inputs produce same hash)\n- Only use for non-security purposes (checksums)\n- Never use for passwords or security\n\n**SHA-1**:\n- Also BROKEN (collisions demonstrated)\n- Being phased out\n- Don't use for new projects\n\n**Use Cases**:\n\n**Password Storage**:\n```\nBAD: Store password in database as plaintext\nGOOD: Store hash of password\n\nUser creates password: \"MyPassword123\"\nSystem hashes it: SHA256(\"MyPassword123\") = \"abc123def456...\"\nStore hash in database, NOT password\n\nLogin attempt:\n1. User enters \"MyPassword123\"\n2. System hashes input\n3. Compare hash to stored hash\n4. If match, password correct\n5. Original password never stored!\n```\n\n**But wait - Rainbow Tables!**\nAttackers can pre-compute hashes of common passwords. Solution: SALT\n\n**Password Hashing with Salt**:\n```\nPassword: \"MyPassword123\"\nRandom Salt: \"x7K9mP2q\"\nCombine: \"MyPassword123x7K9mP2q\"\nHash: SHA256(\"MyPassword123x7K9mP2q\") = \"unique_hash\"\nStore: hash + salt\n\nNow rainbow tables don't work (each password has unique salt)\n```\n\n**Modern Password Hashing**:\nDon't use plain SHA-256 for passwords! Use purpose-built algorithms:\n- **bcrypt**: Slow by design, has built-in salt\n- **scrypt**: Memory-hard (resistant to hardware attacks)\n- **Argon2**: Newest, best choice for new projects\n\nThese are deliberately slow to make brute-force attacks impractical.\n\n**File Integrity Verification**:\n```\nDownload file: ubuntu.iso\nPublished hash: \"abc123def456...\"\nYour hash: SHA256(ubuntu.iso) = \"abc123def456...\"\nIf hashes match → file not corrupted/tampered\nIf different → file modified or corrupted\n```\n\n**Digital Signatures**:\nCombine hashing with asymmetric encryption:\n1. Hash the message (creates small fingerprint)\n2. Encrypt hash with private key (creates signature)\n3. Recipient hashes message\n4. Recipient decrypts signature with public key\n5. If hashes match → authentic and unmodified\n\n## Encryption in Practice\n\n**Data at Rest** (stored data):\n- Disk encryption: BitLocker (Windows), FileVault (Mac), LUKS (Linux)\n- File encryption: GPG, VeraCrypt, 7-Zip with encryption\n- Database encryption: TDE (Transparent Data Encryption)\n- Uses: Symmetric encryption (AES)\n\n**Data in Transit** (moving data):\n- HTTPS: TLS/SSL encryption (hybrid)\n- VPN: IPsec or OpenVPN (hybrid)\n- SSH: Secure remote access (hybrid)\n- Signal/WhatsApp: End-to-end encryption (hybrid)\n- Uses: Asymmetric for key exchange, symmetric for data\n\n**Data in Use** (processing data):\n- Emerging field: Homomorphic encryption\n- Process encrypted data without decrypting\n- Still mostly research/specialized applications\n\n## Key Management: The Weakest Link\n\nThe strongest encryption is worthless with poor key management.\n\n**Key Management Principles**:\n1. **Generate keys securely** (use cryptographically secure random number generators)\n2. **Store keys securely** (hardware security modules, key management systems)\n3. **Rotate keys regularly** (change keys periodically)\n4. **Destroy keys properly** (when no longer needed)\n5. **Never hardcode keys** (no keys in source code!)\n6. **Limit key access** (principle of least privilege)\n\n**Common Key Management Mistakes**:\n- Hardcoding encryption keys in source code\n- Storing keys in same location as encrypted data\n- Using weak keys (short passwords)\n- Never rotating keys\n- Sharing private keys\n- Inadequate key backup (lose key = lose data)\n\n**Professional Key Management**:\n- Hardware Security Modules (HSMs)\n- Key Management Services (AWS KMS, Azure Key Vault)\n- Secrets management (HashiCorp Vault)\n- Certificate authorities for PKI\n\n## Common Attacks Against Encryption\n\n**Brute Force**: Try every possible key\n- Defense: Use long keys (AES-256, RSA-4096)\n\n**Known Plaintext**: Attacker knows some plaintext and corresponding ciphertext\n- Defense: Use modern algorithms (AES resists this)\n\n**Man-in-the-Middle**: Intercept key exchange\n- Defense: Certificate pinning, authenticated key exchange\n\n**Side-Channel**: Timing attacks, power analysis\n- Defense: Constant-time implementations\n\n**Implementation Flaws**: Bug in code, not algorithm\n- Defense: Use well-tested libraries, don't roll your own crypto\n\n**Poor Key Management**: Steal the keys\n- Defense: Proper key management practices"
      },
      "ascii_art": "ENCRYPTION TYPES\n\nSYMMETRIC:\n[Plaintext] ---> [AES + Key] ---> [Ciphertext]\n[Ciphertext] --> [AES + Same Key] --> [Plaintext]\n\nASYMMETRIC:\n[Plaintext] ---> [RSA + Public Key] ---> [Ciphertext]\n[Ciphertext] --> [RSA + Private Key] --> [Plaintext]\n\nHASHING:\n[Plaintext] ---> [SHA-256] ---> [Hash]\n                                    |\n                                    v\n                              [No Reverse!]",
      "examples": [
        {
          "scenario": "Securing Database with Encryption",
          "explanation": "Database contains customer credit cards. Use AES-256 to encrypt credit card column. Generate master encryption key, store in HSM. Encrypt each credit card with AES-256. Even if attacker steals database backup, credit cards are encrypted and useless without key. Key management is critical - HSM protects the master key."
        },
        {
          "scenario": "HTTPS Connection to Bank",
          "explanation": "Visit https://bank.com. Browser and server perform TLS handshake: Server sends public key in certificate. Browser verifies certificate (is this really bank.com?). Browser generates random session key, encrypts with server's public key. Server decrypts session key with private key. Both now have shared session key. Rest of session uses AES with session key (fast symmetric encryption)."
        }
      ]
    },
    {
      "block_id": "a66f4c4c-9252-4177-87d3-272484f76b99",
      "type": "real_world",
      "content": {
        "text": "**Real-World Case: Password Breach Without Encryption**\n\nCompany: LinkedIn (2012 breach)\nProblem: Stored 117 million password hashes with SHA-1, NO SALT\n\nWhat happened:\n- Attacker breached database, stole password hashes\n- LinkedIn used SHA-1 hashing (good)\n- But NO salt (very bad)\n- Attacker used rainbow tables (pre-computed hashes)\n- Cracked 95% of passwords within days\n\nWhy it failed:\n- SHA-1 alone is fast (attacker can test billions of passwords per second)\n- No salt = rainbow tables work perfectly\n- Common passwords (\"password123\") have well-known hashes\n\nProper approach:\n- Use bcrypt/scrypt/Argon2 (slow, purpose-built for passwords)\n- Always use unique salt per password\n- Result: Even with database breach, passwords remain secure\n\n**Real-World Case: Proper Encryption Saves the Day**\n\nCompany: Apple vs FBI (2016)\nSituation: FBI wanted Apple to unlock iPhone of terrorist\n\nApple's encryption:\n- AES-256 encryption of entire device\n- Encryption key derived from user passcode + hardware security\n- Even Apple cannot decrypt without passcode\n- Hardware security limits brute force attempts\n\nResult:\n- FBI couldn't break encryption\n- Had to pay $1 million to third party for exploit\n- Demonstrates: Proper encryption protects even against nation-state attackers\n\nKey lesson: Encryption with proper key management is incredibly powerful.\n\n**Real-World Case: WhatsApp End-to-End Encryption**\n\nWhatsApp implements Signal Protocol for 2 billion users:\n\n1. Each user has asymmetric key pair\n2. Messages encrypted with recipient's public key\n3. Only recipient's private key can decrypt\n4. Even WhatsApp cannot read messages\n5. Perfect forward secrecy: Session keys constantly rotate\n\nResult: Law enforcement cannot compel WhatsApp to decrypt messages - WhatsApp genuinely cannot access content.\n\nThis is encryption done right: Technical architecture that ensures privacy."
      },
      "industry_examples": [
        "Healthcare: HIPAA requires encryption of patient data at rest and in transit - hospitals use AES-256 for database encryption, TLS for network traffic",
        "Finance: PCI-DSS requires encryption of credit card data - payment processors use HSMs to manage encryption keys, AES for data encryption",
        "Military: Classified data encrypted with NSA-approved algorithms - everything from emails to satellite communications protected by strong encryption"
      ]
    },
    {
      "block_id": "739755db-4ae9-40fc-adcd-8d584ca35da9",
      "type": "explanation",
      "content": {
        "text": "**Pitfall 1: Rolling Your Own Crypto**\nCreating your own encryption algorithm or implementing encryption from scratch. Crypto is HARD. Even experts make mistakes. Use well-tested libraries.\n\n**Pitfall 2: Using Deprecated Algorithms**\nUsing MD5 or SHA-1 for security purposes, or DES for encryption. These are broken. Use SHA-256+ and AES.\n\n**Pitfall 3: Encryption Without Authentication**\nEncrypting data but not verifying integrity. Attacker can modify ciphertext. Use authenticated encryption (AES-GCM) or add HMAC.\n\n**Pitfall 4: Weak Keys**\nUsing short passwords as encryption keys directly. \"password\" as AES key is worthless. Use key derivation functions (PBKDF2, bcrypt).\n\n**Pitfall 5: Storing Keys with Encrypted Data**\nEncrypting database, storing encryption key in same database. Like locking your house and leaving key under doormat. Separate key storage.\n\n**Pitfall 6: Not Using Salt for Passwords**\nHashing passwords without salt. Rainbow tables will crack them instantly. Always use unique salt per password.\n\n**Pitfall 7: Using ECB Mode**\nUsing AES in ECB mode (Electronic Codebook). Same plaintext = same ciphertext (patterns leak). Use CBC, GCM, or other modern modes.\n\n**Pitfall 8: Trusting Encryption = Security**\nEncrypting data and assuming you're secure. Encryption is ONE control. You need access control, authentication, logging, monitoring, etc."
      }
    },
    {
      "block_id": "76080f8b-e60d-45a9-b6b4-fa4840464ce3",
      "type": "explanation",
      "content": {
        "text": "**Immediate Actions**:\n1. Enable disk encryption on your computer (BitLocker/FileVault/LUKS)\n2. Verify HTTPS when visiting sensitive sites (look for lock icon)\n3. Use end-to-end encrypted messaging (Signal, WhatsApp)\n4. Check if your passwords are hashed: visit haveibeenpwned.com\n5. Learn OpenSSL basics: encrypt a file with symmetric encryption\n\n**This Week**:\n1. Practice with GPG: Generate key pair, encrypt/decrypt files\n2. Understand your browser's certificate viewer (inspect HTTPS certificates)\n3. Use openssl command to encrypt/decrypt data\n4. Read about bcrypt and understand why it's better than SHA-256 for passwords\n5. Practice: Hash files with SHA-256, verify integrity\n\n**This Month**:\n1. Complete TryHackMe Cryptography room\n2. Implement proper password hashing in a practice project (bcrypt)\n3. Set up encrypted file storage (VeraCrypt volume)\n4. Learn about PKI (Public Key Infrastructure) and certificate authorities\n5. Understand TLS handshake process deeply\n6. Practice with SSH keys (generate, use for authentication)\n\n**Essential Encryption Tools**:\n- OpenSSL (Swiss Army knife of crypto)\n- GPG/PGP (file/email encryption)\n- VeraCrypt (disk/file encryption)\n- HashiCorp Vault (secrets management)\n- Let's Encrypt (free SSL certificates)\n\n**Learning Resources**:\n- Cryptopals Challenges (practical crypto exercises)\n- Coursera: Cryptography I (Stanford)\n- \"Serious Cryptography\" by Jean-Philippe Aumasson\n- TryHackMe Cryptography path\n- Applied Cryptography by Bruce Schneier\n\n**Best Practices Checklist**:\n- ✅ Use AES-256 for symmetric encryption\n- ✅ Use RSA-2048+ or ECC-256+ for asymmetric\n- ✅ Use SHA-256+ for hashing (never MD5/SHA-1 for security)\n- ✅ Use bcrypt/scrypt/Argon2 for password hashing\n- ✅ Always salt passwords (unique salt per password)\n- ✅ Use authenticated encryption (AES-GCM or encrypt-then-MAC)\n- ✅ Never hardcode keys in source code\n- ✅ Store keys separately from encrypted data\n- ✅ Use well-tested crypto libraries (OpenSSL, libsodium)\n- ✅ Enable TLS 1.2+ for all web applications\n- ✅ Implement proper key rotation\n- ✅ Use HSM or KMS for production key storage\n\n**Career Applications**:\n- Security Engineer: Implement encryption in applications\n- DevSecOps: Manage secrets and encryption keys\n- Compliance: Ensure encryption meets regulatory requirements\n- Cryptographer: Design and analyze cryptographic systems (requires deep math)\n\n**Quick Reference**:\n```\nNeed to: Encrypt large file → Use: AES-256\nNeed to: Securely exchange keys → Use: RSA/Diffie-Hellman\nNeed to: Store passwords → Use: bcrypt/Argon2\nNeed to: Verify file integrity → Use: SHA-256\nNeed to: Secure web traffic → Use: TLS/HTTPS\nNeed to: Sign documents → Use: RSA signatures\nNeed to: Encrypt email → Use: PGP/GPG\n```\n\n**Remember**:\n- Encryption protects confidentiality\n- Hashing verifies integrity\n- Digital signatures provide authentication\n- Key management is the hardest part\n- Use proven algorithms and libraries\n- Defense in depth: Encryption is one layer of many\n\nMaster these fundamentals and you'll understand how the secure digital world actually works. Encryption isn't magic - it's applied mathematics protecting your data."
      }
    },
    {
      "type": "video",
      "title": "Video Tutorial: Encryption Fundamentals",
      "content": {
        "resources": "Watch this comprehensive video tutorial to reinforce your learning with visual demonstrations and practical examples.\n\n**Video**: [Encryption Explained by Computerphile](https://www.youtube.com/watch?v=jhXCTbFnK8o)\n\n**What you'll see:**\nSymmetric vs asymmetric encryption, hashing, digital signatures, and modern cryptographic practices.\n\n**Duration**: ~15 minutes\n\n**Recommended viewing**: After completing the lesson to solidify understanding.\n\n**Additional Resources:**\n- [NIST Cryptographic Standards](https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines)\n- [Crypto101 Free Cryptography Book](https://www.crypto101.io/)\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)"
      }
    }
  ],
  "estimated_time": 30,
  "learning_objectives": [
    "Understand core concepts",
    "Apply knowledge in real-world scenarios",
    "Identify common security issues",
    "Implement best practices"
  ],
  "post_assessment": [
    {
      "question_id": "q1",
      "type": "multiple_choice",
      "question": "What is the main concept covered in this lesson?",
      "options": [
        "Option A",
        "Option B",
        "Option C",
        "Option D"
      ],
      "correct_answer": 0,
      "explanation": "Review the lesson content for details.",
      "difficulty": 2,
      "points": 10
    },
    {
      "question_id": "q2",
      "type": "multiple_choice",
      "question": "Which best practice should you implement?",
      "options": [
        "Best Practice A",
        "Best Practice B",
        "Best Practice C",
        "Best Practice D"
      ],
      "correct_answer": 0,
      "explanation": "Review the lesson content for details.",
      "difficulty": 2,
      "points": 10
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "teach_like_im_10",
    "memory_hooks",
    "connect_to_what_i_know",
    "minimum_effective_dose",
    "meta_learning",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ]
}