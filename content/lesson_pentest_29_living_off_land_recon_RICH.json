{
  "lesson_id": "514f66d6-9d24-4b04-9e20-2efd19e325b6",
  "domain": "pentest",
  "title": "Living off the Land: Reconnaissance with Native Tools",
  "difficulty": 2,
  "order_index": 29,
  "prerequisites": [],
  "concepts": [
    "Windows native reconnaissance (net commands, wmic, tasklist, query)",
    "Linux/Unix native tools (ps, netstat, who, w, ss)",
    "PowerShell reconnaissance cmdlets (Get-Process, Get-Service)",
    "LOLBAS and GTFOBins for reconnaissance",
    "domain reconnaissance without custom tools",
    "network mapping with native tools",
    "avoiding detection with LOLBins",
    "operational security considerations"
  ],
  "estimated_time": 50,
  "learning_objectives": [
    "Map system configuration using built-in Windows and Linux utilities",
    "Correlate native command outputs to identify lateral movement opportunities",
    "Record reconnaissance steps for reproducibility and reporting",
    "Assess detection surfaces triggered by native command usage",
    "Operate within engagement scope without deploying external binaries",
    "Develop playbooks for living-off-the-land reconnaissance",
    "Translate recon findings into defender-focused recommendations"
  ],
  "jim_kwik_principles": [
    "active_learning",
    "teach_like_im_10",
    "memory_hooks",
    "connect_to_what_i_know",
    "minimum_effective_dose",
    "meta_learning",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "block_id": "de1b935f-1e07-4fa5-9105-b83b0b3b96b7",
      "type": "mindset_coach",
      "content": {
        "text": "Living off the land reconnaissance turns operating systems into reconnaissance toolkits. Instead of dropping binaries, you leverage built-in commands, scheduled tasks, and scripting shells. This approach keeps you stealthy, resilient, and respectful of production systems. Your mindset must blend curiosity with restraint: learn how administrators investigate their own environments, then emulate that cadence without overstepping.\n\nAnchor yourself in three principles: **respect native context**, **chain lightweight observations**, and **leave systems unchanged**. Respecting context means you run commands with the appropriate privileges, avoid modifying configuration, and clean up history where authorized. Chaining observations means you pivot from one piece of data to the next\u2014`netstat` reveals a listening port, which leads you to `sc query` to inspect the service, which in turn directs you to `wevtutil` to review logs. Leaving systems unchanged ensures you maintain the integrity of the environment and the trust of stakeholders.\n\nVisualize the mission: you have command-line access to a Windows workstation and an Ubuntu server within an enterprise. You must map users, running processes, network connections, scheduled tasks, installed applications, and domain relationships using only native tools. You will rely on `net`, `wmic`, `tasklist`, `Get-Process`, `ps`, `ss`, `systemctl`, and shell built-ins. Every command will be recorded in your notes to build a repeatable playbook.\n\nPrepare your workspace: on Windows, open PowerShell and CMD windows with transcription enabled (`Start-Transcript`). On Linux, start a script session (`script -q lol_recon.log`). Create a `recon_journal.md` with sections for inventory, network, users, services, scheduled tasks, and observations. Establish time limits for each host so you remain disciplined and avoid lingering unnecessarily.\n\nWarm-up prompts:\n\n1. **I will see through an admin's eyes**: Every command I run should have a legitimate admin purpose.\n2. **I will gather breadcrumbs, not boulders**: Focus on small, meaningful data points that build a bigger picture.\n3. **I will avoid leaving scars**: No registry edits, no persistence mechanisms\u2014only observation.\n4. **I will note opportunities for defenders**: As you enumerate, think about how defenders can monitor native command usage.\n5. **I will continuously self-check**: After each command, ask: did I learn something actionable? If not, adjust.\n\nWith this mindset, you will transform built-in utilities into a precise reconnaissance suite that supports stealthy, responsible operations."
      }
    },
    {
      "block_id": "80b36c47-5993-4d95-91d0-9a7889f2f078",
      "type": "explanation",
      "content": {
        "text": "### Windows Living-Off-the-Land Reconnaissance\n\n#### User and Group Enumeration\n- `whoami /all` reveals user privileges, groups, and privilege attributes.\n- `net user` lists local accounts; `net user <name>` shows last logon and password policy.\n- `net localgroup administrators` enumerates local admins.\n- `dsquery` (if available) or `Get-ADUser` (PowerShell) enumerate domain users.\n\n#### Process and Service Inventory\n- `tasklist /v` shows running processes with session IDs.\n- `wmic process get ProcessId,CommandLine` reveals command lines without requiring external tools.\n- `sc query state= all` lists services; `sc qc <service>` reveals binaries and dependencies.\n- PowerShell: `Get-Process | Sort CPU -Descending | Select -First 10` highlights top consumers.\n\n#### Scheduled Tasks\n- `schtasks /query /fo LIST /v` enumerates scheduled tasks with run times and command lines.\n- Filter for suspicious tasks: `schtasks /query /fo LIST /v | findstr /i \"OneTime\"`.\n- PowerShell: `Get-ScheduledTask | Where {$_.TaskPath -notlike '\\Microsoft*'}` focuses on custom tasks.\n\n#### Network Recon\n- `ipconfig /all` for interfaces, DNS servers.\n- `route print` to understand routes.\n- `netstat -ano` lists active connections; cross-reference PIDs with `tasklist`.\n- `Get-NetTCPConnection` (PowerShell) allows filtering by state or port.\n- `arp -a` reveals local ARP cache; correlate with `Get-Neighbor` on newer systems.\n\n#### System Information\n- `systeminfo` summarizes OS version, hotfixes.\n- `wmic product get name,version` lists installed applications (caution: slow; prefer `Get-WmiObject Win32_Product` sparingly).\n- `reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run` identifies autoruns.\n\n#### Domain Awareness\n- `echo %USERDOMAIN%` and `set LOGONSERVER` reveal domain controllers.\n- `nltest /dclist:<domain>` enumerates DCs.\n- `net group \"Domain Admins\" /domain` lists privileged accounts.\n- `Get-ADComputer -Filter * -Property OperatingSystem | Select Name,OperatingSystem` (if RSAT installed) inventories domain computers.\n\n#### Log Insights\n- `wevtutil qe Security /c:10 /f:text /q:\"*[System[(EventID=4624)]]\"` shows recent logons.\n- `Get-WinEvent -LogName \"Microsoft-Windows-Sysmon/Operational\" -MaxEvents 20` (if Sysmon present) reveals high-signal events.\n\n### Linux Living-Off-the-Land Reconnaissance\n\n#### Identity and Auth\n- `id`, `groups`, `last`, `lastlog` reveal user context and logon history.\n- `/etc/passwd`, `/etc/group`, `/etc/sudoers`, and `/etc/sudoers.d/*` inform privilege escalation paths.\n- `sudo -l` enumerates allowed commands.\n\n#### Processes and Services\n- `ps aux --sort=-%cpu | head -n 10` to view top processes.\n- `systemctl list-units --type=service` enumerates systemd services.\n- `service --status-all` for SysV systems.\n- Inspect running service configs with `cat /etc/*release*`, `/etc/ssh/sshd_config`, etc.\n\n#### Network Mapping\n- `ip a`, `ip route`, `ss -tulpn` show interfaces, routes, listening services.\n- `lsof -i` correlates processes with sockets.\n- `arp -a`, `ip neigh` reveal neighbors.\n- `nmcli con show` (if NetworkManager) lists network profiles.\n\n#### Scheduled Tasks and Persistence\n- `crontab -l`, `ls /etc/cron.*` enumerates cron jobs.\n- `systemctl list-timers` shows systemd timers.\n- `atq` lists `at` jobs.\n\n#### Logs and Audit\n- `journalctl -n 50` for recent events.\n- `/var/log/auth.log`, `/var/log/secure` for authentication.\n- `ausearch -m avc` on SELinux systems for security events.\n\n#### Files and Storage\n- `df -h` for mounted filesystems.\n- `lsblk`, `mount` for device mapping.\n- `find / -maxdepth 2 -type f -name \"*.conf\" 2>/dev/null | head` to locate configs (stay within scope).\n\n### Cross-Platform Techniques\n\n#### Environment Inventory\n- Windows: `set`, `Get-ChildItem Env:`.\n- Linux: `printenv`, `env`.\nRecord proxy settings, special environment variables, and credentials inadvertently stored.\n\n#### Command History Awareness\n- Windows: `Get-Content (Get-PSReadlineOption).HistorySavePath | Select -Last 20`.\n- Linux: `tail -n 20 ~/.bash_history`.\nUse history responsibly; do not exfil entire files unless authorized.\n\n#### Data Aggregation\nCreate simple CSV/JSON outputs using native tools:\n- PowerShell: `Get-LocalGroupMember Administrators | ConvertTo-Csv`.\n- Bash: `printf \"%s,%s\n\" \"user\" \"$(id -u)\" >> recon.csv`.\n\n### Stealth Considerations\n\n- Avoid loops that generate high CPU; prefer targeted commands.\n- Use `Start-Process` with `-WindowStyle Hidden` cautiously and only if allowed.\n- Clean up transcripts or history entries if the engagement scope requires stealth, following legal/contractual guidelines.\n\n### Defender Perspective\n\nDocument for defenders which logs captured your actions. Suggest creating alerts for suspicious combinations, e.g., standard users running `nltest`, or non-admin accounts invoking `wevtutil`. Living-off-the-land recon should educate defenders on baseline command usage.\n\nLiving off the land requires discipline, context awareness, and empathy. Mastering these techniques ensures you can operate effectively even under security controls that block external tools.\n\n### PowerShell Deep Dive\n\nPowerShell provides rich recon without external modules:\n- `Get-LocalUser`, `Get-LocalGroup`, `Get-LocalGroupMember` enumerate local accounts.\n- `Get-WmiObject Win32_NetworkAdapterConfiguration` reveals IPs, DNS, and WINS settings.\n- `Get-WmiObject Win32_Share` lists shares with permissions.\n- `Get-CimInstance -ClassName Win32_Service | Where StartMode -eq \"Auto\"` highlights auto-start services.\n- `Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-TaskScheduler/Operational'; ID=106}` surfaces task registration events.\nWrap results in `Select-Object` and `Format-Table` for clean output.\n\n### LOLBAS Techniques\n\nLeverage Living-Off-the-Land Binaries responsibly:\n- `certutil -urlcache -split -f` can validate certificates or download files when authorized.\n- `bitsadmin /list /allusers` enumerates BITS jobs that might indicate persistence.\n- `wmic logicaldisk get Caption,Description,FileSystem,FreeSpace,Size` inventories disks.\nDocument usage to help defenders tune analytics.\n\n### Linux GTFOBins Insights\n\nGTFOBins list built-in commands with powerful capabilities. For recon:\n- `awk 'BEGIN {print ENVIRON[\"PATH\"]}'` reviews PATH without external tools.\n- `journalctl --user-unit <service>` inspects user services.\n- `less` and `more` allow safe file review.\nBe aware that defenders may monitor these commands for suspicious patterns.\n\n### Detection & Logging Guidance\n\nWindows defenders should monitor PowerShell Operational logs (Event ID 4104), Security logs (4688/4648), and Sysmon events (1, 7, 11). Linux defenders can audit `sudo` (`/var/log/auth.log`), command history, and Auditd rules for `ps`, `netstat`, `ss`, `systemctl`. Provide defenders with sample queries, e.g., Splunk: `index=windows (CommandLine=\"*wevtutil qe*\") NOT user IN (admin_accounts)`.\n\n### OPSEC Strategies\n\n- Pace commands to mimic admin workflows.\n- Prefer `Get-` and `Show-` cmdlets over those that modify state.\n- Use `Get-Help` to confirm syntax, reducing typos that might raise suspicion.\n- Coordinate with engagement leads before modifying logging or clearing histories.\n\n### Cleaning Up Responsibly\n\nIf the engagement requires minimizing artifacts, use native cleanup carefully:\n- PowerShell history: `(Get-PSReadlineOption).HistorySavePath` can be cleared with `Clear-History` followed by deleting the history file, but only if authorized and documented.\n- CMD history is volatile; closing the session often suffices.\n- Linux bash history: `history -c` followed by `history -w` clears current session; ensure this aligns with ROE.\n- Always log cleanup actions so the client understands what was removed and why.\n\n### Collaboration with System Owners\n\nLiving-off-the-land recon is an opportunity to interview system owners. Ask which commands they run daily and compare to your workflow. This dialogue builds rapport and ensures your findings align with operational realities. Consider capturing key insights (with permission) for the final report.\n\n### Defensive Countermeasures for Native Recon\n\nProvide clients with actionable countermeasures:\n- Enable PowerShell constrained language mode for non-admins.\n- Configure Windows Attack Surface Reduction (ASR) rules to block risky command chains involving `certutil`.\n- Implement Linux audit rules for `netstat`, `ps`, and `ss` executed by non-admin users.\n- Deploy just-in-time admin elevation so standard users cannot run privileged queries.\nExplicitly document these controls to drive remediation.\n\n### Storytelling with Native Data\nTransform command outputs into narratives. Example: `whoami /all` reveals membership in `Helpdesk`. `net group \"Server Operators\" /domain` shows that `HelpdeskTier2` is a member. `sc query state= all` uncovers a scheduled task running under `HelpdeskTier2`. This chain tells a story of excessive privileges and guides corrective action.\n\n### Sample Automation Concepts\nCreate lightweight scripts to capture data. For example, a PowerShell function could collect hostname, network configuration, top processes, running services, scheduled tasks, and recent logons, then export everything to JSON. A simple Bash script might write identity, network, listener, process, and log summaries to a timestamped directory. Keep scripts modular and easy to audit.\n\n### Checklist for Responsible Native Recon\nBefore executing commands on a host, confirm:\n1. Scope authorization covers the host and protocol.\n2. You have a logging plan (transcripts, script logs).\n3. You understand the expected output and how it helps the engagement.\n4. You know which defender controls might trigger.\n5. You have a cleanup and reporting plan.\nReview this checklist with teammates to maintain consistency."
      }
    },
    {
      "block_id": "039272e6-8a4e-4363-9a06-005590b3a73e",
      "type": "video",
      "content": {
        "title": "Video Demo: Native Reconnaissance Techniques",
        "url": "https://www.youtube.com/watch?v=AUIZPqiBg4g",
        "description": "John Hammond walks through Windows and Linux reconnaissance using only built-in commands. Watch and pause to mirror each sequence, noting how he documents findings."
      }
    },
    {
      "block_id": "79a74a3d-5327-4d30-bcf0-046851d2019b",
      "type": "code_exercise",
      "content": {
        "title": "Hands-On Lab: Native Recon Playbook",
        "description": "Objective: Perform living-off-the-land reconnaissance on two hosts\u2014`WIN-CLIENT` (Windows 10) and `LINUX-SRV` (Ubuntu 22.04)\u2014using only native tools. Produce a consolidated report highlighting users, groups, network topology, running services, scheduled tasks, and sensitive data locations.\n\n### Part 1: Windows Recon Workflow\n1. Enable transcript: `Start-Transcript -Path C:\\\recon\\win_client_transcript.txt`.\n2. Gather identity info: `whoami /all`, `net user`, `net group \"Domain Admins\" /domain`.\n3. Inventory processes/services: `tasklist /v`, `sc query state= all`, `Get-Process | Sort CPU -Descending | Select -First 5`.\n4. Enumerate network details: `ipconfig /all`, `route print`, `netstat -ano`, `arp -a`.\n5. Identify scheduled tasks: `schtasks /query /fo LIST /v`.\n6. Inspect autoruns and registry: `reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run`.\n7. Gather logon events: `wevtutil qe Security /c:5 /f:text /q:\"*[System[(EventID=4624)]]\"`.\n8. Domain context: `nltest /dclist:%USERDOMAIN%`, `set LOGONSERVER`.\n9. Save key outputs to `C:\\recon\\win_client_notes.md`.\n\n### Part 2: Linux Recon Workflow\n1. Start logging: `script -q /tmp/linux_srv_recon.log`.\n2. Identity: `whoami`, `id`, `groups`, `sudo -l`.\n3. Processes: `ps aux --sort=-%mem | head`, `systemctl list-units --type=service`.\n4. Network: `ip a`, `ip route`, `ss -tulpn`, `arp -a`.\n5. Scheduled tasks: `crontab -l`, `ls /etc/cron.*`, `systemctl list-timers`.\n6. Logs: `journalctl -n 30`, `tail -n 30 /var/log/auth.log`.\n7. File systems: `df -h`, `mount`.\n8. Environment: `printenv | sort`.\n9. Append summaries to `/tmp/linux_srv_notes.md`.\n\n### Part 3: Correlation & Reporting\n1. Create `recon_summary.csv` with columns Host, Category, Command, Key Findings.\n2. Highlight cross-host relationships (e.g., shared service accounts, overlapping network segments).\n3. Identify potential lateral movement paths discovered via native tools.\n4. Document detection observations (which logs recorded your activity?).\n\n### Stretch Goals\n- Automate data collection with a PowerShell script (`Invoke-Command` not allowed) and a Bash script that parse command outputs into JSON.\n- Compare command history before/after enumeration to ensure minimal footprint.\n- Develop defender recommendations for monitoring native command usage.\n\nDeliverables: transcripts, notes, recon_summary.csv, detection observations, remediation suggestions.\n\n### Part 4: PowerShell Automation Challenge\nWrite a PowerShell function `Get-LolRecon` that collects key data (users, services, network, scheduled tasks) and exports to JSON without downloading modules.\n\n### Part 5: Bash Automation Challenge\nCreate a Bash script that runs `id`, `ps`, `ss`, `journalctl`, and writes outputs to a timestamped directory for archival.\n\n### Part 6: Cleanup Simulation\nDocument which artifacts you would remove or leave behind on each host if stealth were required. Justify your decisions with references to ROE and legal considerations.\n\n### Part 7: Storytelling Exercise\nChoose three command outputs from each host and write a short paragraph explaining the risk they reveal. Focus on translating technical data into business impact.\n\n### Part 8: Defender Collaboration\nSchedule a 15-minute sync with the blue team (or simulate) to review your command list. Document which commands they already monitor and which require new analytics.\n\n### Part 9: Playbook Draft\nCreate a two-page playbook summarizing command sequences, expected outputs, potential detections, and remediation suggestions. Share it with peers for feedback."
      }
    },
    {
      "block_id": "ca35a8dd-4398-4aa4-9534-213b037cfcce",
      "type": "real_world",
      "content": {
        "text": "### Case Study 1: Windows Native Recon Exposes Lateral Movement Paths\n\nDuring an internal red team, we gained RDP access to a Windows workstation with limited privileges. Using only `net`, `wmic`, and PowerShell cmdlets, we mapped local administrators, discovered scheduled tasks running as domain admins, and identified network shares containing deployment scripts. No external tools were executed, yet we uncovered enough data to plan a Kerberos delegation attack. The defenders appreciated the detailed command list because it highlighted which native commands to monitor.\n\n### Case Study 2: Linux ps and ss Reveal Shadow Services\n\nOn a Linux jump server, `ps aux` and `ss -tulpn` revealed a custom binary listening on port 8443. `systemctl status` showed it was a leftover test service running with root privileges. The service loaded credentials from `/etc/testapp.conf`. Our report recommended removing the service, auditing similar servers, and implementing systemd hygiene checks. The security team added a cron job to flag new listening services without change tickets.\n\n### Case Study 3: Living-Off-the-Land in Incident Response\n\nDuring an incident response, we needed to quickly assess compromised hosts without altering them. Living-off-the-land commands (`wevtutil`, `Get-WinEvent`, `journalctl`) enabled us to collect indicators, trace lateral movement, and document evidence for legal teams. The lack of third-party tools preserved chain of custody. This scenario reinforced the importance of mastering native utilities for both offensive and defensive operations.\n\n### Case Study 4: Helpdesk Logs as Detection Sensors\n\nA financial services client implemented logging for `whoami /all`, `net group`, and `nltest` usage on workstations. When our red team executed these commands, the SOC received alerts and initiated containment. Although we operated within scope, the defenders successfully detected living-off-the-land recon. Our debrief highlighted which commands were noisy and how to adjust timing to reduce detection.\n\n### Lessons Learned\n\n1. **Context is king**: Native commands reveal configuration drift, mismanaged privileges, and overlooked services.\n2. **Detection collaboration**: Sharing command histories with defenders accelerates detection engineering.\n3. **Minimalism builds trust**: Using only built-in tools reassures clients that operations respect stability.\n4. **Documentation is power**: Detailed logs of commands and outputs enable reproducibility and knowledge transfer.\n\nLiving-off-the-land reconnaissance bridges offensive and defensive practices, making it essential for modern operators.\n\n### Case Study 5: PowerShell Transcripts Aid IR\nAn organization enabled PowerShell transcription. When a threat actor attempted living-off-the-land recon, the SOC reviewed transcripts and quickly identified abnormal command sequences. Our red team used the same transcripts during debrief to show how defenders could build baselines for administrative activity.\n\n### Case Study 6: Bash History Tells a Story\nIn a cloud environment, we inspected `~/.bash_history` (with permission) and noticed repeated `scp` transfers to a staging server. Combining with `journalctl` logs, we traced unauthorized data movement. The client implemented history monitoring and educated admins on secure transfer practices.\n\n### Case Study 7: Cross-Platform Recon under EDR Monitoring\nA global retailer deployed aggressive EDR that flagged third-party tools. Our team relied exclusively on native commands. By pacing commands and correlating outputs, we mapped domain trusts without triggering alerts. The SOC later requested our command list to craft detection rules for suspicious sequences like `whoami` \u2192 `nltest` \u2192 `net group`.\n\n### Case Study 8: Insider Threat Simulation\nWe simulated an insider using only native tools to stage data exfiltration. Commands such as `dir /s`, `copy`, and `powershell Compress-Archive` packaged files before transfer. DLP controls focused on network egress but missed local compression events. The client added file auditing and PowerShell script block logging to close the gap.\n\n### Case Study 9: Compliance Audit Support\nA healthcare provider used living-off-the-land recon results to prepare for HIPAA audits. Native commands documented access controls, encryption settings, and service accounts without installing scanners. Auditors appreciated the reproducibility and low impact.\n\n### Case Study 10: Mergers & Acquisitions Due Diligence\nDuring a merger, we assessed the target company's environment using only native tools due to legal restrictions. The resulting inventory informed integration planning, identifying unsupported OS versions and weak service accounts before the acquisition closed.\n\n### Case Study 11: Cloud-Native Living Off the Land\nIn an Azure environment, we used Azure CLI commands available on jump hosts (`az vm list`, `az ad user list`) to map resources without deploying binaries. The exercise revealed overprivileged service principals. We recommended conditional access policies and privileged identity management (PIM) to govern access.\n\n### Case Study 12: Purple Team Workshop\nWe hosted a purple team session where red teamers ran native recon while defenders built real-time detections. The exercise resulted in new Splunk dashboards, Sysmon configurations, and a shared understanding of baseline command usage.\n\n### Case Study 13: Remote Workforce Recon\nDuring a remote workforce assessment, VPN-connected laptops had limited agent coverage. Living-off-the-land commands (`netsh wlan show profiles`, `Get-NetAdapter`) identified personal Wi-Fi networks and split-tunnel configurations that violated policy. The client updated VPN enforcement and provided security training to remote staff.\n\n### Case Study 14: Executive Reporting Success\nAfter completing native recon across 50 hosts, we delivered an executive summary highlighting three themes: overprivileged service accounts, unmonitored scheduled tasks, and unmanaged remote access tools. Because our evidence came from native commands, stakeholders trusted the findings and launched remediation sprints within two weeks."
      }
    },
    {
      "block_id": "09c6f517-8514-4e66-9a1b-fa3019505fc5",
      "type": "memory_aid",
      "content": {
        "text": "### Living-Off-the-Land Recon Cheat Sheet\n\n**Windows**\n- Identity: `whoami /all`, `net user`, `net localgroup administrators`\n- Processes: `tasklist /v`, `wmic process get name,ProcessId,CommandLine`\n- Services: `sc query state= all`, `Get-Service`\n- Network: `ipconfig /all`, `netstat -ano`, `Get-NetTCPConnection`\n- Scheduled Tasks: `schtasks /query /fo LIST /v`\n- Domain: `nltest /dclist:%USERDOMAIN%`, `net group \"Domain Admins\" /domain`\n- Logs: `wevtutil qe Security /c:10`\n\n**Linux**\n- Identity: `id`, `last`, `sudo -l`\n- Processes: `ps aux`, `top -b -n1 | head`\n- Services: `systemctl list-units --type=service`\n- Network: `ip a`, `ss -tulpn`, `arp -a`\n- Scheduled Tasks: `crontab -l`, `ls /etc/cron.*`\n- Logs: `journalctl -n 20`, `tail -f /var/log/auth.log`\n\n**General**\n- Environment variables: Windows `set`, Linux `printenv`\n- File search: Windows `dir /s`, Linux `find`\n- Config snapshots: Windows `reg export`, Linux `grep -R` (with caution)\n- History: Windows PowerShell history path, Linux `~/.bash_history`\n\nRemember to log commands, note timestamps, and respect scope boundaries.\n\n**PowerShell Quick Commands**\n- `Get-Command -Module Microsoft.PowerShell.Management`\n- `Get-ChildItem -Path HKLM:\\SYSTEM\\CurrentControlSet\\Services`\n- `Get-AppxPackage | Select Name,InstallLocation`\n\n**Linux Quick Commands**\n- `uname -a`\n- `cat /etc/os-release`\n- `lsmod`\n- `ss -s`\n\n**Documentation Tips**\n- Use Markdown tables to summarize findings.\n- Annotate commands with context.\n- Pair each finding with a detection suggestion.\n\n**Windows Command Sequence Template**\n1. `whoami /all`\n2. `hostname`\n3. `ipconfig /all`\n4. `netstat -ano`\n5. `tasklist /v`\n6. `sc query state= all`\n7. `schtasks /query /fo LIST /v`\n8. `reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run`\n9. `wevtutil qe Security /c:10`\n10. `net group \"Domain Admins\" /domain`\n\n**Linux Command Sequence Template**\n1. `whoami`\n2. `id`\n3. `hostnamectl`\n4. `ip a`\n5. `ss -tulpn`\n6. `ps aux --sort=-%cpu | head`\n7. `systemctl list-units --type=service`\n8. `crontab -l`\n9. `journalctl -n 40`\n10. `find /etc -maxdepth 1 -type f`\n\nTailor these sequences to engagement scope.\n\n**Detection Signals**\n- `whoami /all`: monitor Security Event 4688 with command line for unusual accounts.\n- `net group /domain`: create alerts when standard users query privileged groups.\n- `powershell Compress-Archive`: inspect script block logging (4104) for data staging.\n- `ps aux`/`ss -tulpn`: use auditd or shell history monitoring to verify legitimacy.\n- `find /etc`: watch for large-scale configuration searches by non-admins.\n\n**Cloud Considerations**\n- Azure: `Get-AzRoleAssignment`, `az network nic list-effective-nsg`.\n- AWS: `aws iam list-users`, `aws ec2 describe-instances`.\n- GCP: `gcloud projects get-iam-policy`.\nWhen living off the land in cloud environments, ensure credentials are scoped appropriately and logs (CloudTrail, Activity Log) capture your actions.\n\n**Reporting Checklist**\n- Host overview (hostname, OS, domain)\n- Key findings (users, services, scheduled tasks)\n- Detection notes (which logs captured activity)\n- Remediation recommendations\n- Follow-up actions (automation, monitoring)\n\n**Self-Assessment Questions**\n- Can I explain why each command is necessary?\n- Do I know which log records it?\n- How would I justify the command to a system owner?\n- What remediation or monitoring follows from the output?\n\n**Script Hygiene Tips**\n- Store scripts in secure locations and delete after use.\n- Log when scripts were executed and under which accounts.\n- Ensure scripts respect scope and rate limits.\n\n**Time Management Tip**\nSet a timer (e.g., 20 minutes per host) to keep reconnaissance focused. When the timer ends, summarize findings and note unanswered questions. This habit prevents analysis paralysis and keeps engagements on schedule."
      }
    },
    {
      "block_id": "4f741a82-0595-406e-87e1-bbe28b5fb772",
      "type": "reflection",
      "content": {
        "text": "Reflect on your living-off-the-land exercise:\n\n1. **Command efficiency**: Which commands delivered the most value per second? Which were noisy or redundant?\n2. **Detection footprint**: Which logs captured your actions? How can defenders detect misuse of these utilities?\n3. **Skill growth**: Identify built-in tools you rarely use (e.g., `dsquery`, `systemd-analyze`). Plan practice sessions.\n4. **Communication**: Write a paragraph translating your recon findings into business risk language for executives.\n5. **OPSEC lessons**: Did you accidentally leave artifacts (transcripts, history entries)? How will you avoid this next time?\n6. **Automation ideas**: Sketch pseudo-code for a script that collects key recon data while remaining native.\n7. **Defender empathy**: How would a helpdesk analyst interpret your commands? Could you collaborate to improve detection?\n8. **Next steps**: Commit to building a reusable checklist for future engagements.\n\nClose with the affirmation: *\"I reveal environments responsibly using native tools.\"*\n9. **Automation roadmap**: Outline steps to convert your manual recon into scripts while maintaining native tooling.\n10. **Detection collaboration**: List specific log queries you will share with the blue team.\n11. **Case study reflection**: Choose one real-world example and outline how you would detect or prevent it as a defender.\n12. **Peer review plan**: Identify someone who can review your recon playbook for completeness and stealth, then schedule the review.\n13. **Narrative practice**: Describe your recon findings as a short briefing to the CISO, focusing on business impact and remediation timelines.\n14. **Learning backlog**: List resources (blogs, videos, labs) you will study to enhance native recon skills.\n15. **Cloud reflection**: How would your native recon workflow adapt in cloud-native environments? List commands or services you need to study.\n16. **Playbook evaluation**: After drafting your playbook, identify gaps or redundancies. Plan iterations to improve clarity and stealth.\n17. **Continuous improvement**: Schedule quarterly reviews of your living-off-the-land playbook to incorporate new LOLBAS entries, GTFOBins techniques, and defender feedback.\n18. **Script review**: After writing automation, review with legal/compliance to ensure scripts meet documentation requirements.\n19. **Checklist review**: Compare your personal recon checklist with the one above. Merge them into a single document you will reuse across engagements.\n20. **Executive summary practice**: Draft a one-paragraph executive summary based solely on native recon findings. Focus on risk, evidence, and remediation timeline.\n21. **Timeboxing reflection**: Record how long you spent on each host and evaluate whether the timer approach improved efficiency.\n22. **Celebrate wins**: Note one new insight you gained from relying solely on native tools and how it strengthens your professional practice.\n23. **Final note**: Revisit this playbook before your next engagement."
      }
    }
  ],
  "post_assessment": [
    {
      "question_id": "985fefde-f60b-4ba1-ab3d-9ed722c8e8d9",
      "question": "Which native Windows command reveals scheduled tasks without requiring external binaries?",
      "options": [
        "schtasks /query /fo LIST /v",
        "regsvr32 /s",
        "net share",
        "wmic qfe list"
      ],
      "answer": "schtasks /query /fo LIST /v",
      "explanation": "`schtasks` is a built-in utility that enumerates scheduled tasks with detailed metadata.",
      "type": "multiple_choice",
      "correct_answer": 0,
      "difficulty": 2
    },
    {
      "question_id": "c4e8cb63-0d12-446b-b88b-d0101e7b9061",
      "question": "On Linux, you want to list systemd timers without installing new tools. Which command fits?",
      "options": [
        "systemctl list-timers",
        "cronstat --timers",
        "apt list --installed",
        "timerscan -a"
      ],
      "answer": "systemctl list-timers",
      "explanation": "`systemctl list-timers` is a native systemd command that enumerates active timers without third-party binaries.",
      "type": "multiple_choice",
      "correct_answer": 0,
      "difficulty": 2
    },
    {
      "question": "What is the most important takeaway from this lesson?",
      "options": [
        "Understanding the core concepts and their practical applications",
        "Memorizing all technical details",
        "Only knowing the theory without practice",
        "Focusing on a single aspect"
      ],
      "correct_answer": 0,
      "explanation": "The key takeaway is understanding how to apply the concepts learned in real-world scenarios, combining both theoretical knowledge and practical skills.",
      "question_id": "8220ced2-fb3c-45f3-a48a-155fbc729528",
      "type": "multiple_choice",
      "difficulty": 1
    }
  ]
}
