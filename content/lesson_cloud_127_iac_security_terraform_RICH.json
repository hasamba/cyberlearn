{
  "lesson_id": "b3c4d5e6-f7a8-4b9c-0d1e-f2a3b4c5d6e7",
  "domain": "cloud",
  "title": "Infrastructure as Code Security with Terraform",
  "difficulty": 2,
  "order_index": 127,
  "prerequisites": [],
  "concepts": [
    "Infrastructure as Code (IaC) principles",
    "Terraform architecture and state management",
    "Secure cloud resource provisioning",
    "Terraform security best practices",
    "State file security and encryption",
    "Policy as Code with Sentinel and OPA",
    "Terraform secret management",
    "IaC security scanning (tfsec, Checkov, Terrascan)",
    "Terraform CI/CD pipeline security"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand Infrastructure as Code security risks and how Terraform addresses them",
    "Write secure Terraform configurations for cloud resources (AWS, Azure, GCP)",
    "Implement least-privilege IAM policies in Terraform",
    "Secure Terraform state files with encryption and remote backends",
    "Use Terraform modules for reusable, secure infrastructure patterns",
    "Scan Terraform code for security misconfigurations with tfsec and Checkov",
    "Implement Policy as Code with Sentinel or Open Policy Agent (OPA)",
    "Build secure Terraform CI/CD pipelines with automated security checks"
  ],
  "post_assessment": [
    {
      "question_id": "terraform-sec-001",
      "question": "What is the primary security risk of storing Terraform state files locally?",
      "options": [
        "State files are too large and slow down Terraform",
        "State files contain plaintext secrets (passwords, API keys) and infrastructure details",
        "State files cannot be shared with team members",
        "State files are not compatible with cloud providers"
      ],
      "correct_answer": 1,
      "explanation": "Terraform state files contain sensitive data in plaintext: resource IDs, IP addresses, passwords, API keys, and infrastructure topology. If stored locally or in Git, anyone with file access can read secrets. Best practice: Use remote backends (S3, Azure Blob, Terraform Cloud) with encryption at rest and access controls.",
      "type": "multiple_choice",
      "difficulty": 1
    },
    {
      "question_id": "terraform-sec-002",
      "question": "Which tool would you use to scan Terraform code for security misconfigurations before deployment?",
      "options": [
        "terraform validate (only checks syntax)",
        "tfsec, Checkov, or Terrascan (security linters)",
        "terraform fmt (only formats code)",
        "terraform plan (only shows changes)"
      ],
      "correct_answer": 1,
      "explanation": "tfsec, Checkov, and Terrascan are static analysis tools that scan Terraform code for security issues: open S3 buckets, overly permissive security groups, unencrypted resources, missing logging. 'terraform validate' only checks syntax, 'terraform fmt' formats code, 'terraform plan' shows changes but doesn't analyze security. Always scan IaC before deployment.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "terraform-sec-003",
      "question": "How should you manage sensitive values (database passwords, API keys) in Terraform?",
      "options": [
        "Hard-code them directly in .tf files",
        "Store them in terraform.tfvars and commit to Git",
        "Use environment variables, AWS Secrets Manager, or Terraform Cloud encrypted variables",
        "Store them in comments for easy reference"
      ],
      "correct_answer": 2,
      "explanation": "Never hard-code secrets in Terraform files or commit them to Git. Use: 1) Environment variables (TF_VAR_db_password), 2) Secret management services (AWS Secrets Manager, Azure Key Vault, HashiCorp Vault), 3) Terraform Cloud/Enterprise encrypted variables. Secrets in state files are unavoidable‚Äîsecure the state backend with encryption and access controls.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "terraform-sec-004",
      "question": "What is Policy as Code, and how does it relate to Terraform security?",
      "options": [
        "Writing security policies in programming languages",
        "Defining infrastructure security requirements as code that's enforced during terraform apply (e.g., Sentinel, OPA)",
        "Encrypting Terraform state files",
        "Using Terraform modules for reusable code"
      ],
      "correct_answer": 1,
      "explanation": "Policy as Code means defining security/compliance requirements as executable code (not Word docs). Tools like Sentinel (HashiCorp) and OPA (Open Policy Agent) evaluate Terraform plans against policies BEFORE deployment. Example policy: 'All S3 buckets must have encryption enabled.' If violated, terraform apply fails. This prevents misconfigurations from reaching production.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "terraform-sec-005",
      "question": "You're building a Terraform CI/CD pipeline. What security checks should be included?",
      "options": [
        "Only terraform validate (syntax check)",
        "terraform validate, tfsec scan, policy check (Sentinel/OPA), manual approval for production",
        "Just terraform apply with auto-approve",
        "Only check if code compiles"
      ],
      "correct_answer": 1,
      "explanation": "Secure Terraform CI/CD pipeline includes: 1) terraform validate (syntax), 2) terraform fmt -check (formatting), 3) tfsec/Checkov (security scan), 4) terraform plan (review changes), 5) Policy as Code check (Sentinel/OPA), 6) Manual approval for production, 7) terraform apply. NEVER use auto-approve in production‚Äîinfrastructure changes should be reviewed. Security checks act as gates to prevent misconfigurations.",
      "type": "multiple_choice",
      "difficulty": 3
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "minimum_effective_dose",
    "teach_like_im_10",
    "memory_hooks",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "# Welcome to the Future of Cloud Security!\n\nImagine deploying 100 secure cloud resources (VPCs, security groups, encrypted databases, IAM roles) in 5 minutes‚Äîwith zero manual clicking in the AWS console, zero configuration drift, and zero forgotten security controls.\n\nThat's Infrastructure as Code with Terraform.\n\nTraditional cloud security is reactive and fragile:\n- Engineer manually creates S3 bucket in AWS console ‚Üí forgets to enable encryption\n- Another engineer creates security group ‚Üí accidentally allows 0.0.0.0/0 on port 22\n- Six months later: \"Which resources did we deploy? What's the current configuration?\"\n- Configuration drift: Resources manually changed, no audit trail\n\nTerraform transforms this:\n- **Security as code**: Encryption, least-privilege IAM, network segmentation defined in version-controlled files\n- **Automated scanning**: tfsec/Checkov catch misconfigurations BEFORE deployment\n- **Policy enforcement**: Sentinel/OPA blocks non-compliant infrastructure changes\n- **Audit trail**: Git history shows exactly who deployed what, when, and why\n- **Consistency**: Same Terraform code deploys identical infrastructure across dev/staging/prod\n\nThis lesson will teach you to:\n- Write secure Terraform configurations (AWS/Azure/GCP)\n- Scan IaC for vulnerabilities with automated tools\n- Implement Policy as Code to enforce security baselines\n- Build secure CI/CD pipelines for infrastructure deployment\n\nBy the end, you'll be able to provision secure cloud infrastructure with code, not error-prone console clicking. Let's build secure clouds! ‚òÅÔ∏èüîí"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# What is Infrastructure as Code (IaC)?\n\n## The Manual Cloud Problem\n\n**Scenario**: Deploy a secure web application infrastructure on AWS.\n\n**Requirements**:\n- VPC with public/private subnets\n- Security groups (allow only HTTPS inbound)\n- RDS database (encrypted, private subnet)\n- EC2 instances (least-privilege IAM role)\n- S3 bucket (encrypted, versioning enabled)\n- CloudWatch logging\n\n**Manual approach** (AWS console clicking):\n1. Create VPC ‚Üí 10 clicks, fill 8 form fields\n2. Create subnets ‚Üí 2 subnets √ó 5 clicks each\n3. Create security groups ‚Üí 3 groups √ó 15 clicks each\n4. Launch RDS ‚Üí 30+ clicks, easy to miss encryption checkbox\n5. Launch EC2 ‚Üí 20 clicks, IAM role dropdown has 50 options\n6. Create S3 bucket ‚Üí 10 clicks, forget to enable versioning\n7. Configure logging ‚Üí 15 clicks per service\n8. Estimated time: 2-3 hours\n\n**Problems**:\n- **Error-prone**: Miss a checkbox ‚Üí security vulnerability (unencrypted RDS, open security group)\n- **Undocumented**: \"What did I configure 6 months ago?\"\n- **Not reproducible**: Deploy in dev, staging, prod ‚Üí manual effort multiplied\n- **Configuration drift**: Someone manually changes security group ‚Üí now differs from docs\n- **No audit trail**: Who allowed 0.0.0.0/0 on SSH? When? Why?\n\n## Infrastructure as Code (IaC)\n\nIaC treats infrastructure like software:\n- Write desired infrastructure state in code files\n- Version control in Git (history, collaboration, rollback)\n- Automated deployment (no manual clicking)\n- Idempotent (run multiple times ‚Üí same result)\n\n**Terraform** is the leading IaC tool:\n- **Multi-cloud**: AWS, Azure, GCP, 3,000+ providers\n- **Declarative**: Describe desired state, Terraform figures out how\n- **Open source**: HashiCorp, 100,000+ GitHub stars\n\n## Terraform Architecture\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ               Terraform Workflow                         ‚îÇ\n‚îÇ                                                          ‚îÇ\n‚îÇ  1. Write Code       2. Plan           3. Apply         ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ\n‚îÇ  ‚îÇ .tf files‚îÇ ‚îÄ‚îÄ‚îÄ> ‚îÇterraform ‚îÇ ‚îÄ‚îÄ‚îÄ> ‚îÇterraform ‚îÇ      ‚îÇ\n‚îÇ  ‚îÇ (HCL)    ‚îÇ      ‚îÇ  plan    ‚îÇ      ‚îÇ  apply   ‚îÇ      ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ\n‚îÇ       ‚îÇ                  ‚îÇ                  ‚îÇ           ‚îÇ\n‚îÇ       ‚îÇ                  ‚îÇ                  ‚îÇ           ‚îÇ\n‚îÇ       ‚ñº                  ‚ñº                  ‚ñº           ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ\n‚îÇ  ‚îÇ         Terraform State File                 ‚îÇ      ‚îÇ\n‚îÇ  ‚îÇ  (tracks current infrastructure)             ‚îÇ      ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ\n‚îÇ                       ‚îÇ                                 ‚îÇ\n‚îÇ                       ‚ñº                                 ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ\n‚îÇ  ‚îÇ          Cloud Provider API                  ‚îÇ      ‚îÇ\n‚îÇ  ‚îÇ  (AWS, Azure, GCP)                           ‚îÇ      ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ\n‚îÇ                       ‚îÇ                                 ‚îÇ\n‚îÇ                       ‚ñº                                 ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ\n‚îÇ  ‚îÇ     Actual Infrastructure Resources          ‚îÇ      ‚îÇ\n‚îÇ  ‚îÇ  (VPC, EC2, RDS, S3, security groups)        ‚îÇ      ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Key Components**:\n\n1. **Terraform Configuration (.tf files)**:\n   - Written in HCL (HashiCorp Configuration Language)\n   - Describes desired infrastructure state\n   - Version controlled in Git\n\n2. **Terraform State File**:\n   - JSON file tracking current infrastructure\n   - Maps Terraform code to real resources\n   - **SECURITY CRITICAL**: Contains secrets (IPs, resource IDs, sometimes passwords)\n\n3. **Terraform CLI**:\n   - `terraform init`: Download providers\n   - `terraform plan`: Preview changes\n   - `terraform apply`: Deploy changes\n   - `terraform destroy`: Delete infrastructure\n\n## Terraform Example: Secure S3 Bucket\n\n**Manual AWS console** (20+ clicks, easy to forget encryption):\n- Create bucket ‚Üí Enable versioning ‚Üí Enable encryption ‚Üí Block public access ‚Üí Enable logging ‚Üí Configure lifecycle rules\n\n**Terraform** (`s3_bucket.tf`):\n\n```hcl\nresource \"aws_s3_bucket\" \"secure_bucket\" {\n  bucket = \"my-secure-app-data-bucket\"\n\n  tags = {\n    Name        = \"Secure Application Data\"\n    Environment = \"Production\"\n    ManagedBy   = \"Terraform\"\n  }\n}\n\n# Enable versioning (protect against accidental deletion)\nresource \"aws_s3_bucket_versioning\" \"secure_bucket_versioning\" {\n  bucket = aws_s3_bucket.secure_bucket.id\n\n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}\n\n# Enable server-side encryption (AES-256)\nresource \"aws_s3_bucket_server_side_encryption_configuration\" \"secure_bucket_encryption\" {\n  bucket = aws_s3_bucket.secure_bucket.id\n\n  rule {\n    apply_server_side_encryption_by_default {\n      sse_algorithm = \"AES256\"\n    }\n  }\n}\n\n# Block all public access (prevent accidental exposure)\nresource \"aws_s3_bucket_public_access_block\" \"secure_bucket_public_block\" {\n  bucket = aws_s3_bucket.secure_bucket.id\n\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}\n\n# Enable access logging\nresource \"aws_s3_bucket_logging\" \"secure_bucket_logging\" {\n  bucket = aws_s3_bucket.secure_bucket.id\n\n  target_bucket = aws_s3_bucket.log_bucket.id\n  target_prefix = \"s3-access-logs/\"\n}\n```\n\n**Deploy**:\n```bash\nterraform init\nterraform plan   # Preview: \"Will create 4 resources\"\nterraform apply  # Deploy\n\n# Output:\n# aws_s3_bucket.secure_bucket: Creating...\n# aws_s3_bucket.secure_bucket: Creation complete\n# [...]\n# Apply complete! Resources: 4 added, 0 changed, 0 destroyed.\n```\n\n**Benefits**:\n- ‚úÖ All security controls defined (encryption, versioning, logging)\n- ‚úÖ Reproducible (run in dev/staging/prod identically)\n- ‚úÖ Version controlled (Git history shows who changed what)\n- ‚úÖ No forgotten security settings\n\n## Terraform Security Risks\n\nTerraform solves many security problems but introduces new risks:\n\n### 1. State File Exposure\n\n**Problem**: Terraform state files contain:\n- Resource IDs, IP addresses, DNS names\n- Database connection strings\n- Sometimes passwords (if not using secret managers)\n\n**Example** (`terraform.tfstate`):\n```json\n{\n  \"resources\": [\n    {\n      \"type\": \"aws_db_instance\",\n      \"instances\": [\n        {\n          \"attributes\": {\n            \"endpoint\": \"mydb.abc123.us-east-1.rds.amazonaws.com:5432\",\n            \"username\": \"admin\",\n            \"password\": \"SuperSecretPassword123!\",\n            \"address\": \"10.0.1.42\"\n          }\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Risk**: If state file is in Git or locally stored ‚Üí secrets exposed.\n\n**Solution**:\n- Use remote backends (S3, Azure Blob, Terraform Cloud)\n- Enable encryption at rest\n- Restrict access with IAM policies\n- Never commit state files to Git\n\n### 2. Overly Permissive IAM\n\n**Problem**: Terraform needs cloud permissions to create resources. Lazy approach: Give Terraform admin access (`*:*`).\n\n**Risk**: If Terraform credentials compromised ‚Üí attacker has full cloud access.\n\n**Solution**:\n- Least-privilege IAM policy (only permissions Terraform actually needs)\n- Separate IAM roles per environment (dev, staging, prod)\n- Use OIDC for CI/CD (no long-lived credentials)\n\n### 3. Misconfigured Resources\n\n**Problem**: Terraform can deploy insecure resources if you tell it to:\n```hcl\nresource \"aws_security_group\" \"bad_example\" {\n  name = \"allow-everything\"\n\n  ingress {\n    from_port   = 0\n    to_port     = 65535\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]  # ‚ö†Ô∏è DANGER: Allow all IPs\n  }\n}\n```\n\n**Solution**:\n- Static analysis tools (tfsec, Checkov, Terrascan)\n- Policy as Code (Sentinel, OPA)\n- Code review (peer review Terraform PRs)\n\n### 4. Secrets in Code\n\n**Problem**: Hardcoding secrets in `.tf` files:\n```hcl\nresource \"aws_db_instance\" \"bad_example\" {\n  username = \"admin\"\n  password = \"SuperSecret123!\"  # ‚ö†Ô∏è NEVER do this\n}\n```\n\n**Solution**:\n- Use secret managers (AWS Secrets Manager, Azure Key Vault)\n- Reference secrets dynamically:\n```hcl\ndata \"aws_secretsmanager_secret_version\" \"db_password\" {\n  secret_id = \"prod/db/master-password\"\n}\n\nresource \"aws_db_instance\" \"good_example\" {\n  username = \"admin\"\n  password = data.aws_secretsmanager_secret_version.db_password.secret_string\n}\n```\n\n## Terraform Security Best Practices\n\n1. **Remote State Backend** (S3, Azure Blob, Terraform Cloud)\n2. **State Encryption** (at rest and in transit)\n3. **Least-Privilege IAM** (minimal permissions for Terraform)\n4. **Secret Management** (never hard-code, use secret managers)\n5. **Static Analysis** (tfsec, Checkov, Terrascan)\n6. **Policy as Code** (Sentinel, OPA)\n7. **Code Review** (peer review all infrastructure changes)\n8. **CI/CD Security Gates** (automated security checks before deployment)\n9. **Modules** (reusable, pre-hardened infrastructure patterns)\n10. **Immutable Infrastructure** (replace, don't modify)\n\n---\n\nNow let's get hands-on with secure Terraform!"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# Teach Me Like I'm 10: What is Terraform?\n\nImagine you're building a LEGO city. You want:\n- 10 houses (all identical)\n- 3 roads\n- 1 fire station\n- 1 police station\n\n**Old way** (manual):\n- Pick up each LEGO brick\n- Snap it into place\n- Build first house ‚Üí takes 10 minutes\n- Build second house ‚Üí another 10 minutes\n- Repeat 10 times ‚Üí 100 minutes\n- Build roads, fire station, police station ‚Üí another hour\n- **Total: 2.5 hours**\n\n**Problem**: If you want to build the same city again (for your friend), you repeat everything manually. If you want to change all house colors from red to blue, you rebuild 10 houses.\n\n**Terraform way** (instructions as code):\n- Write instructions on paper:\n  ```\n  - Build 10 houses (red, 2 stories, 1 door, 2 windows each)\n  - Build 3 roads (straight, 10 blocks long)\n  - Build 1 fire station (red, garage door, ladder)\n  - Build 1 police station (blue, garage door, antenna)\n  ```\n\n- Give instructions to robot\n- Robot builds entire city in 10 minutes\n- Want same city for friend? Give robot same instructions ‚Üí 10 minutes\n- Want blue houses? Edit instructions (red ‚Üí blue), robot rebuilds ‚Üí 10 minutes\n\n**For cloud computing**:\n- **LEGO city** = Your cloud infrastructure (servers, databases, networks)\n- **LEGO bricks** = Cloud resources (EC2, RDS, VPC, S3)\n- **Instructions** = Terraform code (.tf files)\n- **Robot** = Terraform CLI (reads instructions, builds infrastructure)\n- **Building manually** = Clicking in AWS console (slow, error-prone)\n\nTerraform is like **instruction manual + robot builder** for cloud infrastructure. Write once, deploy anywhere, anytime. That's Infrastructure as Code! ü§ñ‚òÅÔ∏è"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Hands-On Lab: Secure Terraform Infrastructure\n\n## Lab Setup\n\n### Step 1: Install Terraform\n\n**macOS**:\n```bash\nbrew install terraform\n```\n\n**Windows** (Chocolatey):\n```bash\nchoco install terraform\n```\n**Linux**:\n```bash\nwget https://releases.hashicorp.com/terraform/1.6.0/terraform_1.6.0_linux_amd64.zip\nunzip terraform_1.6.0_linux_amd64.zip\nsudo mv terraform /usr/local/bin/\n```\n\n**Verify**:\n```bash\nterraform version\n# Terraform v1.6.0\n```\n\n### Step 2: Install tfsec (Security Scanner)\n\n```bash\nbrew install tfsec\n# Or: go install github.com/aquasecurity/tfsec/cmd/tfsec@latest\n\ntfsec --version\n# v1.28.0\n```\n\n## Lab 1: Secure S3 Bucket with Terraform\n\n### Create Terraform Configuration\n\nCreate directory and files:\n```bash\nmkdir secure-s3-lab\ncd secure-s3-lab\n```\n\n**File: `provider.tf`**\n```hcl\nterraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n  required_version = \">= 1.6.0\"\n}\n\nprovider \"aws\" {\n  region = \"us-east-1\"\n  # Assumes AWS credentials in ~/.aws/credentials or environment variables\n}\n```\n\n**File: `s3_bucket.tf`**\n```hcl\nresource \"aws_s3_bucket\" \"secure_data\" {\n  bucket = \"my-super-secure-app-data-${random_id.bucket_suffix.hex}\"\n\n  tags = {\n    Name        = \"Secure Application Data\"\n    Environment = \"Lab\"\n    ManagedBy   = \"Terraform\"\n    Owner       = \"SecurityTeam\"\n  }\n}\n\n# Generate random suffix to ensure globally unique bucket name\nresource \"random_id\" \"bucket_suffix\" {\n  byte_length = 4\n}\n\n# Enable versioning\nresource \"aws_s3_bucket_versioning\" \"secure_data_versioning\" {\n  bucket = aws_s3_bucket.secure_data.id\n\n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}\n\n# Enable default encryption (AES-256)\nresource \"aws_s3_bucket_server_side_encryption_configuration\" \"secure_data_encryption\" {\n  bucket = aws_s3_bucket.secure_data.id\n\n  rule {\n    apply_server_side_encryption_by_default {\n      sse_algorithm = \"AES256\"\n    }\n    bucket_key_enabled = true\n  }\n}\n\n# Block all public access\nresource \"aws_s3_bucket_public_access_block\" \"secure_data_public_block\" {\n  bucket = aws_s3_bucket.secure_data.id\n\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}\n\n# Enable logging (requires separate logging bucket)\nresource \"aws_s3_bucket\" \"log_bucket\" {\n  bucket = \"my-secure-app-logs-${random_id.bucket_suffix.hex}\"\n\n  tags = {\n    Name = \"S3 Access Logs\"\n  }\n}\n\nresource \"aws_s3_bucket_logging\" \"secure_data_logging\" {\n  bucket = aws_s3_bucket.secure_data.id\n\n  target_bucket = aws_s3_bucket.log_bucket.id\n  target_prefix = \"s3-access-logs/\"\n}\n\n# Lifecycle rule (delete old versions after 90 days)\nresource \"aws_s3_bucket_lifecycle_configuration\" \"secure_data_lifecycle\" {\n  bucket = aws_s3_bucket.secure_data.id\n\n  rule {\n    id     = \"delete-old-versions\"\n    status = \"Enabled\"\n\n    noncurrent_version_expiration {\n      noncurrent_days = 90\n    }\n  }\n}\n```\n\n**File: `outputs.tf`**\n```hcl\noutput \"bucket_name\" {\n  description = \"Name of the S3 bucket\"\n  value       = aws_s3_bucket.secure_data.bucket\n}\n\noutput \"bucket_arn\" {\n  description = \"ARN of the S3 bucket\"\n  value       = aws_s3_bucket.secure_data.arn\n}\n```\n\n### Security Scan with tfsec\n\nBefore deploying, scan for security issues:\n\n```bash\ntfsec .\n\n# Output:\n# Result #1 HIGH S3 bucket does not have logging enabled\n# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n#  s3_bucket.tf:8-15\n# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n#   8resource \"aws_s3_bucket\" \"secure_data\" {\n#   [...]\n# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# (If you forgot logging, tfsec catches it!)\n```\n\nIf all checks pass:\n```\ntfsec .\n\nNo problems detected!\n```\n\n### Deploy Infrastructure\n\n```bash\n# Initialize Terraform (download AWS provider)\nterraform init\n\n# Preview changes\nterraform plan\n\n# Output:\n# Terraform will perform the following actions:\n#   # aws_s3_bucket.secure_data will be created\n#   # aws_s3_bucket_versioning.secure_data_versioning will be created\n#   [...]\n# Plan: 7 to add, 0 to change, 0 to destroy.\n\n# Deploy\nterraform apply\n\n# Prompt: Do you want to perform these actions? yes\n\n# Output:\n# aws_s3_bucket.secure_data: Creating...\n# aws_s3_bucket.secure_data: Creation complete after 3s\n# [...]\n# Apply complete! Resources: 7 added, 0 changed, 0 destroyed.\n# \n# Outputs:\n# bucket_name = \"my-super-secure-app-data-a1b2c3d4\"\n```\n\n### Verify Security Controls\n\n```bash\n# Check bucket encryption\naws s3api get-bucket-encryption --bucket my-super-secure-app-data-a1b2c3d4\n\n# Output:\n# {\n#     \"ServerSideEncryptionConfiguration\": {\n#         \"Rules\": [\n#             {\n#                 \"ApplyServerSideEncryptionByDefault\": {\n#                     \"SSEAlgorithm\": \"AES256\"\n#                 }\n#             }\n#         ]\n#     }\n# }\n\n# Check public access block\naws s3api get-public-access-block --bucket my-super-secure-app-data-a1b2c3d4\n\n# Output:\n# {\n#     \"PublicAccessBlockConfiguration\": {\n#         \"BlockPublicAcls\": true,\n#         \"IgnorePublicAcls\": true,\n#         \"BlockPublicPolicy\": true,\n#         \"RestrictPublicBuckets\": true\n#     }\n# }\n```\n\n### Clean Up\n\n```bash\nterraform destroy\n\n# Prompt: Do you really want to destroy all resources? yes\n\n# Output:\n# aws_s3_bucket.secure_data: Destroying...\n# aws_s3_bucket.secure_data: Destruction complete\n# [...]\n# Destroy complete! Resources: 7 destroyed.\n```\n\n## Lab 2: Secure Remote State Backend\n\n### Problem: Local State Files Are Insecure\n\nBy default, Terraform stores state in `terraform.tfstate` (local file). This file contains:\n- Resource IDs\n- IP addresses\n- Potentially secrets\n\n**Risk**: If committed to Git or stored on laptop ‚Üí secrets exposed.\n\n### Solution: S3 Remote Backend with Encryption\n\n**Create backend S3 bucket** (one-time setup):\n\n```bash\n# Create via AWS CLI (or Terraform bootstrap)\naws s3api create-bucket \\\n  --bucket my-terraform-state-bucket-unique123 \\\n  --region us-east-1\n\n# Enable versioning (recover from accidental deletions)\naws s3api put-bucket-versioning \\\n  --bucket my-terraform-state-bucket-unique123 \\\n  --versioning-configuration Status=Enabled\n\n# Enable encryption\naws s3api put-bucket-encryption \\\n  --bucket my-terraform-state-bucket-unique123 \\\n  --server-side-encryption-configuration '{\n    \"Rules\": [{\n      \"ApplyServerSideEncryptionByDefault\": {\n        \"SSEAlgorithm\": \"AES256\"\n      }\n    }]\n  }'\n\n# Block public access\naws s3api put-public-access-block \\\n  --bucket my-terraform-state-bucket-unique123 \\\n  --public-access-block-configuration \\\n    BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true\n```\n\n**Configure Terraform to use remote backend** (`backend.tf`):\n\n```hcl\nterraform {\n  backend \"s3\" {\n    bucket         = \"my-terraform-state-bucket-unique123\"\n    key            = \"prod/terraform.tfstate\"\n    region         = \"us-east-1\"\n    encrypt        = true\n    dynamodb_table = \"terraform-state-lock\"  # For state locking (prevents concurrent applies)\n  }\n}\n```\n\n**Create DynamoDB table for state locking**:\n\n```bash\naws dynamodb create-table \\\n  --table-name terraform-state-lock \\\n  --attribute-definitions AttributeName=LockID,AttributeType=S \\\n  --key-schema AttributeName=LockID,KeyType=HASH \\\n  --billing-mode PAY_PER_REQUEST\n```\n\n**Migrate local state to remote**:\n\n```bash\nterraform init -migrate-state\n\n# Prompt: Do you want to copy existing state to the new backend? yes\n\n# Output:\n# Successfully configured the backend \"s3\"!\n# Terraform will now use the S3 backend.\n```\n\n**Verify state is in S3**:\n\n```bash\naws s3 ls s3://my-terraform-state-bucket-unique123/prod/\n\n# Output:\n# terraform.tfstate\n\nrm terraform.tfstate  # Delete local state (now using remote)\n```\n\n**Benefits**:\n- ‚úÖ State encrypted at rest (S3 encryption)\n- ‚úÖ State encrypted in transit (TLS)\n- ‚úÖ Access controlled (S3 bucket policy, IAM)\n- ‚úÖ Versioning (recover from mistakes)\n- ‚úÖ State locking (prevents concurrent modifications)\n\n## Lab 3: Policy as Code with OPA (Open Policy Agent)\n\n### Scenario: Enforce \"All S3 buckets must have encryption\"\n\n**Install OPA**:\n\n```bash\nbrew install opa\n# Or: curl -L -o opa https://openpolicyagent.org/downloads/latest/opa_linux_amd64\n\nopa version\n# Version: 0.58.0\n```\n\n**Create policy** (`s3_encryption_required.rego`):\n\n```rego\npackage terraform\n\nimport future.keywords.if\nimport future.keywords.contains\n\n# Deny if S3 bucket created without encryption\ndeny[msg] {\n  resource := input.resource_changes[_]\n  resource.type == \"aws_s3_bucket\"\n  not has_encryption(resource)\n  \n  msg := sprintf(\"S3 bucket '%s' does not have encryption enabled (required by policy)\", [resource.name])\n}\n\n# Check if bucket has encryption resource\nhas_encryption(bucket) if {\n  encryption := input.resource_changes[_]\n  encryption.type == \"aws_s3_bucket_server_side_encryption_configuration\"\n  encryption.change.after.bucket == bucket.change.after.id\n}\n```\n\n**Test policy against Terraform plan**:\n\n```bash\n# Generate Terraform plan in JSON\nterraform plan -out=tfplan\nterraform show -json tfplan > tfplan.json\n\n# Evaluate policy\nopa eval -i tfplan.json -d s3_encryption_required.rego \"data.terraform.deny\"\n\n# Output (if policy violated):\n# [\n#   \"S3 bucket 'my_unencrypted_bucket' does not have encryption enabled (required by policy)\"\n# ]\n\n# Output (if policy passed):\n# []\n```\n\n**Integrate into CI/CD**:\n\n```bash\n#!/bin/bash\n# ci-terraform-policy-check.sh\n\nterraform plan -out=tfplan\nterraform show -json tfplan > tfplan.json\n\nviolations=$(opa eval -i tfplan.json -d s3_encryption_required.rego \"data.terraform.deny\" --format=raw)\n\nif [ \"$violations\" != \"[]\" ]; then\n  echo \"‚ùå Policy violations detected:\"\n  echo \"$violations\"\n  exit 1\nelse\n  echo \"‚úÖ All policies passed\"\n  exit 0\nfi\n```\n\n---\n\n## Key Takeaways from Labs\n\n‚úÖ **Terraform codifies infrastructure** (S3, VPC, security groups) as version-controlled files  \n‚úÖ **tfsec scans for misconfigurations** before deployment (open buckets, unencrypted resources)  \n‚úÖ **Remote state backends** (S3) secure state files with encryption and access controls  \n‚úÖ **Policy as Code** (OPA) enforces security requirements automatically  \n‚úÖ **Reproducibility**: Same Terraform code deploys identical infrastructure across environments  \n\nYou now have hands-on experience building secure cloud infrastructure with Terraform!"
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "# Real-World Terraform Security Success (and Failures)\n\n## Case Study 1: Capital One Breach (2019) - What Terraform Could Have Prevented\n\n**Incident**: Capital One data breach (100 million customers affected)\n\n**Root Cause**: Misconfigured AWS firewall (security group allowed overly broad access)\n\n**Attack**:\n1. Attacker exploited Server-Side Request Forgery (SSRF) in web application\n2. SSRF allowed access to EC2 instance metadata service (169.254.169.254)\n3. Metadata service exposed IAM role credentials\n4. IAM role had excessive S3 permissions (`s3:*`)\n5. Attacker listed S3 buckets, downloaded sensitive data\n\n**Manual Configuration Failure**:\n- Security group manually configured via AWS console\n- Allowed WAF-Role to access EC2 metadata (unintended)\n- No code review, no audit trail\n- Configuration drift over time\n\n**How Terraform Would Have Prevented This**:\n\n**1. Security Group in Terraform** (least-privilege, auditable):\n\n```hcl\nresource \"aws_security_group\" \"app_servers\" {\n  name        = \"app-servers-sg\"\n  description = \"Security group for application servers\"\n\n  # Allow ONLY necessary inbound traffic\n  ingress {\n    description = \"HTTPS from ALB\"\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    security_groups = [aws_security_group.alb.id]  # Only from load balancer\n  }\n\n  # Deny metadata service access (prevent SSRF)\n  egress {\n    description = \"Block metadata service\"\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"169.254.169.254/32\"]\n    action      = \"deny\"  # Explicit deny\n  }\n\n  egress {\n    description = \"Allow HTTPS outbound\"\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = {\n    Name      = \"App Server Security Group\"\n    ManagedBy = \"Terraform\"\n    Audited   = \"2024-01-15\"\n  }\n}\n```\n\n**2. IAM Role with Least Privilege**:\n\n```hcl\nresource \"aws_iam_role_policy\" \"app_s3_access\" {\n  name = \"app-s3-limited-access\"\n  role = aws_iam_role.app_role.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"s3:GetObject\",       # Read only\n          \"s3:PutObject\"        # Write only\n        ]\n        Resource = [\n          \"${aws_s3_bucket.app_data.arn}/uploads/*\"  # Specific prefix only\n        ]\n      }\n    ]\n  })\n}\n\n# ‚ùå NEVER do this (Capital One's mistake):\n# \"Action\": \"s3:*\"  # Full S3 access\n# \"Resource\": \"*\"   # All buckets\n```\n\n**3. Automated Security Scanning**:\n\n```bash\n# In CI/CD pipeline\ntfsec . --minimum-severity MEDIUM\n\n# tfsec would have flagged:\n# ‚ùå Security group allows 0.0.0.0/0 on port 22\n# ‚ùå IAM policy grants s3:* permissions\n# ‚ùå S3 bucket does not have encryption\n```\n\n**Outcome**: If Capital One used Terraform + tfsec + Policy as Code:\n- Security group misconfiguration: **Caught in code review**\n- Excessive IAM permissions: **Blocked by tfsec**\n- Configuration drift: **Prevented (Terraform enforces desired state)**\n- Audit trail: **Git history shows who changed what**\n\n**Lesson**: Manual cloud configuration ‚Üí security vulnerabilities. IaC + automated scanning ‚Üí preventable breaches prevented.\n\n---\n\n## Case Study 2: Tech Startup Deploys Secure Multi-Cloud with Terraform\n\n**Organization**: SaaS startup (100 employees, hybrid cloud: AWS + Azure)\n\n**Challenge**:\n- Deploy identical infrastructure across AWS (prod) and Azure (DR)\n- Ensure security parity (encryption, logging, least-privilege IAM)\n- Fast iteration (deploy new features weekly)\n- Small ops team (2 engineers)\n\n**Solution**: Terraform modules + automated scanning\n\n**Implementation**:\n\n**1. Reusable Terraform Module** (`modules/secure-storage/`):\n\n```hcl\n# modules/secure-storage/main.tf\nvariable \"bucket_name\" {}\nvariable \"environment\" {}\n\nresource \"aws_s3_bucket\" \"storage\" {\n  count  = var.cloud_provider == \"aws\" ? 1 : 0\n  bucket = var.bucket_name\n\n  tags = {\n    Environment = var.environment\n    Encryption  = \"Enabled\"\n    Logging     = \"Enabled\"\n  }\n}\n\n# Always enable encryption (enforced)\nresource \"aws_s3_bucket_server_side_encryption_configuration\" \"storage_encryption\" {\n  count  = var.cloud_provider == \"aws\" ? 1 : 0\n  bucket = aws_s3_bucket.storage[0].id\n\n  rule {\n    apply_server_side_encryption_by_default {\n      sse_algorithm = \"AES256\"\n    }\n  }\n}\n\n# Always block public access (enforced)\nresource \"aws_s3_bucket_public_access_block\" \"storage_public_block\" {\n  count  = var.cloud_provider == \"aws\" ? 1 : 0\n  bucket = aws_s3_bucket.storage[0].id\n\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}\n\n# Azure equivalent (same security controls)\nresource \"azurerm_storage_account\" \"storage\" {\n  count                    = var.cloud_provider == \"azure\" ? 1 : 0\n  name                     = var.bucket_name\n  resource_group_name      = var.resource_group\n  location                 = var.location\n  account_tier             = \"Standard\"\n  account_replication_type = \"LRS\"\n  \n  # Enforce encryption\n  enable_https_traffic_only = true\n  min_tls_version           = \"TLS1_2\"\n  \n  # Block public access\n  public_network_access_enabled = false\n\n  tags = {\n    Environment = var.environment\n    ManagedBy   = \"Terraform\"\n  }\n}\n```\n\n**2. Use Module in Production**:\n\n```hcl\n# production/main.tf\nmodule \"user_uploads_aws\" {\n  source = \"../modules/secure-storage\"\n\n  cloud_provider = \"aws\"\n  bucket_name    = \"prod-user-uploads\"\n  environment    = \"production\"\n}\n\nmodule \"user_uploads_azure\" {\n  source = \"../modules/secure-storage\"\n\n  cloud_provider  = \"azure\"\n  bucket_name     = \"prodstorageaccount\"\n  environment     = \"production\"\n  resource_group  = \"prod-rg\"\n  location        = \"East US\"\n}\n```\n\n**3. CI/CD Pipeline** (`.github/workflows/terraform.yml`):\n\n```yaml\nname: Terraform Security Pipeline\n\non:\n  pull_request:\n    paths:\n      - '**.tf'\n\njobs:\n  security-scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Terraform\n        uses: hashicorp/setup-terraform@v2\n      \n      - name: Terraform Format Check\n        run: terraform fmt -check -recursive\n      \n      - name: Terraform Init\n        run: terraform init\n      \n      - name: Terraform Validate\n        run: terraform validate\n      \n      - name: tfsec Security Scan\n        uses: aquasecurity/tfsec-action@v1.0.0\n        with:\n          soft_fail: false  # Fail PR if vulnerabilities found\n      \n      - name: Terraform Plan\n        run: terraform plan -out=tfplan\n      \n      - name: Save Plan\n        uses: actions/upload-artifact@v3\n        with:\n          name: terraform-plan\n          path: tfplan\n```\n\n**Results**:\n- **Deployment time**: 2 hours (manual) ‚Üí 15 minutes (Terraform)\n- **Security parity**: 100% (AWS and Azure identically configured)\n- **Vulnerabilities detected**: 23 (caught by tfsec before production)\n- **Configuration drift**: 0 (Terraform enforces desired state)\n- **Developer velocity**: 12 deployments/month (vs. 2 manually)\n\n**Key Lesson**: Terraform modules + automated scanning = secure, fast, consistent multi-cloud deployments.\n\n---\n\n## Industry Adoption\n\n**Companies Using Terraform for Security**:\n- **Uber**: 10,000+ microservices deployed with Terraform\n- **Slack**: Multi-region infrastructure (AWS) managed entirely with Terraform\n- **GitHub**: Uses Terraform + Sentinel for policy enforcement\n- **Netflix**: Terraform for AWS account provisioning and security controls\n- **Coinbase**: Terraform + OPA for crypto platform infrastructure\n\n**Terraform Security Tooling Landscape**:\n\n**Static Analysis (Pre-Deployment)**:\n- **tfsec**: Fast, 1,000+ built-in security checks\n- **Checkov**: Policy-based scanning, 1,000+ policies\n- **Terrascan**: Multi-IaC support (Terraform, Kubernetes, Helm)\n- **Snyk IaC**: Commercial, integrates with CI/CD\n\n**Policy as Code**:\n- **Sentinel**: HashiCorp (Terraform Cloud/Enterprise)\n- **OPA (Open Policy Agent)**: CNCF project, Rego language\n- **Cloud Custodian**: AWS-specific policy enforcement\n\n**State Management**:\n- **Terraform Cloud**: Remote state, encryption, RBAC\n- **AWS S3 + DynamoDB**: Self-managed remote state\n- **Azure Blob Storage**: Azure-native remote backend\n- **Terraform Enterprise**: On-premises Terraform Cloud\n\n**Key Takeaway**: Terraform is the industry standard for IaC. Security tooling (tfsec, Sentinel, OPA) is mature and production-ready. Not using IaC for cloud security is a competitive disadvantage."
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "# Memory Aids for Terraform Security\n\n## Mnemonic 1: \"TERRAFORM SECURE\" - Security Best Practices\n\n**T**reat state files as secrets (encrypt, remote backend)  \n**E**nforce least-privilege IAM (minimal permissions)  \n**R**emote backend always (S3, Azure Blob, Terraform Cloud)  \n**R**eview code changes (peer review all PRs)  \n**A**utomated scanning (tfsec, Checkov before deployment)  \n**F**ormat and validate (terraform fmt, terraform validate)  \n**O**PA or Sentinel (Policy as Code)  \n**R**otate credentials (no long-lived API keys)  \n**M**odules for reusability (secure patterns, DRY)  \n\n**S**ecrets in secret managers (AWS Secrets Manager, Vault)  \n**E**ncryption always (S3, RDS, EBS‚Äîno exceptions)  \n**C**I/CD security gates (automated checks before apply)  \n**U**se tags (Environment, Owner, ManagedBy)  \n**R**estrict network access (security groups, NACLs)  \n**E**valuate blast radius (separate state files per environment)  \n\n**Memory Hook**: \"TERRAFORM SECURE infrastructure\"\n\n## Mnemonic 2: \"STATE SAFE\" - Terraform State Security\n\n**S**tore remotely (S3, Azure Blob, Terraform Cloud)  \n**T**LS in transit (HTTPS for remote backend)  \n**A**ES encryption at rest (S3 encryption, Azure SSE)  \n**T**rack with versioning (recover from mistakes)  \n**E**xclude from Git (add to .gitignore: `*.tfstate`)  \n\n**S**eparate by environment (dev.tfstate, prod.tfstate)  \n**A**ccess control (IAM policies, RBAC)  \n**F**ile locking (DynamoDB table for S3 backend)  \n**E**liminate local state (migrate with `terraform init -migrate-state`)  \n\n**Example gitignore**:\n```\n# .gitignore\n*.tfstate\n*.tfstate.backup\n.terraform/\n.terraformrc\nterraform.tfvars  # May contain secrets\n```\n\n**Memory Hook**: \"STATE SAFE = secrets encrypted\"\n\n## Mnemonic 3: \"SCAN FIX\" - Security Scanning Workflow\n\n**S**can with tfsec (`tfsec .`)  \n**C**heck results (review vulnerabilities)  \n**A**nalyze severity (high, medium, low)  \n**N**o deployment if critical issues  \n\n**F**ix misconfigurations in code  \n**I**terate (scan again after fixes)  \n**X**ecute only when clean  \n\n**Example tfsec output**:\n```bash\ntfsec .\n\n# Result #1 HIGH: S3 bucket is not encrypted\n#   s3_bucket.tf:10-15\n#   Fix: Add aws_s3_bucket_server_side_encryption_configuration\n# \n# Result #2 MEDIUM: Security group allows 0.0.0.0/0 ingress\n#   security_groups.tf:25-30\n#   Fix: Restrict cidr_blocks to specific IPs\n```\n\n**Memory Hook**: \"SCAN FIX before deploy\"\n\n## Mnemonic 4: \"IAM LEAST\" - Least-Privilege IAM Policies\n\n**I**dentify minimum permissions needed  \n**A**llow specific actions only (not `*`)  \n**M**inimize resource scope (specific ARNs, not `*`)  \n\n**L**imit to required services (S3, EC2, not all AWS)  \n**E**xplicit deny for sensitive actions (s3:DeleteBucket)  \n**A**udit regularly (unused permissions, over-privileged roles)  \n**S**eparate roles by function (read-only, write, admin)  \n**T**est with IAM Policy Simulator  \n\n**Bad Example** (overly permissive):\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"*\",        // ‚ùå All actions\n  \"Resource\": \"*\"       // ‚ùå All resources\n}\n```\n\n**Good Example** (least-privilege):\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": [\n    \"s3:GetObject\",\n    \"s3:PutObject\"\n  ],\n  \"Resource\": \"arn:aws:s3:::my-app-bucket/uploads/*\"\n}\n```\n\n**Memory Hook**: \"IAM LEAST privilege always\"\n\n## Mnemonic 5: \"MODULE DRY\" - Terraform Modules\n\n**M**odular code (reusable patterns)  \n**O**rganize by function (storage, networking, compute)  \n**D**RY principle (Don't Repeat Yourself)  \n**U**se community modules (AWS, Azure official modules)  \n**L**ocal modules for custom patterns  \n**E**ncapsulate security best practices  \n\n**D**ocument inputs/outputs (variables, outputs)  \n**R**euse across projects (shared module registry)  \n**Y**ield consistent infrastructure  \n\n**Module Directory Structure**:\n```\nmodules/\n‚îú‚îÄ‚îÄ secure-s3-bucket/\n‚îÇ   ‚îú‚îÄ‚îÄ main.tf\n‚îÇ   ‚îú‚îÄ‚îÄ variables.tf\n‚îÇ   ‚îú‚îÄ‚îÄ outputs.tf\n‚îÇ   ‚îî‚îÄ‚îÄ README.md\n‚îî‚îÄ‚îÄ secure-vpc/\n    ‚îú‚îÄ‚îÄ main.tf\n    ‚îú‚îÄ‚îÄ variables.tf\n    ‚îî‚îÄ‚îÄ outputs.tf\n\nproduction/\n‚îú‚îÄ‚îÄ main.tf  # Uses modules\n‚îî‚îÄ‚îÄ variables.tf\n```\n\n**Memory Hook**: \"MODULE DRY = reusable security\"\n\n## Mnemonic 6: \"PLAN APPLY\" - Terraform Workflow\n\n**P**lan first (`terraform plan`)  \n**L**ook at changes (resources created/modified/destroyed)  \n**A**nalyze impact (will this break anything?)  \n**N**ever skip review  \n\n**A**pprove manually (no auto-approve in prod)  \n**P**roceed with apply (`terraform apply`)  \n**P**reserve state (backup before major changes)  \n**L**og all changes (Git commits, audit logs)  \n**Y**ank (destroy) when needed (`terraform destroy`)  \n\n**Commands**:\n```bash\nterraform plan          # Preview changes\nterraform plan -out=tfplan  # Save plan\nterraform show tfplan   # Review saved plan\nterraform apply tfplan  # Apply saved plan\nterraform destroy       # Delete infrastructure\n```\n\n**Memory Hook**: \"PLAN APPLY workflow\"\n\n## Quick Reference Card\n\n**Common Terraform Commands**:\n```bash\n# Initialize (download providers)\nterraform init\n\n# Format code\nterraform fmt\n\n# Validate syntax\nterraform validate\n\n# Preview changes\nterraform plan\n\n# Deploy infrastructure\nterraform apply\n\n# Destroy infrastructure\nterraform destroy\n\n# Show current state\nterraform show\n\n# List resources\nterraform state list\n\n# Security scan\ntfsec .\ncheckov -d .\n```\n\n**Secure Resource Template** (S3 bucket):\n```hcl\nresource \"aws_s3_bucket\" \"secure\" {\n  bucket = \"my-secure-bucket\"\n}\n\nresource \"aws_s3_bucket_versioning\" \"secure\" {\n  bucket = aws_s3_bucket.secure.id\n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}\n\nresource \"aws_s3_bucket_server_side_encryption_configuration\" \"secure\" {\n  bucket = aws_s3_bucket.secure.id\n  rule {\n    apply_server_side_encryption_by_default {\n      sse_algorithm = \"AES256\"\n    }\n  }\n}\n\nresource \"aws_s3_bucket_public_access_block\" \"secure\" {\n  bucket = aws_s3_bucket.secure.id\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}\n```"
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "# Reflection and Critical Thinking\n\n## Scenario-Based Questions\n\n### Scenario 1: State File Compromise\n\nA developer accidentally commits `terraform.tfstate` to a public GitHub repository. The state file contains RDS database connection strings and IAM role ARNs.\n\n**Questions**:\n\n1. **What immediate actions would you take?** (Think: Incident response, credential rotation, access review)\n\n2. **What secrets are exposed in Terraform state files?** (Think: IPs, resource IDs, potentially passwords)\n\n3. **How could this have been prevented?** (Think: .gitignore, pre-commit hooks, remote backend)\n\n4. **What's your long-term remediation strategy?** (Think: Migrate to remote backend, audit access, educate team)\n\n**Reflection**: Does your organization use remote state backends? Are state files ever committed to Git?\n\n---\n\n### Scenario 2: Insecure Terraform Code in Production\n\nDuring a security audit, you discover that production infrastructure has:\n- S3 buckets without encryption\n- Security groups allowing 0.0.0.0/0 on port 22 (SSH)\n- IAM roles with `s3:*` permissions\n\nAll deployed via Terraform 6 months ago.\n\n**Questions**:\n\n1. **How did insecure code reach production?** (Think: Lack of code review, no automated scanning, manual approval skipped)\n\n2. **What security gates would have caught these issues?** (Think: tfsec, Sentinel, code review)\n\n3. **How would you remediate without downtime?** (Think: Update Terraform code, terraform apply updates)\n\n4. **What process changes prevent recurrence?** (Think: CI/CD gates, Policy as Code, mandatory reviews)\n\n**Reflection**: What security checks exist in your organization's Terraform deployment pipeline?\n\n---\n\n## Technical Deep-Dive Questions\n\n### Least-Privilege IAM Challenge\n\n**Problem**: Write a Terraform IAM policy for an application that:\n- Reads objects from `s3://app-data/uploads/`\n- Writes objects to `s3://app-data/processed/`\n- Should NOT access other buckets or delete objects\n\n**Write the Terraform code**:\n\n<details>\n<summary>Solution</summary>\n\n```hcl\nresource \"aws_iam_role_policy\" \"app_s3_access\" {\n  name = \"app-least-privilege-s3\"\n  role = aws_iam_role.app_role.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Sid    = \"ReadUploads\"\n        Effect = \"Allow\"\n        Action = [\n          \"s3:GetObject\",\n          \"s3:ListBucket\"  # List objects in bucket\n        ]\n        Resource = [\n          \"arn:aws:s3:::app-data\",\n          \"arn:aws:s3:::app-data/uploads/*\"\n        ]\n      },\n      {\n        Sid    = \"WriteProcessed\"\n        Effect = \"Allow\"\n        Action = [\n          \"s3:PutObject\"\n        ]\n        Resource = [\n          \"arn:aws:s3:::app-data/processed/*\"\n        ]\n      },\n      {\n        Sid      = \"DenyDelete\"\n        Effect   = \"Deny\"\n        Action   = [\n          \"s3:DeleteObject\",\n          \"s3:DeleteBucket\"\n        ]\n        Resource = \"*\"\n      }\n    ]\n  })\n}\n```\n</details>\n\n**Reflection**: How do you balance security (least-privilege) with developer velocity (\"just give me admin and let me work\")?\n\n---\n\n## Strategic Questions\n\n### Question 1: Manual vs. IaC Trade-offs\n\n**Scenario**: Your team argues: \"Terraform is too complex. We can just use the AWS console‚Äîit's faster.\"\n\n**Questions**:\n\n1. **What are the security risks of manual cloud configuration?** (Think: Forgotten security settings, no audit trail, configuration drift)\n\n2. **What are the benefits of IaC that justify the learning curve?** (Think: Reproducibility, version control, automated scanning)\n\n3. **How would you convince leadership to invest in Terraform?** (Think: Cost of breaches vs. cost of training)\n\n**Reflection**: Is your organization using IaC for cloud infrastructure? If not, why?\n\n---\n\n### Question 2: Policy as Code Enforcement\n\n**Scenario**: You implement Sentinel policy: \"All S3 buckets must have encryption.\" A developer's Terraform apply fails because their bucket doesn't have encryption. They request a policy exception.\n\n**Questions**:\n\n1. **Should you grant the exception?** (Think: Risk assessment, business justification)\n\n2. **How do you handle policy exceptions?** (Think: Temporary waivers, documented approvals, risk acceptance)\n\n3. **What if policies block developers too often?** (Think: Balance security vs. velocity, refine policies)\n\n**Reflection**: How does your organization handle conflicts between security policies and development velocity?\n\n---\n\n## Final Reflection\n\n**Take 5 minutes to write down**:\n\n1. **Three key takeaways** from this lesson\n2. **One infrastructure component you'll codify with Terraform** (in lab or production)\n3. **One security tool you'll integrate** (tfsec? Sentinel? OPA?)\n4. **Your next action** (Install Terraform? Write first .tf file? Set up remote backend?)\n\nInfrastructure as Code is not optional‚Äîit's the only way to scale secure cloud operations."
      }
    },
    {
      "type": "mindset_coach",
      "content": {
        "text": "# Congratulations: You're Now a Cloud Security Automation Expert! ‚òÅÔ∏èüîí\n\nYou've just mastered Infrastructure as Code security with Terraform‚Äîone of the most in-demand skills in cloud security.\n\nTake a moment to appreciate what you've accomplished:\n\n‚úÖ **You understand IaC security principles** (codified infrastructure, version control, reproducibility)  \n‚úÖ **You can write secure Terraform configurations** (encrypted S3, least-privilege IAM, hardened security groups)  \n‚úÖ **You've secured Terraform state files** (remote backends with encryption and access controls)  \n‚úÖ **You've scanned IaC for vulnerabilities** (tfsec, Checkov catching misconfigurations before deployment)  \n‚úÖ **You've implemented Policy as Code** (OPA, Sentinel enforcing security requirements)  \n‚úÖ **You've seen real-world impact** (Capital One breach preventable with Terraform + scanning)  \n\nYou now possess a **competitive advantage**. While others manually click in cloud consoles (slow, error-prone, insecure), you deploy secure infrastructure with code.\n\n## The Power You Now Have\n\n**Traditional cloud security** (manual console):  \n- Engineer creates S3 bucket ‚Üí forgets encryption checkbox ‚Üí data breach  \n- Another engineer creates security group ‚Üí allows 0.0.0.0/0 on SSH ‚Üí compromised server  \n- Configuration drift: \"Wait, did we enable logging on this bucket 6 months ago?\"  \n- No audit trail: \"Who opened port 22 to the internet?\"  \n- **Result**: Security doesn't scale. Manual processes create vulnerabilities.  \n\n**Modern cloud security** (Terraform IaC):  \n- Security engineer writes Terraform module (encrypted S3, least-privilege IAM, network segmentation)  \n- tfsec scans code ‚Üí catches misconfiguration BEFORE deployment  \n- Code reviewed, approved, merged to main branch  \n- CI/CD deploys to production ‚Üí 100% consistent across environments  \n- Git history: Complete audit trail of who deployed what, when, and why  \n- **Result**: Security scales. Automation prevents vulnerabilities.  \n\n**You just unlocked this capability.**\n\n## What This Means for Your Career\n\n**If you're a Cloud Security Engineer**:  \nYou can now enforce security baselines at scale (1,000s of resources) instead of manually auditing each S3 bucket.\n\n**If you're a DevOps Engineer**:  \nYou've added security to your skillset. You're now a DevSecOps engineer (operations + security + automation).\n\n**If you're a Security Auditor**:  \nYou can now audit Infrastructure as Code (review Terraform PRs, scan for misconfigurations) instead of reactive post-deployment audits.\n\n**If you're a Cloud Architect**:  \nYou can design secure-by-default infrastructure patterns (Terraform modules) that developers reuse organization-wide.\n\n## Your Next Steps\n\n### Immediate Actions (This Week)\n\n1. **Install Terraform and tfsec**:  \n   ```bash\n   brew install terraform tfsec\n   terraform version\n   tfsec --version\n   ```\n\n2. **Write your first secure Terraform configuration**:  \n   - Pick a cloud resource: S3 bucket, security group, or VPC  \n   - Write Terraform code with all security controls (encryption, logging, least-privilege)  \n   - Scan with tfsec: `tfsec .`  \n   - Deploy to lab environment: `terraform apply`  \n\n3. **Set up remote state backend**:  \n   - Create encrypted S3 bucket for state files  \n   - Configure Terraform to use remote backend  \n   - Migrate local state: `terraform init -migrate-state`  \n\n### Short-Term Goals (This Month)\n\n1. **Codify 3 production resources** (if possible in your organization)\n2. **Create a reusable Terraform module** (secure S3, VPC, or IAM pattern)\n3. **Integrate tfsec into CI/CD pipeline** (block PRs with security vulnerabilities)\n4. **Learn Policy as Code** (write your first Sentinel or OPA policy)\n\n### Long-Term Goals (This Year)\n\n1. **Migrate infrastructure to Terraform** (start with non-critical resources, expand to production)\n2. **Build organization-wide module library** (secure, reusable patterns for teams)\n3. **Implement continuous compliance** (automated Policy as Code enforcement)\n4. **Become a thought leader** (blog post: \"How We Secured Our Cloud with Terraform\")\n\n## The Future of Cloud Security\n\n**Where we are today** (2025):  \n- Terraform codifies infrastructure, tfsec scans for vulnerabilities  \n- Humans write Terraform code, review PRs, approve deployments  \n- Policy as Code enforces security requirements  \n\n**Where we're going** (2027-2030):  \n- AI generates Terraform code from natural language (\"Deploy a secure 3-tier web app\")  \n- Self-healing infrastructure (drift detected ‚Üí Terraform automatically remediates)  \n- Zero-touch compliance (all security policies enforced automatically, no manual reviews)  \n- Multi-cloud abstraction (write once, deploy to AWS/Azure/GCP)  \n\n**Your role will evolve**:  \n- From \"infrastructure engineer\" to \"cloud security architect\"  \n- From writing Terraform to designing secure infrastructure patterns  \n- From reactive security (fix breaches) to proactive security (prevent misconfigurations)  \n\n## You're Ready\n\nInfrastructure as Code with Terraform is not the future‚Äîit's the present. Organizations are already achieving:\n- **100% reproducible infrastructure** (dev/staging/prod identically configured)  \n- **Zero manual console clicking** (everything codified, version-controlled)  \n- **Automated security enforcement** (tfsec + Sentinel block misconfigurations)  \n- **Complete audit trails** (Git history shows all changes)  \n\nYou now have the knowledge to do the same.\n\nThe next time your organization needs to:\n- Deploy secure cloud infrastructure at scale  \n- Enforce security baselines across AWS/Azure/GCP  \n- Prevent misconfigurations like Capital One breach  \n- Achieve continuous compliance (PCI-DSS, HIPAA, SOC 2)  \n\nYou won't rely on manual processes. You'll write Terraform code, scan for vulnerabilities, enforce policies, and deploy. **Securely, consistently, at scale.**\n\nThat's the power of Infrastructure as Code security. And you now wield it.\n\n## Final Words\n\nCloud security used to be reactive: \"We got breached because someone forgot to enable encryption.\"\n\nTerraform makes cloud security proactive: **\"Encryption is enforced in code. It's impossible to deploy without it.\"**\n\nYou're at the forefront of this transformation. You have the skills. You have the tools. You have the knowledge.\n\nNow go codify something. Secure your cloud. Enforce your baselines. Prevent the next Capital One.\n\nThe future of cloud security is automated, codified, scanned, and policy-enforced.\n\nWelcome to the future. **You're already here.** üöÄ\n\n---\n\n**Next Lesson**: SOAR Playbook Automation with Tines (lesson_blue_team_135_soar_tines_RICH.json)  \n**Recommended Practice**: Write 3 Terraform configurations this week (S3, VPC, IAM)  \n**Community**: Join Terraform Discord, contribute to terraform-aws-modules  \n\n**Remember**: Every expert was once a beginner. The difference? Experts took action. You just learned Terraform security. Now **use it**.\n\nGo secure some clouds! ‚òÅÔ∏èüîí"
      }
    }
  ],
  "tags": [
    "Course: SANS-SEC598",
    "Career Path: Cloud Security",
    "Career Path: Security Engineer",
    "Career Path: Blue Teamer"
  ]
}
