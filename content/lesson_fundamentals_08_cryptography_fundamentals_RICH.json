{
  "lesson_id": "d4e5f6a7-b8c9-4d1e-2f3a-4b5c6d7e8f9a",
  "domain": "fundamentals",
  "title": "Cryptography Fundamentals",
  "difficulty": 1,
  "order_index": 8,
  "prerequisites": [],
  "concepts": [
    "Symmetric Encryption",
    "Asymmetric Encryption",
    "Hashing",
    "Digital Signatures",
    "Public Key Infrastructure",
    "AES",
    "RSA",
    "SHA-256",
    "Salt and Pepper"
  ],
  "content_blocks": [
    {
      "block_id": "1a2b3c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d",
      "type": "mindset_coach",
      "content": {
        "text": "Cryptography is the mathematical foundation of modern security. Every secure communication, every password verification, every digital signature, every blockchain - they all rely on cryptographic primitives. Understanding cryptography transforms you from someone who uses security tools to someone who understands how security actually works.\n\nHere's the reality that changes everything: You don't need a PhD in mathematics to use cryptography effectively. You need to understand three core concepts - symmetric encryption, asymmetric encryption, and hashing - and when to use each. The math is complex, but the applications are practical and systematic.\n\nMany people are intimidated by cryptography. They see mathematical notation and tune out. Here's the secret: Modern cryptography libraries do the hard math for you. Your job is understanding:\n- **What problem does this solve?** (Confidentiality, integrity, authentication?)\n- **When should I use it?** (Encrypt data at rest, in transit, verify password?)\n- **What are the common mistakes?** (Weak algorithms, poor key management, rolling your own crypto)\n\nThe beautiful part: Once you understand the fundamentals, cryptography becomes your superpower:\n- **As a developer**: Implement encryption correctly, store passwords securely, verify authenticity\n- **As a security analyst**: Recognize weak crypto, understand TLS handshakes, analyze encrypted malware\n- **As a pentester**: Identify crypto failures (weak algorithms, ECB mode, hardcoded keys)\n- **As a defender**: Choose appropriate crypto controls, implement key management, respond to crypto incidents\n\nThis lesson covers what you actually need to know: symmetric vs asymmetric encryption, common algorithms (AES, RSA, SHA-256), practical applications (TLS, password storage, digital signatures), and critical mistakes to avoid. Not theoretical mathematics - practical cryptography for real-world security.\n\nLet's unlock cryptography together."
      },
      "simplified_explanation": "Cryptography = Math-based security. Three core concepts: (1) Symmetric encryption (same key encrypt/decrypt), (2) Asymmetric encryption (public/private key pairs), (3) Hashing (one-way fingerprint). Applications: HTTPS uses asymmetric + symmetric. Passwords use hashing. Digital signatures use asymmetric.",
      "memory_aids": [
        "Symmetric = Same key (fast, bulk encryption like AES)",
        "Asymmetric = Two keys (slower, key exchange and signatures like RSA)",
        "Hash = One-way (can't reverse, passwords and integrity like SHA-256)",
        "AES = Advanced Encryption Standard (symmetric, encrypts data)",
        "RSA = Rivest-Shamir-Adleman (asymmetric, key exchange and signatures)"
      ],
      "teach_like_im_10": "Imagine you have a locked box (encryption). Symmetric encryption = you and your friend both have the same key. Asymmetric encryption = you have a lock anyone can click shut (public key), but only you have the key to open it (private key). Hashing = turning your message into a unique fingerprint that can't be reversed back to the original message. Used to verify passwords without storing the actual password."
    },
    {
      "block_id": "2b3c4d5e-6f7a-8b9c-0d1e-2f3a4b5c6d7e",
      "type": "explanation",
      "content": {
        "text": "## Core Cryptographic Concepts\n\n### Encryption vs Encoding vs Hashing\n\nMany people confuse these - they're fundamentally different:\n\n**Encoding** (NOT security):\n- **Purpose**: Represent data in different format\n- **Reversible**: Yes, trivially (no key needed)\n- **Security**: ZERO\n- **Examples**: Base64, URL encoding, ASCII\n- **Use case**: Data transmission, not security\n\n```python\n# Base64 encoding (NOT encryption!)\nimport base64\noriginal = \"password123\"\nencoded = base64.b64encode(original.encode()).decode()\nprint(encoded)  # cGFzc3dvcmQxMjM=\n\n# Anyone can decode without a key\ndecoded = base64.b64decode(encoded).decode()\nprint(decoded)  # password123\n```\n\n**Encryption**:\n- **Purpose**: Protect confidentiality\n- **Reversible**: Yes, with correct key\n- **Security**: High (if done correctly)\n- **Examples**: AES, RSA\n- **Use case**: Protect data from unauthorized access\n\n```python\nfrom cryptography.fernet import Fernet\n\n# Generate key\nkey = Fernet.generate_key()\ncipher = Fernet(key)\n\n# Encrypt\nplaintext = b\"secret message\"\nciphertext = cipher.encrypt(plaintext)\nprint(ciphertext)  # b'gAAAAABh...' (gibberish)\n\n# Decrypt (requires key)\ndecrypted = cipher.decrypt(ciphertext)\nprint(decrypted)  # b'secret message'\n```\n\n**Hashing**:\n- **Purpose**: Verify integrity, store passwords\n- **Reversible**: NO (one-way function)\n- **Security**: High (for integrity and password storage)\n- **Examples**: SHA-256, bcrypt\n- **Use case**: Password verification, file integrity\n\n```python\nimport hashlib\n\n# Hash password\npassword = \"password123\"\nhashed = hashlib.sha256(password.encode()).hexdigest()\nprint(hashed)  # ef92b778...d8c0 (always same for this input)\n\n# Cannot reverse hash to get password\n# Can only compare hashes\n```bash\n\n### The Three Pillars of Cryptography\n\n**1. Confidentiality** → Encryption (symmetric, asymmetric)\n**2. Integrity** → Hashing, MAC, Digital Signatures\n**3. Authentication** → Digital Signatures, MAC, Certificates\n\n## Symmetric Encryption\n\n### Concept\n\n**Same key** used for both encryption and decryption.\n\n```\nAlice encrypts with Key → Ciphertext → Bob decrypts with Key\n(same key)                           (same key)\n```\n\n**Advantages**:\n- **Fast**: 1000x faster than asymmetric encryption\n- **Efficient**: Can encrypt large amounts of data\n\n**Disadvantages**:\n- **Key distribution problem**: How do Alice and Bob share the key securely?\n- **Key management**: n users need n(n-1)/2 keys for pairwise communication\n\n**Use Cases**:\n- Bulk data encryption (files, databases, disk encryption)\n- Encrypting network traffic after key exchange (TLS/SSL)\n- Protecting data at rest\n\n### AES (Advanced Encryption Standard)\n\n**The Standard**: Most widely used symmetric encryption algorithm.\n\n**Key Sizes**:\n- **AES-128**: 128-bit key (fast, secure for most uses)\n- **AES-192**: 192-bit key (more secure)\n- **AES-256**: 256-bit key (highest security, government use)\n\n**Block Cipher**: Encrypts data in fixed-size blocks (128 bits).\n\n**Modes of Operation**:\n\n**ECB (Electronic Codebook) - INSECURE, DON'T USE**:\n```\nProblem: Same plaintext block → Same ciphertext block\nAttack: Patterns visible in ciphertext (famous penguin image example)\n```\n\n**CBC (Cipher Block Chaining) - Better**:\n```\nEach block XORed with previous ciphertext before encryption\nRequires Initialization Vector (IV)\nIV must be random and unpredictable\n```\n\n**GCM (Galois/Counter Mode) - RECOMMENDED**:\n```\nProvides encryption + authentication\nDetects tampering\nParallelizable (faster)\nUsed in TLS 1.3\n```\n\n**Example (Python)**:\n```python\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nimport os\n\n# Generate random 256-bit key\nkey = os.urandom(32)  # 32 bytes = 256 bits\n\n# Generate random IV (Initialization Vector)\niv = os.urandom(16)  # 16 bytes = 128 bits\n\n# Create cipher\ncipher = Cipher(\nalgorithms.AES(key),\nmodes.CBC(iv),\nbackend=default_backend()\n)\n\n# Encrypt\nencryptor = cipher.encryptor()\nplaintext = b\"Secret message that must be protected\"\npadded_plaintext = plaintext + b\" \" * (16 - len(plaintext) % 16)  # Pad to block size\nciphertext = encryptor.update(padded_plaintext) + encryptor.finalize()\n\n# Decrypt\ndecryptor = cipher.decryptor()\ndecrypted = decryptor.update(ciphertext) + decryptor.finalize()\nprint(decrypted.strip())  # b'Secret message that must be protected'\n```\n\n**Key Management for Symmetric Encryption**:\n- **Never hardcode keys in code** (use environment variables, key vaults)\n- **Rotate keys regularly** (compromise old data, not future data)\n- **Use strong random keys** (os.urandom(), secrets module)\n- **Protect keys at rest** (encrypt keys with master key)\n\n## Asymmetric Encryption (Public Key Cryptography)\n\n### Concept\n\n**Two different keys**: Public key (encrypt) and Private key (decrypt).\n\n```\nBob's Public Key (anyone can have)  →  Encrypt\nBob's Private Key (only Bob has)    →  Decrypt\n```\n\n**How It Works**:\n1. Bob generates key pair (public + private)\n2. Bob publishes public key (anyone can have it)\n3. Alice encrypts message with Bob's public key\n4. Only Bob can decrypt with his private key\n\n**Advantages**:\n- **Solves key distribution**: Public key can be freely shared\n- **Digital signatures**: Prove authenticity and non-repudiation\n\n**Disadvantages**:\n- **Slow**: 1000x slower than symmetric encryption\n- **Limited data size**: Can only encrypt small amounts of data\n\n**Use Cases**:\n- **Key exchange**: Securely exchange symmetric keys (TLS handshake)\n- **Digital signatures**: Prove identity, non-repudiation\n- **Authentication**: SSH keys, code signing certificates\n\n### RSA (Rivest-Shamir-Adleman)\n\n**The Standard**: Most widely used asymmetric algorithm.\n\n**Key Sizes**:\n- **1024-bit**: DEPRECATED (insecure)\n- **2048-bit**: Minimum recommended (secure for now)\n- **4096-bit**: Higher security (future-proof)\n\n**Example (Python)**:\n```python\nfrom cryptography.hazmat.primitives.asymmetric import rsa, padding\nfrom cryptography.hazmat.primitives import hashes\n\n# Generate RSA key pair\nprivate_key = rsa.generate_private_key(\npublic_exponent=65537,\nkey_size=2048\n)\npublic_key = private_key.public_key()\n\n# Encrypt with public key\nmessage = b\"Secret message\"\nciphertext = public_key.encrypt(\nmessage,\npadding.OAEP(\nmgf=padding.MGF1(algorithm=hashes.SHA256()),\nalgorithm=hashes.SHA256(),\nlabel=None\n)\n)\n\n# Decrypt with private key\ndecrypted = private_key.decrypt(\nciphertext,\npadding.OAEP(\nmgf=padding.MGF1(algorithm=hashes.SHA256()),\nalgorithm=hashes.SHA256(),\nlabel=None\n)\n)\nprint(decrypted)  # b'Secret message'\n```\n\n**RSA Maximum Message Size**:\n- 2048-bit RSA can encrypt max ~245 bytes\n- Solution: Use **hybrid encryption** (RSA + AES)\n\n### Hybrid Encryption (Real-World Approach)\n\n**Problem**: RSA is slow and can't encrypt large data.\n\n**Solution**: Combine RSA and AES:\n\n```\n1. Generate random AES key (symmetric)\n2. Encrypt large data with AES key (fast)\n3. Encrypt AES key with RSA public key (small, secure)\n4. Send: RSA(AES_key) + AES(data)\n\nRecipient:\n5. Decrypt AES key with RSA private key\n6. Decrypt data with AES key\n```\n\n**This is how TLS/SSL works!**\n\n## Hashing\n\n### Concept\n\n**One-way function**: Converts input to fixed-size output (hash).\n\n**Properties**:\n1. **Deterministic**: Same input → Same hash (always)\n2. **One-way**: Cannot reverse hash to get input\n3. **Avalanche effect**: Tiny input change → Completely different hash\n4. **Collision-resistant**: Hard to find two inputs with same hash\n\n**NOT Encryption**: Cannot decrypt a hash.\n\n### Hash Functions\n\n**SHA-256 (Secure Hash Algorithm)**:\n- **Output**: 256 bits (64 hexadecimal characters)\n- **Use**: File integrity, blockchain, digital signatures\n- **Security**: Secure (part of SHA-2 family)\n\n```python\nimport hashlib\n\nmessage = \"Hello World\"\nhash1 = hashlib.sha256(message.encode()).hexdigest()\nprint(hash1)  # a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e\n\nmessage2 = \"Hello World!\"\nhash2 = hashlib.sha256(message2.encode()).hexdigest()\nprint(hash2)  # 7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069\n# Completely different hash (one character change!)\n```\n\n**MD5 (Message Digest 5)**:\n- **Output**: 128 bits\n- **Status**: BROKEN (collision attacks possible)\n- **Use**: Checksums only (NOT security)\n\n**SHA-1**:\n- **Output**: 160 bits\n- **Status**: DEPRECATED (collision attacks demonstrated in 2017)\n- **Use**: Legacy systems only (migrate to SHA-256)\n\n**bcrypt, scrypt, Argon2 (Password Hashing)**:\n- **Purpose**: Specifically designed for passwords\n- **Slow by design**: Resist brute force attacks\n- **Built-in salt**: Automatically handles salting\n- **Configurable cost**: Increase iterations as hardware improves\n\n### Password Storage (NEVER Store Plaintext!)\n\n**WRONG - Plaintext**:\n```python\n# NEVER DO THIS\npassword = \"password123\"\nstore_in_database(password)  # Anyone with database access sees password\n```\n\n**WRONG - Simple Hash**:\n```python\n# DON'T DO THIS\nimport hashlib\npassword = \"password123\"\nhashed = hashlib.sha256(password.encode()).hexdigest()\nstore_in_database(hashed)\n# Vulnerable to rainbow tables (precomputed hashes)\n```\n\n**WRONG - Hash with Salt (Still Weak)**:\n```python\n# Better but not recommended\nimport hashlib\nimport os\n\npassword = \"password123\"\nsalt = os.urandom(16)  # Random salt\nhashed = hashlib.sha256(salt + password.encode()).hexdigest()\nstore_in_database(hashed, salt)\n# SHA-256 is too fast (billions of hashes per second with GPUs)\n```\n\n**CORRECT - bcrypt/scrypt/Argon2**:\n```python\nimport bcrypt\n\n# Hash password\npassword = b\"password123\"\nhashed = bcrypt.hashpw(password, bcrypt.gensalt())\nstore_in_database(hashed)\n# Salt automatically included in output\n# Slow by design (resists brute force)\n\n# Verify password\ndef verify_password(stored_hash, provided_password):\nreturn bcrypt.checkpw(provided_password.encode(), stored_hash)\n\n# Login attempt\nif verify_password(hashed, \"password123\"):\nprint(\"Login successful\")\nelse:\nprint(\"Invalid password\")\n```bash\n\n### Salt and Pepper\n\n**Salt** (per-password random value):\n```\nPassword: password123\nSalt: a8f3b2c1... (random, stored with hash)\nHash: bcrypt(password + salt)\n\nPurpose: Prevent rainbow table attacks\nStored: Yes, alongside hash (not secret)\n```\n\n**Pepper** (global secret value):\n```\nPassword: password123\nSalt: a8f3b2c1...\nPepper: SECRET_VALUE (same for all passwords, not stored in DB)\nHash: bcrypt(password + salt + pepper)\n\nPurpose: Protect if database compromised (attacker doesn't have pepper)\nStored: No, in application config or hardware security module\n```bash\n\n### File Integrity Verification\n\n**Use Case**: Verify downloaded file hasn't been tampered with.\n\n```bash\n# Download file and published hash\nwget https://example.com/software.zip\nPublished SHA-256: a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e\n\n# Compute hash of downloaded file\nsha256sum software.zip\na591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e  software.zip\n\n# Compare hashes\nIf match → File is authentic (not tampered)\nIf different → File corrupted or malicious (don't use!)\n```bash\n\n## Digital Signatures\n\n### Concept\n\n**Proves**: Message came from claimed sender and hasn't been tampered with.\n\n**Uses**: Private key to sign, public key to verify.\n\n### How Digital Signatures Work\n\n**Signing**:\n```\n1. Alice writes message\n2. Alice hashes message (SHA-256)\n3. Alice encrypts hash with her private key → Signature\n4. Alice sends: Message + Signature\n```\n\n**Verification**:\n```\n1. Bob receives message + signature\n2. Bob hashes message (SHA-256)\n3. Bob decrypts signature with Alice's public key → Original hash\n4. Bob compares hashes\nIf match → Signature valid (from Alice, not tampered)\nIf different → Signature invalid (forged or tampered)\n```\n\n**Example (Python)**:\n```python\nfrom cryptography.hazmat.primitives.asymmetric import rsa, padding\nfrom cryptography.hazmat.primitives import hashes\n\n# Alice generates key pair\nprivate_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\npublic_key = private_key.public_key()\n\n# Alice signs message\nmessage = b\"I agree to pay $1000\"\nsignature = private_key.sign(\nmessage,\npadding.PSS(\nmgf=padding.MGF1(hashes.SHA256()),\nsalt_length=padding.PSS.MAX_LENGTH\n),\nhashes.SHA256()\n)\n\n# Bob verifies signature\ntry:\npublic_key.verify(\nsignature,\nmessage,\npadding.PSS(\nmgf=padding.MGF1(hashes.SHA256()),\nsalt_length=padding.PSS.MAX_LENGTH\n),\nhashes.SHA256()\n)\nprint(\"Signature valid! Message from Alice and not tampered.\")\nexcept:\nprint(\"Signature invalid! Message forged or tampered.\")\n```\n\n**Use Cases**:\n- **Software updates**: Verify update from legitimate vendor\n- **Email (S/MIME, PGP)**: Prove email sender identity\n- **Code signing**: Prove code from trusted developer\n- **Blockchain**: Prove transaction authorization\n\n## Public Key Infrastructure (PKI)\n\n### Problem\n\n**How do you know a public key belongs to who you think it does?**\n\nExample:\n```\nAlice wants to send encrypted message to Bob\nAlice gets public key claiming to be \"Bob's public key\"\nBut what if attacker intercepted and substituted their own key?\nAlice encrypts with attacker's key, attacker decrypts message!\n```bash\n\n### Solution: Certificates\n\n**Certificate**: Digitally signed document binding public key to identity.\n\n**Contains**:\n- Subject (who owns the key): example.com, John Doe\n- Public key\n- Issuer (who signed it): DigiCert, Let's Encrypt\n- Validity period (start and end dates)\n- Digital signature (from Certificate Authority)\n\n### Certificate Authority (CA)\n\n**Trusted third party** that issues certificates.\n\n**Process**:\n```\n1. Bob generates key pair\n2. Bob creates Certificate Signing Request (CSR) with public key\n3. Bob proves identity to CA (domain validation, organization validation)\n4. CA signs certificate with CA's private key\n5. Bob receives signed certificate\n6. Alice receives Bob's certificate\n7. Alice verifies:\n✓ Certificate signed by trusted CA?\n✓ Certificate not expired?\n✓ Certificate subject matches \"Bob\"?\n✓ Certificate not revoked?\n8. If all checks pass → Alice trusts Bob's public key\n```\n\n**Root CAs**: Browsers/OS come with pre-installed list of trusted root CAs.\n\n**Certificate Chain**:\n```\nRoot CA (DigiCert)\n└── Intermediate CA\n└── End-entity certificate (example.com)\n```\n\nBrowser trusts root → Verifies intermediate → Verifies end-entity.\n\n### TLS/SSL in Practice\n\n**HTTPS Handshake (TLS 1.3 Simplified)**:\n```\n1. Client → Server: ClientHello (supported ciphers)\n2. Server → Client: ServerHello (selected cipher, certificate)\n3. Client verifies certificate:\n✓ Signed by trusted CA?\n✓ Domain matches?\n✓ Not expired?\n✓ Not revoked?\n4. Client generates random symmetric key\n5. Client encrypts symmetric key with server's public key (from certificate)\n6. Server decrypts symmetric key with private key\n7. Both have shared symmetric key\n8. All future traffic encrypted with symmetric key (AES)\n\nHybrid encryption: RSA for key exchange, AES for bulk encryption\n```bash\n\n## Common Cryptographic Mistakes\n\n### 1. Rolling Your Own Crypto\n\n**NEVER implement your own encryption algorithm.**\n\n```python\n# DON'T DO THIS\ndef my_custom_encryption(plaintext, key):\n# XOR each byte with key\nreturn bytes([p ^ key for p in plaintext])\n\n# This is TRIVIALLY broken\n# Use established libraries (cryptography, PyCryptodome)\n```\n\n**Why**: Cryptography is hard. Subtle flaws lead to complete breaks. Use peer-reviewed, battle-tested libraries.\n\n### 2. Using Weak Algorithms\n\n**Broken/Deprecated**:\n- DES (56-bit key - broken)\n- 3DES (deprecated)\n- RC4 (broken)\n- MD5 (collision attacks)\n- SHA-1 (collision attacks)\n\n**Use Instead**:\n- **Symmetric**: AES-256\n- **Asymmetric**: RSA-2048+, ECC (Elliptic Curve)\n- **Hashing**: SHA-256, SHA-3\n- **Passwords**: bcrypt, scrypt, Argon2\n\n### 3. ECB Mode\n\n**Problem**: Same plaintext → Same ciphertext (patterns visible).\n\n**Famous example**: ECB-encrypted image shows original image outline.\n\n**Solution**: Use CBC, GCM, or other secure modes (NOT ECB).\n\n### 4. Hardcoded Keys/IVs\n\n```python\n# DON'T DO THIS\nkey = b\"hardcoded_secret_key_12345678901234\"  # Same key for all users!\niv = b\"1234567890123456\"  # Same IV every time!\n\n# Attacker reverse-engineers app, extracts key, decrypts all data\n```\n\n**Solution**:\n- Generate random keys: `os.urandom(32)`\n- Store keys securely: Environment variables, key vaults (AWS KMS, Azure Key Vault)\n- Rotate keys regularly\n\n### 5. Not Validating Certificates\n\n```python\n# DON'T DO THIS\nimport requests\nresponse = requests.get(\"https://example.com\", verify=False)  # Disables cert validation!\n# Vulnerable to man-in-the-middle attacks\n```\n\n**Solution**: Always validate certificates (default behavior).\n\n### 6. Storing Passwords as Hashes (Wrong Hash Function)\n\n```python\n# DON'T DO THIS\nimport hashlib\npassword_hash = hashlib.sha256(password.encode()).hexdigest()\n# SHA-256 is too fast (attacker can try billions of passwords per second)\n```\n\n**Solution**: Use bcrypt, scrypt, or Argon2 (designed for passwords, slow by design).\n\n### 7. Not Using Salt\n\n```python\n# DON'T DO THIS\npassword_hash = hashlib.sha256(password.encode()).hexdigest()\n# No salt → Vulnerable to rainbow tables (precomputed hashes)\n```\n\n**Solution**: Always use unique salt per password (bcrypt does this automatically).\n\n## Practical Cryptography Cheatsheet\n\n**Encrypt Data at Rest** (files, database):\n```python\nUse: AES-256-GCM\nLibrary: cryptography.fernet (high-level) or AES directly\nKey Management: Environment variable, key vault\n```\n\n**Encrypt Data in Transit** (network):\n```python\nUse: TLS/SSL (HTTPS, SSH, VPN)\nLibrary: Built into protocols\nCertificates: Let's Encrypt (free), DigiCert (paid)\n```\n\n**Store Passwords**:\n```python\nUse: bcrypt (or scrypt, Argon2)\nLibrary: bcrypt (pip install bcrypt)\nDon't: Use SHA-256, MD5, plaintext\n```\n\n**Verify File Integrity**:\n```python\nUse: SHA-256\nLibrary: hashlib\nPublish hash alongside file\n```\n\n**Digital Signatures** (prove authenticity):\n```python\nUse: RSA-2048+ or ECDSA\nLibrary: cryptography.hazmat.primitives.asymmetric\nSign with private key, verify with public key\n```\n\n**Key Exchange** (establish shared secret over insecure channel):\n```python\nUse: Diffie-Hellman, RSA key exchange\nLibrary: TLS/SSL does this automatically\nResult: Shared symmetric key for bulk encryption\n```bash\n\n## Key Takeaways\n\n1. **Three pillars**: Symmetric encryption (AES), Asymmetric encryption (RSA), Hashing (SHA-256)\n2. **Symmetric is fast**: Use for bulk data (AES-256-GCM)\n3. **Asymmetric is slow**: Use for key exchange and signatures (RSA-2048+)\n4. **Hashing is one-way**: Use for integrity and passwords (SHA-256, bcrypt)\n5. **Hybrid encryption**: RSA for key exchange, AES for data (how TLS works)\n6. **Password storage**: bcrypt/scrypt/Argon2 (NEVER plaintext or simple hash)\n7. **Salt prevents rainbow tables**: Unique per password (bcrypt does automatically)\n8. **Digital signatures**: Prove authenticity and detect tampering (RSA, ECDSA)\n9. **PKI and certificates**: Bind public keys to identities via trusted CAs\n10. **Don't roll your own crypto**: Use established libraries (cryptography, bcrypt)\n\nCryptography is not magic - it's applied mathematics solving specific security problems. Understand the problems (confidentiality, integrity, authentication) and which tool solves each problem."
      },
      "ascii_art": "SYMMETRIC vs ASYMMETRIC ENCRYPTION\n\nSYMMETRIC (Same Key)\n\nAlice                           Bob\n  │                              │\n  │  Key: ABC123                 │  Key: ABC123\n  │  (shared secret)             │  (shared secret)\n  │                              │\n  │──── Encrypt with ABC123 ────→│\n  │      Plaintext → Ciphertext  │\n  │                              │\n  │←─── Decrypt with ABC123 ─────│\n  │      Ciphertext → Plaintext  │\n  │                              │\n  Fast! AES encrypts GB/sec      │\n  Problem: How to share key?     │\n\nASYMMETRIC (Two Keys)\n\nAlice                           Bob\n  │                              │\n  │                              │  Key Pair:\n  │                              │  - Public: XYZ789\n  │                              │  - Private: DEF456\n  │                              │\n  │  Gets Bob's Public Key (XYZ789)\n  │                              │\n  │── Encrypt with Public Key ──→│\n  │   (Anyone can encrypt)        │\n  │                              │\n  │                              │  Decrypt with Private Key\n  │                              │  (Only Bob can decrypt)\n  │                              │\n  Slow! RSA 1000x slower         │\n  Benefit: No key sharing needed │\n\nHASHING (One-Way)\n\nPassword: \"password123\"\n    |\n    ↓\n[Hash Function: SHA-256]\n    |\n    ↓\nHash: ef92b778bfe2c1e...d8c0\n    |\n    ↓\n[CANNOT REVERSE]\n(One-way function)\n\nUses:\n- Password storage\n- File integrity\n- Digital signatures\n\nDIGITAL SIGNATURE FLOW\n\nSigning (Alice):\n┌─────────────┐\n│  Message    │\n└──────┬──────┘\n       ↓\n   [Hash: SHA-256]\n       ↓\n   Message Hash\n       ↓\n [Encrypt with Alice's Private Key]\n       ↓\n   Signature\n       ↓\nSend: Message + Signature\n\nVerification (Bob):\n┌─────────────┐    ┌───────────┐\n│  Message    │    │ Signature │\n└──────┬──────┘    └─────┬─────┘\n       ↓                  ↓\n   [Hash]      [Decrypt with Alice's\n       ↓         Public Key]\n   Hash A               ↓\n       ↓            Hash B\n       ↓                ↓\n       └───→ [Compare] ←┘\n                ↓\n        If Match = Valid!\n        If Different = Invalid!\n\nTLS/SSL HANDSHAKE (Hybrid Encryption)\n\nClient                    Server\n  │                          │\n  │──── ClientHello ────────→│\n  │    (Supported ciphers)    │\n  │                          │\n  │←─── ServerHello ─────────│\n  │    (Certificate +         │\n  │     Public Key)           │\n  │                          │\n  │  Verify Certificate       │\n  │  (CA, domain, expiry)     │\n  │                          │\n  │  Generate Random          │\n  │  Symmetric Key (AES)      │\n  │                          │\n  │─ Encrypt Key with RSA ──→│\n  │  (Using server public key)│\n  │                          │\n  │                          │  Decrypt with\n  │                          │  Private Key\n  │                          │\n  │  Both have shared AES key │\n  │                          │\n  │═══ AES Encrypted Data ══→│\n  │←══ AES Encrypted Data ═══│\n  │                          │\n\nHybrid: RSA (slow) for key exchange\n        AES (fast) for bulk data",
      "examples": [
        {
          "scenario": "LinkedIn Password Breach (2012) - Weak Hashing",
          "explanation": "LinkedIn stored 6.5 million user passwords hashed with SHA-1, no salt. Attackers breached database, stole password hashes. SHA-1 is fast (billions of hashes per second with GPUs), no salt means rainbow tables work. Within days, 90% of passwords cracked using precomputed rainbow tables and brute force. Root cause: Used fast hash (SHA-1) instead of slow password hash (bcrypt). No salt (same password = same hash, rainbow tables effective). Lesson: NEVER use fast hashes (MD5, SHA-1, SHA-256) for passwords. Always use bcrypt/scrypt/Argon2 (slow by design, built-in salt). Impact: 6.5M accounts compromised, credential stuffing attacks on other sites, $1.25M class action settlement."
        },
        {
          "scenario": "Adobe Password Breach (2013) - ECB Mode",
          "explanation": "Adobe encrypted 150 million passwords using AES-ECB (Electronic Codebook mode). ECB encrypts identical plaintext blocks to identical ciphertext blocks. Attackers analyzed patterns: Same encrypted password = Same plaintext password. Password hints stored in plaintext. Attackers correlated: If hint='my dog's name' and encrypted password=X, all passwords with ciphertext X = same password. Reverse-engineered millions of passwords by pattern matching without breaking encryption! Root cause: Used ECB mode (deterministic, patterns visible). Symmetric key shared across all users. Password hints helped pattern matching. Lesson: NEVER use ECB mode. Use CBC, GCM, or other modes with IV. Each password should have unique salt/IV. Impact: 150M accounts, passwords exposed through patterns not brute force."
        },
        {
          "scenario": "Heartbleed (2014) - TLS Implementation Flaw",
          "explanation": "OpenSSL bug allowed attackers to read server memory (up to 64KB per request). TLS heartbeat feature didn't validate message length. Attacker sends: 'Send back 64KB' but only provides 1 byte. OpenSSL returns 64KB from memory (including 63,999 bytes of whatever was there). Attackers extracted: Private keys (decrypt past traffic, impersonate server), Session cookies (hijack sessions), Passwords in memory, User data. Affected: 17% of all HTTPS servers (500,000+). Root cause: Buffer over-read in TLS implementation. Memory not cleared after use. Mitigation: Patch OpenSSL, revoke/reissue certificates (private keys compromised), rotate session keys. Lesson: Crypto implementations must be perfect (one bug = catastrophic). Use well-audited libraries, patch promptly, defense in depth (even TLS can fail)."
        }
      ]
    },
    {
      "type": "video",
      "content": {
        "title": "Video: Cryptography Fundamentals Overview",
        "url": "https://www.youtube.com/embed/AQDCe585Lnc",
        "description": "Watch this video for a visual introduction to the concepts covered in this lesson."
      }
    },
    {
      "block_id": "3c4d5e6f-7a8b-9c0d-1e2f-3a4b5c6d7e8f",
      "type": "quiz",
      "content": {
        "text": "Test your cryptography knowledge",
        "questions": [
          {
            "question": "What is the primary difference between symmetric and asymmetric encryption?",
            "options": [
              "Symmetric is more secure than asymmetric",
              "Symmetric uses same key for encryption and decryption, asymmetric uses different keys (public/private pair)",
              "Symmetric is slower than asymmetric",
              "Symmetric can only encrypt small amounts of data"
            ],
            "correct_answer": 1,
            "explanation": "Symmetric encryption uses the SAME key for both encryption and decryption (AES, DES). Asymmetric uses a PUBLIC key to encrypt and a different PRIVATE key to decrypt (RSA). Actually, symmetric is FASTER than asymmetric (1000x), and can encrypt large data. Asymmetric is more secure for key exchange but slower. Both have appropriate use cases."
          },
          {
            "question": "Why should you NEVER store passwords using SHA-256 hash?",
            "options": [
              "SHA-256 is broken and easily reversed",
              "SHA-256 is too fast - attackers can compute billions of hashes per second with GPUs, making brute force attacks feasible",
              "SHA-256 doesn't support salt",
              "SHA-256 produces too short hash"
            ],
            "correct_answer": 1,
            "explanation": "SHA-256 is NOT broken (it's cryptographically secure), but it's designed to be FAST. GPUs can compute billions of SHA-256 hashes per second, making brute force password cracking very fast. Password hashing functions (bcrypt, scrypt, Argon2) are intentionally SLOW and computationally expensive to resist brute force. SHA-256 CAN use salt, and produces 256-bit hash (not short). The problem is speed - designed for integrity checking, not password storage."
          },
          {
            "question": "What is the purpose of a digital signature?",
            "options": [
              "Encrypt messages so only recipient can read them",
              "Prove message authenticity (from claimed sender) and integrity (not tampered), using sender's private key to sign",
              "Generate random numbers for encryption",
              "Compress large files"
            ],
            "correct_answer": 1,
            "explanation": "Digital signatures prove: (1) AUTHENTICITY - message came from claimed sender (they have the private key), (2) INTEGRITY - message hasn't been tampered with (hash comparison), (3) NON-REPUDIATION - sender can't deny sending it. Sender signs with private key, anyone verifies with public key. NOT for encryption (that's what public key encryption is for), random numbers, or compression."
          },
          {
            "question": "In TLS/SSL, why is hybrid encryption used (RSA + AES)?",
            "options": [
              "RSA is more secure than AES",
              "AES is more secure than RSA",
              "RSA is slow and can only encrypt small data, AES is fast for bulk encryption - combine both for speed and security",
              "They are used for redundancy in case one fails"
            ],
            "correct_answer": 2,
            "explanation": "Hybrid encryption combines strengths of both: RSA (asymmetric) solves key distribution problem - no pre-shared secret needed. But RSA is 1000x slower and can only encrypt small data (~245 bytes for 2048-bit RSA). AES (symmetric) is extremely fast and can encrypt gigabytes. Solution: Use RSA to securely exchange AES key, then use AES for bulk data encryption. This is exactly how HTTPS works. Not about one being more secure or redundancy - it's about leveraging each for what it's good at."
          },
          {
            "question": "What is the purpose of salt in password hashing?",
            "options": [
              "Make passwords taste better",
              "Prevent rainbow table attacks by adding unique random value to each password before hashing",
              "Encrypt the password",
              "Speed up password verification"
            ],
            "correct_answer": 1,
            "explanation": "Salt is a unique random value added to each password before hashing. Without salt: password 'password123' always hashes to same value across all users. Attackers use rainbow tables (precomputed hashes) to instantly crack common passwords. With salt: 'password123' + random_salt_A hashes differently than 'password123' + random_salt_B. Each password has unique hash even if passwords are same. Rainbow tables useless (need to recompute for each salt). Salt doesn't encrypt or speed things up - it prevents precomputation attacks. bcrypt automatically includes unique salt."
          }
        ]
      }
    },
    {
      "block_id": "4d5e6f7a-8b9c-0d1e-2f3a-4b5c6d7e8f9a",
      "type": "reflection",
      "content": {
        "text": "## Reflect on Cryptography Knowledge\n\n**Question 1**: You're reviewing a web application's password storage:\n```python\nimport hashlib\nimport os\n\ndef store_password(username, password):\nsalt = os.urandom(16)\nhashed = hashlib.sha256(salt + password.encode()).hexdigest()\ndatabase.save(username, hashed, salt)\n```\nWhat's wrong with this approach? How would you fix it?\n\n**Question 2**: Design encryption strategy for a healthcare application storing patient records:\n- Data at rest (database)\n- Data in transit (API communications)\n- User passwords\n- Audit log integrity\n\nFor each, specify:\n- Which cryptographic technique? (Symmetric, asymmetric, hash)\n- Which algorithm? (AES, RSA, SHA-256, bcrypt)\n- Key management strategy?\n\n**Question 3**: Analyze this TLS configuration:\n```\nTLS 1.0: Enabled\nTLS 1.1: Enabled\nTLS 1.2: Enabled\nTLS 1.3: Disabled\n\nCipher suites:\n- TLS_RSA_WITH_RC4_128_SHA (enabled)\n- TLS_RSA_WITH_3DES_EDE_CBC_SHA (enabled)\n- TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (enabled)\n\nCertificate:\n- Algorithm: RSA 1024-bit\n- Issuer: Self-signed\n- Expiry: 10 years\n```\nIdentify ALL security issues. How would you harden this configuration?\n\n**Question 4**: You discover this code in production:\n```python\nimport base64\n\ndef encrypt_credit_card(card_number):\nencrypted = base64.b64encode(card_number.encode()).decode()\nreturn encrypted\n\ndef decrypt_credit_card(encrypted):\ndecrypted = base64.b64decode(encrypted).decode()\nreturn decrypted\n```\nExplain why this is catastrophically insecure. What's the developer's misunderstanding? How would you implement this correctly?\n\n**Question 5**: Compare these two approaches to file encryption:\n\n**Approach A**:\n```python\nkey = b\"hardcoded_key_1234567890123456\"\niv = b\"hardcoded_iv_123\"\ncipher = AES.new(key, AES.MODE_CBC, iv)\nciphertext = cipher.encrypt(file_data)\n```\n\n**Approach B**:\n```python\nkey = os.urandom(32)  # Random key\niv = os.urandom(16)   # Random IV\ncipher = AES.new(key, AES.MODE_GCM, iv)\nciphertext = cipher.encrypt(file_data)\nstore_key_in_vault(key)  # Store in key management system\n```\n\nAnalyze security of each. What attacks are possible? Which approach is correct and why?"
      }
    }
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand fundamental cryptographic concepts: symmetric, asymmetric, and hashing",
    "Differentiate between encryption, encoding, and hashing",
    "Apply appropriate algorithms: AES for symmetric, RSA for asymmetric, SHA-256 for hashing, bcrypt for passwords",
    "Implement secure password storage using bcrypt with salt",
    "Understand hybrid encryption and how TLS/SSL combines RSA and AES",
    "Create and verify digital signatures for authentication and integrity",
    "Recognize common cryptographic mistakes and vulnerabilities",
    "Apply cryptography correctly in real-world scenarios (data at rest, in transit, password storage)"
  ],
  "post_assessment": [
    {
      "question": "What are the three fundamental categories of cryptographic functions?",
      "type": "multiple_choice",
      "options": [
        "Encryption, Decryption, Authentication",
        "Symmetric Encryption, Asymmetric Encryption, Hashing",
        "Public, Private, Secret",
        "AES, RSA, SHA"
      ],
      "correct_answer": "Symmetric Encryption, Asymmetric Encryption, Hashing",
      "explanation": "The three fundamental cryptographic function categories are: (1) SYMMETRIC ENCRYPTION - same key encrypts and decrypts (AES), fast, for bulk data; (2) ASYMMETRIC ENCRYPTION - public/private key pairs (RSA), slow, for key exchange and signatures; (3) HASHING - one-way functions (SHA-256), for integrity and password storage. AES/RSA/SHA are specific algorithms within these categories. Encryption/decryption are operations, not categories.",
      "question_id": "8eb42919-f7c7-4657-beab-17b12d21e051",
      "difficulty": 1
    },
    {
      "question": "Why is bcrypt recommended for password storage instead of SHA-256?",
      "type": "multiple_choice",
      "options": [
        "bcrypt produces longer hashes",
        "bcrypt is intentionally slow and computationally expensive, making brute force attacks impractical, and includes automatic salting",
        "bcrypt is newer than SHA-256",
        "bcrypt can be reversed to recover the password"
      ],
      "correct_answer": "bcrypt is intentionally slow and computationally expensive, making brute force attacks impractical, and includes automatic salting",
      "explanation": "bcrypt is designed specifically for password hashing with: (1) SLOW BY DESIGN - takes ~100ms vs SHA-256's microseconds, making brute force attacks 100,000x slower; (2) CONFIGURABLE WORK FACTOR - can increase iterations as hardware improves; (3) AUTOMATIC SALTING - includes unique salt per password, preventing rainbow tables. SHA-256 is fast (great for integrity, terrible for passwords). bcrypt CANNOT be reversed (still one-way). Hash length is irrelevant to security here.",
      "question_id": "b4d97418-ed78-4268-ab10-d136b0e91533",
      "difficulty": 1
    },
    {
      "question": "How does hybrid encryption work in TLS/SSL?",
      "type": "multiple_choice",
      "options": [
        "All data encrypted with RSA",
        "All data encrypted with AES",
        "RSA encrypts the AES session key (key exchange), then AES encrypts all data (bulk encryption)",
        "Both RSA and AES encrypt every packet for redundancy"
      ],
      "correct_answer": "RSA encrypts the AES session key (key exchange), then AES encrypts all data (bulk encryption)",
      "explanation": "TLS uses hybrid encryption combining both: (1) RSA (or Diffie-Hellman) performs KEY EXCHANGE - client generates random AES key, encrypts it with server's public RSA key, sends to server; (2) Both parties now have shared AES symmetric key; (3) AES encrypts ALL data (fast, efficient bulk encryption). This gets security benefits of asymmetric crypto (no pre-shared secret) with speed of symmetric crypto. Not redundancy - each has specific role.",
      "question_id": "7460ae30-4b1b-460b-9159-9d4544cee949",
      "difficulty": 1
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "minimum_effective_dose",
    "teach_like_im_10",
    "memory_hooks",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ]
}