{
  "lesson_id": "b2c3d4e5-f6a7-4b1c-2d3e-4f5a6b7c8d9e",
  "domain": "fundamentals",
  "title": "Common Vulnerabilities and OWASP Top 10",
  "difficulty": 1,
  "order_index": 6,
  "prerequisites": [],
  "concepts": [
    "OWASP Top 10",
    "Injection Attacks",
    "Broken Authentication",
    "Sensitive Data Exposure",
    "XML External Entities",
    "Broken Access Control",
    "Security Misconfiguration",
    "Cross-Site Scripting",
    "Insecure Deserialization",
    "Using Components with Known Vulnerabilities"
  ],
  "content_blocks": [
    {
      "block_id": "1a2b3c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d",
      "type": "mindset_coach",
      "content": {
        "text": "Most cyberattacks don't use sophisticated zero-day exploits or nation-state malware. They exploit the same common vulnerabilities that have existed for decades: SQL injection, broken authentication, misconfigured systems. The OWASP Top 10 represents the most critical web application security risks - and they're responsible for the majority of breaches.\n\nHere's the truth that changes everything: If you master these 10 vulnerability classes, you can prevent or detect 80%+ of real-world attacks. Not theoretical attacks. Not advanced persistent threats. The attacks actually happening every day against every organization.\n\nMany people think security requires advanced knowledge of cryptography, assembly language, and kernel exploitation. Reality: Most attackers succeed with basic techniques against fundamental vulnerabilities. The Equifax breach (147 million records stolen)? Unpatched Apache Struts (known vulnerability, CVE published months before). Capital One breach (100 million records stolen)? Server-side request forgery (SSRF), misconfigured firewall. Target breach (40 million credit cards)? Vendor credentials, network segmentation failure.\n\nThis lesson isn't about exotic attacks. It's about the vulnerabilities that actually matter in the real world. Master these and you'll:\n- **As a defender**: Prevent the majority of attacks, prioritize remediation efforts correctly\n- **As a developer**: Write secure code from the start, avoid introducing common vulnerabilities\n- **As a pentester**: Find vulnerabilities in every web application you test\n- **As an analyst**: Recognize attack patterns, investigate incidents effectively\n\nThe OWASP Top 10 is your security checklist. It's the foundation. Don't skip past it searching for advanced topics - these fundamentals are what actually protect (or compromise) systems in practice.\n\nLet's master the vulnerabilities that matter most."
      },
      "simplified_explanation": "OWASP Top 10 = The 10 most critical web security risks. Includes SQL injection, broken auth, XSS, misconfigurations, etc. Most breaches exploit these common vulnerabilities, not exotic zero-days. Master the Top 10 and you prevent 80%+ of attacks.",
      "memory_aids": [
        "OWASP = Open Web Application Security Project (nonprofit security organization)",
        "Top 10 updated every 3-4 years based on real-world data from thousands of organizations",
        "SQL injection = Attacker injects malicious SQL into user input",
        "XSS = Cross-Site Scripting = Inject malicious JavaScript into web pages"
      ],
      "teach_like_im_10": "Imagine a website is like a restaurant. OWASP Top 10 is a list of the most common ways bad people sneak in or cause problems: picking the lock (broken auth), poisoning the food (injection), leaving doors unlocked (misconfiguration), pretending to be staff (broken access control). If the restaurant fixes these 10 issues, most troublemakers can't get in."
    },
    {
      "block_id": "2b3c4d5e-6f7a-8b9c-0d1e-2f3a4b5c6d7e",
      "type": "explanation",
      "content": {
        "text": "## What is OWASP Top 10?\n\n**OWASP (Open Web Application Security Project)** is a nonprofit organization focused on improving software security. Their most famous project is the **OWASP Top 10** - a regularly updated list of the most critical web application security risks.\n\n**Key Facts**:\n- Updated every 3-4 years based on data from security firms, bug bounties, organizations\n- Latest version: **OWASP Top 10 - 2021**\n- Based on analysis of 500,000+ vulnerabilities from real applications\n- Industry standard for web security baseline\n\n**Why It Matters**:\n- Provides focus (can't fix everything, fix these first)\n- Common language for security teams, developers, executives\n- Compliance frameworks reference OWASP Top 10 (PCI DSS, etc.)\n- Practical and actionable (not theoretical)\n\n## OWASP Top 10 (2021)\n\n### A01:2021 - Broken Access Control\n\n**What It Is**: Users can access resources or perform actions they shouldn't be authorized for.\n\n**Examples**:\n- **Horizontal Privilege Escalation**: User A accesses User B's data\n- URL: `https://bank.com/account?id=12345` (your account)\n- Attacker changes to: `https://bank.com/account?id=12346` (someone else's account)\n- If no authorization check, attacker views other user's account\n\n- **Vertical Privilege Escalation**: Regular user accesses admin functions\n- Regular user navigates to: `https://app.com/admin/users`\n- If no role check, regular user can access admin panel\n\n- **Insecure Direct Object References (IDOR)**: Direct access to objects via predictable IDs\n- `https://docs.com/file?id=100` downloads file 100\n- Attacker tries `id=1, id=2, id=3...` enumerating all files\n\n**Real-World Impact**:\n- **USPS Informed Delivery (2018)**: Any logged-in user could view anyone else's mail scans by changing account ID in request\n- **Facebook (2019)**: Instagram bug allowed access to any user's private media by manipulating API requests\n\n**Prevention**:\n```python\n# BAD: No authorization check\n@app.route('/account/<account_id>')\ndef view_account(account_id):\naccount = get_account(account_id)\nreturn render_template('account.html', account=account)\n\n# GOOD: Verify user owns the account\n@app.route('/account/<account_id>')\ndef view_account(account_id):\naccount = get_account(account_id)\nif account.owner_id != current_user.id:\nabort(403)  # Forbidden\nreturn render_template('account.html', account=account)\n```\n\n**Best Practices**:\n- Deny by default (require explicit authorization)\n- Check authorization for EVERY request (not just once)\n- Use indirect references (map user-facing ID to actual object)\n- Log access control failures (detect enumeration attacks)\n\n### A02:2021 - Cryptographic Failures\n\n**What It Is**: Failures protecting sensitive data in transit and at rest (formerly \"Sensitive Data Exposure\").\n\n**Examples**:\n- **Unencrypted Transmission**: Sending passwords over HTTP (not HTTPS)\n- **Weak Encryption**: Using outdated algorithms (DES, MD5, SHA1)\n- **Hardcoded Keys**: Encryption keys stored in source code\n- **No Encryption at Rest**: Database stores credit cards in plaintext\n\n**Real-World Impact**:\n- **Yahoo (2013-2014)**: 3 billion accounts compromised, passwords hashed with weak MD5 (easily crackable)\n- **Heartbleed (2014)**: OpenSSL bug leaked sensitive data from server memory (credentials, private keys)\n\n**Prevention**:\n```python\n# BAD: Storing passwords in plaintext\nuser.password = request.form['password']\n\n# BAD: Weak hashing\nuser.password = hashlib.md5(request.form['password'].encode()).hexdigest()\n\n# GOOD: Strong password hashing\nfrom werkzeug.security import generate_password_hash\nuser.password = generate_password_hash(request.form['password'], method='pbkdf2:sha256', salt_length=16)\n```\n\n**Best Practices**:\n- Always use TLS/HTTPS for transmission (never send sensitive data over HTTP)\n- Use strong, modern algorithms (AES-256, SHA-256, bcrypt/scrypt/Argon2 for passwords)\n- Never store passwords in plaintext or reversible encryption\n- Don't invent your own crypto (use established libraries)\n- Rotate keys regularly\n- Separate keys from code (use key management systems)\n\n**Encryption Checklist**:\n- **In Transit**: TLS 1.2+, strong cipher suites, valid certificates\n- **At Rest**: AES-256 for data, bcrypt/scrypt/Argon2 for passwords, encrypted backups\n- **Key Management**: Separate from app, rotated regularly, access controlled\n\n### A03:2021 - Injection\n\n**What It Is**: Untrusted data sent to interpreter as part of command/query, tricking it into executing unintended commands.\n\n**Types of Injection**:\n\n**1. SQL Injection (Most Common)**\n\n**Vulnerable Code**:\n```python\n# User input: username = \"admin'--\", password = \"anything\"\nquery = f\"SELECT * FROM users WHERE username='{username}' AND password='{password}'\"\n# Resulting query: SELECT * FROM users WHERE username='admin'--' AND password='anything'\n# The -- comments out the password check, attacker logs in as admin!\n```\n\n**Attack Examples**:\n```sql\n-- Authentication bypass\nusername: admin'--\nQuery becomes: SELECT * FROM users WHERE username='admin'-- AND password='...'\n(Password check commented out)\n\n-- Extract data\nusername: ' OR 1=1--\nQuery becomes: SELECT * FROM users WHERE username='' OR 1=1-- AND password='...'\n(Returns all users because 1=1 is always true)\n\n-- Data exfiltration via UNION\nusername: ' UNION SELECT null, username, password FROM users--\nQuery becomes: SELECT id, name FROM products WHERE name='' UNION SELECT null, username, password FROM users--\n(Extracts all usernames and passwords)\n\n-- Database destruction\nusername: '; DROP TABLE users--\nQuery becomes: SELECT * FROM users WHERE username=''; DROP TABLE users--' AND password='...'\n(Deletes entire users table)\n```\n\n**Prevention - Parameterized Queries**:\n```python\n# GOOD: Parameterized query (treats input as data, not code)\ncursor.execute(\n\"SELECT * FROM users WHERE username=? AND password=?\",\n(username, password)\n)\n```\n\n**2. OS Command Injection**\n\n**Vulnerable Code**:\n```python\n# User input: filename = \"file.txt; rm -rf /\"\nimport os\nos.system(f\"cat {filename}\")  # Executes: cat file.txt; rm -rf /\n```\n\n**Prevention**:\n```python\n# GOOD: Use safe APIs, don't invoke shell\nimport subprocess\nsubprocess.run(['cat', filename], shell=False)  # Filename treated as literal argument\n\n# BETTER: Don't execute OS commands based on user input at all\n```\n\n**3. LDAP Injection**\n\n**Vulnerable Code**:\n```python\n# User input: username = \"*)(uid=*\"\nldap_filter = f\"(cn={username})\"\n# Resulting filter: (cn=*)(uid=*)\n# Returns all users instead of specific user\n```\n\n**4. NoSQL Injection (MongoDB, etc.)**\n\n**Vulnerable Code**:\n```javascript\n// User input: {\"username\": {\"$ne\": null}, \"password\": {\"$ne\": null}}\ndb.users.find({username: req.body.username, password: req.body.password})\n// MongoDB $ne (not equal) operator bypasses authentication\n```\n\n**Real-World Impact**:\n- **Heartland Payment Systems (2008)**: SQL injection stole 130 million credit cards\n- **Sony Pictures (2011)**: SQL injection exposed 1 million accounts\n\n**Prevention Principles**:\n1. **Use Parameterized Queries/Prepared Statements** (primary defense)\n2. **Input Validation**: Whitelist allowed characters\n3. **Escape Special Characters**: If parameterized queries not possible\n4. **Least Privilege**: Database user has minimal permissions\n5. **WAF (Web Application Firewall)**: Detect and block injection attempts\n\n### A04:2021 - Insecure Design\n\n**What It Is**: Missing or ineffective security controls in design phase (new category in 2021).\n\n**Examples**:\n- **No Rate Limiting**: Password reset allows unlimited attempts (brute force)\n- **No CAPTCHA**: Automated bot abuse\n- **Insufficient Workflow**: Online store processes order before payment verified\n- **Trust Boundaries**: Trusting client-side input without server validation\n\n**Example Scenario**:\n```\nVulnerable Design:\n1. User requests password reset\n2. System emails reset link (no rate limit)\n3. Attacker scripts 1000 reset requests per minute\n4. User's inbox flooded, attackers can hijack account\n\nSecure Design:\n1. User requests password reset\n2. Rate limit: Max 3 requests per hour\n3. CAPTCHA required after first request\n4. Reset link expires in 15 minutes\n5. Email notification if suspicious activity\n```\n\n**Prevention**:\n- **Threat Modeling**: Identify threats during design (before coding)\n- **Security Requirements**: Define security controls alongside functional requirements\n- **Secure Design Patterns**: Use established patterns (defense in depth, least privilege)\n- **User Story Abuse Cases**: \"As an attacker, I want to...\"\n\n### A05:2021 - Security Misconfiguration\n\n**What It Is**: Insecure default configurations, incomplete setups, open cloud storage, verbose error messages, missing patches.\n\n**Examples**:\n\n**1. Default Credentials**\n```\nAdmin panel: admin/admin (default password never changed)\nDatabase: root/root\nRouter: admin/password\n```\n\n**2. Directory Listing Enabled**\n```\nhttp://example.com/uploads/\n[Shows all uploaded files, including sensitive documents]\n```\n\n**3. Verbose Error Messages**\n```\nError: mysql_query() failed: You have an error in your SQL syntax near 'SELECT * FROM users WHERE id=1' AND password='...' at line 1\n[Reveals database structure and query, aids SQL injection]\n\nBetter: \"An error occurred. Please try again later.\" [Log details server-side]\n```\n\n**4. Unnecessary Features Enabled**\n```\n- Debug mode enabled in production\n- Unused ports open (FTP, Telnet, SMB)\n- Sample applications not removed\n- Default accounts not disabled\n```\n\n**5. Missing Security Headers**\n```\nMissing:\n- X-Frame-Options (allows clickjacking)\n- X-Content-Type-Options (allows MIME sniffing attacks)\n- Content-Security-Policy (allows XSS)\n- Strict-Transport-Security (allows downgrade attacks)\n```\n\n**Real-World Impact**:\n- **Capital One (2019)**: Misconfigured web application firewall allowed SSRF, 100M records stolen\n- **Elasticsearch/MongoDB Ransomware (2017+)**: Thousands of databases publicly exposed with no authentication\n\n**Prevention**:\n- **Hardening Guides**: Follow CIS benchmarks, vendor hardening guides\n- **Minimal Install**: Only install necessary components\n- **Change Defaults**: Change all default passwords, remove default accounts\n- **Disable Unnecessary Features**: Remove sample apps, close unused ports\n- **Security Headers**: Implement all relevant security headers\n- **Error Handling**: Generic errors to users, detailed logs server-side\n- **Patching**: Regular updates, vulnerability scanning\n- **Configuration Management**: Automated, consistent configurations\n\n### A06:2021 - Vulnerable and Outdated Components\n\n**What It Is**: Using libraries, frameworks, or dependencies with known vulnerabilities.\n\n**Examples**:\n- Old WordPress plugins with known exploits\n- Unpatched Apache Struts (Equifax breach)\n- Vulnerable JavaScript libraries (jQuery, etc.)\n- Outdated OpenSSL (Heartbleed)\n\n**The Problem**:\n```\nModern application dependencies:\nYour App\n├── Framework (e.g., Django)\n│    ├── Library A (has 10 dependencies)\n│    └── Library B (has 5 dependencies)\n├── Library C (has 20 dependencies)\n└── Library D (has 15 dependencies)\n\nTotal: 50+ dependencies (many you don't even know about)\nEach dependency can have vulnerabilities\n```\n\n**Real-World Impact**:\n- **Equifax (2017)**: Unpatched Apache Struts vulnerability (CVE-2017-5638), patch available 2 months before breach, 147M records stolen\n- **British Airways (2018)**: Vulnerable JavaScript library, payment data stolen from 380,000 customers\n\n**Prevention**:\n```bash\n# Inventory components\nnpm audit  # Node.js\npip-audit  # Python\nbundle audit  # Ruby\n\n# Remove unused dependencies\nnpm prune\n\n# Update components\nnpm update\npip install --upgrade package\n\n# Monitor for vulnerabilities\n# Tools: Snyk, Dependabot, WhiteSource\n```\n\n**Best Practices**:\n- **Inventory**: Know what components you're using (software composition analysis)\n- **Monitor**: Subscribe to security advisories for your components\n- **Update Regularly**: Patch promptly (automated updates for low-risk)\n- **Remove Unused**: Delete unused dependencies\n- **Trusted Sources**: Only use components from trusted sources\n- **Vulnerability Scanning**: Automated scanning in CI/CD pipeline\n\n### A07:2021 - Identification and Authentication Failures\n\n**What It Is**: Broken authentication mechanisms allowing attackers to compromise accounts (formerly \"Broken Authentication\").\n\n**Examples**:\n\n**1. Weak Password Requirements**\n```\nAllows: password123, 12345678, qwerty\nNo complexity requirements, no length requirements\n```\n\n**2. Credential Stuffing**\n```\nAttacker has list of leaked credentials from other breaches:\nuser@email.com:password123\nTries same credentials on your site\n(Many users reuse passwords across sites)\n```\n\n**3. No Brute Force Protection**\n```\nUnlimited login attempts allowed\nAttacker tries common passwords:\nadmin:password\nadmin:admin\nadmin:12345\n... (millions of attempts)\n```\n\n**4. Weak Session Management**\n```\nSession ID in URL: http://example.com/page?sessionid=123456\n- Appears in browser history, logs, Referer header\n- Easily stolen via social engineering\n\nSession ID doesn't expire:\n- Old session still valid after logout\n- Session hijacking remains possible indefinitely\n```\n\n**5. Missing MFA (Multi-Factor Authentication)**\n```\nSingle factor (password) only\nIf password compromised, account fully compromised\n```\n\n**Real-World Impact**:\n- **Reddit (2018)**: SMS-based 2FA bypassed via SMS interception, employee accounts compromised\n- **Twitter (2020)**: Social engineering bypassed authentication, high-profile accounts hacked\n\n**Prevention**:\n\n**Strong Passwords**:\n```python\n# Minimum 8 characters (12+ recommended)\n# Require mix of uppercase, lowercase, numbers, symbols\n# Check against common passwords list\n# Implement password strength meter\n\nfrom password_strength import PasswordPolicy\npolicy = PasswordPolicy.from_names(\nlength=12,\nuppercase=1,\nnumbers=1,\nspecial=1,\n)\nerrors = policy.test('password123')  # Returns violations\n```\n\n**Multi-Factor Authentication**:\n```\nSomething you know: Password\nSomething you have: Phone app (TOTP), hardware token (YubiKey)\nSomething you are: Fingerprint, face recognition\n\nIdeal: Password + TOTP (Google Authenticator, Authy)\n```\n\n**Rate Limiting**:\n```python\nfrom flask_limiter import Limiter\n\n@limiter.limit(\"5 per minute\")  # Max 5 login attempts per minute\n@app.route('/login', methods=['POST'])\ndef login():\n# Login logic\n```\n\n**Secure Session Management**:\n```python\n# Session ID in HTTP-only cookie (not accessible to JavaScript)\nresponse.set_cookie('session_id', value, httponly=True, secure=True, samesite='Strict')\n\n# Regenerate session ID after login (prevent session fixation)\nsession.regenerate()\n\n# Set session timeout\nsession.set_expiry(1800)  # 30 minutes\n\n# Logout: Invalidate session server-side\nsession.delete()\n```bash\n\n### A08:2021 - Software and Data Integrity Failures\n\n**What It Is**: Code and infrastructure that don't protect against integrity violations (new category in 2021).\n\n**Examples**:\n\n**1. Insecure CI/CD Pipeline**\n```\nAttacker compromises build server\nInjects backdoor into application during build\nMalicious code deployed to production\n(SolarWinds supply chain attack)\n```\n\n**2. Auto-Update Without Verification**\n```\nApplication downloads updates over HTTP (not HTTPS)\nNo signature verification\nAttacker performs MITM, serves malicious update\n```\n\n**3. Insecure Deserialization**\n```python\n# User provides serialized object via cookie or parameter\nimport pickle\nuser_data = pickle.loads(base64.b64decode(request.cookies['user']))\n# Attacker provides malicious serialized object\n# Upon deserialization, executes arbitrary code (RCE)\n```\n\n**Prevention**:\n\n**Digital Signatures**:\n```bash\n# Sign software updates\ngpg --sign --armor software-update.zip\n\n# Verify signature before installing\ngpg --verify software-update.zip.asc software-update.zip\n```\n\n**Secure CI/CD**:\n- Separate build and deployment environments\n- Code signing for all artifacts\n- Immutable build logs\n- Access control on CI/CD systems\n- Security scanning in pipeline\n\n**Safe Deserialization**:\n```python\n# DON'T use pickle for untrusted data\n# DO use safe formats (JSON)\nimport json\nuser_data = json.loads(request.cookies['user'])  # Safer (data only, no code execution)\n\n# If must deserialize, validate strictly\n```bash\n\n### A09:2021 - Security Logging and Monitoring Failures\n\n**What It Is**: Insufficient logging and monitoring allows breaches to go undetected.\n\n**Statistics**:\n- Average time to detect breach: **207 days** (IBM 2021)\n- Many breaches discovered by third parties, not victim organization\n\n**What to Log**:\n```\nAuthentication:\n- Login successes/failures\n- Password changes\n- Account lockouts\n- MFA bypass attempts\n\nAuthorization:\n- Access denied events\n- Privilege changes\n- Admin actions\n\nInput Validation:\n- SQL injection attempts\n- XSS attempts\n- Path traversal attempts\n\nApplication Errors:\n- Exceptions\n- Database errors\n- Failed operations\n\nFor each event:\n- Timestamp\n- User (who)\n- Action (what)\n- Resource (where)\n- Outcome (success/failure)\n- Source IP\n- User agent\n```\n\n**What NOT to Log**:\n```\n❌ Passwords\n❌ Session tokens\n❌ Credit card numbers\n❌ Encryption keys\n❌ Personally identifiable information (PII) when not necessary\n```\n\n**Monitoring and Alerting**:\n```\nAlert on:\n- Multiple failed logins (brute force)\n- Login from unusual location/device\n- Privilege escalation\n- Access to sensitive resources\n- High volume of requests (DoS)\n- SQL injection attempts\n- Admin actions outside business hours\n\nTools: Splunk, ELK Stack, SIEM (QRadar, ArcSight)\n```\n\n**Prevention**:\n```python\nimport logging\n\n# Log authentication attempts\nlogging.info(f\"Login attempt: user={username}, ip={request.remote_addr}, success={success}\")\n\n# Log authorization failures\nif not authorized:\nlogging.warning(f\"Access denied: user={current_user.id}, resource={resource_id}, ip={request.remote_addr}\")\n\n# Log suspicious activity\nif sql_injection_detected:\nlogging.critical(f\"SQL injection attempt: user={current_user.id}, input={user_input}, ip={request.remote_addr}\")\n# Send immediate alert to security team\n```bash\n\n### A10:2021 - Server-Side Request Forgery (SSRF)\n\n**What It Is**: Application fetches remote resource without validating URL, attacker provides URL pointing to internal resources.\n\n**Example Vulnerable Code**:\n```python\n# User provides URL to fetch image from\nurl = request.form['image_url']\nresponse = requests.get(url)  # Fetch from user-provided URL\n# Display image\n```\n\n**Attack Scenarios**:\n\n**1. Access Internal Resources**\n```\nAttacker provides URL: http://localhost:8080/admin\nServer fetches from localhost (internal admin panel)\nAttacker sees response, accesses internal system\n```\n\n**2. Cloud Metadata Exposure**\n```\nAttacker provides URL: http://169.254.169.254/latest/meta-data/iam/security-credentials/\n(AWS metadata endpoint)\nServer fetches AWS credentials\nAttacker obtains cloud access keys\n```\n\n**3. Port Scanning**\n```\nAttacker provides URLs:\nhttp://internal-server:22 (SSH)\nhttp://internal-server:3306 (MySQL)\nhttp://internal-server:6379 (Redis)\nBased on responses, attacker maps internal network\n```\n\n**Real-World Impact**:\n- **Capital One (2019)**: SSRF against AWS metadata endpoint, 100M records stolen, $80M fine\n\n**Prevention**:\n\n**Input Validation**:\n```python\nimport ipaddress\nfrom urllib.parse import urlparse\n\ndef is_safe_url(url):\nparsed = urlparse(url)\n\n# Only allow HTTP/HTTPS\nif parsed.scheme not in ['http', 'https']:\nreturn False\n\n# Resolve hostname to IP\ntry:\nip = ipaddress.ip_address(socket.gethostbyname(parsed.hostname))\nexcept:\nreturn False\n\n# Block private IPs, localhost, link-local\nif ip.is_private or ip.is_loopback or ip.is_link_local:\nreturn False\n\n# Block cloud metadata endpoints\nif str(ip).startswith('169.254.'):\nreturn False\n\nreturn True\n\nurl = request.form['image_url']\nif not is_safe_url(url):\nabort(400, \"Invalid URL\")\n\nresponse = requests.get(url, timeout=5)\n```\n\n**Additional Defenses**:\n- Whitelist allowed domains (most secure)\n- Network segmentation (web servers can't reach internal systems)\n- Disable unnecessary URL schemas (file://, gopher://, etc.)\n- Use separate server for outbound requests\n\n## OWASP Top 10 Summary Table\n\n| Rank | Vulnerability | Primary Impact | Prevention |\n|------|---------------|----------------|------------|\n| A01 | Broken Access Control | Unauthorized data access | Authorization checks on every request |\n| A02 | Cryptographic Failures | Data theft | TLS, strong encryption, no plaintext passwords |\n| A03 | Injection | Data theft, server compromise | Parameterized queries, input validation |\n| A04 | Insecure Design | Various depending on flaw | Threat modeling, secure design patterns |\n| A05 | Security Misconfiguration | Varies (data theft, compromise) | Hardening, patch management, remove defaults |\n| A06 | Vulnerable Components | Varies based on vulnerability | Inventory, monitor, patch dependencies |\n| A07 | Authentication Failures | Account takeover | Strong passwords, MFA, rate limiting |\n| A08 | Integrity Failures | Supply chain compromise | Digital signatures, secure CI/CD |\n| A09 | Logging/Monitoring Failures | Late detection, extended breach | Comprehensive logging, SIEM, alerts |\n| A10 | Server-Side Request Forgery | Internal access, data theft | URL validation, whitelist, network segmentation |\n\n## Key Takeaways\n\n1. **OWASP Top 10 represents 80%+ of real-world attacks** - Master these, prevent most breaches\n2. **Broken Access Control is #1** - Check authorization on EVERY request\n3. **Injection still prevalent** - Use parameterized queries ALWAYS\n4. **Authentication is critical** - Implement MFA, strong passwords, rate limiting\n5. **Misconfiguration is easy** - Change defaults, remove unnecessary features, harden systems\n6. **Dependencies are risky** - Inventory, monitor, patch regularly\n7. **Design matters** - Threat model before coding, secure by design not bolted on\n8. **Logging is essential** - Can't detect what you don't log\n9. **Cryptography is hard** - Use established libraries, TLS everywhere\n10. **SSRF is dangerous** - Validate URLs, whitelist domains, segment networks\n\nThe Top 10 isn't exhaustive (many other vulnerabilities exist), but it's the essential foundation. Focus here first."
      },
      "ascii_art": "SQL INJECTION ATTACK FLOW\n\n1. Normal Query:\nUser inputs: username = \"alice\", password = \"secret123\"\nQuery: SELECT * FROM users WHERE username='alice' AND password='secret123'\nResult: Returns alice's record (correct)\n\n2. SQL Injection Attack:\nUser inputs: username = \"admin'--\", password = \"anything\"\nQuery: SELECT * FROM users WHERE username='admin'--' AND password='anything'\n                                              ^\n                                              Comment marker (rest ignored)\nResult: Returns admin's record WITHOUT checking password! (bypassed auth)\n\n3. Data Extraction:\nUser inputs: username = \"' UNION SELECT null,username,password FROM users--\"\nQuery: SELECT id,name FROM products WHERE name='' UNION SELECT null,username,password FROM users--'\nResult: Returns all usernames and passwords from users table!\n\nSSRF ATTACK FLOW\n\n[Internet]                [DMZ]              [Internal Network]\n   │                        │                         │\n   │  1. Fetch this URL!    │                         │\n   │  http://169.254.       │                         │\n   │  169.254/metadata      │                         │\nAttacker ──────────────→ Web App                     │\n                            │                         │\n                            │  2. Server makes        │\n                            │     internal request    │\n                            ├────────────────────→ AWS Metadata\n                            │                      (169.254.169.254)\n                            │                         │\n                            │  3. Returns credentials │\n                            │     access keys, etc.   │\n                            │←────────────────────────┤\n                            │                         │\n                            │  4. Sends to attacker   │\nAttacker ←──────────────────┤                         │\n   │                        │                         │\n   │  5. Uses stolen creds  │                         │\n   │     to access cloud    │                         │\n   └────────────────────────┴─────────→ Cloud Resources\n\nBroken Access Control:\n\nHorizontal Escalation:        Vertical Escalation:\n┌─────────┐  ┌─────────┐     ┌─────────┐\n│ User A  │  │ User B  │     │  Admin  │\n│ (ID:10) │  │ (ID:11) │     │ (ID:99) │\n└────┬────┘  └─────────┘     └─────────┘\n     │                             ▲\n     │ 1. Normal: /account?id=10   │\n     │    (sees own data)           │\n     │                              │\n     │ 2. Attack: /account?id=11    │\n     └────→ Sees User B's data!     │\n                                    │\n     3. Attack: /admin/users        │\n     └──────────────────────────────┘\n        Regular user accesses admin page!",
      "examples": [
        {
          "scenario": "Equifax Breach (2017) - Vulnerable Component",
          "explanation": "Attackers exploited CVE-2017-5638, a remote code execution vulnerability in Apache Struts (Java web framework). Patch had been available for 2 months but Equifax hadn't applied it. Attackers: (1) Scanned internet for vulnerable Struts servers, (2) Found Equifax server, (3) Exploited to gain initial access, (4) Moved laterally through network (weeks undetected), (5) Exfiltrated 147 million records including SSNs. Root causes: Vulnerable component (A06), security misconfiguration (unpatched), logging/monitoring failure (took months to detect). Cost: $1.4 billion, CEO resigned, massive reputation damage. Prevention: Patch management, vulnerability scanning, network segmentation, monitoring."
        },
        {
          "scenario": "Capital One Breach (2019) - SSRF + Misconfiguration",
          "explanation": "Attacker exploited SSRF vulnerability in web application firewall. Application fetched user-provided URLs without validation. Attacker provided: http://169.254.169.254/latest/meta-data/iam/security-credentials/ (AWS metadata endpoint). Server fetched and returned IAM credentials. Attacker used stolen credentials to access S3 buckets containing 100M customer records. Root causes: SSRF vulnerability (A10), security misconfiguration (overly permissive WAF, S3 bucket permissions). Impact: $80M fine, class action lawsuit, reputation damage. Prevention: URL validation (whitelist allowed domains, block internal IPs), principle of least privilege (minimal S3 permissions), WAF hardening."
        },
        {
          "scenario": "British Airways Breach (2018) - Vulnerable JavaScript Library",
          "explanation": "Attackers compromised third-party JavaScript library used by British Airways website. Modified library to steal payment card data (Magecart attack). When users made bookings, malicious JavaScript sent card details to attacker server. Affected 380,000 customers over 15 days before detection. Root causes: Vulnerable component (A06), integrity failure (no subresource integrity checking), monitoring failure (took 15 days to detect). Impact: £20M fine (GDPR), customer trust damaged. Prevention: Subresource Integrity (SRI) tags verify JavaScript hasn't been tampered with, Content Security Policy restricts where scripts can send data, monitoring for unusual outbound connections."
        }
      ]
    },
    {
      "type": "video",
      "content": {
        "title": "Video: Common Vulnerabilities and OWASP Top 10 Overview",
        "url": "https://www.youtube.com/embed/j5zB1jn_4tc",
        "description": "Watch this video for a visual introduction to the concepts covered in this lesson."
      }
    },
    {
      "block_id": "3c4d5e6f-7a8b-9c0d-1e2f-3a4b5c6d7e8f",
      "type": "quiz",
      "content": {
        "text": "Test your understanding of OWASP Top 10",
        "questions": [
          {
            "question": "Which vulnerability allows an attacker to view another user's account by changing the account ID in the URL?",
            "options": [
              "SQL Injection",
              "Broken Access Control (IDOR)",
              "Cross-Site Scripting (XSS)",
              "SSRF"
            ],
            "correct_answer": 1,
            "explanation": "This is Broken Access Control, specifically Insecure Direct Object References (IDOR). The application exposes internal object IDs (like account IDs) and doesn't verify the user is authorized to access that object. Attacker changes /account?id=100 to /account?id=101 and views someone else's account. Prevention: Check authorization for every request, use indirect references."
          },
          {
            "question": "What is the primary defense against SQL injection?",
            "options": [
              "Input validation (block special characters)",
              "Parameterized queries / Prepared statements",
              "Web Application Firewall (WAF)",
              "Encryption"
            ],
            "correct_answer": 1,
            "explanation": "Parameterized queries (prepared statements) are the primary defense. They separate SQL code from data, treating user input as data only (never as code). Example: cursor.execute('SELECT * FROM users WHERE username=?', (username,)). Input validation helps but can be bypassed. WAF is defense in depth (additional layer). Encryption doesn't prevent injection."
          },
          {
            "question": "You discover your application uses a 5-year-old version of a popular JavaScript library with 10 known critical vulnerabilities. Which OWASP category does this represent?",
            "options": [
              "Security Misconfiguration",
              "Vulnerable and Outdated Components",
              "Cryptographic Failures",
              "Insecure Design"
            ],
            "correct_answer": 1,
            "explanation": "This is A06: Vulnerable and Outdated Components. Using dependencies with known vulnerabilities is extremely common and dangerous. The Equifax breach (147M records) was caused by an unpatched component. Prevention: Inventory dependencies, monitor for vulnerabilities (npm audit, Snyk, Dependabot), update regularly, remove unused dependencies."
          },
          {
            "question": "An application allows users to provide a URL to fetch and display an image. An attacker provides: http://169.254.169.254/latest/meta-data/. What attack is this?",
            "options": [
              "SQL Injection",
              "XSS (Cross-Site Scripting)",
              "SSRF (Server-Side Request Forgery)",
              "CSRF (Cross-Site Request Forgery)"
            ],
            "correct_answer": 2,
            "explanation": "This is SSRF (A10). The attacker tricks the server into making requests to internal resources (in this case, AWS metadata endpoint at 169.254.169.254 which contains credentials). Server has access to internal resources that attacker doesn't, so attacker uses server as a proxy. Capital One breach used this exact technique. Prevention: Validate URLs, whitelist allowed domains, block internal IPs."
          },
          {
            "question": "What is the purpose of implementing logging and monitoring (A09)?",
            "options": [
              "Prevent all attacks from succeeding",
              "Encrypt sensitive data",
              "Detect breaches and suspicious activity quickly to minimize damage",
              "Block SQL injection attempts"
            ],
            "correct_answer": 2,
            "explanation": "Logging and monitoring enable detection, not prevention. Average breach detection time is 207 days - logging reduces this. Log authentication attempts, authorization failures, errors, suspicious activity. Monitor logs with SIEM, alert on anomalies. Faster detection = less damage. While WAF blocks some attacks, logging is about detection and response, not prevention. Important: Don't log passwords, session tokens, or PII."
          }
        ]
      }
    },
    {
      "block_id": "4d5e6f7a-8b9c-0d1e-2f3a-4b5c6d7e8f9a",
      "type": "reflection",
      "content": {
        "text": "## Reflect on Vulnerability Knowledge\n\n**Question 1**: You're reviewing code for a new web application feature. The feature allows users to download reports by providing a report ID:\n```python\n@app.route('/download/<report_id>')\ndef download_report(report_id):\nfile_path = f'/var/reports/{report_id}.pdf'\nreturn send_file(file_path)\n```\nWhat vulnerabilities exist? How would you fix them?\n\n**Question 2**: Your security scanner reports these findings:\n- jQuery version 1.8 (CVE-2020-11022, CVE-2020-11023)\n- Apache Struts 2.3.12 (CVE-2017-5638 - RCE)\n- TLS 1.0 enabled\n- Directory listing enabled on /uploads/\n- Default admin credentials on database (root/root)\n\nPrioritize these findings (most critical to least) and explain your reasoning.\n\n**Question 3**: Analyze this login function:\n```python\ndef login(username, password):\nquery = f\"SELECT * FROM users WHERE username='{username}' AND password='{password}'\"\nresult = db.execute(query)\nif result:\nsession['user_id'] = result['id']\nreturn redirect('/dashboard')\nelse:\nreturn \"Login failed\"\n```\nIdentify MULTIPLE vulnerabilities (hint: there are at least 4 different OWASP Top 10 issues).\n\n**Question 4**: You're implementing a feature to generate PDF reports from user-provided HTML:\n```python\ndef generate_pdf(html_content):\n# Convert user HTML to PDF\npdf = HTML(string=html_content).write_pdf()\nreturn pdf\n```\nWhat security risks exist if html_content comes from user input? What OWASP categories apply?\n\n**Question 5**: Design a security review checklist for a new web application covering all OWASP Top 10 categories. For each category, list 2-3 specific things to check.\n\nExample format:\n- **A01 Broken Access Control**:\n- [ ] Authorization checked on every endpoint?\n- [ ] User can't access other users' data?\n- [ ] Regular users can't access admin functions?\n\nComplete for all 10 categories. This checklist becomes your security assessment framework."
      }
    }
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand the OWASP Top 10 and its importance in web security",
    "Identify and explain each of the 10 vulnerability categories",
    "Recognize vulnerable code patterns for injection, broken access control, and authentication issues",
    "Apply appropriate prevention techniques for each vulnerability class",
    "Analyze real-world breaches and identify which OWASP categories were violated",
    "Prioritize security efforts based on OWASP Top 10 risk ratings",
    "Perform basic security code review using OWASP Top 10 as a framework"
  ],
  "post_assessment": [
    {
      "question": "What does OWASP stand for and what is the OWASP Top 10?",
      "type": "multiple_choice",
      "options": [
        "Online Web Application Security Protocol - Top 10 security tools",
        "Open Web Application Security Project - Top 10 most critical web security risks",
        "Official Web App Security Practices - Top 10 compliance requirements",
        "Operational Web Application Security Procedures - Top 10 best practices"
      ],
      "correct_answer": "Open Web Application Security Project - Top 10 most critical web security risks",
      "explanation": "OWASP (Open Web Application Security Project) is a nonprofit focused on improving software security. The OWASP Top 10 is a regularly-updated list of the 10 most critical web application security risks based on real-world data from thousands of organizations. It's the industry standard baseline for web security, referenced by compliance frameworks and used to prioritize security efforts.",
      "question_id": "3edba7ca-4e0c-49d9-8b82-33dee23402f5",
      "difficulty": 1
    },
    {
      "question": "Why are parameterized queries the primary defense against SQL injection?",
      "type": "multiple_choice",
      "options": [
        "They encrypt the SQL query",
        "They separate SQL code from user data, treating input as data only (never as executable code)",
        "They validate that input doesn't contain SQL keywords",
        "They slow down the query to detect attacks"
      ],
      "correct_answer": "They separate SQL code from user data, treating input as data only (never as executable code)",
      "explanation": "Parameterized queries (prepared statements) send the SQL structure and data separately to the database. The database knows the structure is code and the parameters are data, so user input can never be executed as SQL code. Example: cursor.execute('SELECT * FROM users WHERE id=?', (user_id,)). Even if user_id contains SQL syntax, it's treated as a literal string value, not executable code. This is fundamentally different from input validation (which can be bypassed) or encryption (irrelevant to injection).",
      "question_id": "1bad252f-ea19-46dc-9245-9fe7cef897f5",
      "difficulty": 1
    },
    {
      "question": "Which OWASP vulnerability was responsible for the Equifax breach that exposed 147 million records?",
      "type": "multiple_choice",
      "options": [
        "SQL Injection",
        "Vulnerable and Outdated Components (unpatched Apache Struts)",
        "Broken Authentication",
        "XSS (Cross-Site Scripting)"
      ],
      "correct_answer": "Vulnerable and Outdated Components (unpatched Apache Struts)",
      "explanation": "Equifax was breached via CVE-2017-5638, a remote code execution vulnerability in Apache Struts (Java web framework). The patch had been available for 2 months but wasn't applied. This is A06: Vulnerable and Outdated Components. The breach demonstrates why dependency management, vulnerability scanning, and prompt patching are critical. 147 million records stolen, $1.4 billion cost, CEO resigned - all from failing to patch a known vulnerability.",
      "question_id": "70d437df-c44c-4eec-8bf1-3cc6f3a441b9",
      "difficulty": 1
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "meta_learning",
    "minimum_effective_dose",
    "teach_like_im_10",
    "memory_hooks",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ]
}