{
  "lesson_id": "b9c0d1e2-f3a4-5b6c-7d8e-9f0a1b2c3d4e",
  "domain": "dfir",
  "title": "Rootkit Detection in Memory Forensics",
  "difficulty": 3,
  "order_index": 54,
  "prerequisites": ["a8b9c0d1-e2f3-4a5b-6c7d-8e9f0a1b2c3d"],
  "concepts": [
    "Rootkit fundamentals",
    "User-mode vs kernel-mode rootkits",
    "DKOM (Direct Kernel Object Manipulation)",
    "SSDT hooking",
    "IDT hooking",
    "IRP hooking",
    "Hidden processes detection",
    "Hidden drivers detection",
    "Inline hooking detection",
    "Volatility rootkit plugins",
    "GMER analysis",
    "Behavioral rootkit indicators"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand rootkit operation at user-mode and kernel-mode levels",
    "Detect DKOM-based process hiding in memory dumps",
    "Identify SSDT, IDT, and IRP hooks used by rootkits",
    "Use Volatility plugins to detect hidden processes and drivers",
    "Analyze kernel memory for inline hooks",
    "Investigate real-world rootkit campaigns"
  ],
  "post_assessment": [
    {
      "question_id": "dfir54_q1",
      "type": "multiple_choice",
      "difficulty": 3,
      "question": "You run pslist and psscan plugins. pslist shows 45 processes, but psscan shows 48 processes. Three processes only appear in psscan. What rootkit technique is indicated?",
      "options": [
        "SSDT hooking to hide processes from enumeration APIs",
        "DKOM unlinking processes from ActiveProcessLinks list",
        "Process hollowing to replace legitimate processes",
        "User-mode API hooking in kernel32.dll"
      ],
      "correct_answer": 1,
      "explanation": "This indicates DKOM (Direct Kernel Object Manipulation) unlinking. How it works: (1) pslist walks the ActiveProcessLinks doubly-linked list in EPROCESS structures, (2) psscan searches memory for EPROCESS pool tags (doesn't rely on links), (3) Rootkit unlinks malicious processes from ActiveProcessLinks by manipulating Flink/Blink pointers, (4) Unlinked processes invisible to pslist but psscan finds them via pool tag scanning. SSDT hooking would hide from both plugins. Process hollowing doesn't hide processes. User-mode hooking doesn't affect kernel plugins."
    },
    {
      "question_id": "dfir54_q2",
      "type": "multiple_choice",
      "difficulty": 3,
      "question": "During SSDT (System Service Descriptor Table) analysis, you find NtCreateFile hook pointing to address 0xF80000123456 which is NOT in ntoskrnl.exe or any loaded driver. What does this indicate?",
      "options": [
        "Normal Windows kernel behavior for dynamic code generation",
        "Kernel rootkit using inline hooking with unregistered driver code",
        "Memory corruption artifact from crash",
        "Legitimate security software hook (EDR)"
      ],
      "correct_answer": 1,
      "explanation": "This indicates a kernel rootkit with unregistered malicious driver code. Analysis: (1) SSDT entries should point to functions in ntoskrnl.exe or legitimate driver modules, (2) Address 0xF80000123456 not belonging to any registered driver = malicious code injected into kernel memory, (3) NtCreateFile is critical API for file operations - rootkits hook it to hide files, (4) Legitimate EDR hooks point to their registered driver modules (visible in module list). Normal Windows never hooks SSDT to arbitrary memory. Memory corruption would cause system crash, not functional hook. Detection: Use ssdt plugin to enumerate all hooks, check if target addresses are within known good modules."
    },
    {
      "question_id": "dfir54_q3",
      "type": "multiple_choice",
      "difficulty": 3,
      "question": "You're analyzing a system with suspected rootkit. The apihooks plugin shows kernel32!CreateFileW's first 5 bytes are 'E9 AB CD EF 12' instead of normal 'FF 25 XX XX XX XX'. What hooking technique is this?",
      "options": [
        "SSDT hooking in kernel mode",
        "Inline hooking with relative JMP (E9) trampoline in user mode",
        "Import Address Table (IAT) hooking",
        "Interrupt Descriptor Table (IDT) hooking"
      ],
      "correct_answer": 1,
      "explanation": "This is inline hooking using a relative JMP (E9) trampoline. Technical breakdown: (1) E9 = x86 opcode for relative JMP (5 bytes total: E9 + 4-byte offset), (2) Original bytes 'FF 25' = indirect JMP (normal Windows API stub), (3) Hooking malware overwrote first 5 bytes with JMP to malicious handler, (4) Handler logs call, performs malicious action, then jumps to original+5. This is user-mode hooking (kernel32.dll). SSDT is kernel-mode only. IAT hooking modifies import table pointers, not function code. IDT is for interrupt handling, not API functions. Detection: apihooks plugin compares memory vs disk versions of DLLs, identifies modified bytes."
    },
    {
      "question_id": "dfir54_q4",
      "type": "multiple_choice",
      "difficulty": 3,
      "question": "A rootkit uses DKOM to hide by zeroing the ImageFileName field in EPROCESS structure instead of unlinking from ActiveProcessLinks. How would this affect Volatility detection?",
      "options": [
        "pslist shows process with blank name, psscan shows real name",
        "Both pslist and psscan show process but neither can determine name",
        "Process completely invisible to both pslist and psscan",
        "pslist shows real name, psscan shows blank name"
      ],
      "correct_answer": 0,
      "explanation": "pslist would show process with blank/corrupted name, psscan would show real name. Here's why: (1) pslist walks ActiveProcessLinks and reads ImageFileName from current EPROCESS to display name (reads live structure), (2) psscan searches for EPROCESS pool tags and reconstructs structure from pool allocation (includes original ImageFileName from pool metadata), (3) Zeroing ImageFileName doesn't unlink process, so pslist still finds it via links but shows no name, (4) psscan reconstructs from pool header which contains original name. Complete invisibility requires unlinking from ActiveProcessLinks. This technique is less effective than unlinking but may evade basic detection tools that rely on ImageFileName."
    },
    {
      "question_id": "dfir54_q5",
      "type": "multiple_choice",
      "difficulty": 3,
      "question": "You find a driver with no corresponding file on disk. The driver's DriverStart is in kernel memory but ServiceName registry key is missing. What rootkit loading technique was likely used?",
      "options": [
        "Normal Windows driver loaded via PnP manager",
        "Kernel exploit loading unsigned driver directly into memory (DSEFix/TDL3 technique)",
        "Legitimate driver that was uninstalled but remains in memory",
        "Driver loaded via documented NtLoadDriver API"
      ],
      "correct_answer": 1,
      "explanation": "This indicates kernel exploit loading unsigned driver directly into memory. Analysis: (1) No file on disk = driver never written to filesystem (fileless technique), (2) No ServiceName registry key = not registered via Services control manager (legitimate loading), (3) Driver in kernel memory = successfully loaded and executing, (4) Modern Windows enforces Driver Signature Enforcement (DSE) - unsigned drivers can't load normally, (5) Rootkits exploit vulnerabilities to disable DSE (e.g., TDL3/TDL4 exploit), then use undocumented MmLoadSystemImage() or similar to load driver from memory. Normal PnP loading requires file+registry. Uninstalled drivers don't remain in memory after reboot. NtLoadDriver requires file on disk and registry entry. Detection: moddump plugin to extract driver, virusscan plugin to check against malware signatures."
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "teach_like_im_10",
    "memory_hooks",
    "connect_to_what_i_know",
    "meta_learning",
    "minimum_effective_dose",
    "reframe_limiting_beliefs"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "# Welcome to the Hidden War: Detecting Rootkits\n\n## The Ultimate Stealth Challenge\n\nYou've learned to detect injected code, hollowed processes, and malicious DLLs. But what if malware could hide from **everything**?\n\n- Hide from Task Manager\n- Hide from Process Explorer\n- Hide from netstat\n- Hide from file explorers\n- Even hide from some forensic tools\n\n**That's what rootkits do.** They operate at the deepest levels of the operating system, manipulating kernel structures that most tools trust implicitly.\n\n## Why This Is the Most Critical Lesson\n\n**Real-world impact**:\n- **Sony BMG Rootkit (2005)**: Pre-installed on 22 million CDs, hid from antivirus, created security vulnerabilities\n- **Stuxnet (2010)**: Nation-state rootkit that hid malicious drivers, infected Iranian nuclear facility\n- **TDL4 Rootkit (2011)**: Infected 4.5 million systems, survived OS reinstalls via bootkit, created massive botnet\n- **Winnti Group (2019-present)**: APT rootkit hiding C2 backdoors in gaming companies, government agencies\n\n## What You'll Master Today\n\n1. **Rootkit Fundamentals**: User-mode vs. kernel-mode, why kernel is more dangerous\n2. **DKOM (Direct Kernel Object Manipulation)**: How rootkits unlink processes from kernel lists\n3. **Hook Detection**: SSDT, IDT, IRP, and inline hooks\n4. **Volatility Rootkit Plugins**: psxview, ssdt, idt, apihooks, modscan\n5. **Real-World Cases**: TDL4, FU Rootkit, Rustock, Zeus\n\n## Your \"Why\" for Learning This\n\n**Scenario**: Enterprise breach. Incident response team finds network traffic to unknown C2 server. They run every scanner, check every process, inspect every file. **Nothing found.**\n\n**Two weeks later**: Ransomware encrypts entire network. Investigation reveals kernel rootkit was hiding C2 backdoor the entire time.\n\n**With today's knowledge**: You would have run `python vol.py -f memory.dmp windows.psxview` and immediately seen the hidden processes. Breach contained in hours, not weeks.\n\n**Rootkit detection is the difference between catching APTs and missing them entirely.**\n\nLet's learn to see the invisible. üîçüëÅÔ∏è"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# Rootkit Fundamentals: Understanding the Enemy\n\n## What Is a Rootkit?\n\n**Definition**: Software designed to maintain **stealthy, persistent** access to a system by **hiding its presence** from users and security tools.\n\n**Etymology**: \"Root\" (admin access) + \"Kit\" (tools) = Tools for maintaining root access\n\n**Key characteristics**:\n1. **Stealth**: Hides files, processes, network connections, registry keys\n2. **Persistence**: Survives reboots (some even survive OS reinstalls)\n3. **Privilege**: Often runs at highest privilege (kernel mode)\n4. **Backdoor**: Provides remote access or maintains other malware\n\n## User-Mode vs. Kernel-Mode Rootkits\n\n### User-Mode Rootkits (Ring 3)\n\n**Operating level**: Same privilege as normal applications\n\n**Techniques**:\n- **API hooking**: Intercept function calls (e.g., kernel32!CreateFileW)\n- **DLL injection**: Inject into every process to hook APIs globally\n- **Import Address Table (IAT) hooking**: Modify IAT entries to redirect API calls\n\n**Example**: Hacker Defender (2003) - injected DLL hooking Win32 APIs\n\n**Strengths**:\n- ‚úÖ Easier to develop (user-mode APIs well-documented)\n- ‚úÖ Less likely to crash system (kernel crashes = BSOD)\n- ‚úÖ Works without kernel exploits\n\n**Weaknesses**:\n- ‚ùå Easier to detect (user-mode memory accessible to security tools)\n- ‚ùå Must hook many processes (can't hook kernel once)\n- ‚ùå Doesn't survive process termination\n- ‚ùå Can be bypassed by direct syscalls\n\n---\n\n### Kernel-Mode Rootkits (Ring 0)\n\n**Operating level**: Highest privilege, same as OS kernel\n\n**Techniques**:\n- **DKOM (Direct Kernel Object Manipulation)**: Modify kernel data structures\n- **SSDT hooking**: Hook System Service Descriptor Table (syscall table)\n- **IDT hooking**: Hook Interrupt Descriptor Table\n- **IRP hooking**: Hook I/O Request Packets (driver communication)\n- **Inline hooking**: Modify kernel function code directly\n\n**Example**: TDL4 (2011) - kernel rootkit with bootkit, infected MBR\n\n**Strengths**:\n- ‚úÖ Ultimate stealth (can hide from user-mode tools completely)\n- ‚úÖ Single hook affects entire system (hook kernel once = affects all processes)\n- ‚úÖ Can disable security software\n- ‚úÖ Can survive sophisticated detection attempts\n\n**Weaknesses**:\n- ‚ùå Requires kernel exploit or signed driver (Driver Signature Enforcement)\n- ‚ùå High risk of system crashes (kernel bugs = BSOD)\n- ‚ùå Harder to develop (kernel APIs complex, documentation limited)\n- ‚ùå Can be detected by memory forensics (kernel memory artifacts)\n\n---\n\n## Rootkit Kill Chain\n\n```\n1. Initial Access\n   ‚îú‚îÄ> Phishing email with malicious attachment\n   ‚îú‚îÄ> Drive-by download from compromised website\n   ‚îî‚îÄ> Exploit kit (RIG, Angler)\n\n2. Privilege Escalation\n   ‚îú‚îÄ> Kernel exploit (CVE-2019-0803, CVE-2018-8453)\n   ‚îú‚îÄ> Steal admin credentials\n   ‚îî‚îÄ> Social engineering (fake UAC prompt)\n\n3. Rootkit Installation\n   ‚îú‚îÄ> Load malicious kernel driver\n   ‚îú‚îÄ> Modify kernel structures (DKOM)\n   ‚îî‚îÄ> Install hooks (SSDT, IDT, IRP)\n\n4. Defense Evasion\n   ‚îú‚îÄ> Hide rootkit process\n   ‚îú‚îÄ> Hide rootkit driver\n   ‚îú‚îÄ> Hide rootkit files\n   ‚îî‚îÄ> Disable security software\n\n5. Persistence\n   ‚îú‚îÄ> Registry Run key (user-mode)\n   ‚îú‚îÄ> Kernel driver service (HKLM\\System\\CurrentControlSet\\Services)\n   ‚îî‚îÄ> Bootkit (MBR/VBR infection)\n\n6. Command & Control\n   ‚îú‚îÄ> Hide network connections\n   ‚îú‚îÄ> Establish encrypted C2 channel\n   ‚îî‚îÄ> Await commands from attacker\n```\n\n---\n\n## DKOM: Direct Kernel Object Manipulation\n\n### What Is DKOM?\n\n**Definition**: Technique where rootkit **directly modifies kernel data structures** (EPROCESS, DRIVER_OBJECT, etc.) to hide objects from enumeration.\n\n**Why it works**: Most security tools rely on Windows APIs to enumerate processes/drivers. APIs walk kernel structures (linked lists). If rootkit unlinks object from list, it becomes invisible to APIs.\n\n### DKOM Technique 1: Process Unlinking\n\n**Target**: EPROCESS structure's ActiveProcessLinks field\n\n**EPROCESS structure** (simplified):\n\n```c\nstruct EPROCESS {\n    // ... many fields ...\n    +0x2e0 UniqueProcessId : Uint8B     // PID\n    +0x2e8 ActiveProcessLinks : LIST_ENTRY  // Doubly-linked list\n    +0x448 ImageFileName : [15] UChar  // Process name\n    // ... many more fields ...\n};\n\nstruct LIST_ENTRY {\n    PLIST_ENTRY Flink;  // Forward link (next)\n    PLIST_ENTRY Blink;  // Backward link (previous)\n};\n```\n\n**Normal linked list**:\n\n```\nExplorer.exe  <--->  Chrome.exe  <--->  Notepad.exe  <--->  Malware.exe\n   Flink ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>                                         ^\n   Blink <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Flink ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ+\n```\n\n**After DKOM unlinking Malware.exe**:\n\n```\nExplorer.exe  <--->  Chrome.exe  <--->  Notepad.exe\n   Flink ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>                    ^\n   Blink <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ+\n\n                                    Malware.exe  (orphaned, invisible)\n```\n\n**Rootkit pseudocode**:\n\n```c\n// Find malware EPROCESS\nPEPROCESS malwareProcess = FindProcessByPID(malwarePID);\n\n// Unlink from ActiveProcessLinks\nPLIST_ENTRY current = &malwareProcess->ActiveProcessLinks;\nPLIST_ENTRY next = current->Flink;\nPLIST_ENTRY prev = current->Blink;\n\n// Relink neighbors to each other (skip over malware)\nprev->Flink = next;  // Previous now points to next\nnext->Blink = prev;  // Next now points back to previous\n\n// Malware EPROCESS still exists in memory but not in list\n// Tools walking ActiveProcessLinks will never find it\n```\n\n**Detection**:\n\n- **pslist plugin**: Walks ActiveProcessLinks ‚Üí Won't find unlinked process\n- **psscan plugin**: Scans memory for EPROCESS pool tags ‚Üí **WILL find unlinked process**\n- **Comparison**: If psscan finds processes pslist doesn't ‚Üí DKOM detected\n\n---\n\n### DKOM Technique 2: Driver Unlinking\n\n**Target**: DRIVER_OBJECT linked list\n\n**Similar principle**: Drivers are linked in kernel structures. Unlinking hides malicious driver from module enumeration.\n\n**Detection**:\n\n- **modules plugin**: Walks PsLoadedModuleList ‚Üí Won't find unlinked driver\n- **modscan plugin**: Scans for DRIVER_OBJECT pool tags ‚Üí **WILL find unlinked driver**\n\n---\n\n## SSDT Hooking: Syscall Interception\n\n### What Is the SSDT?\n\n**System Service Descriptor Table (SSDT)**: Kernel table mapping syscall numbers to kernel function addresses.\n\n**Purpose**: When user-mode program calls Windows API (e.g., CreateFile), it eventually triggers syscall (e.g., NtCreateFile). SSDT tells kernel which function to execute.\n\n**SSDT structure** (simplified, x86):\n\n```c\nstruct SSDT {\n    PVOID *ServiceTable;      // Array of function pointers\n    ULONG *CounterTable;      // Call counters (optional)\n    ULONG NumberOfServices;   // Array size\n    PUCHAR ArgumentTable;     // Argument sizes\n};\n\n// ServiceTable example:\nServiceTable[0x00] = NtAccessCheck\nServiceTable[0x01] = NtAcquireCMFKeyExclusive\n...\nServiceTable[0x25] = NtCreateFile  ‚Üê Common hook target\nServiceTable[0x26] = NtCreateKey\n...\nServiceTable[0x11C] = NtWriteFile\n```\n\n### How SSDT Hooking Works\n\n**Normal syscall flow**:\n\n```\nUser-Mode Application\n   |\n   | CreateFile(\"secret.txt\")\n   V\nkernel32.dll!CreateFileW\n   |\n   | Calls NtCreateFile (syscall 0x25)\n   V\nKernel Mode (syscall dispatcher)\n   |\n   | Looks up SSDT[0x25]\n   V\nntoskrnl.exe!NtCreateFile (legitimate)\n   |\n   | Performs file creation\n   V\nReturn to user mode\n```\n\n**With SSDT hooking**:\n\n```\nUser-Mode Application\n   |\n   | CreateFile(\"rootkit.sys\")\n   V\nkernel32.dll!CreateFileW\n   |\n   | Calls NtCreateFile (syscall 0x25)\n   V\nKernel Mode (syscall dispatcher)\n   |\n   | Looks up SSDT[0x25]\n   V\nRootkit Hook Handler  ‚Üê SSDT[0x25] was modified!\n   |\n   | if (filename == \"rootkit.sys\")\n   |     return ERROR_FILE_NOT_FOUND  (hide file)\n   | else\n   |     call ntoskrnl.exe!NtCreateFile (original)\n   V\nReturn to user mode (file hidden)\n```\n\n**Rootkit pseudocode**:\n\n```c\n// Save original function address\nPVOID originalNtCreateFile = KeServiceDescriptorTable.ServiceTable[0x25];\n\n// Install hook\nKeServiceDescriptorTable.ServiceTable[0x25] = (PVOID)MyHookedNtCreateFile;\n\n// Hook handler\nNTSTATUS MyHookedNtCreateFile(POBJECT_ATTRIBUTES ObjectAttributes, ...) {\n    // Check if file to be opened is rootkit file\n    if (wcsstr(ObjectAttributes->ObjectName, L\"rootkit.sys\")) {\n        // Hide file\n        return STATUS_OBJECT_NAME_NOT_FOUND;\n    }\n    \n    // Otherwise, call original\n    return ((NtCreateFileFunc)originalNtCreateFile)(ObjectAttributes, ...);\n}\n```\n\n### Detection with Volatility\n\n```bash\npython vol.py -f memory.dmp windows.ssdt\n\nOutput:\nIndex  Address            Module\n0x0000 0xfffff80123456789 ntoskrnl.exe!NtAccessCheck\n0x0001 0xfffff80123456890 ntoskrnl.exe!NtAcquireCMFKeyExclusive\n...\n0x0025 0xfffff80f00123456 <UNKNOWN>  ‚Üê Hook! Should be ntoskrnl\n0x0026 0xfffff80123457000 ntoskrnl.exe!NtCreateKey\n```\n\n**Red flag**: Entry pointing to unknown module or not in ntoskrnl.exe\n\n**Legitimate hooks**: Security software (EDR) may hook SSDT, but hooks point to registered driver (CrowdStrike, Defender ATP)\n\n---\n\n## IDT Hooking: Interrupt Interception\n\n### What Is the IDT?\n\n**Interrupt Descriptor Table (IDT)**: Table mapping interrupt numbers (0-255) to interrupt handler addresses.\n\n**Purpose**: When interrupt occurs (hardware event, exception, software interrupt), CPU looks up handler in IDT.\n\n**Common interrupts**:\n- INT 0x00: Divide by zero exception\n- INT 0x03: Breakpoint (debugger)\n- INT 0x0D: General protection fault\n- INT 0x0E: Page fault\n- INT 0x2E: System call (x86 Windows)\n- INT 0x80: System call (Linux)\n\n### Why Rootkits Hook IDT\n\n- **Syscall interception**: Hook INT 0x2E to intercept all syscalls\n- **Anti-debugging**: Hook INT 0x03 to detect/defeat debuggers\n- **Exception hiding**: Hook INT 0x0E to hide malicious memory access\n\n### Detection with Volatility\n\n```bash\npython vol.py -f memory.dmp windows.idt\n\nOutput:\nCPU  Index  Address            Module\n0    0x00   0xfffff80123456789 ntoskrnl.exe!KiDivideErrorFault\n0    0x03   0xfffff80123456890 ntoskrnl.exe!KiBreakpointTrap\n...\n0    0x2E   0xfffff80f00abcdef <UNKNOWN>  ‚Üê Hook detected!\n```\n\n**Red flag**: IDT entry pointing outside ntoskrnl.exe or hal.dll\n\n---\n\n## IRP Hooking: Driver Communication Interception\n\n### What Are IRPs?\n\n**I/O Request Packets (IRPs)**: Data structures used for communication between drivers and between kernel and drivers.\n\n**Example**: When you open file, I/O Manager creates IRP and sends it to filesystem driver stack.\n\n### IRP Hooking\n\nRootkit intercepts IRPs to:\n- Hide files from filesystem queries\n- Hide registry keys from registry driver\n- Hide network connections from TCP/IP driver\n\n**Detection**: Check DriverObject->MajorFunction[] table for hooks pointing to unknown drivers.\n\n---\n\n## Inline Hooking in Kernel\n\n**Technique**: Modify first few bytes of kernel function with JMP to rootkit handler.\n\n**Example**:\n\n```\nOriginal NtCreateFile (ntoskrnl.exe):\n0xfffff801234567"
      }
    }
  ],
  "tags": ["dfir", "memory-forensics", "rootkit-detection", "kernel-analysis", "volatility", "dkom", "ssdt-hooking", "advanced"]
}