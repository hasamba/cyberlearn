{
  "lesson_id": "b8e4d9f0-5c3f-4f2b-8a6d-9e8f7d6c5b4e",
  "domain": "linux",
  "title": "Linux Process Management and Monitoring",
  "subtitle": "Master process lifecycle, monitoring, and security implications",
  "difficulty": 2,
  "order_index": 3,
  "prerequisites": [
    "3b2aa25c-082d-4ff7-962c-fcde78b16bf4",
    "a7f3c8d9-4b2e-4e1a-9f5c-8d7e6c5b4a3d"
  ],
  "concepts": [
    "Process lifecycle (fork, exec, exit)",
    "Process states (running, sleeping, zombie, stopped)",
    "Process identifiers (PID, PPID, UID, GID)",
    "ps, top, htop commands",
    "Process priorities and nice values",
    "Signals and kill command",
    "/proc filesystem deep dive",
    "Background and foreground processes",
    "Process monitoring and resource usage",
    "Detecting suspicious processes"
  ],
  "estimated_time": 50,
  "learning_objectives": [
    "Understand the Linux process model and lifecycle",
    "Master process monitoring tools (ps, top, htop, pstree)",
    "Use /proc filesystem to inspect running processes",
    "Manage process priorities and resource allocation",
    "Send signals to control process behavior",
    "Identify resource-intensive and suspicious processes",
    "Detect malware and rootkits through process analysis",
    "Troubleshoot performance issues using process metrics"
  ],
  "post_assessment": [
    {
      "question": "What is PID 1 on a Linux system?",
      "options": [
        "The kernel process",
        "The init/systemd process (first user-space process)",
        "The shell process",
        "The most recently started process"
      ],
      "correct": 1,
      "explanation": "PID 1 is the init process (systemd on modern systems), the first user-space process started by the kernel. It's the ancestor of all other processes.",
      "question_id": "2fa41460-3522-42c6-8e86-9f195c3bb373",
      "type": "multiple_choice",
      "difficulty": 2,
      "correct_answer": 0
    },
    {
      "question": "What does a zombie process indicate?",
      "options": [
        "A malware infection",
        "A process consuming too much CPU",
        "A child process that exited but parent hasn't read exit status",
        "A process that cannot be killed"
      ],
      "correct": 2,
      "explanation": "Zombie (defunct) processes have finished execution but their parent hasn't called wait() to read the exit status. They consume minimal resources but indicate poor process management.",
      "question_id": "9c52936a-6859-4fcf-87e8-71cc836c6b53",
      "type": "multiple_choice",
      "difficulty": 2,
      "correct_answer": 0
    },
    {
      "question": "Which command shows real-time process activity sorted by CPU usage?",
      "options": [
        "ps aux",
        "top",
        "pstree",
        "lsof"
      ],
      "correct": 1,
      "explanation": "top provides real-time, continuously updated view of processes sorted by resource usage (CPU by default).",
      "question_id": "5c59ecf6-b511-461c-978b-3bdb32f5affd",
      "type": "multiple_choice",
      "difficulty": 2,
      "correct_answer": 0
    },
    {
      "question": "What signal does 'kill -9 <PID>' send?",
      "options": [
        "SIGTERM (graceful termination)",
        "SIGKILL (immediate termination, cannot be caught)",
        "SIGHUP (hangup)",
        "SIGSTOP (pause process)"
      ],
      "correct": 1,
      "explanation": "kill -9 sends SIGKILL, which immediately terminates the process. It cannot be caught or ignored, unlike SIGTERM (kill -15).",
      "question_id": "97627d42-c5d3-41b6-a045-391cf6fa6436",
      "type": "multiple_choice",
      "difficulty": 2,
      "correct_answer": 0
    },
    {
      "question": "Where can you find the command line of a running process with PID 1234?",
      "options": [
        "/proc/1234/status",
        "/proc/1234/cmdline",
        "/proc/1234/exe",
        "/var/log/processes"
      ],
      "correct": 1,
      "explanation": "/proc/<PID>/cmdline contains the complete command line used to start the process, useful for identifying malicious processes.",
      "question_id": "b879fc22-64a7-4fc1-a279-74fbe292235e",
      "type": "multiple_choice",
      "difficulty": 2,
      "correct_answer": 0
    },
    {
      "question": "What does a nice value of -20 mean?",
      "options": [
        "Lowest priority (least CPU time)",
        "Highest priority (most CPU time)",
        "Normal priority",
        "Process is suspended"
      ],
      "correct": 1,
      "explanation": "Nice values range from -20 (highest priority) to +19 (lowest priority). Lower nice = higher priority = more CPU time.",
      "question_id": "c5d90f1a-a1dc-4ea9-887c-86ed90963193",
      "type": "multiple_choice",
      "difficulty": 2,
      "correct_answer": 0
    },
    {
      "question": "How do you find all processes running as root?",
      "options": [
        "ps -u root",
        "top -r",
        "htop --root",
        "lsof -root"
      ],
      "correct": 0,
      "explanation": "ps -u root filters processes by user. You can also use 'ps aux | grep root' or 'ps -ef | grep root'.",
      "question_id": "494c7ef5-7fe0-4c34-9e7b-0bb9f8ee08a1",
      "type": "multiple_choice",
      "difficulty": 2,
      "correct_answer": 0
    },
    {
      "question": "Which /proc file shows open file descriptors for a process?",
      "options": [
        "/proc/<PID>/files",
        "/proc/<PID>/fd/",
        "/proc/<PID>/handles",
        "/proc/<PID>/lsof"
      ],
      "correct": 1,
      "explanation": "/proc/<PID>/fd/ directory contains symbolic links to all file descriptors opened by the process.",
      "question_id": "aeff2efb-4abc-406f-9dbc-ff7e2024c234",
      "type": "multiple_choice",
      "difficulty": 2,
      "correct_answer": 0
    },
    {
      "question": "What is the first step when you suspect a process is malware?",
      "options": [
        "Immediately kill it with kill -9",
        "Investigate: check cmdline, exe, network connections, parent process",
        "Reboot the system",
        "Delete the binary"
      ],
      "correct": 1,
      "explanation": "Always investigate first: check /proc/<PID>/exe (binary location), /proc/<PID>/cmdline (how it started), network connections (netstat/ss), parent process. This preserves forensic evidence.",
      "question_id": "67207742-3f46-4e72-a849-54c34f9df77a",
      "type": "multiple_choice",
      "difficulty": 2,
      "correct_answer": 0
    },
    {
      "question": "How can you run a process with lower priority to avoid impacting system performance?",
      "options": [
        "kill -19 <PID>",
        "nice -n 19 ./cpu-intensive-task",
        "renice -20 <PID>",
        "top -p <PID>"
      ],
      "correct": 1,
      "explanation": "nice -n 19 starts a process with lowest priority (+19). For running processes, use renice 19 <PID>.",
      "question_id": "701294ea-fa39-44f0-ba6b-70beb43ed92b",
      "type": "multiple_choice",
      "difficulty": 2,
      "correct_answer": 0
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "meta_learning",
    "teach_like_im_10",
    "minimum_effective_dose",
    "memory_hooks",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "explanation",
      "content": {
        "text": "# What is a Process?\n\nA **process** is an instance of a running program. Every time you execute a command, open an application, or run a script, the kernel creates a process.\n\n**Key Distinction**:\n- **Program**: Static code stored on disk (binary file)\n- **Process**: Program loaded into memory and executing\n\n```\n/usr/bin/firefox  ←  Program (file on disk)\n↓\nfork() + exec()\n↓\nPID 4521: firefox  ←  Process (running in memory)\n```bash\n\n## Why Process Management Matters for Security\n\n1. **Malware Detection**: Suspicious processes indicate compromises\n2. **Resource Monitoring**: Crypto miners consume excessive CPU\n3. **Privilege Analysis**: Which processes run as root?\n4. **Network Activity**: What processes have open connections?\n5. **Incident Response**: Identifying attacker tools (shells, scanners)\n6. **Forensics**: Understanding system state during breach\n\n**Real-World Example**: The **Mirai botnet** (2016) created processes named `[kworker]` to blend in with legitimate kernel worker threads. Proper process analysis revealed the deception."
      }
    },
    {
      "type": "video",
      "content": {
        "title": "Video: Linux Process Management and Monitoring Overview",
        "url": "https://www.youtube.com/embed/6OHVjVtjQVw",
        "description": "Watch this video for a visual introduction to the concepts covered in this lesson."
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# Process Identifiers and Attributes\n\nEvery process has multiple identifiers and attributes:\n\n## Core Identifiers\n\n```bash\nps -eo pid,ppid,uid,gid,user,comm\n\nPID  PPID   UID   GID USER     COMMAND\n1     0     0     0 root     systemd\n1234     1  1000  1000 alice    bash\n1235  1234  1000  1000 alice    firefox\n```\n\n**Definitions**:\n- **PID (Process ID)**: Unique identifier for the process\n- **PPID (Parent PID)**: PID of the process that created this one\n- **UID (User ID)**: Numeric user ID running the process\n- **GID (Group ID)**: Primary group ID\n- **EUID/EGID**: Effective user/group (can differ with SUID/SGID)\n\n## Process Hierarchy\n\nLinux processes form a **tree** - every process (except PID 1) has a parent:\n\n```\nsystemd (PID 1)\n├─ sshd (PID 1089)\n│   └─ sshd: alice (PID 4521)    ← SSH session\n│       └─ bash (PID 4522)        ← Shell\n│           ├─ vim (PID 4567)     ← Editor\n│           └─ python (PID 4589)  ← Script\n└─ apache2 (PID 1234)\n├─ apache2 (PID 1235)         ← Worker processes\n└─ apache2 (PID 1236)\n```\n\n**View hierarchy**:\n```bash\npstree -p        # Show tree with PIDs\npstree -u        # Show user transitions\npstree -a        # Show command arguments\n```\n\n**Security Insight**: Unexpected parent-child relationships indicate compromise:\n- **Suspicious**: `bash` child of `apache2` (web shell!)\n- **Suspicious**: `nc` (netcat) child of `cron` (backdoor!)"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Mastering ps: Process Snapshots\n\n**ps** provides a **snapshot** of current processes (unlike top's real-time view).\n\n## Essential ps Commands\n\n```bash\n# BSD-style (no dash) - most common\nps aux              # All processes, all users, full details\nps aux | grep apache\n\n# UNIX-style (with dash)\nps -ef              # Every process, full format\nps -u alice         # Processes for user alice\nps -p 1234          # Specific PID\n\n# Custom output format\nps -eo pid,ppid,cmd,%cpu,%mem --sort=-%cpu\nps -eo pid,user,cmd | grep -i \"suspicious\"\n\n# Show process tree\nps -ef --forest\nps auxf\n```bash\n\n## Understanding ps Output\n\n```bash\nps aux\n\nUSER  PID  %CPU %MEM    VSZ   RSS TTY   STAT START   TIME COMMAND\nroot    1   0.0  0.1  16896  9876 ?     Ss   10:30   0:01 /sbin/init\nalice 4521  15.3  5.2 298765 54321 ?     Sl   11:45   2:34 /usr/bin/firefox\nwww   1234   0.1  0.8  45678 12345 ?     S    10:32   0:05 /usr/sbin/apache2\n```\n\n**Key Columns**:\n- **%CPU**: CPU usage percentage\n- **%MEM**: Memory usage percentage\n- **VSZ**: Virtual memory size (KB)\n- **RSS**: Resident Set Size - actual physical RAM used (KB)\n- **TTY**: Terminal (? = no controlling terminal, pts/0 = pseudo-terminal)\n- **STAT**: Process state (see next section)\n- **TIME**: Total CPU time consumed\n\n## Process States (STAT column)\n\n```\nR  = Running or runnable\nS  = Sleeping (waiting for event)\nD  = Uninterruptible sleep (usually I/O)\nT  = Stopped (by job control signal)\nZ  = Zombie (terminated, waiting for parent)\n\nModifiers:\n<  = High priority (nice < 0)\nN  = Low priority (nice > 0)\ns  = Session leader\nl  = Multi-threaded\n+  = Foreground process group\n```\n\n**Example Analysis**:\n```bash\nps aux | grep \"Z\"     # Find zombie processes\nps aux | grep \"D\"     # Find processes in uninterruptible sleep (I/O issues)\nps aux --sort=-%cpu | head -10  # Top 10 CPU hogs\n```"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Real-Time Monitoring with top and htop\n\n## top - The Classic Monitor\n\n```bash\ntop                 # Basic real-time view\ntop -u alice        # Filter by user\ntop -p 1234,5678    # Monitor specific PIDs\n\n# Interactive commands (while top is running):\n# k - kill process\n# r - renice (change priority)\n# M - sort by memory\n# P - sort by CPU (default)\n# 1 - show individual CPU cores\n# q - quit\n```\n\n**Top Output Explained**:\n```\ntop - 14:30:21 up 5 days,  3:21,  3 users,  load average: 1.52, 1.48, 1.35\nTasks: 287 total,   2 running, 285 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  8.3 us,  2.1 sy,  0.0 ni, 89.2 id,  0.2 wa,  0.0 hi,  0.2 si,  0.0 st\nMiB Mem :  15956.8 total,   2341.2 free,   8765.4 used,   4850.2 buff/cache\nMiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   6234.5 avail Mem\n```\n\n**CPU Breakdown**:\n- **us**: User space CPU time\n- **sy**: System/kernel CPU time\n- **ni**: Nice'd (low priority) processes\n- **id**: Idle\n- **wa**: I/O wait (high = disk bottleneck)\n- **hi**: Hardware interrupts\n- **si**: Software interrupts\n- **st**: Steal time (virtualized environments)\n\n**Load Average**:\n- **1.52, 1.48, 1.35** = 1-min, 5-min, 15-min averages\n- **< 1.0** = System not fully utilized\n- **= Number of CPUs** = Fully loaded\n- **> Number of CPUs** = Overloaded (processes queuing)\n\n## htop - Enhanced Interactive Monitor\n\n```bash\nsudo apt install htop\nhtop\n\n# Features over top:\n# - Color-coded interface\n# - Mouse support\n# - Horizontal/vertical scrolling\n# - Process tree view (F5)\n# - Easy kill/renice (F9/F7)\n# - Search (F3)\n```\n\n**Pro Tip**: `htop` is easier for beginners, but `top` is always available (even on minimal systems)."
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# The /proc Filesystem: Process Intelligence\n\n**/proc** is a **virtual filesystem** - files don't exist on disk, they're generated by the kernel in real-time.\n\n## Key /proc Directories\n\n```bash\n/proc/<PID>/          # Everything about process <PID>\n/proc/cpuinfo         # CPU details\n/proc/meminfo         # Memory statistics\n/proc/net/tcp         # Active TCP connections\n/proc/sys/            # Kernel parameters (sysctl)\n```bash\n\n## Essential /proc/<PID> Files\n\n```bash\n# Command line used to start process\ncat /proc/1234/cmdline | tr '\\0' ' '\n\n# Actual binary being executed (follows symlinks)\nls -l /proc/1234/exe\n\n# Current working directory\nls -l /proc/1234/cwd\n\n# Environment variables\ncat /proc/1234/environ | tr '\\0' '\\n'\n\n# Process status (PID, state, parent, memory, etc.)\ncat /proc/1234/status\n\n# Open file descriptors\nls -l /proc/1234/fd/\n\n# Memory maps (loaded libraries, mapped files)\ncat /proc/1234/maps\n\n# Network connections for this process\nls -l /proc/1234/net/\n```bash\n\n## Security Investigation Example\n\n```bash\n# Suspicious process detected: PID 6789\n\n# 1. What binary is running?\nls -l /proc/6789/exe\n# lrwxrwxrwx 1 www-data www-data 0 Jan 15 14:30 /proc/6789/exe -> /tmp/.hidden/malware\n# ⚠️ Binary in /tmp is suspicious!\n\n# 2. How was it started?\ncat /proc/6789/cmdline | tr '\\0' ' '\n# /tmp/.hidden/malware -c 192.168.1.100:4444\n# ⚠️ Connecting to external IP - likely C2 server!\n\n# 3. Who is the parent process?\ncat /proc/6789/status | grep PPid\n# PPid: 1234\nps -p 1234\n# PID  TTY  STAT  TIME COMMAND\n# 1234  ?    Ss   0:05 /usr/sbin/apache2\n# ⚠️ Spawned by apache2 - web shell exploitation!\n\n# 4. What files is it accessing?\nls -l /proc/6789/fd/\n# lr-x------ 1 www-data www-data 64 Jan 15 14:30 3 -> /etc/passwd\n# lr-x------ 1 www-data www-data 64 Jan 15 14:30 4 -> /etc/shadow\n# ⚠️ Reading password files!\n\n# 5. What network connections?\nlsof -p 6789 | grep ESTABLISHED\n# malware  6789 www-data  5u  IPv4  TCP 10.0.1.50:45678->192.168.1.100:4444 (ESTABLISHED)\n# ⚠️ Active connection to external C2!\n\n# Conclusion: Confirmed malware - isolate and investigate!\n```"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Process Control: Signals and kill\n\n**Signals** are software interrupts sent to processes to control their behavior.\n\n## Common Signals\n\n```bash\nkill -l    # List all signals\n\n1) SIGHUP     - Hangup (reload config for daemons)\n2) SIGINT     - Interrupt (Ctrl+C)\n3) SIGQUIT    - Quit\n9) SIGKILL    - Kill immediately (cannot be caught)\n15) SIGTERM    - Terminate gracefully (default)\n18) SIGCONT    - Continue if stopped\n19) SIGSTOP    - Stop process (cannot be caught)\n20) SIGTSTP    - Stop (Ctrl+Z)\n```bash\n\n## Using kill and killall\n\n```bash\n# Graceful termination (allows cleanup)\nkill 1234\nkill -15 1234\nkill -SIGTERM 1234    # All equivalent\n\n# Force kill (no cleanup, immediate)\nkill -9 1234\nkill -SIGKILL 1234\n\n# Reload config (common for web servers)\nkill -HUP 1234\nkill -1 1234\n\n# Kill by name (all matching processes)\nkillall firefox\nkillall -9 chrome\n\n# Kill all processes for a user\nkillall -u alice\npkill -u alice\n\n# Kill by pattern matching\npkill -f \"python.*malicious\"\n```bash\n\n## Process States and Job Control\n\n```bash\n# Start process in background\n./long-running-task &\n\n# List background jobs\njobs\n# [1]+  Running    ./long-running-task &\n\n# Bring to foreground\nfg %1\n\n# Suspend foreground process\n# (Press Ctrl+Z)\n# [1]+  Stopped    ./long-running-task\n\n# Resume in background\nbg %1\n\n# Detach from terminal (keeps running after logout)\nnohup ./task &\n\n# Better: use screen or tmux\nscreen -S mysession\n./long-running-task\n# Ctrl+A, D to detach\nscreen -r mysession    # Reattach later\n```bash\n\n## When to Use Which Signal\n\n| Scenario | Signal | Reason |\n|----------|--------|--------|\n| Normal shutdown | SIGTERM (15) | Allows cleanup, save state |\n| Reload config | SIGHUP (1) | Nginx, Apache reload without downtime |\n| Stuck process | SIGTERM first, then SIGKILL | Give it a chance to exit gracefully |\n| Debugging | SIGQUIT (3) | Generates core dump |\n| Immediate kill | SIGKILL (9) | Last resort, no cleanup |\n\n**Best Practice**: Always try `kill <PID>` (SIGTERM) before `kill -9 <PID>` (SIGKILL)."
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# Process Priority and Nice Values\n\n**Priority** determines how much CPU time a process receives. Linux uses **nice values** to set priority.\n\n## Nice Value Scale\n\n```\n-20 ← Highest priority (most CPU time)\n↕\n0 ← Default priority\n↕\n+19 ← Lowest priority (least CPU time)\n```\n\n**Permission Requirements**:\n- **Regular users**: Can only increase nice (lower priority) from 0 to +19\n- **Root**: Can set any value (-20 to +19)\n\n## Setting Priority\n\n```bash\n# Start process with low priority\nnice -n 19 ./cpu-intensive-backup.sh\n\n# Start with high priority (requires root)\nsudo nice -n -10 ./critical-database\n\n# Check current nice value\nps -eo pid,ni,comm | grep backup\n# 1234  19 backup.sh\n\n# Change priority of running process\nrenice 10 -p 1234        # Set to +10\nsudo renice -5 -p 5678   # Set to -5 (high priority)\n\n# Change priority for all processes of a user\nrenice 5 -u alice\n```bash\n\n## Practical Use Cases\n\n```bash\n# Background backup (don't slow down interactive work)\nnice -n 19 tar czf backup.tar.gz /data &\n\n# Compile large project with minimal impact\nnice -n 15 make -j8\n\n# CPU-intensive data analysis\nnice -n 10 python analyze_logs.py\n\n# Crypto miner detection\nps -eo pid,ni,%cpu,comm --sort=-%cpu | head -20\n# Look for high CPU + default nice (0) = potential miner\n```bash\n\n## Real-Time Priority (Advanced)\n\nFor time-critical processes (audio, video), Linux supports **real-time scheduling**:\n\n```bash\n# Requires special permissions\nsudo chrt -f 99 ./audio_processing\n\n# View scheduling policy\nchrt -p 1234\n```\n\n**Warning**: Real-time processes can starve all other processes. Use with extreme caution!"
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "# Real-World Case: Cryptocurrency Miner Detection\n\n## The Scenario\n\nA sysadmin noticed **server performance degradation**. Web apps were slow, users complained. No obvious cause in logs.\n\n## Investigation Process\n\n```bash\n# Step 1: Check CPU usage\ntop\n# Top process: 98.7% CPU, named \"[kworker/0:1]\"\n# ⚠️ Kernel workers shouldn't consume this much CPU!\n\n# Step 2: Identify the PID\nps aux | grep kworker | grep -v grep\n# root  7834  98.7  0.5  12345  5678 ?  R  10:30  450:23 [kworker/0:1]\n\n# Step 3: Inspect the binary\nls -l /proc/7834/exe\n# lrwxrwxrwx 1 root root 0 Jan 15 /proc/7834/exe -> /tmp/.x11/kworker\n# ⚠️ Real kernel workers don't have binaries in /tmp!\n\n# Step 4: Check how it started\ncat /proc/7834/cmdline | tr '\\0' ' '\n# /tmp/.x11/kworker -o pool.minexmr.com:4444 -u wallet_address\n# ⚠️ Confirmed: XMRig cryptocurrency miner!\n\n# Step 5: Find parent process\ncat /proc/7834/status | grep PPid\n# PPid: 1\n# ⚠️ Parent is init (1) - process is orphaned/persistent\n\n# Step 6: Check network connections\nlsof -p 7834 | grep ESTABLISHED\n# kworker  7834 root  3u  IPv4  TCP server:45678->pool.minexmr.com:4444\n# ⚠️ Actively mining!\n\n# Step 7: Check persistence mechanism\ncrontab -l\n# @reboot /tmp/.x11/kworker\n# ⚠️ Survives reboots via cron!\n```bash\n\n## Remediation\n\n```bash\n# 1. Kill the process\nkill -9 7834\n\n# 2. Remove cron persistence\ncrontab -r\n\n# 3. Delete malware\nrm -rf /tmp/.x11/\n\n# 4. Find initial compromise vector\n# (In this case: outdated WordPress plugin)\n\n# 5. Harden system\nchmod 1777 /tmp    # Ensure sticky bit on /tmp\n# Add process monitoring\n```bash\n\n## Detection Indicators\n\n1. **High CPU** usage with generic/misspelled process names\n2. **Unusual binary locations**: /tmp, /dev/shm, hidden directories\n3. **Network connections** to mining pools\n4. **Parent process**: Often init (orphaned) or cron\n5. **Renamed processes**: Pretending to be system processes\n\n**Lesson**: Always verify process legitimacy - check exe path, cmdline, and parent!"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Process Forensics: Investigation Cheat Sheet\n\n## Suspicious Process Checklist\n\n```bash\n# Replace <PID> with suspicious process ID\n\n# 1. Basic process info\nps -p <PID> -o pid,ppid,user,%cpu,%mem,stat,start,time,comm,cmd\n\n# 2. Executable location\nls -l /proc/<PID>/exe\nmd5sum /proc/<PID>/exe    # Hash for malware DB lookup\n\n# 3. Command line and arguments\ncat /proc/<PID>/cmdline | tr '\\0' ' ' && echo\n\n# 4. Environment variables\ncat /proc/<PID>/environ | tr '\\0' '\\n' | grep -i \"LD_PRELOAD\\|PATH\"\n# ⚠️ LD_PRELOAD manipulation indicates rootkit!\n\n# 5. Current working directory\nls -l /proc/<PID>/cwd\n\n# 6. Open files and network connections\nlsof -p <PID>\nls -l /proc/<PID>/fd/\n\n# 7. Network connections\nss -anp | grep <PID>\nnetstat -anp | grep <PID>\n\n# 8. Parent process tree\npstree -p -s <PID>\n\n# 9. Memory maps (loaded libraries)\ncat /proc/<PID>/maps | grep -v \"\\[heap\\]\\|\\[stack\\]\\|\\[vdso\\]\"\n\n# 10. User and group context\ncat /proc/<PID>/status | grep -E \"^(Uid|Gid|Groups):\"\n```bash\n\n## Mass Process Audit Commands\n\n```bash\n# Find processes with unusual characteristics\n\n# 1. Processes running from /tmp or /dev/shm\nlsof | grep -E \"^(/tmp|/dev/shm)\" | grep REG\n\n# 2. Processes with deleted binaries (common after upgrade or malware)\nls -l /proc/*/exe 2>/dev/null | grep deleted\n\n# 3. Processes listening on network ports\nss -tlnp    # TCP listening\nss -ulnp    # UDP listening\n\n# 4. Find all processes for a specific user\nps -u www-data -o pid,ppid,cmd\n\n# 5. Processes consuming most memory\nps aux --sort=-%mem | head -20\n\n# 6. Long-running processes (potential persistence)\nps -eo pid,etime,cmd --sort=-etime | head -20\n\n# 7. Processes with unusual parent-child relationships\npstree -p | grep -E \"apache.*bash|nginx.*sh|cron.*nc\"\n```bash\n\n## Automated Monitoring Script\n\n```bash\n# !/bin/bash\n# monitor_suspicious.sh\n\necho \"[*] Checking for suspicious processes...\"\n\n# High CPU processes\necho \"\\n[+] Top CPU consumers:\"\nps aux --sort=-%cpu | head -5\n\n# Processes from temp directories\necho \"\\n[+] Processes running from /tmp:\"\nlsof | grep -E \"^/tmp\" | grep REG | awk '{print $1, $2}' | sort -u\n\n# Unusual listening ports\necho \"\\n[+] Uncommon listening ports:\"\nss -tlnp | grep -vE \":(22|80|443|3306|5432)\" | grep LISTEN\n\n# Unexpected user processes\necho \"\\n[+] Root processes with network connections:\"\nlsof -i -u root\n\necho \"\\n[*] Investigation complete.\"\n```"
      }
    },
    {
      "type": "mindset_coach",
      "content": {
        "text": "# Mastery Mindset: Process Thinking\n\n**Beginner Thought**: \"There are too many process monitoring tools - ps, top, htop, lsof, pstree... I'll never remember which to use when!\"\n\n**Expert Reframe**: Think of these as **different lenses** for viewing the same reality:\n\n- **ps**: Snapshot camera (\"What's running right now?\")\n- **top**: Live video feed (\"What's consuming resources?\")\n- **pstree**: Family tree diagram (\"Who spawned whom?\")\n- **lsof**: X-ray vision (\"What files/network connections?\")\n- **/proc**: Medical records (\"Detailed process internals\")\n\n## The OODA Loop for Process Investigation\n\n**OODA** (Observe, Orient, Decide, Act) applies to process analysis:\n\n1. **Observe**: `top` shows high CPU process\n2. **Orient**: \"Is this normal? Check exe path, parent, network\"\n3. **Decide**: \"Looks like malware - kill and investigate\"\n4. **Act**: `kill -9`, preserve evidence, analyze\n\n## Practice Strategy (Jim Kwik Method)\n\n**Week 1**: Run `ps aux`, `top`, `pstree` daily on your system\n- **Goal**: Familiarize with \"normal\" process baseline\n- **Action**: Note which processes always run, typical CPU/memory usage\n\n**Week 2**: Simulate scenarios\n- Start CPU-intensive task: `dd if=/dev/zero of=/dev/null`\n- Start network connection: `nc -l 12345`\n- **Goal**: Practice identifying them with different tools\n\n**Week 3**: Forensic challenges\n- Download malware samples (in VM!)\n- Practice identifying them using /proc filesystem\n- **Goal**: Build muscle memory for investigation workflow\n\n**Remember**: Every security expert was once confused by ps output. The difference? They **practiced** until it became intuitive. You're building that expertise right now!"
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "# Reflection and Next Steps\n\n## Key Takeaways\n\n1. **Processes** are running instances of programs with unique PIDs\n2. **Process hierarchy** - every process has a parent (except PID 1)\n3. **ps/top/htop** provide different views: snapshot vs real-time\n4. **/proc filesystem** contains detailed process internals\n5. **Signals** control processes (SIGTERM for graceful, SIGKILL for force)\n6. **Nice values** control CPU priority (-20 highest, +19 lowest)\n7. **Process investigation** follows a systematic workflow: exe → cmdline → parent → network\n8. **Suspicious indicators**: unusual locations (/tmp), high CPU, orphaned parent, external connections\n\n## Practice Exercises\n\n1. **Baseline Your System**:\n```bash\nps aux > baseline.txt\npstree -p > process_tree.txt\n# Review weekly, note changes\n```\n\n2. **Create a CPU Hog**:\n```bash\nyes > /dev/null &\n# Practice: Find it with top, check nice value, kill it\n```\n\n3. **Investigate Your Shell**:\n```bash\necho $$    # Your shell's PID\nls -l /proc/$$/exe\ncat /proc/$$/cmdline\nls -l /proc/$$/fd/\n```\n\n4. **Monitor a Web Server**:\n```bash\nps aux | grep apache2\npstree -p $(pgrep apache2 | head -1)\nlsof -i :80\n```\n\n5. **Set Up Monitoring**:\n- Create cron job to log top CPU processes every hour\n- Compare logs over time to detect anomalies\n\n## What's Next?\n\nYou've mastered **process management** - the \"circulatory system\" of Linux. Next lessons build on this:\n- **Networking**: Which processes have network connections?\n- **Log Analysis**: Correlating process activity with system logs\n- **Incident Response**: Using process forensics during breaches\n\n**Challenge**: Can you explain the difference between a zombie process and a stopped process? If yes, you've internalized this lesson. If not, review the process states section!\n\n**Final Thought**: Process management isn't just about commands - it's about **thinking in processes**. Every action on a Linux system creates or modifies processes. Master this, and you've mastered how Linux works at its core."
      }
    }
  ]
}