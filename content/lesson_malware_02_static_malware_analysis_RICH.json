{
  "lesson_id": "5e3b9c1d-7f2a-4e8b-9d0c-1a2b3c4d5e6f",
  "domain": "malware",
  "title": "Static Malware Analysis",
  "subtitle": "Analyzing malware without execution",
  "difficulty": 2,
  "estimated_time": 35,
  "order_index": 2,
  "prerequisites": [
    "malware_01_uuid"
  ],
  "concepts": [
    "Static analysis",
    "File signatures",
    "Strings analysis",
    "PE structure",
    "Disassembly",
    "Obfuscation detection"
  ],
  "learning_objectives": [
    "Master static analysis techniques for malware examination",
    "Learn to extract and analyze file metadata and signatures",
    "Understand PE (Portable Executable) file structure analysis",
    "Identify obfuscation and packing techniques"
  ],
  "content_blocks": [
    {
      "block_id": "857e8d58-a048-445e-b230-e89e105966d3",
      "type": "mindset_coach",
      "title": "The Art of Safe Analysis",
      "content": {
        "text": "**Static analysis is like being a bomb disposal expert** - you examine the threat WITHOUT triggering it.\n\nWhen you receive a suspicious file, you have two choices:\n1. **Run it** and see what happens (dynamic analysis - dangerous!)\n2. **Examine it** without running it (static analysis - safe!)\n\nStatic analysis is your first line of defense. It's safe, fast, and surprisingly powerful.\n\n**The Jim Kwik principle here**: ACTIVE LEARNING through hands-on examples. You won't just read about strings extraction - you'll see ACTUAL malware strings and learn what they reveal.\n\n**Why this matters**: Static analysis skills let you:\n- Triage malware samples safely\n- Extract IOCs (Indicators of Compromise) for detection\n- Identify malware families\n- Find command-and-control servers\n- Understand capabilities WITHOUT detonating malware\n\n**Real example**: In 2017, WannaCry ransomware spread globally. Analysts used static analysis to extract the \"kill switch\" domain (iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com) within HOURS - stopping the outbreak by registering that domain.\n\nStatic analysis literally saved billions of dollars.\n\n**Your goal**: Learn to dissect malware like a surgeon - carefully, methodically, safely."
      }
    },
    {
      "block_id": "6ef25602-1146-44e1-876f-fca8803343ee",
      "type": "explanation",
      "title": "What is Static Malware Analysis?",
      "content": {
        "text": "**Static Analysis** = Examining malware WITHOUT executing it\n\n**Analogy**: Reading a recipe vs. cooking the dish\n- **Static**: Read the recipe (safe, no cooking)\n- **Dynamic**: Cook the dish (see results, but uses ingredients)\n\n## Why Static Analysis First?\n\n**1. SAFE**\n- No risk of infection\n- No risk of triggering destructive payload\n- No risk of alerting attacker (no network connections)\n\n**2. FAST**\n- Automated tools scan in seconds\n- No need for sandbox environment\n- Can analyze thousands of samples quickly\n\n**3. SCALABLE**\n- Process large malware collections\n- Build detection signatures\n- Create YARA rules\n\n**4. INFORMATIVE**\n- Extract strings (URLs, IPs, file paths)\n- Identify packing/obfuscation\n- Determine file type and structure\n- Find embedded resources\n\n## Static Analysis Limitations\n\n**Cannot see**:\n- Runtime behavior\n- Network communications\n- Registry modifications\n- File system changes\n- Process injection\n\n**Can be defeated by**:\n- Encryption\n- Packing/compression\n- Obfuscation\n- Anti-analysis techniques\n\n**Rule of thumb**: Static analysis is FIRST step, not the ONLY step\n\n## Static Analysis Workflow\n\n```\n[Suspicious File]\n↓\n[1. Calculate Hash] → Database lookup (known malware?)\n↓\n[2. File Type Identification] → PE? ELF? Script? Office doc?\n↓\n[3. Strings Extraction] → URLs, IPs, file paths, commands\n↓\n[4. PE Analysis] → Imports, exports, sections, resources\n↓\n[5. Signature Scanning] → YARA rules, antivirus\n↓\n[6. Disassembly] → Assembly code review (advanced)\n↓\n[Report Findings]\n```bash\n\n## Tools of the Trade\n\n**Free/Open Source**:\n- **VirusTotal**: Multi-engine scanner\n- **PEStudio**: PE file analysis (Windows)\n- **Detect It Easy (DIE)**: File type and packer detection\n- **strings**: Extract ASCII/Unicode strings (Linux)\n- **FLOSS**: FireEye Labs Obfuscated String Solver\n- **IDA Free**: Disassembler\n- **Ghidra**: NSA's reverse engineering tool\n- **CFF Explorer**: PE editor and viewer\n\n**Commercial**:\n- **IDA Pro**: Industry-standard disassembler\n- **Binary Ninja**: Modern disassembler\n- **Hex-Rays Decompiler**: IDA plugin (converts assembly → C code)\n\n**Your static analysis lab**:\n```bash\n# Install essential tools (Linux)\nsudo apt-get install binutils\nsudo apt-get install strings\nsudo apt-get install file\nsudo apt-get install radare2\n\n# Download\nwget https://github.com/fireeye/flare-floss/releases/download/v2.1.0/floss-v2.1.0-linux.zip\nwget https://ghidra-sre.org/ # Ghidra\n```"
      }
    },
    {
      "block_id": "15dfa069-8f10-4074-86af-63b83c42d3bc",
      "type": "explanation",
      "title": "Step 1: File Hashing and Identification",
      "content": {
        "text": "Every static analysis begins with calculating the file hash.\n\n## Why Hash Files?\n\n**Hash = Digital fingerprint**\n\n**Uses**:\n1. **Unique identification**: Two identical files = same hash\n2. **Malware database lookups**: Search VirusTotal, malware databases\n3. **IOC sharing**: Share hash instead of malware sample\n4. **Tracking**: Monitor hash across networks\n\n## Hash Algorithms\n\n**MD5** (128-bit):\n```bash\nmd5sum malware.exe\n# Output: 5d41402abc4b2a76b9719d911017c592 malware.exe\n```\n- **Pros**: Fast, widely used\n- **Cons**: Collisions possible (not cryptographically secure)\n- **Use**: Quick identification, legacy compatibility\n\n**SHA-1** (160-bit):\n```bash\nsha1sum malware.exe\n# Output: 2fd4e1c67a2d28fced849ee1bb76e7391b93eb12 malware.exe\n```\n- **Pros**: Better than MD5\n- **Cons**: Also deprecated (collisions demonstrated)\n- **Use**: Still common in older systems\n\n**SHA-256** (256-bit):\n```bash\nsha256sum malware.exe\n# Output: 2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae malware.exe\n```\n- **Pros**: Cryptographically secure, no known collisions\n- **Cons**: Slightly slower\n- **Use**: **PREFERRED** for modern malware analysis\n\n## VirusTotal Lookup\n\n**VirusTotal** = Free multi-scanner (70+ antivirus engines)\n\n**Web interface**:\n1. Go to virustotal.com\n2. Upload file OR paste hash\n3. View results from 70+ scanners\n\n**API**:\n```bash\n# Get your free API key from virustotal.com\nexport VT_API_KEY=\"your-api-key-here\"\n\n# Check file hash\ncurl --request GET \\\n--url https://www.virustotal.com/api/v3/files/5d41402abc4b2a76b9719d911017c592 \\\n--header \"x-apikey: $VT_API_KEY\"\n```\n\n**Python script**:\n```python\nimport hashlib\nimport requests\n\ndef check_virustotal(file_path, api_key):\n# Calculate SHA-256\nwith open(file_path, 'rb') as f:\nfile_hash = hashlib.sha256(f.read()).hexdigest()\n\n# Query VirusTotal\nurl = f\"https://www.virustotal.com/api/v3/files/{file_hash}\"\nheaders = {\"x-apikey\": api_key}\nresponse = requests.get(url, headers=headers)\n\nif response.status_code == 200:\ndata = response.json()\nstats = data['data']['attributes']['last_analysis_stats']\nprint(f\"Hash: {file_hash}\")\nprint(f\"Malicious: {stats['malicious']}\")\nprint(f\"Suspicious: {stats['suspicious']}\")\nprint(f\"Undetected: {stats['undetected']}\")\nelse:\nprint(\"File not found in VirusTotal database\")\n\ncheck_virustotal(\"suspicious.exe\", \"your-api-key\")\n```\n\n**Interpretation**:\n- **60+/70 detect**: Definitely malware\n- **30-60/70 detect**: Likely malware\n- **10-30/70 detect**: Suspicious, investigate further\n- **0-10/70 detect**: Could be false positive, new malware, or clean\n\n**Important**: VirusTotal shares samples with security community. Don't upload confidential/proprietary malware!\n\n## File Type Identification\n\n**Never trust file extensions!**\n\n**Example**: malware.exe might actually be a text file, or malware.txt might be an executable\n\n**Linux `file` command**:\n```bash\nfile suspicious.exe\n# Output: PE32 executable (GUI) Intel 80386, for MS Windows\n\nfile fake-invoice.pdf\n# Output: PE32 executable (console) Intel 80386, for MS Windows\n# ^ This is malware pretending to be a PDF!\n```\n\n**Magic bytes** (file signatures):\n\nEvery file type has a signature in the first few bytes:\n\n```\nPE executables:   4D 5A (MZ)\nELF binaries:     7F 45 4C 46 (\\x7FELF)\nPDF files:        25 50 44 46 (%.PDF)\nZIP archives:     50 4B 03 04 (PK..)\nJPEG images:      FF D8 FF\n```\n\n**Check magic bytes**:\n```bash\n# View first 16 bytes in hex\nxxd -l 16 suspicious.exe\n# Output: 00000000: 4d5a 9000 0300 0000 0400 0000 ffff 0000  MZ..............\n#                    ^^^^^ \n#                    MZ = PE executable\n```\n\n**Detect It Easy (DIE)**:\n- GUI tool for Windows/Linux\n- Identifies file type, compiler, packer, protector\n- Download: https://github.com/horsicq/Detect-It-Easy\n\n```\n[DIE Output for sample]\nFile Type: PE32\nCompiler: Microsoft Visual C++ 2019\nPacker: UPX 3.96\nEntropy: 7.8 (HIGH - indicates packing/encryption)\n```\n\n**High entropy** (7.0-8.0) = Likely packed or encrypted"
      }
    },
    {
      "block_id": "52b52ef6-d10e-4dbe-a2c5-208e2db79705",
      "type": "explanation",
      "title": "Step 2: Strings Extraction and Analysis",
      "content": {
        "text": "**Strings analysis** = Extract human-readable text from binary\n\n## Why Strings Matter\n\nEven compiled binaries contain readable strings:\n- URLs and IP addresses (C2 servers!)\n- File paths\n- Registry keys\n- Error messages\n- Function names\n- Passwords and keys\n- Debugging information\n\n## Basic Strings Extraction\n\n**Linux `strings` command**:\n```bash\n# Extract ASCII strings (min 8 characters)\nstrings malware.exe\n\n# Extract Unicode strings\nstrings -e l malware.exe\n\n# Save to file\nstrings malware.exe > malware_strings.txt\n\n# Find URLs\nstrings malware.exe | grep -E \"https?://\"\n\n# Find IP addresses\nstrings malware.exe | grep -oE \"([0-9]{1,3}\\.){3}[0-9]{1,3}\"\n\n# Find email addresses\nstrings malware.exe | grep -E \"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\"\n```bash\n\n## Real Example: Emotet Malware\n\n```bash\nstrings emotet.dll | head -20\n```\n\n**Output**:\n```\nC:\\Users\\Admin\\AppData\\Local\\Microsoft\\Windows\\Temporary Internet Files\\\nMozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\nPOST\nContent-Type: multipart/form-data\nhttp://192.168.1.100:8080/gate.php\nhttp://malicious-c2.com/update\nSoftware\\Microsoft\\Windows\\CurrentVersion\\Run\nREG_SZ\ncmd.exe /c powershell.exe\n```\n\n**Analysis**:\n- ✅ **File paths**: Typical malware persistence location\n- ✅ **User-Agent**: Mimics Chrome browser\n- ✅ **HTTP POST**: Uploading data to C2\n- ✅ **C2 URLs**: `http://192.168.1.100:8080/gate.php`, `http://malicious-c2.com/update`\n- ✅ **Registry key**: `Software\\Microsoft\\Windows\\CurrentVersion\\Run` (persistence)\n- ✅ **Commands**: PowerShell execution\n\n**IOCs extracted**: 2 C2 URLs, 1 registry key, PowerShell indicator\n\n## FLOSS (Advanced Strings)\n\n**FLOSS** = FireEye Labs Obfuscated String Solver\n\nFinds strings that basic `strings` misses:\n- Stack strings (built at runtime)\n- Encoded/obfuscated strings\n- Encrypted strings\n\n**Installation**:\n```bash\nwget https://github.com/mandiant/flare-floss/releases/download/v2.1.0/floss-v2.1.0-linux.zip\nunzip floss-v2.1.0-linux.zip\nchmod +x floss\n```\n\n**Usage**:\n```bash\n./floss malware.exe\n```\n\n**Output**:\n```\n[FLOSS Static Strings]\nhttps://malware-c2.com/api\n\n[FLOSS Stack Strings]\nC:\\\\Windows\\\\System32\\\\cmd.exe\nnet user admin P@ssw0rd123 /add\nnet localgroup administrators admin /add\n\n[FLOSS Decoded Strings]\n192.168.50.100\n443\nGET /beacon HTTP/1.1\n```\n\n**Key difference**: FLOSS found stack strings and decoded strings that `strings` missed!\n\n## Analyzing Common String Patterns\n\n### C2 Communication Indicators\n\n**URLs**:\n```\nhttp://malicious-domain.com/gate.php\nhttps://192.168.1.100:8443/api\nhxxp://evil[.]com/update  # Defanged URL (safe to share)\n```\n\n**User-Agents** (how malware identifies itself):\n```\nMozilla/5.0 (Windows NT 10.0; Win64; x64)\nUser-Agent: custom-bot-v2.1\n```bash\n\n### Persistence Indicators\n\n**Registry Keys**:\n```\nSOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\nSOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\RunOnce\nSOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon\n```\n\n**Scheduled Tasks**:\n```\nschtasks /create /tn \"WindowsUpdate\" /tr \"C:\\\\malware.exe\"\n```\n\n**Startup Folder**:\n```\nC:\\\\Users\\\\%USERNAME%\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\n```bash\n\n### Credential Theft Indicators\n\n**Mimikatz** (credential dumping tool) strings:\n```\nsekurlsa::logonpasswords\nlsadump::sam\nmimikatz\n```\n\n**LSASS** (credential storage process):\n```\nlsass.exe\nSECURITY\nSAM\n```bash\n\n### Ransomware Indicators\n\n**File extensions**:\n```\n.encrypted\n.locked\n.crypted\n.wannacry\n.locky\n```\n\n**Ransom notes**:\n```\nYOUR FILES ARE ENCRYPTED\nTo decrypt your files, send $500 in Bitcoin to:\nREADME_DECRYPT.txt\n```\n\n**Crypto libraries**:\n```\nCryptEncrypt\nCryptDecrypt\nAES\nRSA\n```bash\n\n### Data Exfiltration Indicators\n\n**FTP**:\n```\nftp.upload\nUSER anonymous\nPASS password\n```\n\n**Cloud storage**:\n```\napi.dropbox.com\ndrive.google.com\naws.amazon.com\n```bash\n\n## Practical Exercise\n\nLet's analyze a real malware sample (WannaCry):\n\n```bash\nstrings wannacry.exe | grep -i \"http\"\n```\n\n**Output**:\n```\nhttp://www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com\nhttp://www.ifferfsodp9ifjaposdfjhgosurijfaewrwergwea.com\n```\n\n**These are the kill switch domains!**\n\nWhen Marcus Hutchins registered the first domain, WannaCry stopped spreading. This simple strings analysis revealed the kill switch.\n\n## Memory Aid: CRFDUP\n\nWhen analyzing strings, look for **CRFDUP**:\n\n- **C**ommand and Control (URLs, IPs)\n- **R**egistry keys (persistence)\n- **F**ile paths (dropped files)\n- **D**ebug messages (error strings)\n- **U**ser-Agents (network communication)\n- **P**asswords and keys (credentials)"
      }
    },
    {
      "block_id": "37016237-ddf5-4246-9441-5b02dd81110f",
      "type": "explanation",
      "title": "Step 3: PE (Portable Executable) Analysis",
      "content": {
        "text": "**PE (Portable Executable)** = File format for Windows executables (.exe, .dll, .sys)\n\nUnderstanding PE structure reveals malware capabilities.\n\n## PE File Structure\n\n```\n[DOS Header] ← \"MZ\" signature\n[DOS Stub]\n[PE Signature] ← \"PE\\0\\0\"\n[COFF Header]\n[Optional Header] ← Entry point, image base\n[Section Headers] ← .text, .data, .rsrc\n[Sections]\n├── .text (code)\n├── .data (initialized data)\n├── .rdata (read-only data)\n├── .rsrc (resources: icons, strings)\n└── .reloc (relocations)\n[Import Table] ← Functions imported from DLLs\n[Export Table] ← Functions exported (for DLLs)\n[Resources]\n```bash\n\n## Key PE Components to Analyze\n\n### 1. Import Table\n\n**Imports = Functions the malware calls from Windows DLLs**\n\n**Example**:\n```\nKERNEL32.dll:\n- CreateFileA\n- WriteFile\n- CreateProcess\n- VirtualAlloc\n\nWS2_32.dll:\n- WSAStartup\n- connect\n- send\n- recv\n\nADVAPI32.dll:\n- RegOpenKeyA\n- RegSetValueExA\n- CryptEncrypt\n```\n\n**Analysis**:\n- ✅ **File operations**: CreateFileA, WriteFile (drops files)\n- ✅ **Process creation**: CreateProcess (spawns other processes)\n- ✅ **Memory allocation**: VirtualAlloc (code injection possible)\n- ✅ **Network**: WSAStartup, connect, send/recv (network communication)\n- ✅ **Registry**: RegOpenKeyA, RegSetValueExA (persistence)\n- ✅ **Crypto**: CryptEncrypt (ransomware indicator)\n\n**Tool: PEView**:\n```\n1. Open malware.exe in PEView\n2. Navigate to \"IMPORT Address Table\"\n3. Review imported functions\n4. Look for suspicious patterns\n```\n\n**Suspicious import patterns**:\n\n**Keylogging**:\n```\nUSER32.dll:\n- GetAsyncKeyState\n- GetForegroundWindow\n```\n\n**Process injection**:\n```\nKERNEL32.dll:\n- VirtualAllocEx\n- WriteProcessMemory\n- CreateRemoteThread\n```\n\n**Anti-debugging**:\n```\nKERNEL32.dll:\n- IsDebuggerPresent\n- CheckRemoteDebuggerPresent\n```bash\n\n### 2. Sections Analysis\n\n**Sections = Containers for code, data, resources**\n\n**Normal PE sections**:\n```\nName     Virtual Size   Raw Size   Entropy\n.text    0x5000        0x4800     6.2   (code)\n.data    0x2000        0x1000     3.5   (data)\n.rdata   0x1000        0x800      4.1   (read-only)\n.rsrc    0x3000        0x2800     5.8   (resources)\n```\n\n**Suspicious PE sections**:\n```\nName     Virtual Size   Raw Size   Entropy\n.text    0x5000        0x4800     7.9   ← HIGH ENTROPY (packed!)\n.upx0    0x10000       0x0        0.0   ← UPX packer\n.upx1    0x8000        0x7F00     7.8   ← UPX packer\n.data    0x2000        0x200      0.5   ← Tiny raw size (suspicious)\n```\n\n**Red flags**:\n- **High entropy (7.0+)**: Packing or encryption\n- **Non-standard section names**: .upx, .aspack, .themida\n- **Virtual size >> Raw size**: Unpacks at runtime\n- **Executable sections with high entropy**: Packed code\n\n**Tool: PEStudio** (Windows):\n```\n1. Open malware.exe in PEStudio\n2. Review \"sections\" tab\n3. Check entropy values\n4. Look for suspicious names\n```bash\n\n### 3. Entry Point Analysis\n\n**Entry point** = Where code execution starts\n\n**Normal entry point**:\n```\nEntry Point: 0x1000 (inside .text section)\n```\n\n**Suspicious entry point**:\n```\nEntry Point: 0x15000 (inside .rsrc section!)\n```\n\n**Why suspicious**: Code should start in .text section, not in .rsrc (resources) or .data\n\n**Packer detection**:\n```\nEntry Point: 0x45000 (inside last section)\n^ Typical of packed malware (unpacker stub)\n```bash\n\n### 4. Resources\n\n**Resources** = Icons, images, strings, dialogs embedded in PE\n\n**Malware hides payloads in resources!**\n\n**Example**:\n```\nResource Type: BITMAP\nResource ID: 101\nSize: 500 KB\nEntropy: 7.8\n^ This \"bitmap\" is actually encrypted malware!\n```\n\n**Tool: Resource Hacker**:\n1. Open malware.exe\n2. Browse resources\n3. Look for large resources with high entropy\n4. Extract suspicious resources\n\n**Common tricks**:\n- Encrypted payload disguised as icon/bitmap\n- Embedded DLL in custom resource type\n- Configuration data in RCDATA resource\n\n### 5. Compilation Timestamp\n\n**Timestamp** = When PE was compiled\n\n**Check**:\n```bash\npefile malware.exe | grep \"TimeDateStamp\"\n# Output: TimeDateStamp: 0x5D8F9C42 (2019-09-28 15:23:14 UTC)\n```\n\n**Red flags**:\n- **1970 or 1980**: Timestamp wiped (anti-forensics)\n- **Future date**: Obvious forgery\n- **Recent date + old malware family**: Recompiled variant\n\n## PE Analysis Tools\n\n**PEStudio** (Windows, free):\n- Comprehensive PE analyzer\n- VirusTotal integration\n- Indicator scoring\n- YARA rule matching\n- Download: https://www.winitor.com/\n\n**CFF Explorer** (Windows, free):\n- PE editor and viewer\n- Modify PE headers\n- Resource viewer\n- Disassembler\n\n**pefile** (Python library):\n```python\nimport pefile\n\npe = pefile.PE('malware.exe')\n\n# Get imports\nfor entry in pe.DIRECTORY_ENTRY_IMPORT:\nprint(entry.dll.decode())\nfor imp in entry.imports:\nprint(f\"  {imp.name.decode()}\")\n\n# Get sections\nfor section in pe.sections:\nprint(f\"{section.Name.decode()}: Entropy={section.get_entropy():.2f}\")\n\n# Get entry point\nprint(f\"Entry Point: 0x{pe.OPTIONAL_HEADER.AddressOfEntryPoint:X}\")\n```bash\n\n## Practical Example: TrickBot Analysis\n\n**TrickBot** = Banking trojan\n\n**PE Analysis reveals**:\n\n**Imports**:\n```\nWININET.dll:\n- InternetOpenA\n- HttpSendRequestA\n- InternetReadFile\n^ Network communication\n\nADVAPI32.dll:\n- RegCreateKeyExA\n- CryptAcquireContextA\n^ Registry persistence + crypto\n\nUSER32.dll:\n- GetAsyncKeyState\n- GetWindowTextA\n^ Keylogging\n```\n\n**Sections**:\n```\n.text: Entropy 6.8 (normal)\n.data: Entropy 7.9 (HIGH - encrypted C2 config!)\n.rsrc: Contains large encrypted resource\n```\n\n**Strings**:\n```\n\"module.dll\"\n\"pwgrab\"\n\"systeminfo\"\n\"bcdedit /set {default} recoveryenabled no\"\n^ Disables Windows recovery (ransomware behavior)\n```\n\n**Conclusion**: Banking trojan with keylogging, credential theft, and persistence capabilities"
      }
    },
    {
      "block_id": "ddeade76-362f-47fa-83fb-85bf7f527132",
      "type": "explanation",
      "title": "Step 4: Detecting Packing and Obfuscation",
      "content": {
        "text": "**Packing** = Compressing/encrypting malware to hide its true content\n\n**Why malware authors pack**:\n- Evade antivirus detection\n- Hide malicious strings and code\n- Make static analysis harder\n- Reduce file size\n\n## Common Packers\n\n**UPX** (Ultimate Packer for eXecutables):\n- Most common packer\n- Free and open-source\n- Easily detected and unpacked\n\n**ASPack**:\n- Commercial packer\n- More sophisticated than UPX\n\n**Themida**:\n- Advanced protection\n- Anti-debugging, anti-dumping\n- Used by both legitimate software and malware\n\n**Custom packers**:\n- Written by malware authors\n- Harder to detect and unpack\n- APT groups use custom packers\n\n## Detecting Packed Malware\n\n### Method 1: Entropy Analysis\n\n**Entropy** = Measure of randomness (0-8 scale)\n\n- **Low entropy (0-4)**: Plain text, normal code\n- **Medium entropy (4-7)**: Compiled code\n- **High entropy (7-8)**: Packed, encrypted, compressed\n\n**Check entropy**:\n```python\nimport math\nfrom collections import Counter\n\ndef calculate_entropy(data):\nif not data:\nreturn 0\nentropy = 0\ncounter = Counter(data)\nfor count in counter.values():\np = count / len(data)\nentropy -= p * math.log2(p)\nreturn entropy\n\nwith open('malware.exe', 'rb') as f:\ndata = f.read()\n\nprint(f\"Entropy: {calculate_entropy(data):.2f}\")\n# Output: Entropy: 7.83 ← PACKED!\n```\n\n**Tool: Detect It Easy (DIE)**:\n```\n[DIE Output]\nPacker: UPX 3.96\nEntropy: 7.9\nCompiler: Microsoft Visual C++ 2019\n```bash\n\n### Method 2: Section Analysis\n\n**Packed PE characteristics**:\n\n```\nNormal PE:\n.text  Raw:0x5000  Virtual:0x5200  Entropy:6.2  Executable:Yes\n.data  Raw:0x2000  Virtual:0x2100  Entropy:3.5  Executable:No\n.rsrc  Raw:0x1000  Virtual:0x1050  Entropy:5.8  Executable:No\n\nPacked PE (UPX):\n.upx0  Raw:0x0     Virtual:0x10000 Entropy:0.0  Executable:Yes\n.upx1  Raw:0x7F00  Virtual:0x8000  Entropy:7.9  Executable:Yes\n.rsrc  Raw:0x200   Virtual:0x300   Entropy:5.2  Executable:No\n^\n^ Virtual size >> Raw size (unpacks at runtime)\n^ High entropy in executable section\n^ Non-standard section names\n```bash\n\n### Method 3: Import Table\n\n**Packed malware has MINIMAL imports**\n\n**Normal malware**:\n```\nImports from KERNEL32.dll (50+ functions)\nImports from USER32.dll (20+ functions)\nImports from WS2_32.dll (15+ functions)\nTotal: 85+ imports\n```\n\n**Packed malware**:\n```\nImports from KERNEL32.dll:\n- LoadLibraryA\n- GetProcAddress\n- VirtualProtect\nTotal: 3 imports\n^\n^ Minimal imports (unpacker will load real imports at runtime)\n```\n\n**Why so few**: Packer only needs LoadLibraryA and GetProcAddress to dynamically load everything else\n\n### Method 4: Entry Point Detection\n\n**Packed entry point**:\n```\nEntry Point: 0x45000 (last section)\n^ Not in .text section (suspicious)\n```\n\n**Entry point code (packed)**:\n```assembly\npushad          ; Save all registers\nmov esi, offset packed_data\nmov edi, offset unpack_dest\nmov ecx, 0x5000\nrep movsb       ; Copy packed data\ncall unpacking_routine\npopad           ; Restore registers\njmp original_entry_point\n```bash\n\n## Unpacking Techniques\n\n### Manual Unpacking\n\n**Process**:\n1. Run malware in debugger\n2. Set breakpoint at tail jump (jmp to unpacked code)\n3. Let unpacker run\n4. Dump unpacked memory to file\n\n**Tools**:\n- **x64dbg**: Debugger for Windows\n- **OllyDbg**: Classic Windows debugger\n- **Scylla**: Import table reconstruction\n\n**Example (x64dbg)**:\n```\n1. Load malware.exe\n2. Run until entry point\n3. Analyze unpacker stub\n4. Set breakpoint after unpacking loop\n5. Run to breakpoint\n6. Dump process memory (Scylla plugin)\n7. Fix import table\n8. Save unpacked PE\n```bash\n\n### Automated Unpacking\n\n**UPX Unpacker** (for UPX-packed files):\n```bash\nupx -d malware.exe -o malware_unpacked.exe\n# Output: Unpacked 1 file.\n```\n\n**UnpacMe** (online unpacking service):\n- Upload packed malware\n- Automated unpacking\n- Returns unpacked binary\n- https://www.unpac.me/\n\n## Obfuscation Techniques\n\n### String Obfuscation\n\n**XOR encoding**:\n```python\n# Malware code\nencrypted = b\"\\x1f\\x0e\\x1c\\x1c\\x1a\"\nkey = 0x42\ndecrypted = bytes([b ^ key for b in encrypted])\nprint(decrypted)  # Output: b\"hello\"\n```\n\n**Base64 encoding**:\n```python\nimport base64\nencoded = b\"Y21kLmV4ZSAvcSBwb3dlcnNoZWxsLmV4ZQ==\"\ndecoded = base64.b64decode(encoded)\nprint(decoded)  # Output: b\"cmd.exe /c powershell.exe\"\n```\n\n**Stack strings** (built at runtime):\n```assembly\nmov byte ptr [ebp-8], 'h'\nmov byte ptr [ebp-7], 't'\nmov byte ptr [ebp-6], 't'\nmov byte ptr [ebp-5], 'p'\nmov byte ptr [ebp-4], ':'\nmov byte ptr [ebp-3], '/'\nmov byte ptr [ebp-2], '/'\nmov byte ptr [ebp-1], 0\n; Now [ebp-8] contains \"http://\\0\"\n```\n\n**FLOSS** finds these!\n\n### Control Flow Obfuscation\n\n**Junk code insertion**:\n```assembly\nmov eax, 1          ; Real code\nmov ebx, 2          ; Real code\npush eax            ; Junk\npop eax             ; Junk\nxor ecx, ecx        ; Junk\nadd eax, ebx        ; Real code\n```\n\n**Opaque predicates** (always true/false):\n```assembly\nmov eax, 5\nimul eax, eax       ; eax = 25\ntest eax, 1         ; Always even (false)\njz real_code        ; Always taken\n; dead code here (never executed)\nreal_code:\n```bash\n\n## Memory Aid: PIES\n\nTo detect packing, check **PIES**:\n\n- **P**acker signatures (UPX, ASPack)\n- **I**mport table (minimal imports = packed)\n- **E**ntropy (7.0+ = packed)\n- **S**ections (non-standard names, high entropy)"
      }
    },
    {
      "block_id": "dbf1af60-5f89-4720-8aab-16e46a79b6d3",
      "type": "memory_aid",
      "title": "Static Analysis Memory Aids",
      "content": {
        "text": "## Static Analysis Workflow\n\n**\"Hash, Type, Strings, PE, Signature, Disassemble\"** → **HTSPSD**\n\n1. **H**ash - Calculate file hash, check VirusTotal\n2. **T**ype - Identify file type (PE, ELF, script)\n3. **S**trings - Extract strings (URLs, IPs, paths)\n4. **P**E - Analyze PE structure (imports, sections)\n5. **S**ignature - Scan with YARA, AV\n6. **D**isassemble - Review assembly code\n\n## String Analysis: CRFDUP\n\nLook for:\n- **C**ommand & Control (URLs, IPs)\n- **R**egistry keys\n- **F**ile paths\n- **D**ebug messages\n- **U**ser-Agents\n- **P**asswords\n\n## Packer Detection: PIES\n\n- **P**acker signatures\n- **I**mport table (minimal = packed)\n- **E**ntropy (7.0+ = packed)\n- **S**ections (non-standard, high entropy)\n\n## Suspicious Imports\n\n**\"KRUNP\"** (Key Registry User Network Process):\n\n- **K**eylogging: GetAsyncKeyState, GetForegroundWindow\n- **R**egistry: RegCreateKey, RegSetValue\n- **U**ser interaction: MessageBox, FindWindow\n- **N**etwork: connect, send, recv, InternetOpen\n- **P**rocess: CreateProcess, CreateRemoteThread\n\n## PE Sections\n\n**\"Text Data Resources\"** → **TDR**:\n\n- **.text**: Code (executable)\n- **.data**: Data (writable)\n- **.rsrc**: Resources (icons, strings)\n\n## Hash Algorithms Priority\n\n**\"SHA > SHA > MD5\"**:\n\n1. **SHA-256**: Best (use this!)\n2. **SHA-1**: Acceptable (legacy)\n3. **MD5**: Last resort (collisions possible)\n\n## Red Flags Checklist\n\n```\n☐ High entropy (7.0+)\n☐ Non-standard section names (.upx, .aspack)\n☐ Minimal imports (<10 functions)\n☐ Entry point not in .text section\n☐ Virtual size >> Raw size\n☐ Suspicious strings (C2 URLs, registry keys)\n☐ Packer signatures detected\n☐ Anti-debugging imports (IsDebuggerPresent)\n☐ Large encrypted resources\n☐ Wiped or fake timestamp\n```\n\nIf 3+ red flags → Highly likely malware\n\n## When to Move to Dynamic Analysis\n\n**Move to dynamic analysis if**:\n- Packed (can't see real code)\n- Obfuscated strings\n- Need to see behavior\n- Static analysis insufficient\n\n**Stay with static if**:\n- Unpacked sample\n- Clear IOCs extracted\n- Known malware family\n- Enough for signature creation"
      }
    },
    {
      "block_id": "41d5fc34-ced9-4feb-ac7c-ee86fc192b4a",
      "type": "explanation",
      "title": "Key Takeaways and Next Steps",
      "content": {
        "text": "## What You've Learned\n\n✅ **Static analysis examines malware WITHOUT execution** - safe and fast\n\n✅ **Always start with file hashing** - Check VirusTotal, create IOCs\n\n✅ **Strings analysis reveals critical IOCs** - URLs, IPs, registry keys, file paths\n\n✅ **PE structure reveals capabilities** - Imports show functions, sections show packing\n\n✅ **High entropy (7.0+) indicates packing** - Packed malware hides true capabilities\n\n✅ **Static analysis has limits** - Can't see runtime behavior, defeated by packing/obfuscation\n\n## Practical Next Steps\n\n**1. Set up your static analysis lab**\n\n**Linux tools**:\n```bash\n# Install basic tools\nsudo apt-get install binutils strings file radare2\n\n# Download FLOSS\nwget https://github.com/mandiant/flare-floss/releases/download/v2.1.0/floss-v2.1.0-linux.zip\n\n# Install Python tools\npip install pefile\npip install pefile\n```\n\n**Windows tools**:\n- PEStudio: https://www.winitor.com/\n- Detect It Easy: https://github.com/horsicq/Detect-It-Easy\n- CFF Explorer: https://ntcore.com/?page_id=388\n- Resource Hacker: http://www.angusj.com/resourcehacker/\n\n**2. Practice on safe samples**\n\n**Malware samples** (SAFE repositories):\n- **theZoo**: https://github.com/ytisf/theZoo (password-protected malware)\n- **Malware Bazaar**: https://bazaar.abuse.ch/\n- **VirusShare**: https://virusshare.com/\n\n**IMPORTANT**: Download in isolated VM, NEVER on host machine!\n\n**3. Analyze a sample end-to-end**\n\n**Exercise: Analyze Emotet sample**\n\n```bash\n# Step 1: Hash\nsha256sum emotet.dll\n\n# Step 2: VirusTotal\ncurl --request GET --url https://www.virustotal.com/api/v3/files/[hash] --header \"x-apikey: [key]\"\n\n# Step 3: Strings\nstrings emotet.dll > strings.txt\ngrep -E \"https?://\" strings.txt\ngrep -E \"([0-9]{1,3}\\.){3}[0-9]{1,3}\" strings.txt\n\n# Step 4: PE analysis\npython\n>>> import pefile\n>>> pe = pefile.PE('emotet.dll')\n>>> for entry in pe.DIRECTORY_ENTRY_IMPORT:\n...     print(entry.dll)\n\n# Step 5: Entropy check\n>>> for section in pe.sections:\n...     print(f\"{section.Name.decode()}: {section.get_entropy():.2f}\")\n\n# Step 6: FLOSS\n./floss emotet.dll > floss_output.txt\n```\n\n**Document findings**:\n- File hash\n- File type\n- Packer (if any)\n- Extracted IOCs (URLs, IPs)\n- Suspicious imports\n- Capabilities (network, persistence, crypto)\n- Conclusion\n\n**4. Create YARA rules**\n\n**YARA** = Pattern matching for malware\n\n**Example rule**:\n```\nrule Emotet_Loader {\nmeta:\ndescription = \"Detects Emotet malware\"\nauthor = \"Your Name\"\ndate = \"2024-01-20\"\n\nstrings:\n$mz = \"MZ\"\n$url1 = \"http://\" nocase\n$reg = \"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\" nocase\n$cmd = \"cmd.exe /c powershell.exe\" nocase\n\ncondition:\n$mz at 0 and 2 of ($url1, $reg, $cmd)\n}\n```\n\n**Test rule**:\n```bash\nyara emotet_rule.yar suspicious_file.exe\n# Output: Emotet_Loader suspicious_file.exe\n```\n\n**5. Build IOC database**\n\nCreate spreadsheet or database:\n\n```\nMalware Family | Hash | C2 URLs | C2 IPs | Registry Keys | File Paths\nEmotet         | 5d41... | http://evil.com | 192.168.1.1 | HKCU\\Run | %TEMP%\\malware.exe\nTrickBot       | 2c26... | https://c2.net  | 203.0.113.5 | HKLM\\Run | %APPDATA%\\bot.dll\n```\n\nUse IOCs for:\n- SIEM alerts\n- Firewall rules\n- EDR detection\n- Threat intelligence sharing\n\n**6. Learn disassembly basics**\n\n**Disassembly** = Convert machine code → assembly code\n\n**Tool: Ghidra** (free, from NSA):\n1. Download: https://ghidra-sre.org/\n2. Open malware.exe\n3. Analyze → Auto Analyze\n4. Review functions, strings, cross-references\n\n**Start small**:\n- Identify main function\n- Follow execution flow\n- Find string references\n- Identify API calls\n\n**Assembly resources**:\n- x86 Assembly Guide: https://www.cs.virginia.edu/~evans/cs216/guides/x86.html\n- Practical Malware Analysis book (chapters 3-7)\n\n## Real-World Application\n\n**Scenario: Your SOC alerts on suspicious file**\n\n**Your response**:\n\n```bash\n# 1. Isolate file (copy to analysis VM)\ncp /alerts/suspicious.exe /analysis/sample_$(date +%Y%m%d).exe\n\n# 2. Hash and check VirusTotal\nsha256sum sample_*.exe\n# If VirusTotal shows 60+/70 detections → Known malware, block hash immediately\n\n# 3. If unknown, start static analysis\nstrings sample_*.exe | grep -E \"https?://\" > extracted_urls.txt\n# Found: http://malicious-c2.com/gate.php\n# ACTION: Block this URL in firewall\n\n# 4. Extract all IOCs\nstrings sample_*.exe | grep -oE \"([0-9]{1,3}\\.){3}[0-9]{1,3}\" > extracted_ips.txt\n# Found: 192.168.50.100\n# ACTION: Block this IP, search SIEM for connections to this IP\n\n# 5. PE analysis\npython analyze_pe.py sample_*.exe\n# Found imports: CryptEncrypt, CreateFile, InternetOpen\n# ASSESSMENT: Likely ransomware (crypto + file + network)\n\n# 6. Report to team\necho \"IOCs extracted. Ransomware suspected. Blocking C2 infrastructure.\"\n```\n\n**Impact**: Static analysis allowed you to extract IOCs and block C2 within minutes, potentially stopping ransomware before widespread encryption.\n\n## Words of Encouragement\n\nStatic analysis feels overwhelming at first. PE headers, imports, entropy, packing - there's a lot to learn.\n\nBut here's the truth: **You don't need to understand everything to be effective.**\n\nStart with the basics:\n1. Hash the file\n2. Extract strings\n3. Look for URLs and IPs\n4. Block what you find\n\n**That alone stops most attacks.**\n\nAs you practice, you'll naturally learn more:\n- PE imports reveal capabilities\n- Entropy reveals packing\n- Disassembly reveals logic\n\nEvery analysis teaches you something new. Every IOC you extract protects your organization.\n\n**Start simple. Build skills gradually. Become the analyst who catches threats others miss.**\n\n**Welcome to static malware analysis. Now go dissect some malware.**"
      }
    },
    {
      "type": "video",
      "title": "Video Tutorial: Static Malware Analysis",
      "content": {
        "resources": "Watch this comprehensive video tutorial to reinforce your learning with visual demonstrations and practical examples.\n\n**Video**: [Static Malware Analysis using PEStudio](https://www.youtube.com/watch?v=Kz7Aw-2sCWI)\n\n**What you'll see:**\nStatic analysis techniques: PE structure analysis, strings extraction, packing detection, and disassembly.\n\n**Duration**: ~30 minutes\n\n**Recommended viewing**: After completing the lesson to solidify understanding.\n\n**Additional Resources:**\n- [Practical Malware Analysis Book](https://practicalmalwareanalysis.com/)\n- [FLOSS - Obfuscated String Solver](https://github.com/mandiant/flare-floss)\n- [PEStudio Tool](https://www.winitor.com/)"
      }
    }
  ],
  "post_assessment": [
    {
      "question_id": "q1",
      "type": "multiple_choice",
      "question": "What is the primary advantage of static analysis over dynamic analysis?",
      "options": [
        "Static analysis can see all runtime behaviors",
        "Static analysis is safe because malware is never executed",
        "Static analysis always works even on packed malware",
        "Static analysis provides more detailed information than dynamic analysis"
      ],
      "correct_answer": 1,
      "explanation": "The primary advantage of static analysis is SAFETY - you examine malware without executing it, eliminating risk of infection, payload detonation, or alerting the attacker. However, it has limitations (can't see runtime behavior, defeated by packing).",
      "difficulty": 2
    },
    {
      "question_id": "q2",
      "type": "multiple_choice",
      "question": "What does entropy measure in malware analysis, and what value indicates packing?",
      "options": [
        "File size; values over 1MB indicate packing",
        "Randomness of data; values of 7.0-8.0 indicate packing",
        "Number of imports; values under 10 indicate packing",
        "Compilation date; recent dates indicate packing"
      ],
      "correct_answer": 1,
      "explanation": "Entropy measures randomness on a 0-8 scale. High entropy (7.0-8.0) indicates packing, encryption, or compression because these make data appear random. Normal compiled code has entropy of 4-7.",
      "difficulty": 2
    },
    {
      "question_id": "q3",
      "type": "multiple_choice",
      "question": "What tool would you use to find obfuscated and stack strings that the basic 'strings' command misses?",
      "options": [
        "VirusTotal",
        "FLOSS (FireEye Labs Obfuscated String Solver)",
        "PEStudio",
        "Ghidra"
      ],
      "correct_answer": 1,
      "explanation": "FLOSS (FireEye Labs Obfuscated String Solver) is specifically designed to find strings that basic extraction misses: stack strings (built at runtime), encoded strings, and obfuscated strings. It's more powerful than the standard 'strings' command.",
      "difficulty": 2
    },
    {
      "question_id": "q4",
      "type": "multiple_choice",
      "question": "Why does packed malware typically have very few imports in its import table?",
      "options": [
        "Packed malware doesn't use Windows APIs",
        "The packer only needs LoadLibraryA and GetProcAddress to load everything else at runtime",
        "Imports are removed by the packer to save space",
        "Packed malware only works in memory without imports"
      ],
      "correct_answer": 1,
      "explanation": "Packed malware shows minimal imports (often just LoadLibraryA, GetProcAddress, and VirtualProtect) because the unpacker dynamically loads all real imports at runtime using these functions. This is a key indicator of packing.",
      "difficulty": 2
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "teach_like_im_10",
    "memory_hooks",
    "minimum_effective_dose",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ]
}