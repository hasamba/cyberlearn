{
  "lesson_id": "f4d5e6f7-8a9b-0c1d-2e3f-4a5b6c7d8e9f",
  "domain": "cloud",
  "title": "Cloud Identity and Access Management (IAM) Deep Dive",
  "difficulty": 2,
  "order_index": 4,
  "prerequisites": [
    "c1a2b3d4-5e6f-7a8b-9c0d-1e2f3a4b5c6d",
    "d2b3c4e5-6f7a-8b9c-0d1e-2f3a4b5c6d7e"
  ],
  "concepts": [
    "Identity Federation (SAML, OIDC, OAuth 2.0)",
    "Single Sign-On (SSO) Architecture",
    "Just-in-Time (JIT) Access and Privileged Access Management (PAM)",
    "Service Accounts and Workload Identity",
    "Multi-Factor Authentication (MFA) Enforcement",
    "Identity Provider (IdP) Integration (Okta, Azure AD, Google Workspace)",
    "Attribute-Based Access Control (ABAC)",
    "Zero Trust Identity Principles",
    "Session Management and Token Security",
    "Identity Attack Vectors (Token Theft, MFA Bypass, Kerberoasting)"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand identity federation protocols (SAML, OIDC, OAuth 2.0) and when to use each",
    "Implement SSO with external identity providers to centralize authentication",
    "Configure Just-in-Time access to reduce standing privileged access",
    "Secure service-to-service authentication with workload identities",
    "Enforce MFA across cloud platforms and detect MFA bypass attempts",
    "Implement attribute-based access control for dynamic policy enforcement",
    "Apply zero-trust identity principles (verify explicitly, least privilege, assume breach)",
    "Detect and prevent identity-based attacks (token theft, replay, privilege escalation)"
  ],
  "content_blocks": [
    {
      "type": "explanation",
      "title": "Cloud Identity Fundamentals",
      "content": {
        "text": "Identity is the new perimeter. In cloud environments, there are no network boundaries—authentication and authorization ARE your security controls.\n\n**The Identity Problem in Multi-Cloud**\n\nModern organizations have:\n- AWS accounts (IAM users, roles)\n- Azure subscriptions (Azure AD users, service principals)\n- Google Cloud projects (Google Workspace users, service accounts)\n- SaaS applications (Salesforce, GitHub, Slack)\n- On-premises Active Directory\n\nManaging separate credentials for each system creates:\n- Password fatigue (users reuse weak passwords)\n- Provisioning/deprovisioning challenges (ex-employees still have access)\n- No centralized audit trail\n- Increased attack surface\n\n**Solution: Identity Federation**\n\nFederation means delegating authentication to a central Identity Provider (IdP). Cloud platforms trust the IdP to verify user identity.\n\n```\n┌─────────────────────────────────────────────────────┐\n│  IDENTITY FEDERATION FLOW                           │\n├─────────────────────────────────────────────────────┤\n│  1. User → Cloud Platform (AWS/Azure/GCP)          │\n│  2. Cloud Platform → IdP (Okta/Azure AD/Google)     │\n│  3. User authenticates with IdP (username + MFA)    │\n│  4. IdP → Cloud Platform (SAML assertion / JWT)     │\n│  5. Cloud Platform grants temporary credentials     │\n│  6. User accesses resources                         │\n└─────────────────────────────────────────────────────┘\n```\n\n**Federation Protocols**\n\n**1. SAML 2.0 (Security Assertion Markup Language)**\n- Enterprise SSO standard (2005)\n- XML-based\n- Used for user authentication (humans)\n- Identity Provider (IdP) issues SAML assertions\n- Service Provider (SP) consumes assertions\n\n**Use Cases:**\n- AWS Console SSO\n- Azure Portal SSO\n- Enterprise SaaS applications\n\n**2. OIDC (OpenID Connect)**\n- Modern identity layer on top of OAuth 2.0 (2014)\n- JSON-based (JWT tokens)\n- Used for user authentication AND service authentication\n- More developer-friendly than SAML\n\n**Use Cases:**\n- Google Cloud Identity Federation\n- Modern web applications\n- Mobile app authentication\n\n**3. OAuth 2.0**\n- Authorization framework (NOT authentication)\n- Delegates access without sharing credentials\n- Uses access tokens and refresh tokens\n\n**Use Cases:**\n- API access delegation (\"Allow App X to access your GitHub repos\")\n- Service-to-service authentication\n\n**SAML vs OIDC Quick Comparison:**\n\n```\n┌──────────────────────────────────────────────────┐\n│  Feature      │  SAML        │  OIDC/OAuth      │\n├──────────────────────────────────────────────────┤\n│  Age          │  2005        │  2014            │\n│  Format       │  XML         │  JSON (JWT)      │\n│  Complexity   │  High        │  Low             │\n│  Use Case     │  Enterprise  │  Modern apps     │\n│  Mobile       │  Poor        │  Excellent       │\n│  API Auth     │  Not ideal   │  Perfect         │\n└──────────────────────────────────────────────────┘\n```\n\n**Just-in-Time (JIT) Access**\n\nTraditional model: Users have standing access (24/7 admin rights).\nProblem: Compromised credentials = immediate full access.\n\n**JIT Access:**\n- Users request elevated access when needed\n- Access granted for limited time (1-8 hours)\n- Automatic expiration\n- Audit trail of all access requests\n\n**AWS Implementation:** SSO with time-limited role assumptions\n**Azure Implementation:** Privileged Identity Management (PIM)\n**GCP Implementation:** Temporary IAM bindings\n\n**Workload Identity (Service Accounts)**\n\nApplications need to authenticate to cloud services. Two approaches:\n\n**❌ Bad: Long-lived credentials (access keys)**\n- Hardcoded in application code\n- Stored in environment variables\n- Never rotated\n- If leaked, valid indefinitely\n\n**✅ Good: Workload Identity (managed identities)**\n- Cloud platform issues temporary credentials\n- Automatically rotated (every 15 minutes - 12 hours)\n- No secrets to manage\n- Can't be leaked (only available to the workload)\n\n**Examples:**\n- AWS: IAM Roles for EC2, Lambda execution roles, IRSA (EKS)\n- Azure: Managed Identities for VMs, App Service\n- GCP: Workload Identity for GKE, service account impersonation\n\n**Multi-Factor Authentication (MFA)**\n\nMFA drastically reduces account compromise risk:\n- Microsoft: MFA blocks 99.9% of automated attacks\n- Google: MFA prevents 100% of automated bot attacks\n\n**MFA Types:**\n1. **SMS/Phone**: Vulnerable to SIM swapping, phishing\n2. **TOTP (Time-based One-Time Password)**: Google Authenticator, Authy\n3. **Push Notifications**: Duo, Okta Verify (vulnerable to MFA fatigue)\n4. **Hardware Keys**: YubiKey, Titan Key (most secure, phishing-resistant)\n\n**MFA Bypass Attacks:**\n\n**1. MFA Fatigue**\n- Attacker has valid password\n- Sends repeated MFA push notifications (50+ per day)\n- User eventually accepts to stop notifications\n- Uber breach (2022) used this technique\n\n**Defense:** Number matching (user must enter code shown in authentication prompt)\n\n**2. Session Cookie Theft**\n- Attacker steals session cookie AFTER user completes MFA\n- Uses stolen cookie to bypass MFA\n- Lapsus$ group used this extensively\n\n**Defense:** Bind sessions to device, IP, user agent; short session lifetimes\n\n**3. Adversary-in-the-Middle (AitM) Phishing**\n- Attacker hosts fake login page\n- User enters credentials + MFA code\n- Attacker proxies credentials to real site in real-time\n- Captures valid session token\n\n**Defense:** Hardware security keys (FIDO2/WebAuthn - cryptographically bound to origin)\n\n**Attribute-Based Access Control (ABAC)**\n\nInstead of static roles, use dynamic attributes:\n\n**Traditional RBAC:**\n- User = Developer → Role = S3 Read Access\n\n**ABAC:**\n- IF user.department = Engineering AND user.clearance = High AND request.time = business_hours AND request.ip = corporate_network THEN allow S3 access\n\n**AWS ABAC Example:**\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [{\n    \"Effect\": \"Allow\",\n    \"Action\": \"s3:*\",\n    \"Resource\": \"*\",\n    \"Condition\": {\n      \"StringEquals\": {\n        \"s3:ExistingObjectTag/Department\": \"${aws:PrincipalTag/Department}\"\n      }\n    }\n  }]\n}\n```\n\nThis policy says: Users can only access S3 objects tagged with their own department.\n\n**Zero Trust Identity Principles**\n\n**Traditional:** Trust but verify (trust corporate network users)\n**Zero Trust:** Never trust, always verify\n\n**Core Tenets:**\n1. **Verify explicitly** - Always authenticate and authorize based on all available data points (user, device, location, risk)\n2. **Use least privilege** - Just-in-time, just-enough access\n3. **Assume breach** - Minimize blast radius, segment access, verify end-to-end\n\n**Implementation:**\n- MFA for all users (no exceptions)\n- Conditional access policies (device compliance, location)\n- Continuous authentication (re-verify periodically)\n- Microsegmentation (limit lateral movement)\n- Audit everything (CloudTrail, Azure Activity Log, GCP Cloud Audit Logs)\n\n**Identity Attack Vectors**\n\n**1. Token Theft**\n\nCloud platforms use temporary tokens:\n- AWS: AccessKeyId + SecretAccessKey + SessionToken\n- Azure: JWT access tokens\n- GCP: OAuth 2.0 access tokens\n\nIf attacker obtains these, they can impersonate the user/service.\n\n**Exfiltration methods:**\n- SSRF (Capital One breach)\n- Compromised CI/CD logs (tokens in build output)\n- Malware on developer workstation\n- Compromised container (mounted service account token)\n\n**2. Golden SAML Attack**\n\nIf attacker compromises the IdP's SAML signing certificate, they can forge SAML assertions for any user.\n\n**Example:** SolarWinds attackers stole ADFS signing certificate → created fake SAML tokens → accessed Microsoft 365 as any user\n\n**Defense:**\n- Protect ADFS signing key (HSM storage)\n- Monitor for unusual certificate usage\n- Short SAML assertion lifetime\n- Conditional access policies (even with valid SAML, check device/location)\n\n**3. Pass-the-Cookie**\n\nSteal authenticated session cookies, replay in different browser.\n\n**Defense:**\n- Bind cookies to device fingerprint\n- Short cookie lifetime\n- Re-authenticate for sensitive actions\n- HttpOnly and Secure flags on cookies"
      }
    },
    {
      "type": "code_exercise",
      "title": "Identity Federation Configuration",
      "content": {
        "text": "**Exercise 1: Configure AWS SSO with Okta (SAML)**\n\n```bash\n# 1. In Okta Admin Console:\n# - Create SAML 2.0 application\n# - Set SSO URL: https://signin.aws.amazon.com/saml\n# - Set Audience URI: urn:amazon:webservices\n# - Download IdP metadata XML\n\n# 2. In AWS IAM Console:\n# Create SAML Identity Provider\naws iam create-saml-provider \\\n  --name OktaSSO \\\n  --saml-metadata-document file://okta-metadata.xml\n\n# 3. Create IAM role for federated users\ncat > trust-policy.json << 'EOF'\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [{\n    \"Effect\": \"Allow\",\n    \"Principal\": {\n      \"Federated\": \"arn:aws:iam::123456789012:saml-provider/OktaSSO\"\n    },\n    \"Action\": \"sts:AssumeRoleWithSAML\",\n    \"Condition\": {\n      \"StringEquals\": {\n        \"SAML:aud\": \"https://signin.aws.amazon.com/saml\"\n      }\n    }\n  }]\n}\nEOF\n\naws iam create-role \\\n  --role-name OktaDevelopers \\\n  --assume-role-policy-document file://trust-policy.json\n\naws iam attach-role-policy \\\n  --role-name OktaDevelopers \\\n  --policy-arn arn:aws:iam::aws:policy/PowerUserAccess\n\n# 4. In Okta, configure attribute mapping:\n# https://aws.amazon.com/SAML/Attributes/Role → arn:aws:iam::123456789012:role/OktaDevelopers,arn:aws:iam::123456789012:saml-provider/OktaSSO\n# https://aws.amazon.com/SAML/Attributes/RoleSessionName → ${user.email}\n\n# 5. Test login:\n# User navigates to Okta dashboard → AWS app → automatically logged into AWS Console\n```\n\n**Exercise 2: Configure Azure AD Conditional Access**\n\n```powershell\n# PowerShell script to create Conditional Access policy\n\nConnect-MgGraph -Scopes \"Policy.ReadWrite.ConditionalAccess\"\n\n# Require MFA for all users accessing from untrusted networks\n$conditions = @{\n  Users = @{\n    IncludeUsers = @(\"All\")\n    ExcludeUsers = @(\"breakglass@company.com\")  # Emergency access account\n  }\n  Applications = @{\n    IncludeApplications = @(\"All\")\n  }\n  Locations = @{\n    IncludeLocations = @(\"All\")\n    ExcludeLocations = @(\"AllTrusted\")  # Corporate office IPs\n  }\n  ClientAppTypes = @(\"browser\", \"mobileAppsAndDesktopClients\")\n}\n\n$grantControls = @{\n  Operator = \"OR\"\n  BuiltInControls = @(\"mfa\")  # Require MFA\n}\n\n$sessionControls = @{\n  SignInFrequency = @{\n    Value = 8\n    Type = \"hours\"\n    IsEnabled = $true\n  }\n}\n\n$params = @{\n  DisplayName = \"Require MFA for untrusted locations\"\n  State = \"enabled\"\n  Conditions = $conditions\n  GrantControls = $grantControls\n  SessionControls = $sessionControls\n}\n\nNew-MgIdentityConditionalAccessPolicy -BodyParameter $params\n\n# Create another policy: Block access from high-risk locations\n$blockPolicy = @{\n  DisplayName = \"Block access from high-risk countries\"\n  State = \"enabled\"\n  Conditions = @{\n    Users = @{ IncludeUsers = @(\"All\") }\n    Applications = @{ IncludeApplications = @(\"All\") }\n    Locations = @{\n      IncludeLocations = @(\"RU\", \"CN\", \"KP\")  # Russia, China, North Korea\n    }\n  }\n  GrantControls = @{\n    Operator = \"OR\"\n    BuiltInControls = @(\"block\")\n  }\n}\n\nNew-MgIdentityConditionalAccessPolicy -BodyParameter $blockPolicy\n```\n\n**Exercise 3: Implement AWS Just-in-Time Access**\n\n```python\n# Lambda function for JIT access (approver workflow)\nimport boto3\nimport json\nfrom datetime import datetime, timedelta\n\niam = boto3.client('iam')\n\ndef lambda_handler(event, context):\n    # Event: {\"user\": \"john.doe\", \"role\": \"ProductionAdmin\", \"duration_hours\": 2, \"justification\": \"Deploy hotfix\"}\n    \n    user = event['user']\n    role_arn = f\"arn:aws:iam::123456789012:role/{event['role']}\"\n    duration = event.get('duration_hours', 1) * 3600  # Convert to seconds\n    justification = event['justification']\n    \n    # Create temporary credentials\n    sts = boto3.client('sts')\n    response = sts.assume_role(\n        RoleArn=role_arn,\n        RoleSessionName=f\"{user}-JIT-{datetime.now().strftime('%Y%m%d%H%M%S')}\",\n        DurationSeconds=duration,\n        Tags=[\n            {'Key': 'User', 'Value': user},\n            {'Key': 'Justification', 'Value': justification},\n            {'Key': 'AccessType', 'Value': 'JIT'}\n        ]\n    )\n    \n    # Log to CloudWatch for audit\n    print(json.dumps({\n        'event': 'JIT_ACCESS_GRANTED',\n        'user': user,\n        'role': event['role'],\n        'duration_hours': event['duration_hours'],\n        'justification': justification,\n        'expiration': response['Credentials']['Expiration'].isoformat()\n    }))\n    \n    # Send credentials to user (via secure channel)\n    return {\n        'statusCode': 200,\n        'body': json.dumps({\n            'message': f'Access granted for {event[\"duration_hours\"]} hours',\n            'credentials': {\n                'AccessKeyId': response['Credentials']['AccessKeyId'],\n                'SecretAccessKey': response['Credentials']['SecretAccessKey'],\n                'SessionToken': response['Credentials']['SessionToken'],\n                'Expiration': response['Credentials']['Expiration'].isoformat()\n            }\n        })\n    }\n```\n\n**Exercise 4: Implement GCP Workload Identity for GKE**\n\n```bash\n# 1. Create GKE cluster with Workload Identity enabled\ngcloud container clusters create secure-cluster \\\n  --region us-central1 \\\n  --workload-pool=my-project.svc.id.goog \\\n  --enable-autoscaling \\\n  --min-nodes 1 --max-nodes 3\n\n# 2. Create Kubernetes service account\nkubectl create serviceaccount app-sa -n production\n\n# 3. Create GCP service account\ngcloud iam service-accounts create app-gcp-sa \\\n  --display-name \"Application Service Account\"\n\n# 4. Grant GCP SA permissions (e.g., access to Cloud Storage)\ngcloud projects add-iam-policy-binding my-project \\\n  --member \"serviceAccount:app-gcp-sa@my-project.iam.gserviceaccount.com\" \\\n  --role \"roles/storage.objectViewer\"\n\n# 5. Bind Kubernetes SA to GCP SA\ngcloud iam service-accounts add-iam-policy-binding \\\n  app-gcp-sa@my-project.iam.gserviceaccount.com \\\n  --role roles/iam.workloadIdentityUser \\\n  --member \"serviceAccount:my-project.svc.id.goog[production/app-sa]\"\n\n# 6. Annotate Kubernetes SA with GCP SA\nkubectl annotate serviceaccount app-sa \\\n  -n production \\\n  iam.gke.io/gcp-service-account=app-gcp-sa@my-project.iam.gserviceaccount.com\n\n# 7. Deploy pod using this service account\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: Pod\nmetadata:\n  name: app-pod\n  namespace: production\nspec:\n  serviceAccountName: app-sa\n  containers:\n  - name: app\n    image: gcr.io/my-project/my-app:latest\n    # Application code automatically gets GCP credentials\nEOF\n\n# 8. Test from inside pod\nkubectl exec -it app-pod -n production -- gcloud storage ls gs://my-bucket/\n# Success! No credentials needed in code.\n```\n\n**Exercise 5: Detect MFA Fatigue Attack**\n\n```python\n# CloudWatch Logs Insights query for AWS (search CloudTrail)\n# Detect multiple MFA challenges for same user in short time\n\nfields @timestamp, userIdentity.arn, eventName, mfaAuthenticated, sourceIPAddress\n| filter eventName = \"AssumeRole\" or eventName = \"ConsoleLogin\"\n| stats count() as attempts by userIdentity.arn, bin(@timestamp, 5m)\n| filter attempts > 10\n| sort @timestamp desc\n\n# Python script to detect in Azure AD sign-in logs\nimport requests\nfrom collections import defaultdict\nfrom datetime import datetime, timedelta\n\naccess_token = \"<Azure AD token>\"\nheaders = {\"Authorization\": f\"Bearer {access_token}\"}\n\n# Get sign-in logs\nurl = \"https://graph.microsoft.com/v1.0/auditLogs/signIns\"\nparams = {\n    \"$filter\": f\"createdDateTime ge {(datetime.utcnow() - timedelta(hours=1)).isoformat()}Z\",\n    \"$select\": \"userPrincipalName,createdDateTime,status,authenticationRequirement\"\n}\n\nresponse = requests.get(url, headers=headers, params=params)\nsign_ins = response.json()['value']\n\n# Group by user and count MFA prompts\nuser_mfa_counts = defaultdict(int)\nfor sign_in in sign_ins:\n    if sign_in.get('authenticationRequirement') == 'multiFactorAuthentication':\n        user_mfa_counts[sign_in['userPrincipalName']] += 1\n\n# Alert on unusual MFA activity\nfor user, count in user_mfa_counts.items():\n    if count > 10:  # More than 10 MFA prompts in 1 hour\n        print(f\"⚠️  ALERT: Potential MFA fatigue attack on {user} ({count} MFA prompts in 1 hour)\")\n```"
      }
    },
    {
      "type": "real_world",
      "title": "Identity Breach Case Studies",
      "content": {
        "text": "**Uber Breach (2022) - MFA Fatigue Attack**\n\n**Attack Vector:**\n- Contractor's credentials compromised (phishing)\n- Attacker had valid username + password\n- Uber used MFA (push notifications)\n\n**Attack Execution:**\n1. Attacker tried to login repeatedly (50+ attempts)\n2. Each attempt sent push notification to contractor's phone\n3. Contractor eventually accepted to stop notifications (MFA fatigue)\n4. Attacker gained access to VPN\n5. Found PowerShell script with hardcoded Thycotic PAM admin credentials\n6. Accessed PAM system → obtained credentials for AWS, Google Workspace, etc.\n7. Full company compromise\n\n**Lessons:**\n- MFA is not foolproof (users can be fatigued)\n- Use number matching or hardware keys (phishing-resistant MFA)\n- Don't hardcode credentials in scripts\n- Implement anomaly detection (50 MFA prompts should alert)\n\n**Okta Breach (2022) - Lapsus$ Group**\n\n**Attack Vector:**\n- Social engineering of Okta support contractor\n- Gained access to Okta internal systems\n- Accessed customer tenants\n\n**Impact:**\n- 366 Okta customers potentially affected\n- Attackers could create/modify users in customer Okta tenants\n- Bypass MFA by creating new admin accounts\n\n**Lessons:**\n- IdP compromise is catastrophic (single point of failure)\n- Monitor for unusual admin activity (new user creation, policy changes)\n- Implement privileged access management for support staff\n- Use breakglass accounts separate from IdP\n\n**CircleCI Breach (2023) - Session Token Theft**\n\n**Attack Vector:**\n- Malware on employee laptop\n- Stole session tokens for internal systems\n- Tokens were valid AFTER MFA was completed\n\n**Attack Execution:**\n1. Malware exfiltrated session cookies\n2. Attacker replayed cookies (bypassed MFA)\n3. Accessed production systems\n4. Rotated encryption keys to access customer secrets\n5. Accessed customer environment variables, API keys, SSH keys\n\n**Impact:**\n- Forced all customers to rotate secrets\n- Reputational damage to CircleCI\n\n**Lessons:**\n- Bind session tokens to device fingerprint\n- Short session lifetimes\n- Re-authenticate for sensitive operations\n- Monitor for session replay (different IP/user agent)"
      }
    },
    {
      "type": "reflection",
      "title": "Identity Security Reflection",
      "content": {
        "text": "**Critical Thinking Questions:**\n\n1. Why is identity federation more secure than managing separate credentials per platform?\n2. How does JIT access reduce risk compared to standing privileged access?\n3. What are the trade-offs between SAML and OIDC for enterprise SSO?\n4. Why are hardware security keys (YubiKey) more secure than TOTP apps (Google Authenticator)?\n5. How would you detect a Golden SAML attack in your environment?\n6. What is the risk of workload identities vs access keys for cloud services?\n7. How does ABAC enable more granular access control than RBAC?\n8. What makes MFA fatigue attacks possible, and how can they be prevented?\n\n**Career Application:**\n- Identity and Access Management (IAM) is a specialized, high-paying career path\n- Average IAM Engineer salary: $120,000-$160,000\n- Understanding federation is critical for multi-cloud architecture\n- Zero Trust initiatives are driving massive IAM investments\n\n**Hands-On Challenge:**\nSet up SSO for your AWS account using a free Okta developer tenant. Experience federation firsthand."
      }
    },
    {
      "type": "memory_aid",
      "title": "Identity Quick Reference",
      "content": {
        "text": "**Federation Protocols: \"SAO\"**\n- **S**AML (enterprise, XML, legacy)\n- **A**uth 2.0 (authorization, delegation)\n- **O**IDC (modern authentication, JSON/JWT)\n\n**Zero Trust Principles: \"VLA\"**\n- **V**erify explicitly (always authenticate)\n- **L**east privilege (JIT, just enough)\n- **A**ssume breach (limit blast radius)\n\n**MFA Types by Security: \"SPH\"** (ascending security)\n- **S**MS (weakest - SIM swap vulnerable)\n- **P**ush / TOTP (medium - fatigue/phishing vulnerable)\n- **H**ardware key (strongest - phishing-resistant)\n\n**Token Types:**\n- **ID Token** (who you are) - OIDC\n- **Access Token** (what you can do) - OAuth 2.0\n- **Refresh Token** (get new access tokens) - OAuth 2.0\n\n**AWS STS AssumeRole:**\n```bash\naws sts assume-role \\\n  --role-arn arn:aws:iam::ACCOUNT:role/ROLE \\\n  --role-session-name SESSION_NAME \\\n  --duration-seconds 3600\n```\n\n**Detect MFA Fatigue (CloudTrail):**\n```sql\nSELECT userIdentity.arn, COUNT(*) as attempts\nFROM cloudtrail_logs\nWHERE eventName IN ('ConsoleLogin', 'AssumeRole')\nAND eventTime > NOW() - INTERVAL '1 hour'\nGROUP BY userIdentity.arn\nHAVING COUNT(*) > 10\n```\n\n**Workload Identity Pattern:**\n```\nAWS: IAM Role → EC2 Instance → Auto credentials\nAzure: Managed Identity → VM/App Service → Auto credentials\nGCP: Workload Identity → GKE Pod → Auto credentials\nKubernetes: ServiceAccount → Pod → Auto credentials\n```"
      }
    },
    {
      "type": "video",
      "title": "Identity and Access Management Resources",
      "content": {
        "resources": "**Official Documentation:**\n- \"AWS IAM Best Practices\" (AWS docs)\n- \"Azure AD Conditional Access\" (Microsoft Learn)\n- \"GCP IAM Overview\" (Google Cloud docs)\n- \"Okta Identity 101\" (Okta University)\n\n**Certifications:**\n- AWS Certified Security - Specialty (heavy IAM focus)\n- Microsoft Certified: Identity and Access Administrator Associate (SC-300)\n- CISSP (Certified Information Systems Security Professional) - Domain 5: Identity and Access Management\n\n**YouTube Channels:**\n- \"Okta Developer\" (identity concepts, OIDC/SAML tutorials)\n- \"Microsoft Security\" (Azure AD deep dives)\n- \"AWS Online Tech Talks\" (IAM federation, STS)\n\n**Hands-On Practice:**\n- Okta Developer Account (free, full-featured SSO testing)\n- Auth0 (free tier, modern identity playground)\n- AWS IAM Policy Simulator (test policies without deploying)\n\n**Books:**\n- \"Solving Identity Management in Modern Applications\" (Atul Tulshibagwale, O'Reilly)\n- \"OAuth 2.0 Simplified\" (Aaron Parecki)\n\n**Security Research:**\n- \"Golden SAML Attack\" (CyberArk research paper)\n- \"MFA Fatigue Attacks\" (Microsoft security blog)\n- \"Pass-the-Cookie Attacks\" (SpecterOps blog)"
      }
    }
  ],
  "post_assessment": [
    {
      "question": "A user authenticates to AWS via Okta SSO (SAML federation) and receives a session valid for 12 hours. The user's Okta account is then disabled. What happens to their AWS session?",
      "options": [
        "AWS session is immediately terminated when Okta account is disabled",
        "AWS session remains valid for the full 12 hours (sessions are not revoked when IdP account is disabled)",
        "AWS checks Okta every 5 minutes and terminates the session within 5 minutes",
        "AWS session is converted to a read-only session"
      ],
      "correct_answer": 1,
      "explanation": "**Correct: AWS session remains valid for the full 12 hours.**\n\nThis is a critical security gap in federated authentication. When a user authenticates via SAML:\n\n1. IdP (Okta) issues SAML assertion (typically valid 5 minutes)\n2. AWS validates assertion and issues STS temporary credentials (valid 1-12 hours)\n3. AWS does NOT continuously check with IdP\n4. If user is disabled in Okta, their AWS session continues until natural expiration\n\n**Why this happens:**\n- AWS STS tokens are self-contained (like JWTs)\n- No callback to IdP for validation\n- Performance/scalability trade-off\n\n**Mitigations:**\n1. **Short session durations** (1-2 hours instead of 12)\n2. **Revoke AWS sessions manually** when user leaves:\n   ```bash\n   aws iam delete-access-key --user-name USER --access-key-id KEY\n   ```\n3. **AWS IAM Access Analyzer** - monitor for unusual activity\n4. **Conditional Access** - require re-authentication periodically\n5. **Session policies** - additional restrictions on federated sessions\n\nThis is why JIT (Just-in-Time) access with short durations is critical for high-security environments.",
      "question_id": "62756ef2-f552-4a88-99f7-c01efe62c768",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "An attacker steals an AWS STS temporary credential (AccessKeyId, SecretAccessKey, SessionToken). The original role had `sts:AssumeRole` permissions. Can the attacker extend their access by assuming the role again?",
      "options": [
        "Yes, they can assume the role again to get fresh credentials",
        "No, temporary credentials cannot be used to assume roles",
        "Yes, but only if they also have the MFA device",
        "No, the role has already been assumed and cannot be re-assumed"
      ],
      "correct_answer": 1,
      "explanation": "**Correct: No, temporary credentials cannot be used to assume roles (in most cases).**\n\nAWS STS temporary credentials (from `AssumeRole`, `AssumeRoleWithSAML`, `AssumeRoleWithWebIdentity`) generally **cannot** be used to call `sts:AssumeRole` again.\n\n**Exception:** If the role explicitly allows role chaining:\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [{\n    \"Effect\": \"Allow\",\n    \"Action\": \"sts:AssumeRole\",\n    \"Resource\": \"arn:aws:iam::ACCOUNT:role/AnotherRole\"\n  }]\n}\n```\n\nEven then, there are limits:\n- Maximum role chaining depth: 1 hop for console, unlimited for CLI/API (but practically limited by session duration)\n- Each assumption reduces the maximum session duration\n\n**Security Implication:**\nStolen temporary credentials are time-limited. Attacker cannot extend access beyond the session duration (MaxSessionDuration, typically 1-12 hours).\n\n**Defense in Depth:**\n1. **Detect unusual API activity** (CloudTrail → GuardDuty)\n2. **Revoke active sessions:**\n   ```bash\n   aws iam put-role-policy --role-name ROLE --policy-name RevokeOldSessions --policy-document '{\n     \"Version\": \"2012-10-17\",\n     \"Statement\": [{\n       \"Effect\": \"Deny\",\n       \"Action\": \"*\",\n       \"Resource\": \"*\",\n       \"Condition\": {\"DateLessThan\": {\"aws:TokenIssueTime\": \"2024-01-15T10:00:00Z\"}}\n     }]\n   }'\n   ```\n3. **Short session durations** (1-2 hours, not 12)\n4. **Monitor for impossible travel** (credential used from US, then China 5 minutes later)",
      "question_id": "ddc0f7a1-12f3-4843-99e0-8139d25a425c",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "Your organization implements phishing-resistant MFA using FIDO2 hardware keys. An attacker creates a convincing phishing site and tricks a user into entering their username and password. Can the attacker authenticate as the user?",
      "options": [
        "Yes, with username and password they can complete authentication",
        "No, FIDO2 keys are cryptographically bound to the origin domain and won't work on the phishing site",
        "Yes, if the attacker also steals the hardware key",
        "No, because hardware keys require biometric authentication"
      ],
      "correct_answer": 1,
      "explanation": "**Correct: No, FIDO2 keys are cryptographically bound to the origin domain.**\n\nThis is what makes FIDO2/WebAuthn **phishing-resistant**:\n\n**How FIDO2 Works:**\n1. User visits legitimate site (e.g., `aws.amazon.com`)\n2. Site sends challenge\n3. User presses button on hardware key (YubiKey, Titan Key)\n4. Key generates signature using:\n   - **Private key** (stored on hardware key, never leaves device)\n   - **Origin domain** (`aws.amazon.com`)\n5. Signature is mathematically bound to the origin\n6. Server verifies signature\n\n**Phishing Scenario:**\n1. Attacker creates `aws-login.com` (looks like AWS)\n2. User enters username + password (attacker captures these)\n3. Fake site requests FIDO2 authentication\n4. User presses hardware key button\n5. **Key generates signature for `aws-login.com`** (the phishing site)\n6. Attacker submits username, password, and signature to real `aws.amazon.com`\n7. **Real AWS rejects the signature** (it's bound to `aws-login.com`, not `aws.amazon.com`)\n8. **Authentication fails**\n\n**Result:** Attacker gets username + password, but cannot complete authentication.\n\n**Contrast with TOTP (Google Authenticator):**\n- TOTP codes are NOT bound to domain\n- User sees code on phone: 123456\n- User types 123456 into phishing site\n- Attacker uses 123456 on real site (within 30-second window)\n- **Authentication succeeds** ❌\n\n**This is why Google/Microsoft mandate FIDO2 for employee accounts.**\n\n**Note about Option C:**\nYes, physical theft of the key is a risk, but:\n- Most keys require user presence (button press)\n- Some keys require biometric (fingerprint)\n- Key can be revoked when theft is discovered\n- Much harder to steal physical device than to phish credentials",
      "question_id": "6fde0dd8-570f-41cc-97bb-57e60ac609e1",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "You implement Azure AD Conditional Access to require MFA for all admin roles. A user with admin rights authenticates successfully with MFA from their laptop. They then try to access Azure Portal from their phone 10 minutes later. What happens?",
      "options": [
        "Access is granted without MFA (session is still valid)",
        "User must complete MFA again (new device requires re-authentication)",
        "Access is blocked (only one device allowed per session)",
        "It depends on whether the session cookie was transferred to the phone"
      ],
      "correct_answer": 1,
      "explanation": "**Correct: User must complete MFA again (new device requires re-authentication).**\n\nAzure AD Conditional Access tracks authentication context including:\n- **Device identity** (device ID, compliant/non-compliant)\n- **Session tokens** (bound to device)\n- **User agent** (browser fingerprint)\n- **IP address**\n\nWhen user switches from laptop to phone:\n- **Different device** (new device ID)\n- **Different user agent** (laptop browser vs mobile browser)\n- **Potentially different IP** (laptop on WiFi, phone on cellular)\n\n**Conditional Access sees this as a NEW session** and re-evaluates policies:\n1. User = admin role ✓\n2. Device = not previously authenticated ✗\n3. **Policy action:** Require MFA\n\n**Configuration Options:**\n\n**Session controls can modify this behavior:**\n```powershell\n$sessionControls = @{\n  SignInFrequency = @{\n    Value = 8\n    Type = \"hours\"\n    IsEnabled = $true\n  }\n  PersistentBrowser = @{\n    Mode = \"never\"  # Never remember MFA\n  }\n}\n```\n\n**Device-specific policies:**\n```powershell\n# Trust compliant devices, require MFA on unmanaged devices\n$conditions = @{\n  Devices = @{\n    IncludeDevices = @(\"All\")\n    ExcludeDeviceStates = @(\"compliant\", \"domainJoined\")\n  }\n}\n$grantControls = @{\n  BuiltInControls = @(\"mfa\")\n}\n```\n\n**Why Option D is wrong:**\nSession cookies are **bound to the device/browser** where they were issued. You cannot simply \"transfer\" an Azure AD session cookie to another device:\n- Cookies include device fingerprints\n- Azure AD validates user agent consistency\n- IP changes trigger re-authentication (in strict mode)\n\n**Best Practice:**\nThis behavior (MFA per device) is a **security feature**, not a bug. It ensures:\n- Stolen session cookies can't be used on attacker's device\n- Compromised device doesn't compromise all user's devices\n- Each device has independent authentication context",
      "question_id": "fcac70e0-aeda-4422-8fd2-adbe8774e147",
      "type": "multiple_choice",
      "difficulty": 2
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "teach_like_im_10",
    "memory_hooks",
    "minimum_effective_dose",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ]
}