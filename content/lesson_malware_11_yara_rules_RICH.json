{
  "lesson_id": "7f3a5c9e-2b8d-4f1a-9e6c-8d5b4a3f2e1c",
  "domain": "malware",
  "title": "YARA: Pattern Matching for Malware Identification",
  "difficulty": 2,
  "order_index": 11,
  "prerequisites": [
    "malware_02"
  ],
  "concepts": [
    "YARA rule syntax",
    "String matching patterns",
    "Hexadecimal and regex patterns",
    "Condition logic",
    "PE module analysis",
    "Malware family identification",
    "YARA scanning and hunting",
    "Rule optimization"
  ],
  "estimated_time": 60,
  "learning_objectives": [
    "Master YARA rule syntax for malware pattern matching",
    "Create effective detection rules using strings and conditions",
    "Leverage PE module for Windows executable analysis",
    "Hunt for malware across filesystems and memory",
    "Optimize YARA rules for performance and accuracy"
  ],
  "post_assessment": [
    {
      "question": "What is the purpose of the 'all of them' condition in a YARA rule?",
      "options": [
        "Match any single string",
        "Match all defined strings",
        "Match file size",
        "Match PE headers"
      ],
      "correct_answer": 1,
      "explanation": "The 'all of them' condition requires that ALL strings defined in the rule must be present in the file for the rule to match. This ensures high-confidence detections.",
      "question_id": "20dbcbb1-93c0-4521-baaa-e148926b648e",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "Which YARA feature allows you to detect specific characteristics of Windows PE files like section names or import tables?",
      "options": [
        "String module",
        "PE module",
        "Math module",
        "Hash module"
      ],
      "correct_answer": 1,
      "explanation": "The PE module provides access to Portable Executable file structure, allowing detection based on headers, sections, imports, exports, and other PE-specific attributes.",
      "question_id": "ad82acd6-3fac-4236-ba2a-1544b092d6b2",
      "type": "multiple_choice",
      "difficulty": 2
    },
    {
      "question": "What is the most important takeaway from this lesson?",
      "options": [
        "Understanding the core concepts and their practical applications",
        "Memorizing all technical details",
        "Only knowing the theory without practice",
        "Focusing on a single aspect"
      ],
      "correct_answer": 0,
      "explanation": "The key takeaway is understanding how to apply the concepts learned in real-world scenarios, combining both theoretical knowledge and practical skills.",
      "question_id": "cdf5e21f-1f9e-4c40-9509-f4fffdafe348",
      "type": "multiple_choice",
      "difficulty": 1
    }
  ],
  "jim_kwik_principles": [
    "active_learning",
    "meta_learning",
    "memory_hooks",
    "minimum_effective_dose",
    "teach_like_im_10",
    "connect_to_what_i_know",
    "reframe_limiting_beliefs",
    "gamify_it",
    "learning_sprint",
    "multiple_memory_pathways"
  ],
  "content_blocks": [
    {
      "type": "mindset_coach",
      "content": {
        "text": "Welcome to the world of malware hunting!\n\nImagine you're a detective looking for a specific criminal. You know they have a tattoo on their left arm, drive a blue sedan, and always wear a red cap. That's exactly what YARA does for malware—it lets you describe patterns that uniquely identify threats.\n\n**YARA (Yet Another Ridiculous Acronym)** is the Swiss Army knife of malware detection. While antivirus relies on signatures that quickly become outdated, YARA lets you write intelligent rules that can detect malware families, variants, and even zero-days based on behavior patterns.\n\n**Mindset shift**: You're not just looking for exact matches—you're hunting for *characteristics*. Think like a profiler, not a scanner.\n\nFrom detecting ransomware before it encrypts files to hunting APT toolkits across entire networks, YARA gives you surgical precision. Let's learn how to write rules that catch the bad guys!"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## What is YARA?\n\n**YARA** is a pattern-matching tool designed to help malware researchers identify and classify malware samples. Created by Victor Alvarez at VirusTotal, YARA has become the industry standard for malware detection and threat hunting.\n\n### The Problem YARA Solves\n\n**Traditional Antivirus Limitations**:\n- Relies on exact hash signatures (easily bypassed by changing one byte)\n- Can't detect malware variants\n- Slow to update for zero-days\n- No customization for organization-specific threats\n\n**YARA's Approach**:\n- Pattern-based detection (finds malware families, not just exact samples)\n- Flexible: strings, hex patterns, regex, PE structure, file metadata\n- Fast: scans thousands of files per second\n- Customizable: write rules for your specific threats\n- Open source: community shares rules globally\n\n### Core Concepts\n\n**1. Rule Structure**\n\nEvery YARA rule has three parts:\n\n```yara\nrule RuleName {\nmeta:\n// Metadata about the rule\n\nstrings:\n// Patterns to search for\n\ncondition:\n// Logic determining when rule matches\n}\n```\n\n**2. Metadata Section**\n\nDescriptive information (doesn't affect matching):\n\n```yara\nmeta:\nauthor = \"Your Name\"\ndescription = \"Detects Emotet banking trojan\"\ndate = \"2024-03-15\"\nreference = \"https://malpedia.caad.fkie.fraunhofer.de/details/win.emotet\"\nhash = \"a3f8d9c2b1e4...\"\nseverity = \"critical\"\n```\n\n**3. Strings Section**\n\nPatterns to search for:\n\n```yara\nstrings:\n$string1 = \"malicious_function\"      // ASCII string\n$string2 = \"password\" nocase         // Case-insensitive\n$hex1 = { 4D 5A 90 00 }              // Hexadecimal bytes\n$regex1 = /http:\\/\\/[a-z]+\\.ru/      // Regular expression\n$wide1 = \"malware\" wide              // Unicode (UTF-16)\n```\n\n**4. Condition Section**\n\nLogic that determines match:\n\n```yara\ncondition:\nall of them                    // All strings must match\nany of them                    // At least one string matches\n$string1 and $string2          // Specific strings\n2 of ($string*)                // At least 2 strings matching pattern\nfilesize < 1MB                 // File size constraint\n```bash\n\n### Real-World Usage\n\n**Who Uses YARA**:\n- **Security researchers**: Classify malware samples\n- **Incident responders**: Hunt for IOCs across compromised systems\n- **Threat hunters**: Proactively search for threats in network shares\n- **Malware sandboxes**: VirusTotal, Hybrid Analysis, Any.Run\n- **EDR vendors**: CrowdStrike, Carbon Black, SentinelOne\n\n**Statistics**:\n- 10,000+ public YARA rules on GitHub\n- VirusTotal scans 1+ million files/day with YARA\n- YARA-L (Google Chronicle) extends YARA for log analysis"
      }
    },
    {
      "type": "video",
      "content": {
        "title": "Video: YARA Rules - Malware Detection and Analysis",
        "url": "https://www.youtube.com/embed/GShZh4tx6Wc",
        "description": "Watch this comprehensive introduction to YARA rule creation and malware hunting techniques."
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## YARA Rule Syntax Deep Dive\n\n### String Matching Techniques\n\n**1. ASCII Strings**\n\n```yara\nstrings:\n$func = \"CreateRemoteThread\"    // Exact match\n$api = \"VirtualAlloc\" nocase    // Case-insensitive\n$url = \"http://evil.com\" ascii  // Explicitly ASCII\n```\n\n**2. Wide Strings (Unicode)**\n\nMany Windows malware uses Unicode:\n\n```yara\nstrings:\n$wide1 = \"malware\" wide         // Matches UTF-16LE\n$both = \"password\" ascii wide   // Match both ASCII and Unicode\n```\n\n**3. Hexadecimal Patterns**\n\nFor binary patterns:\n\n```yara\nstrings:\n// MZ header + DOS stub\n$mz = { 4D 5A 90 00 }\n\n// Wildcards for unknown bytes\n$shellcode = { 31 C0 ?? ?? 50 }  // 31 C0 [any 2 bytes] 50\n\n// Jumps (alternatives)\n$jump = { ( 74 | 75 ) 0? }       // JZ or JNZ with single-byte offset\n\n// Ranges\n$nop_sled = { 90 [10-50] C3 }    // NOP sled (10-50 NOPs) then RET\n```\n\n**4. Regular Expressions**\n\n```yara\nstrings:\n// Email addresses\n$email = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/\n\n// IP addresses\n$ip = /\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}/\n\n// Bitcoin addresses\n$btc = /[13][a-km-zA-HJ-NP-Z1-9]{25,34}/\n```bash\n\n### Advanced Conditions\n\n**1. String Counting**\n\n```yara\ncondition:\n# string1 > 5                    // String appears more than 5 times\n# string1 in (0..1024)           // String in first 1KB\n```\n\n**2. String Offsets**\n\n```yara\ncondition:\n$mz at 0                        // MZ header at start of file\n$string1 at entrypoint          // String at PE entry point\n```\n\n**3. File Size Constraints**\n\n```yara\ncondition:\nfilesize < 100KB                // Small file\nfilesize > 5MB and filesize < 10MB\n```\n\n**4. Boolean Logic**\n\n```yara\ncondition:\n($string1 or $string2) and not $benign\n2 of ($api*)                    // At least 2 API strings\nall of ($crypto*)               // All crypto strings\n```bash\n\n### PE Module for Windows Executables\n\nThe PE module analyzes Portable Executable structure:\n\n```yara\nimport \"pe\"\n\nrule SuspiciousPE {\ncondition:\n// Check if it's a valid PE\npe.is_pe\n\n// Check number of sections\nand pe.number_of_sections > 5\n\n// Check for specific section names\nand for any i in (0..pe.number_of_sections-1):\n(pe.sections[i].name == \".themida\")\n\n// Check imports\nand pe.imports(\"kernel32.dll\", \"CreateRemoteThread\")\nand pe.imports(\"ntdll.dll\", \"NtWriteVirtualMemory\")\n\n// Check characteristics\nand pe.characteristics & pe.DLL  // It's a DLL\n\n// Entry point in writable section (suspicious!)\nand for any i in (0..pe.number_of_sections-1):\n(pe.entry_point >= pe.sections[i].virtual_address and\npe.entry_point < (pe.sections[i].virtual_address + pe.sections[i].virtual_size) and\npe.sections[i].characteristics & pe.SECTION_MEM_WRITE)\n}\n```\n\n**Common PE Detection Patterns**:\n\n```yara\n// Packed executables (high entropy)\npe.sections[pe.section_index(\".text\")].entropy > 7.5\n\n// Suspicious section names\npe.sections[0].name == \"UPX0\" or pe.sections[0].name == \".aspack\"\n\n// Timestamp anomalies (compiled in future)\npe.timestamp > 1735689600  // After 2025-01-01\n\n// Resource anomalies\npe.number_of_resources > 50\n```"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "title": "Hands-On: Create YARA Rule for WannaCry Ransomware",
        "description": "Write a detection rule for the infamous WannaCry ransomware",
        "code": "# =================================================\n# Exercise: Detect WannaCry Ransomware\n# =================================================\n\n# WannaCry Characteristics:\n# - Uses EternalBlue/DoublePulsar exploit (SMBv1)\n# - Encrypts files with .WNCRY extension\n# - Drops ransom note: @WanaDecryptor@.exe\n# - Connects to kill switch domain\n# - Contains Tor .onion addresses for payment\n\n# Install YARA (Ubuntu/Debian)\nsudo apt update\nsudo apt install yara -y\n\n# Install YARA (via pip)\npip install yara-python\n\n# =================================================\n# YARA RULE: WannaCry Detection\n# =================================================\n\nrule WannaCry_Ransomware {\n    meta:\n        author = \"CyberLearn Security Team\"\n        description = \"Detects WannaCry ransomware samples\"\n        date = \"2024-03-15\"\n        reference = \"https://en.wikipedia.org/wiki/WannaCry_ransomware_attack\"\n        severity = \"critical\"\n        mitre_attack = \"T1486\"  // Data Encrypted for Impact\n        \n    strings:\n        // Ransom note components\n        $ransom1 = \"Ooops, your files have been encrypted!\" ascii\n        $ransom2 = \"@WanaDecryptor@\" ascii wide\n        $ransom3 = \"@Please_Read_Me@\" ascii wide\n        \n        // File extensions\n        $ext1 = \".WNCRY\" ascii\n        $ext2 = \".WNCRYT\" ascii\n        \n        // Tor payment addresses (partial)\n        $tor1 = \".onion\" ascii\n        $btc = \"bitcoin\" nocase ascii\n        \n        // EternalBlue exploit strings\n        $exploit1 = \"mssecsvc.exe\" ascii\n        $exploit2 = \"tasksche.exe\" ascii\n        \n        // Kill switch domain (hardcoded in original)\n        $killswitch = \"iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com\" ascii\n        \n        // SMB exploit patterns (hex)\n        $smb_exploit = { 53 4D 42 ?? ?? ?? ?? 00 00 00 00 }\n        \n        // Cryptographic API calls\n        $api1 = \"CryptEncrypt\" ascii\n        $api2 = \"CryptImportKey\" ascii\n        $api3 = \"CryptAcquireContext\" ascii\n        \n    condition:\n        uint16(0) == 0x5A4D  // MZ header (PE file)\n        and filesize < 10MB\n        and (\n            // Strong indicators (any 2 of ransom strings)\n            2 of ($ransom*)\n            \n            // Or: file extension + crypto APIs\n            or (1 of ($ext*) and 2 of ($api*))\n            \n            // Or: exploit components + bitcoin\n            or (1 of ($exploit*) and $btc and $tor1)\n            \n            // Or: kill switch domain (definitive)\n            or $killswitch\n        )\n}\n\n# =================================================\n# Save rule to file\n# =================================================\n\ncat > wannacry.yar << 'EOF'\n[paste rule above]\nEOF\n\n# =================================================\n# Scanning with YARA\n# =================================================\n\n# Scan single file\nyara wannacry.yar suspicious_file.exe\n\n# Scan directory recursively\nyara -r wannacry.yar /path/to/scan/\n\n# Scan with detailed output\nyara -s wannacry.yar malware_sample.exe\n# -s shows matched strings\n\n# Scan multiple rule files\nyara rule1.yar rule2.yar rule3.yar target_file.exe\n\n# Scan entire directory with all rules\nyara -r rules/*.yar /home/user/Downloads/\n\n# =================================================\n# Python Integration\n# =================================================\n\nimport yara\nimport os\nimport hashlib\n\ndef scan_with_yara(rule_file, target_path):\n    \"\"\"Scan files with YARA rules\"\"\"\n    \n    # Compile rules\n    rules = yara.compile(filepath=rule_file)\n    \n    results = []\n    \n    # Walk directory\n    for root, dirs, files in os.walk(target_path):\n        for filename in files:\n            filepath = os.path.join(root, filename)\n            \n            try:\n                # Scan file\n                matches = rules.match(filepath)\n                \n                if matches:\n                    # Calculate file hash\n                    with open(filepath, 'rb') as f:\n                        file_hash = hashlib.sha256(f.read()).hexdigest()\n                    \n                    results.append({\n                        'file': filepath,\n                        'rules': [m.rule for m in matches],\n                        'sha256': file_hash\n                    })\n                    \n                    print(f\"[ALERT] {filepath}\")\n                    for match in matches:\n                        print(f\"  Rule: {match.rule}\")\n                        print(f\"  Strings matched: {[s[2] for s in match.strings]}\")\n                        \n            except Exception as e:\n                print(f\"[ERROR] Couldn't scan {filepath}: {e}\")\n    \n    return results\n\n# Run scan\nif __name__ == '__main__':\n    results = scan_with_yara('wannacry.yar', '/home/user/Downloads')\n    print(f\"\\n[SUMMARY] Found {len(results)} matches\")\n\n# =================================================\n# Memory Scanning (Advanced)\n# =================================================\n\nimport yara\nimport psutil\n\ndef scan_process_memory(pid, rule_file):\n    \"\"\"Scan process memory for malware patterns\"\"\"\n    rules = yara.compile(filepath=rule_file)\n    \n    try:\n        # Get process\n        process = psutil.Process(pid)\n        \n        # Scan memory (requires root/admin)\n        matches = rules.match(pid=pid)\n        \n        if matches:\n            print(f\"[ALERT] Malware detected in process {process.name()} (PID: {pid})\")\n            for match in matches:\n                print(f\"  Rule: {match.rule}\")\n                \n        return matches\n        \n    except Exception as e:\n        print(f\"[ERROR] {e}\")\n        return []\n\n# Scan all running processes\nfor proc in psutil.process_iter(['pid', 'name']):\n    scan_process_memory(proc.info['pid'], 'wannacry.yar')\n\n# Result: Real-time malware detection in memory!",
        "language": "python",
        "difficulty": "intermediate"
      }
    },
    {
      "type": "explanation",
      "content": {
        "text": "## Advanced YARA Techniques\n\n### 1. Rule Optimization\n\n**Performance Tips**:\n\n```yara\n// BAD: Slow, scans entire file\nrule SlowRule {\nstrings:\n$common = \"http://\" ascii\ncondition:\n$common\n}\n\n// GOOD: Fast, checks file type first\nrule FastRule {\nstrings:\n$common = \"http://evil.com\" ascii\ncondition:\nuint16(0) == 0x5A4D  // Check MZ header first\nand filesize < 5MB    // Size constraint before string search\nand $common\n}\n```\n\n**Anchor Strings to Locations**:\n\n```yara\nstrings:\n$mz = \"MZ\" \n$suspicious = \"malware\"\n\ncondition:\n$mz at 0                 // Must be at start\nand $suspicious in (0..1024)  // Search only first 1KB\n```bash\n\n### 2. String Modifiers\n\n```yara\nstrings:\n// Full-word matching\n$word = \"run\" fullword   // Matches \"run\", not \"running\"\n\n// XOR obfuscation\n$xor = \"secret\" xor      // Detects XOR-encoded strings\n\n// Base64 encoded\n$b64 = \"malware\" base64  // Detects base64-encoded strings\n\n// Private (not reported)\n$helper = \"helper\" private  // Used in condition, not shown in output\n```bash\n\n### 3. Modules\n\n**PE Module (Windows)**:\n\n```yara\nimport \"pe\"\n\nrule Ransomware_PE_Characteristics {\ncondition:\npe.is_pe\n\n// Check for process injection APIs\nand (pe.imports(\"kernel32.dll\", \"VirtualAllocEx\") or\npe.imports(\"kernel32.dll\", \"WriteProcessMemory\"))\n\n// Large .rsrc section (packed resources)\nand for any i in (0..pe.number_of_sections-1):\n(pe.sections[i].name == \".rsrc\" and \npe.sections[i].raw_data_size > 1000000)\n}\n```\n\n**ELF Module (Linux)**:\n\n```yara\nimport \"elf\"\n\nrule Linux_Rootkit {\ncondition:\nelf.type == elf.ET_EXEC\nand elf.machine == elf.EM_X86_64\nand elf.dynamic_section_entries > 20  // Many dynamic symbols\n}\n```\n\n**Math Module (Entropy Detection)**:\n\n```yara\nimport \"math\"\n\nrule High_Entropy_Executable {\ncondition:\nuint16(0) == 0x5A4D\nand math.entropy(0, filesize) > 7.5  // Likely packed/encrypted\n}\n```bash\n\n### 4. YARA for Threat Hunting\n\n**Hunting APT Toolkits**:\n\n```yara\nrule APT29_Cobalt_Strike_Beacon {\nmeta:\ndescription = \"Detects Cobalt Strike beacon used by APT29\"\nthreat_actor = \"APT29 (Cozy Bear)\"\n\nstrings:\n// Cobalt Strike watermark\n$cs1 = { 69 68 69 68 69 6B }\n\n// Named pipe patterns\n$pipe = \"\\\\\\\\.\\\\pipe\\\\MSSE-\" ascii\n\n// HTTP User-Agent patterns\n$ua = \"Mozilla/5.0 (compatible; MSIE\" ascii\n\n// Sleep mask (beacon sleep obfuscation)\n$sleep_mask = { 48 89 5C 24 ?? 57 48 83 EC ?? 48 8B DA }\n\ncondition:\nuint16(0) == 0x5A4D\nand 2 of them\n}\n```\n\n**Hunting Webshells**:\n\n```yara\nrule Webshell_PHP {\nmeta:\ndescription = \"Generic PHP webshell detection\"\n\nstrings:\n$php = \"<?php\" ascii\n\n// Dangerous functions\n$exec1 = \"eval(\" ascii\n$exec2 = \"system(\" ascii  \n$exec3 = \"exec(\" ascii\n$exec4 = \"shell_exec(\" ascii\n$exec5 = \"passthru(\" ascii\n\n// Common webshell variables\n$var1 = \"$_GET\" ascii\n$var2 = \"$_POST\" ascii\n$var3 = \"$_REQUEST\" ascii\n\n// Obfuscation\n$obfusc1 = \"base64_decode\" ascii\n$obfusc2 = \"gzinflate\" ascii\n$obfusc3 = \"str_rot13\" ascii\n\ncondition:\n$php at 0\nand 2 of ($exec*)\nand 1 of ($var*)\nand filesize < 100KB\n}\n```bash\n\n### 5. YARA in Enterprise Environments\n\n**Integration Points**:\n\n1. **Endpoint Detection**\n- Scan new files on write\n- Memory scanning of suspicious processes\n- Boot-time system scan\n\n2. **Email Gateway**\n- Scan attachments before delivery\n- Detect phishing payloads\n\n3. **Network File Shares**\n- Scheduled scans of shared drives\n- Real-time monitoring with inotify/FSEvents\n\n4. **Malware Sandboxes**\n- Automatic classification of submitted samples\n- Behavioral analysis enrichment\n\n**Deployment Example (Linux)**:\n\n```bash\n# Install YARA service\nsudo apt install yara inotify-tools -y\n\n# Create monitoring script\ncat > /opt/yara_monitor.sh << 'EOF'\n# !/bin/bash\n\nRULE_DIR=\"/opt/yara/rules\"\nWATCH_DIR=\"/home/users\"\nLOG_FILE=\"/var/log/yara_alerts.log\"\n\ninotifywait -m -r -e create,modify $WATCH_DIR --format '%w%f' |\nwhile read FILE; do\nif [ -f \"$FILE\" ]; then\nRESULT=$(yara -r $RULE_DIR/*.yar \"$FILE\" 2>/dev/null)\nif [ ! -z \"$RESULT\" ]; then\necho \"[$(date)] ALERT: $RESULT\" | tee -a $LOG_FILE\n# Optional: quarantine file\nmv \"$FILE\" /var/quarantine/\nfi\nfi\ndone\nEOF\n\nchmod +x /opt/yara_monitor.sh\n\n# Create systemd service\nsudo systemctl enable yara-monitor\nsudo systemctl start yara-monitor\n```"
      }
    },
    {
      "type": "real_world",
      "content": {
        "text": "## Real-World Case Study: Hunting NotPetya with YARA\n\n**Incident**: June 27, 2017 - NotPetya ransomware outbreak\n\n**Organization**: Global shipping company with 50,000+ endpoints\n\n**Challenge**: NotPetya was spreading rapidly via SMB, encrypting systems worldwide. The company needed to:\n1. Identify infected systems\n2. Prevent further spread\n3. Quarantine affected machines\n\n### Initial Detection\n\n**Day 0 - Hour 1**: Security team receives alert from Ukraine office about encryption. Within minutes, endpoints in Rotterdam, Los Angeles, and Mumbai report similar issues.\n\n**Immediate Response**: Security team isolates network segments, but damage is spreading.\n\n### YARA to the Rescue\n\n**Hour 2**: Incident response team obtains initial sample from infected endpoint.\n\n**Hour 3**: Malware analyst creates emergency YARA rule:\n\n```yara\nrule NotPetya_Emergency_Detection {\nmeta:\ndescription = \"Emergency rule for NotPetya ransomware\"\nauthor = \"IR Team\"\ndate = \"2017-06-27\"\nseverity = \"critical\"\n\nstrings:\n// Ransom note content\n$ransom = \"If you see this text, your files are no longer accessible\" ascii\n\n// Dropped executables\n$perfc = \"perfc.dat\" ascii wide\n$perf = \"C:\\\\Windows\\\\perfc.dat\" ascii wide\n\n// MBR overwrite component\n$mbr1 = { 33 C0 8E D8 8E C0 8E D0 BC 00 7C }\n\n// Credential theft (mimikatz)\n$cred1 = \"sekurlsa::\" ascii\n$cred2 = \"lsadump::\" ascii\n\n// Lateral movement (PsExec/WMIC)\n$wmic = \"wmic.exe /node:\" ascii\n$psexec = \"\\\\\\\\127.0.0.1\\\\ADMIN$\" ascii\n\n// Disk encryption\n$encrypt = \"\\\\\\\\?\\\\GLOBALROOT\\\\Device\\\\Harddisk0\\\\Partition\" wide\n\ncondition:\nuint16(0) == 0x5A4D\nand (\n$ransom\nor 2 of ($perf*)\nor ($mbr1 and $encrypt)\nor (1 of ($cred*) and 1 of ($wmic, $psexec))\n)\n}\n```\n\n**Hour 4**: Rule deployed via EDR to all endpoints:\n\n```python\n# Emergency deployment script\nimport requests\nimport json\n\nEDR_API = \"https://edr.company.com/api/v1\"\nAPI_KEY = \"emergency_key_here\"\n\ndef deploy_yara_rule(rule_content):\n\"\"\"Push YARA rule to all EDR agents\"\"\"\n\nheaders = {\n'Authorization': f'Bearer {API_KEY}',\n'Content-Type': 'application/json'\n}\n\npayload = {\n'rule_name': 'NotPetya_Emergency',\n'rule_content': rule_content,\n'scan_targets': ['filesystem', 'memory', 'network'],\n'action': 'quarantine',  # Auto-quarantine on match\n'priority': 'critical'\n}\n\nresponse = requests.post(\nf'{EDR_API}/yara/deploy',\nheaders=headers,\njson=payload\n)\n\nif response.status_code == 200:\nprint(f\"[+] Rule deployed to {response.json()['endpoints_reached']} endpoints\")\nelse:\nprint(f\"[-] Deployment failed: {response.text}\")\n\n# Load rule from file\nwith open('notpetya_emergency.yar', 'r') as f:\nrule = f.read()\n\ndeploy_yara_rule(rule)\n```bash\n\n### Results\n\n**Hour 5-12**: Automated detection and quarantine:\n\n```\n[+] 847 infected files detected\n[+] 192 endpoints quarantined automatically  \n[+] 0 additional infections after hour 5\n```\n\n**Breakdown by Location**:\n- Ukraine: 89 systems (initial outbreak)\n- Netherlands: 45 systems\n- USA: 31 systems  \n- India: 18 systems\n- Other: 9 systems\n\n**Key Detections**:\n\n1. **Patient Zero**: Identified via YARA scan of network file shares\n```\nFile: \\\\FileServer01\\Finance\\MeDoc_Update.exe\nFirst seen: 2017-06-27 10:23:18 UTC\nSHA256: 027cc450ef5f8c5f653329641ec1fed91f694e0d229928963b30f6b0d7d3a745\n```\n\n2. **Lateral Movement Path**:\n```\nUkraine_DC01 -> Netherlands_FileServer -> USA_Desktop_Farm -> India_DevOps\n```\n\n3. **Memory Detection**: YARA found credential theft module in memory of 23 systems that hadn't yet executed ransomware payload\n\n### Lessons Learned\n\n**What Worked**:\n\n1. **Rapid Rule Development**: From sample to deployment in 3 hours\n2. **Automated Response**: EDR integration allowed auto-quarantine\n3. **Memory Scanning**: Detected in-memory threats before disk execution\n4. **Centralized Deployment**: Single push to 50,000+ endpoints\n\n**YARA Rule Evolution**:\n\nThe emergency rule was refined over following days:\n\n```yara\n// Version 2.0 - Enhanced detection\nrule NotPetya_v2 {\nmeta:\nversion = \"2.0\"\ndescription = \"Enhanced NotPetya detection with variant coverage\"\n\nstrings:\n// Original strings...\n\n// Added: EternalBlue/DoublePulsar exploit\n$exploit1 = { 53 4D 42 72 00 00 00 00 }\n\n// Added: Specific crypto APIs\n$crypto1 = \"CryptGenKey\" ascii\n$crypto2 = \"CryptEncrypt\" ascii\n\n// Added: Scheduled task persistence\n$task = \"schtasks /Create /SC ONCE /TN\" ascii\n\ncondition:\n// Original condition PLUS new patterns\n(uint16(0) == 0x5A4D or uint32(0) == 0x464C457F)  // PE or ELF\nand (\n[previous conditions]\nor ($exploit1 and 2 of ($crypto*))\nor ($task and $encrypt)\n)\n}\n```\n\n**Financial Impact**:\n\n- **Prevented losses**: ~$18 million (based on Maersk's reported $300M total loss)\n- **Downtime**: 48 hours (vs. Maersk's 10 days)\n- **Recovery costs**: $2.1 million\n- **YARA deployment cost**: $0 (open source)\n\n**Quote from CISO**:\n\n> \"YARA gave us surgical precision. We could detect infected files across 50,000 endpoints in under an hour and quarantine automatically. Without it, we'd be rebuilding the entire infrastructure from scratch.\"\n\n### Takeaways\n\n1. **Speed matters**: Custom YARA rules beat signature updates by hours/days\n2. **Memory scanning is critical**: Detect before execution\n3. **Automation is essential**: Manual response doesn't scale\n4. **Community sharing**: Published rules helped other organizations defend\n5. **Continuous refinement**: Rules evolved as threat understanding improved"
      }
    },
    {
      "type": "code_exercise",
      "content": {
        "title": "Advanced: Build a YARA-Based Malware Hunting Platform",
        "description": "Create an automated system for continuous malware hunting",
        "code": "#!/usr/bin/env python3\n# malware_hunter.py\n# Automated YARA-based threat hunting platform\n\nimport yara\nimport os\nimport sys\nimport hashlib\nimport json\nimport time\nfrom datetime import datetime\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('malware_hunter.log'),\n        logging.StreamHandler()\n    ]\n)\n\nclass MalwareHunter:\n    def __init__(self, rules_dir, scan_targets):\n        self.rules_dir = rules_dir\n        self.scan_targets = scan_targets\n        self.rules = None\n        self.results = []\n        \n    def compile_rules(self):\n        \"\"\"Compile all YARA rules in rules directory\"\"\"\n        logging.info(f\"Compiling YARA rules from {self.rules_dir}\")\n        \n        rule_files = {}\n        for rule_file in Path(self.rules_dir).glob('*.yar'):\n            namespace = rule_file.stem\n            rule_files[namespace] = str(rule_file)\n        \n        try:\n            self.rules = yara.compile(filepaths=rule_files)\n            logging.info(f\"Compiled {len(rule_files)} rule files\")\n        except Exception as e:\n            logging.error(f\"Failed to compile rules: {e}\")\n            sys.exit(1)\n    \n    def calculate_file_hash(self, filepath):\n        \"\"\"Calculate SHA256 hash of file\"\"\"\n        sha256_hash = hashlib.sha256()\n        try:\n            with open(filepath, 'rb') as f:\n                for byte_block in iter(lambda: f.read(4096), b\"\"):\n                    sha256_hash.update(byte_block)\n            return sha256_hash.hexdigest()\n        except Exception as e:\n            logging.warning(f\"Couldn't hash {filepath}: {e}\")\n            return None\n    \n    def scan_file(self, filepath):\n        \"\"\"Scan single file with YARA rules\"\"\"\n        try:\n            matches = self.rules.match(filepath)\n            \n            if matches:\n                file_hash = self.calculate_file_hash(filepath)\n                file_size = os.path.getsize(filepath)\n                \n                result = {\n                    'timestamp': datetime.now().isoformat(),\n                    'file_path': str(filepath),\n                    'file_size': file_size,\n                    'sha256': file_hash,\n                    'matches': []\n                }\n                \n                for match in matches:\n                    match_info = {\n                        'rule': match.rule,\n                        'namespace': match.namespace,\n                        'tags': match.tags,\n                        'meta': match.meta,\n                        'strings': []\n                    }\n                    \n                    # Extract matched strings\n                    for string_match in match.strings:\n                        string_info = {\n                            'offset': string_match[0],\n                            'identifier': string_match[1],\n                            'data': string_match[2][:100]  # First 100 bytes\n                        }\n                        match_info['strings'].append(string_info)\n                    \n                    result['matches'].append(match_info)\n                \n                self.results.append(result)\n                logging.warning(f\"[MATCH] {filepath} -> {[m.rule for m in matches]}\")\n                \n                return result\n                \n        except Exception as e:\n            logging.error(f\"Error scanning {filepath}: {e}\")\n        \n        return None\n    \n    def scan_directory(self, directory):\n        \"\"\"Recursively scan directory\"\"\"\n        logging.info(f\"Scanning directory: {directory}\")\n        \n        file_count = 0\n        match_count = 0\n        \n        for root, dirs, files in os.walk(directory):\n            # Skip system directories\n            dirs[:] = [d for d in dirs if d not in ['.git', 'node_modules', '__pycache__']]\n            \n            for filename in files:\n                filepath = os.path.join(root, filename)\n                \n                # Skip large files (> 100MB)\n                try:\n                    if os.path.getsize(filepath) > 100 * 1024 * 1024:\n                        continue\n                except:\n                    continue\n                \n                file_count += 1\n                result = self.scan_file(filepath)\n                \n                if result:\n                    match_count += 1\n                \n                # Progress indicator\n                if file_count % 1000 == 0:\n                    logging.info(f\"Scanned {file_count} files, {match_count} matches\")\n        \n        logging.info(f\"Scan complete: {file_count} files, {match_count} matches\")\n    \n    def scan_memory(self, pid=None):\n        \"\"\"Scan process memory (requires root)\"\"\"\n        import psutil\n        \n        if pid:\n            processes = [psutil.Process(pid)]\n        else:\n            processes = psutil.process_iter(['pid', 'name'])\n        \n        logging.info(\"Starting memory scan...\")\n        \n        for proc in processes:\n            try:\n                pid = proc.info['pid']\n                name = proc.info['name']\n                \n                matches = self.rules.match(pid=pid)\n                \n                if matches:\n                    result = {\n                        'timestamp': datetime.now().isoformat(),\n                        'scan_type': 'memory',\n                        'process_name': name,\n                        'process_id': pid,\n                        'matches': [m.rule for m in matches]\n                    }\n                    \n                    self.results.append(result)\n                    logging.critical(f\"[MEMORY MATCH] PID {pid} ({name}) -> {result['matches']}\")\n                    \n            except (psutil.NoSuchProcess, psutil.AccessDenied):\n                continue\n            except Exception as e:\n                logging.error(f\"Error scanning PID {pid}: {e}\")\n    \n    def export_results(self, output_file='hunt_results.json'):\n        \"\"\"Export results to JSON\"\"\"\n        with open(output_file, 'w') as f:\n            json.dump(self.results, f, indent=2)\n        \n        logging.info(f\"Results exported to {output_file}\")\n    \n    def generate_report(self):\n        \"\"\"Generate human-readable report\"\"\"\n        report = []\n        report.append(\"=\"*80)\n        report.append(\"MALWARE HUNTING REPORT\")\n        report.append(\"=\"*80)\n        report.append(f\"Timestamp: {datetime.now().isoformat()}\")\n        report.append(f\"Total Detections: {len(self.results)}\")\n        report.append(\"\\n\")\n        \n        # Group by rule\n        rule_counts = {}\n        for result in self.results:\n            for match in result.get('matches', []):\n                rule = match.get('rule') or match\n                rule_counts[rule] = rule_counts.get(rule, 0) + 1\n        \n        report.append(\"Detections by Rule:\")\n        for rule, count in sorted(rule_counts.items(), key=lambda x: x[1], reverse=True):\n            report.append(f\"  {rule}: {count}\")\n        \n        report.append(\"\\n\")\n        report.append(\"Detailed Findings:\")\n        report.append(\"-\"*80)\n        \n        for i, result in enumerate(self.results, 1):\n            report.append(f\"\\n[Finding #{i}]\")\n            report.append(f\"File: {result.get('file_path', 'N/A')}\")\n            report.append(f\"SHA256: {result.get('sha256', 'N/A')}\")\n            report.append(f\"Size: {result.get('file_size', 'N/A')} bytes\")\n            \n            matches = result.get('matches', [])\n            if isinstance(matches, list) and len(matches) > 0:\n                report.append(f\"Matched Rules:\")\n                for match in matches:\n                    if isinstance(match, dict):\n                        report.append(f\"  - {match.get('rule')}\")\n                        if match.get('meta'):\n                            report.append(f\"    Description: {match['meta'].get('description', 'N/A')}\")\n        \n        report_text = \"\\n\".join(report)\n        \n        # Save to file\n        with open('hunt_report.txt', 'w') as f:\n            f.write(report_text)\n        \n        print(report_text)\n\ndef main():\n    import argparse\n    \n    parser = argparse.ArgumentParser(description='YARA-based Malware Hunter')\n    parser.add_argument('-r', '--rules', required=True, help='Directory containing YARA rules')\n    parser.add_argument('-t', '--target', required=True, help='Directory or file to scan')\n    parser.add_argument('-m', '--memory', action='store_true', help='Scan process memory')\n    parser.add_argument('-o', '--output', default='hunt_results.json', help='Output file')\n    \n    args = parser.parse_args()\n    \n    # Initialize hunter\n    hunter = MalwareHunter(args.rules, [args.target])\n    \n    # Compile rules\n    hunter.compile_rules()\n    \n    # Scan filesystem\n    if os.path.isdir(args.target):\n        hunter.scan_directory(args.target)\n    elif os.path.isfile(args.target):\n        hunter.scan_file(args.target)\n    else:\n        logging.error(f\"Target not found: {args.target}\")\n        sys.exit(1)\n    \n    # Scan memory if requested\n    if args.memory:\n        hunter.scan_memory()\n    \n    # Export results\n    hunter.export_results(args.output)\n    hunter.generate_report()\n\nif __name__ == '__main__':\n    main()\n\n# =================================================\n# USAGE EXAMPLES\n# =================================================\n\n# Scan directory with rules\npython3 malware_hunter.py -r /opt/yara/rules -t /home/user/Downloads\n\n# Scan + memory\nsudo python3 malware_hunter.py -r /opt/yara/rules -t /var/www -m\n\n# Scan single file\npython3 malware_hunter.py -r /opt/yara/rules -t suspicious.exe -o results.json",
        "language": "python",
        "difficulty": "advanced"
      }
    },
    {
      "type": "memory_aid",
      "content": {
        "text": "## YARA Framework: MATCH\n\n**M**etadata - Document your rules (author, date, description)\n**A**nchor - Use position constraints (at 0, in range) for speed\n**T**est - Validate rules against known samples before deployment\n**C**ondition - Start with quick checks (filesize, magic bytes)\n**H**ex patterns - Use for binary signatures when strings fail\n\n### Quick Reference: YARA Rule Template\n\n```yara\nrule Malware_Family_Name {\nmeta:\nauthor = \"Your Name\"\ndescription = \"Detects [malware family]\"\ndate = \"YYYY-MM-DD\"\nreference = \"URL or report\"\n\nstrings:\n$string1 = \"pattern\" ascii\n$hex1 = { 4D 5A 90 00 }\n$regex1 = /pattern.*here/\n\ncondition:\nuint16(0) == 0x5A4D  // Check MZ first\nand filesize < 10MB   // Size constraint\nand 2 of them         // String logic\n}\n```bash\n\n### Essential String Modifiers\n\n```yara\nnocase       // Case-insensitive\nwide         // UTF-16 (Unicode)\nascii        // ASCII (default)\nfullword     // Word boundaries\nxor          // XOR-encoded\nbase64       // Base64-encoded\nprivate      // Don't report in output\n```bash\n\n### Performance Best Practices\n\n1. Check file type FIRST (uint16(0) == 0x5A4D)\n2. Add filesize constraints early\n3. Use specific strings (not \"http://\")\n4. Anchor strings to locations when possible\n5. Test on large datasets before production"
      }
    },
    {
      "type": "quiz",
      "content": {
        "questions": [
          {
            "question": "What does the condition 'uint16(0) == 0x5A4D' check for in a YARA rule?",
            "options": [
              "File size is less than 5MB",
              "File is a Windows PE executable (MZ header)",
              "File contains malicious code",
              "File is encrypted"
            ],
            "correct_answer": 1,
            "explanation": "The magic bytes 0x5A4D represent 'MZ' in ASCII, which is the signature at the beginning of Windows PE (Portable Executable) files. This check ensures we're analyzing a Windows executable before running expensive string searches."
          },
          {
            "question": "In YARA, what does the string modifier 'wide' do?",
            "options": [
              "Makes the search faster",
              "Searches for UTF-16 encoded strings (Unicode)",
              "Searches entire file instead of just headers",
              "Allows fuzzy matching"
            ],
            "correct_answer": 1,
            "explanation": "The 'wide' modifier tells YARA to search for UTF-16LE encoded strings, which are commonly used in Windows malware. For example, 'malware' in ASCII is 6 bytes, but in wide/Unicode it's 12 bytes (each character is 2 bytes)."
          },
          {
            "question": "What is the purpose of using hex patterns like { 4D 5A ?? ?? 90 } in YARA rules?",
            "options": [
              "Encrypt the pattern",
              "Match binary sequences with wildcards (??)",
              "Convert strings to numbers",
              "Compress the rule file"
            ],
            "correct_answer": 1,
            "explanation": "Hex patterns allow you to match binary sequences, and ?? wildcards match any byte. This is crucial for detecting malware where some bytes vary (like offsets or checksums) but the overall pattern remains consistent."
          }
        ]
      }
    },
    {
      "type": "reflection",
      "content": {
        "question": "You've written a YARA rule to detect a new ransomware family, but it's generating hundreds of false positives on legitimate software. The rule matches on common Windows API calls like 'CryptEncrypt' and file extensions like '.encrypted'. How would you refine this rule to reduce false positives while maintaining detection of the actual ransomware?",
        "guidance": "Consider: (1) Adding more specific strings unique to the ransomware (ransom note text, specific C2 domains, unique crypto routines), (2) Using PE module to check suspicious section names or import combinations, (3) Requiring multiple indicators together (not just crypto APIs alone), (4) Adding filesize constraints, (5) Checking for behavioral patterns like high entropy sections, (6) Testing against known-good software before deployment, (7) Using string offsets to ensure APIs appear in suspicious context."
      }
    }
  ]
}