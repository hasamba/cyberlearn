#!/usr/bin/env python3
"""
Fix validation errors in new pentest lessons (18, 21-30).

Issues to fix:
1. Invalid jim_kwik_principles values ('state_management', 'spaced_repetition')
2. estimated_time as string ("60min") instead of integer (60)
3. Missing post_assessment fields (type, correct_answer, difficulty)
"""

import json
import uuid
from pathlib import Path
from typing import Dict, List

# Valid Jim Kwik principles (from Pydantic enum)
VALID_JIM_KWIK = [
    'active_learning',
    'minimum_effective_dose',
    'teach_like_im_10',
    'memory_hooks',
    'meta_learning',
    'connect_to_what_i_know',
    'reframe_limiting_beliefs',
    'gamify_it',
    'learning_sprint',
    'multiple_memory_pathways'
]

# Mapping of invalid to valid principles
PRINCIPLE_MAPPING = {
    'state_management': 'meta_learning',  # Both about optimizing learning state
    'spaced_repetition': 'memory_hooks'   # Both memory-related techniques
}

# Lessons that need fixing
LESSONS_TO_FIX = [
    "lesson_pentest_18_ntlm_hashes_relay_attacks_RICH.json",
    "lesson_pentest_21_metasploit_fundamentals_RICH.json",
    "lesson_pentest_22_metasploit_payload_engineering_RICH.json",
    "lesson_pentest_23_metasploit_post_exploitation_RICH.json",
    "lesson_pentest_24_automating_metasploit_RICH.json",
    "lesson_pentest_25_pivoting_linux_tools_RICH.json",
    "lesson_pentest_26_pivoting_windows_tools_RICH.json",
    "lesson_pentest_27_advanced_tunneling_http_dns_RICH.json",
    "lesson_pentest_28_protocol_enumeration_RICH.json",
    "lesson_pentest_29_living_off_land_recon_RICH.json",
    "lesson_pentest_30_public_exploits_RICH.json"
]

def fix_jim_kwik_principles(principles: List[str]) -> tuple[List[str], int]:
    """Fix invalid jim_kwik_principles"""
    fixed_count = 0
    fixed_principles = []

    for principle in principles:
        if principle in VALID_JIM_KWIK:
            fixed_principles.append(principle)
        elif principle in PRINCIPLE_MAPPING:
            fixed = PRINCIPLE_MAPPING[principle]
            fixed_principles.append(fixed)
            fixed_count += 1
            print(f"    Mapped '{principle}' → '{fixed}'")
        else:
            print(f"    [WARNING] Unknown principle '{principle}', keeping as-is")
            fixed_principles.append(principle)

    return fixed_principles, fixed_count

def fix_estimated_time(time_value) -> tuple[int, bool]:
    """Fix estimated_time format (convert '60min' to 60)"""
    if isinstance(time_value, int):
        return time_value, False

    if isinstance(time_value, str):
        # Extract number from string like "60min"
        import re
        match = re.match(r'(\d+)', time_value)
        if match:
            fixed = int(match.group(1))
            print(f"    Fixed estimated_time: '{time_value}' → {fixed}")
            return fixed, True

    print(f"    [WARNING] Could not parse estimated_time: {time_value}, defaulting to 60")
    return 60, True

def fix_post_assessment_question(question: Dict, index: int) -> tuple[Dict, int]:
    """Add missing fields to post_assessment question"""
    fixed_count = 0

    # Add type if missing
    if 'type' not in question:
        question['type'] = 'multiple_choice'
        print(f"    Added type: multiple_choice")
        fixed_count += 1

    # Add correct_answer if missing
    if 'correct_answer' not in question:
        question['correct_answer'] = 0  # Default to first option
        print(f"    Added correct_answer: 0 (default)")
        fixed_count += 1

    # Add difficulty if missing
    if 'difficulty' not in question:
        question['difficulty'] = 2  # Default to medium
        print(f"    Added difficulty: 2")
        fixed_count += 1

    return question, fixed_count

def fix_lesson_file(filepath: Path) -> bool:
    """Fix all issues in a lesson file"""
    print(f"\n[*] Processing: {filepath.name}")

    try:
        # Read JSON
        with open(filepath, 'r', encoding='utf-8') as f:
            lesson = json.load(f)

        total_fixes = 0

        # Fix 1: jim_kwik_principles
        if 'jim_kwik_principles' in lesson:
            fixed_principles, count = fix_jim_kwik_principles(lesson['jim_kwik_principles'])
            if count > 0:
                lesson['jim_kwik_principles'] = fixed_principles
                total_fixes += count
                print(f"  Fixed {count} jim_kwik_principles")

        # Fix 2: estimated_time
        if 'estimated_time' in lesson:
            fixed_time, changed = fix_estimated_time(lesson['estimated_time'])
            if changed:
                lesson['estimated_time'] = fixed_time
                total_fixes += 1

        # Fix 3: post_assessment
        if 'post_assessment' in lesson:
            for i, question in enumerate(lesson['post_assessment']):
                print(f"  Question {i+1}:")
                fixed_question, count = fix_post_assessment_question(question, i)
                if count > 0:
                    total_fixes += count

        if total_fixes > 0:
            # Write back to file
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(lesson, f, indent=2, ensure_ascii=False)
            print(f"  [OK] Applied {total_fixes} fixes, saved to file")
            return True
        else:
            print("  [OK] No fixes needed")
            return True

    except json.JSONDecodeError as e:
        print(f"  [ERROR] JSON parse error: {e}")
        return False
    except Exception as e:
        print(f"  [ERROR] {e}")
        return False

def main():
    print("="*70)
    print("PENTEST LESSONS FIX SCRIPT")
    print("="*70)
    print("\nThis script fixes validation errors in pentest lessons:")
    print("  1. Invalid jim_kwik_principles")
    print("  2. estimated_time as string ('60min' → 60)")
    print("  3. Missing post_assessment fields")
    print("\nLessons to fix:")
    for lesson in LESSONS_TO_FIX:
        print(f"  - {lesson}")

    content_dir = Path('content')
    if not content_dir.exists():
        print("\n[ERROR] content/ directory not found")
        return

    # Process each lesson
    results = {'success': 0, 'failed': 0}

    for lesson_file in LESSONS_TO_FIX:
        filepath = content_dir / lesson_file

        if not filepath.exists():
            print(f"\n[WARNING] File not found: {lesson_file}")
            continue

        if fix_lesson_file(filepath):
            results['success'] += 1
        else:
            results['failed'] += 1

    # Summary
    print("\n" + "="*70)
    print("SUMMARY")
    print("="*70)
    print(f"Successfully fixed: {results['success']} files")
    print(f"Failed: {results['failed']} files")

    if results['failed'] == 0:
        print("\n[OK] All pentest lessons fixed successfully!")
        print("\nNext step: Run 'python load_all_lessons.py' to load fixed lessons")
    else:
        print("\n[!] Some files had errors - review output above")

if __name__ == '__main__':
    main()
